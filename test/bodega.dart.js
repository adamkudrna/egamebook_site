// Generated by dart2js, the Dart to JavaScript compiler version: 1.10.1.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
//
// dartDeferredLibraryLoader(uri, successCallback, errorCallback):
//    if this function is defined, it will be called when a deferered library
//    is loaded. It should load and eval the javascript of `uri`, and call
//    successCallback. If it fails to do so, it should call errorCallback with
//    an error.
(function($) {
var supportsDirectProtoAccess = function() {
  var cls = function() {
  };
  cls.prototype = {p: {}};
  var object = new cls();
  return object.__proto__ && object.__proto__.p === cls.prototype.p;
}();
;
function map(x) {
  x = Object.create(null);
  x.x = 0;
  delete x.x;
  return x;
}
var A = map();
var B = map();
var C = map();
var D = map();
var E = map();
var F = map();
var G = map();
var H = map();
var J = map();
var K = map();
var L = map();
var M = map();
var N = map();
var O = map();
var P = map();
var Q = map();
var R = map();
var S = map();
var T = map();
var U = map();
var V = map();
var W = map();
var X = map();
var Y = map();
var Z = map();
function Isolate() {}
init();

$ = Isolate.$isolateProperties;
$.functionThatReturnsNull = function() {
};
;
function setupProgram(programData) {
  "use strict";
  function generateAccessor(fieldDescriptor, accessors, cls) {
    var fieldInformation = fieldDescriptor.split("-");
    var field = fieldInformation[0];
    var len = field.length;
    var code = field.charCodeAt(len - 1);
    var reflectable;
    if (fieldInformation.length > 1)
      reflectable = true;
    else
      reflectable = false;
    code = code >= 60 && code <= 64 ? code - 59 : code >= 123 && code <= 126 ? code - 117 : code >= 37 && code <= 43 ? code - 27 : 0;
    if (code) {
      var getterCode = code & 3;
      var setterCode = code >> 2;
      var accessorName = field = field.substring(0, len - 1);
      var divider = field.indexOf(":");
      if (divider > 0) {
        accessorName = field.substring(0, divider);
        field = field.substring(divider + 1);
      }
      if (getterCode) {
        var args = getterCode & 2 ? "receiver" : "";
        var receiver = getterCode & 1 ? "this" : "receiver";
        var body = "return " + receiver + "." + field;
        var property = cls + ".prototype.get$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
      if (setterCode) {
        var args = setterCode & 2 ? "receiver, value" : "value";
        var receiver = setterCode & 1 ? "this" : "receiver";
        var body = receiver + "." + field + " = value";
        var property = cls + ".prototype.set$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
    }
    return field;
  }
  function defineClass(name, fields) {
    var accessors = [];
    var str = "function " + name + "(";
    var body = "";
    var fieldNames = "";
    for (var i = 0; i < fields.length; i++) {
      if (i != 0)
        str += ", ";
      var field = generateAccessor(fields[i], accessors, name);
      fieldNames += "'" + field + "',";
      var parameter = "p_" + field;
      str += parameter;
      body += "this." + field + " = " + parameter + ";\n";
    }
    if (supportsDirectProtoAccess)
      body += "this." + "$deferredAction" + "();";
    str += ") {\n" + body + "}\n";
    str += name + ".builtin$cls=\"" + name + "\";\n";
    str += "$desc=$collectedClasses." + name + "[1];\n";
    str += name + ".prototype = $desc;\n";
    if (typeof defineClass.name != "string")
      str += name + ".name=\"" + name + "\";\n";
    str += name + "." + "$__fields__" + "=[" + fieldNames + "];\n";
    str += accessors.join("");
    return str;
  }
  init.createNewIsolate = function() {
    return new Isolate();
  };
  init.classIdExtractor = function(o) {
    return o.constructor.name;
  };
  init.classFieldsExtractor = function(o) {
    var fieldNames = o.constructor.$__fields__;
    if (!fieldNames)
      return [];
    var result = [];
    result.length = fieldNames.length;
    for (var i = 0; i < fieldNames.length; i++)
      result[i] = o[fieldNames[i]];
    return result;
  };
  init.instanceFromClassId = function(name) {
    return new init.allClasses[name]();
  };
  init.initializeEmptyInstance = function(name, o, fields) {
    init.allClasses[name].apply(o, fields);
    return o;
  };
  var inheritFrom = supportsDirectProtoAccess ? function(constructor, superConstructor) {
    var prototype = constructor.prototype;
    prototype.__proto__ = superConstructor.prototype;
    prototype.constructor = constructor;
    prototype["$is" + constructor.name] = constructor;
    return convertToFastObject(prototype);
  } : function() {
    function tmp() {
    }
    return function(constructor, superConstructor) {
      tmp.prototype = superConstructor.prototype;
      var object = new tmp();
      convertToSlowObject(object);
      var properties = constructor.prototype;
      var members = Object.keys(properties);
      for (var i = 0; i < members.length; i++) {
        var member = members[i];
        object[member] = properties[member];
      }
      object["$is" + constructor.name] = constructor;
      object.constructor = constructor;
      constructor.prototype = object;
      return object;
    };
  }();
  function finishClasses(processedClasses) {
    var allClasses = init.allClasses;
    processedClasses.combinedConstructorFunction += "return [\n" + processedClasses.constructorsList.join(",\n  ") + "\n]";
    var constructors = new Function("$collectedClasses", processedClasses.combinedConstructorFunction)(processedClasses.collected);
    processedClasses.combinedConstructorFunction = null;
    for (var i = 0; i < constructors.length; i++) {
      var constructor = constructors[i];
      var cls = constructor.name;
      var desc = processedClasses.collected[cls];
      var globalObject = desc[0];
      desc = desc[1];
      allClasses[cls] = constructor;
      globalObject[cls] = constructor;
    }
    constructors = null;
    var finishedClasses = init.finishedClasses;
    function finishClass(cls) {
      if (finishedClasses[cls])
        return;
      finishedClasses[cls] = true;
      var superclass = processedClasses.pending[cls];
      if (superclass && superclass.indexOf("+") > 0) {
        var s = superclass.split("+");
        superclass = s[0];
        var mixinClass = s[1];
        finishClass(mixinClass);
        var mixin = allClasses[mixinClass];
        var mixinPrototype = mixin.prototype;
        var clsPrototype = allClasses[cls].prototype;
        var properties = Object.keys(mixinPrototype);
        for (var i = 0; i < properties.length; i++) {
          var d = properties[i];
          if (!hasOwnProperty.call(clsPrototype, d))
            clsPrototype[d] = mixinPrototype[d];
        }
      }
      if (!superclass || typeof superclass != "string") {
        var constructor = allClasses[cls];
        var prototype = constructor.prototype;
        prototype.constructor = constructor;
        prototype.$isObject = constructor;
        prototype.$deferredAction = function() {
        };
        return;
      }
      finishClass(superclass);
      var superConstructor = allClasses[superclass];
      if (!superConstructor)
        superConstructor = existingIsolateProperties[superclass];
      var constructor = allClasses[cls];
      var prototype = inheritFrom(constructor, superConstructor);
      if (mixinPrototype)
        prototype.$deferredAction = mixinDeferredActionHelper(mixinPrototype, prototype);
      if (prototype.$isInterceptor)
        prototype.$deferredAction();
    }
    var properties = Object.keys(processedClasses.pending);
    for (var i = 0; i < properties.length; i++)
      finishClass(properties[i]);
  }
  function finishAddStubsHelper() {
    var prototype = this;
    while (!prototype.hasOwnProperty("$deferredAction"))
      prototype = prototype.__proto__;
    delete prototype.$deferredAction;
    var properties = Object.keys(prototype);
    for (var index = 0; index < properties.length; index++) {
      var property = properties[index];
      var firstChar = property.charCodeAt(0);
      var elem;
      if (property !== "^" && property !== "$reflectable" && firstChar !== 43 && firstChar !== 42 && (elem = prototype[property]) != null && elem.constructor === Array && property !== "<>")
        addStubs(prototype, elem, property, false, []);
    }
    convertToFastObject(prototype);
    prototype = prototype.__proto__;
    prototype.$deferredAction();
  }
  function mixinDeferredActionHelper(mixinPrototype, targetPrototype) {
    var chain;
    if (targetPrototype.hasOwnProperty("$deferredAction"))
      chain = targetPrototype.$deferredAction;
    return function foo() {
      var prototype = this;
      while (!prototype.hasOwnProperty("$deferredAction"))
        prototype = prototype.__proto__;
      if (chain)
        prototype.$deferredAction = chain;
      else {
        delete prototype.$deferredAction;
        convertToFastObject(prototype);
      }
      mixinPrototype.$deferredAction();
      prototype.$deferredAction();
    };
  }
  function processClassData(cls, descriptor, processedClasses) {
    descriptor = convertToSlowObject(descriptor);
    var previousProperty;
    var properties = Object.keys(descriptor);
    var hasDeferredWork = false;
    var shouldDeferWork = supportsDirectProtoAccess && cls != "Object";
    for (var i = 0; i < properties.length; i++) {
      var property = properties[i];
      var firstChar = property.charCodeAt(0);
      if (property === "static") {
        processStatics(init.statics[cls] = descriptor.static, processedClasses);
        delete descriptor.static;
      } else if (firstChar === 43) {
        mangledNames[previousProperty] = property.substring(1);
        var flag = descriptor[property];
        if (flag > 0)
          descriptor[previousProperty].$reflectable = flag;
      } else if (firstChar === 42) {
        descriptor[previousProperty].$defaultValues = descriptor[property];
        var optionalMethods = descriptor.$methodsWithOptionalArguments;
        if (!optionalMethods)
          descriptor.$methodsWithOptionalArguments = optionalMethods = {};
        optionalMethods[property] = previousProperty;
      } else {
        var elem = descriptor[property];
        if (property !== "^" && elem != null && elem.constructor === Array && property !== "<>")
          if (shouldDeferWork)
            hasDeferredWork = true;
          else
            addStubs(descriptor, elem, property, false, []);
        else
          previousProperty = property;
      }
    }
    if (hasDeferredWork)
      descriptor.$deferredAction = finishAddStubsHelper;
    var classData = descriptor["^"], split, supr, fields = classData;
    var s = fields.split(";");
    fields = s[1] == "" ? [] : s[1].split(",");
    supr = s[0];
    split = supr.split(":");
    if (split.length == 2) {
      supr = split[0];
      var functionSignature = split[1];
      if (functionSignature)
        descriptor.$signature = function(s) {
          return function() {
            return init.types[s];
          };
        }(functionSignature);
    }
    if (supr)
      processedClasses.pending[cls] = supr;
    processedClasses.combinedConstructorFunction += defineClass(cls, fields);
    processedClasses.constructorsList.push(cls);
    processedClasses.collected[cls] = [globalObject, descriptor];
    classes.push(cls);
  }
  function processStatics(descriptor, processedClasses) {
    var properties = Object.keys(descriptor);
    for (var i = 0; i < properties.length; i++) {
      var property = properties[i];
      if (property === "^")
        continue;
      var element = descriptor[property];
      var firstChar = property.charCodeAt(0);
      var previousProperty;
      if (firstChar === 43) {
        mangledGlobalNames[previousProperty] = property.substring(1);
        var flag = descriptor[property];
        if (flag > 0)
          descriptor[previousProperty].$reflectable = flag;
        if (element && element.length)
          init.typeInformation[previousProperty] = element;
      } else if (firstChar === 42) {
        globalObject[previousProperty].$defaultValues = element;
        var optionalMethods = descriptor.$methodsWithOptionalArguments;
        if (!optionalMethods)
          descriptor.$methodsWithOptionalArguments = optionalMethods = {};
        optionalMethods[property] = previousProperty;
      } else if (typeof element === "function") {
        globalObject[previousProperty = property] = element;
        functions.push(property);
        init.globalFunctions[property] = element;
      } else if (element.constructor === Array)
        addStubs(globalObject, element, property, true, functions);
      else {
        previousProperty = property;
        processClassData(property, element, processedClasses);
      }
    }
  }
  function addStubs(prototype, array, name, isStatic, functions) {
    var index = 0, alias = array[index], f;
    if (typeof alias == "string")
      f = array[++index];
    else {
      f = alias;
      alias = name;
    }
    var funcs = [prototype[name] = prototype[alias] = f];
    f.$stubName = name;
    functions.push(name);
    for (; index < array.length; index += 2) {
      f = array[index + 1];
      if (typeof f != "function")
        break;
      f.$stubName = array[index + 2];
      funcs.push(f);
      if (f.$stubName) {
        prototype[f.$stubName] = f;
        functions.push(f.$stubName);
      }
    }
    index++;
    for (var i = 0; i < funcs.length; index++, i++)
      funcs[i].$callName = array[index];
    var getterStubName = array[index];
    array = array.slice(++index);
    var requiredParameterInfo = array[0];
    var requiredParameterCount = requiredParameterInfo >> 1;
    var isAccessor = (requiredParameterInfo & 1) === 1;
    var isSetter = requiredParameterInfo === 3;
    var isGetter = requiredParameterInfo === 1;
    var optionalParameterInfo = array[1];
    var optionalParameterCount = optionalParameterInfo >> 1;
    var optionalParametersAreNamed = (optionalParameterInfo & 1) === 1;
    var isIntercepted = requiredParameterCount + optionalParameterCount != funcs[0].length;
    var functionTypeIndex = array[2];
    var unmangledNameIndex = 2 * optionalParameterCount + requiredParameterCount + 3;
    if (getterStubName) {
      f = tearOff(funcs, array, isStatic, name, isIntercepted);
      prototype[name].$getter = f;
      f.$getterStub = true;
      if (isStatic) {
        init.globalFunctions[name] = f;
        functions.push(getterStubName);
      }
      prototype[getterStubName] = f;
      funcs.push(f);
      f.$stubName = getterStubName;
      f.$callName = null;
    }
  }
  function tearOffGetter(funcs, reflectionInfo, name, isIntercepted) {
    return isIntercepted ? new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(x) {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [x], name);" + "return new c(this, funcs[0], x, name);" + "}")(funcs, reflectionInfo, name, H, null) : new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [], name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, reflectionInfo, name, H, null);
  }
  function tearOff(funcs, reflectionInfo, isStatic, name, isIntercepted) {
    var cache;
    return isStatic ? function() {
      if (cache === void 0)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, true, [], name).prototype;
      return cache;
    } : tearOffGetter(funcs, reflectionInfo, name, isIntercepted);
  }
  var functionCounter = 0;
  if (!init.libraries)
    init.libraries = [];
  if (!init.mangledNames)
    init.mangledNames = map();
  if (!init.mangledGlobalNames)
    init.mangledGlobalNames = map();
  if (!init.statics)
    init.statics = map();
  if (!init.typeInformation)
    init.typeInformation = map();
  if (!init.globalFunctions)
    init.globalFunctions = map();
  var libraries = init.libraries;
  var mangledNames = init.mangledNames;
  var mangledGlobalNames = init.mangledGlobalNames;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var length = programData.length;
  var processedClasses = map();
  processedClasses.collected = map();
  processedClasses.pending = map();
  processedClasses.constructorsList = [];
  processedClasses.combinedConstructorFunction = "function $reflectable(fn){fn.$reflectable=1;return fn};\n" + "var $desc;\n";
  for (var i = 0; i < length; i++) {
    var data = programData[i];
    var name = data[0];
    var uri = data[1];
    var metadata = data[2];
    var globalObject = data[3];
    var descriptor = data[4];
    var isRoot = !!data[5];
    var fields = descriptor && descriptor["^"];
    if (fields instanceof Array)
      fields = fields[0];
    var classes = [];
    var functions = [];
    processStatics(descriptor, processedClasses);
    libraries.push([name, uri, classes, functions, metadata, fields, isRoot, globalObject]);
  }
  finishClasses(processedClasses);
}
var dart = [
["Scripter_Implementation", "bodega.dart", , N, {
  "^": "",
  main: [function(args, mainIsolatePort) {
    var presenter, t1, t2, t3, book;
    H.assertSubtype(args, "$isList", [P.String], "$asList");
    H.interceptedTypeCheck(mainIsolatePort, "$isSendPort");
    presenter = new D.EgbIsolatePresenterProxy(mainIsolatePort, null, H.assertSubtype(H.setRuntimeTypeInfo([], [A.EgbMessage]), "$isList", [A.EgbMessage], "$asList"), null, H.assertSubtype(null, "$isCompleter", [P.$int], "$asCompleter"), H.assertSubtype(null, "$isStreamController", [G.CurrentState], "$asStreamController"), null);
    H.assertHelper(mainIsolatePort != null);
    t1 = $.RawReceivePortImpl__nextFreeId;
    $.RawReceivePortImpl__nextFreeId = t1 + 1;
    t2 = new H.RawReceivePortImpl(t1, null, false);
    t3 = init.globalState.currentContext;
    t3._addRegistration$2(t1, t2);
    t3._updateGlobalState$0();
    t3 = new H.ReceivePortImpl(t2, null);
    t3.ReceivePortImpl$fromRawReceivePort$1(t2);
    presenter.port = t3;
    t2 = presenter.get$_onMessageFromMainIsolate();
    t1 = H.getVoidRuntimeType();
    H.buildFunctionType(t1, [H.getDynamicRuntimeType()])._assertCheck$1(t2);
    H.buildFunctionType(t1)._assertCheck$1(null);
    t3 = t3._controller;
    t3.toString;
    H.assertSubtype(t3, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle");
    H.assertSubtype(H.setRuntimeTypeInfo(new P._ControllerStream(H.assertSubtype(t3, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle")), [null]), "$isStream", [H.getRuntimeTypeArgument(t3, "_StreamController", 0)], "$asStream").listen$4$cancelOnError$onDone$onError(t2, null, null, null);
    mainIsolatePort.send$1(new H._NativeJsSendPort(presenter.port._rawPort, init.globalState.currentContext.id));
    book = N.ScripterImpl$();
    book.presenter = presenter;
    presenter.scripter = book;
  }, "call$2", "main$closure", 4, 0, 60],
  ScripterImpl: {
    "^": "EgbScripter;barbrawl,bodega,isEngineer,isMedic,isSpaceman,maxPhysicalPoints,maxMentalPoints,physicalPoints,mentalPoints,isHawkeyed,isStrong,knowsJapanese,understandsAnimals,understandsAI,hasScienceEducation,understandsElectronics,isHandy,isLimping,hasLameHand,pulledLever,pickedUpIntercom,snappedAtGorilla,corridorLeftDoorRepaired,miseryPoursPhrase,firstShutUp,secondShutUp,stoleOfficersBanana,hullBreachRepaired,scannerRepaired,hasCaptainGun,junctionExplained,cargoBayExplained,hasSteelRod,currentlyInJump,jumpedToUnity,justArrivedAtUnity,knowsAboutEleanor,siftedThroughLockers,currentlyHighOnShabu,roomBeforeOvercameBySleepiness,gorillaAttitude,unityOperatorAttitude,afterEleanorFirstChatGoto,getInformalRole,getRoleAdjective,manOrWoman,isMan,isWoman,isStuttering,pointsToDistribute,madeFunOfDrunkednessOnFuneral,name<,bodegaAttitude,title,conceitedness,clock,bodegaShip,messengerShip,firstCombat,bodegaTopics,b,zil,exploration,gorilla,printSleepiness,getHoursToHyperdrive,powerCellsTotal,energyReserve,cargoBayGravity,unityTopics,lastSymptoms,gamebookUid,pageMap,firstPage,_preGotoPosition,currentPage,_choicesToShow,_playerChronology,_playerChronologyChanged,currentBlockIndex,LAST_BLOCK_ON_PAGE,_constructors,_runnerPort,port,presenter",
    set$physicalPoints: function(physicalPoints) {
      this.physicalPoints = H.assertSubtype(physicalPoints, "$isStat", [P.$int], "$asStat");
    },
    set$mentalPoints: function(mentalPoints) {
      this.mentalPoints = H.assertSubtype(mentalPoints, "$isStat", [P.$int], "$asStat");
    },
    set$name: function($name) {
      this.name = H.stringTypeCheck($name);
    },
    set$clock: function(clock) {
      this.clock = H.assertSubtype(clock, "$isStat", [P.$int], "$asStat");
    },
    set$bodegaTopics: function(bodegaTopics) {
      this.bodegaTopics = H.assertSubtype(bodegaTopics, "$isList", [P.String], "$asList");
    },
    set$energyReserve: function(energyReserve) {
      this.energyReserve = H.assertSubtype(energyReserve, "$isStat", [P.$int], "$asStat");
    },
    set$unityTopics: function(unityTopics) {
      this.unityTopics = H.assertSubtype(unityTopics, "$isList", [P.String], "$asList");
    },
    populateVarsFromState$0: function() {
      var t1 = $.get$vars();
      t1.$indexSet(0, "barbrawl", this.barbrawl);
      t1.$indexSet(0, "bodega", this.bodega);
      t1.$indexSet(0, "isEngineer", this.isEngineer);
      t1.$indexSet(0, "isMedic", this.isMedic);
      t1.$indexSet(0, "isSpaceman", this.isSpaceman);
      t1.$indexSet(0, "maxPhysicalPoints", this.maxPhysicalPoints);
      t1.$indexSet(0, "maxMentalPoints", this.maxMentalPoints);
      t1.$indexSet(0, "physicalPoints", this.physicalPoints);
      t1.$indexSet(0, "mentalPoints", this.mentalPoints);
      t1.$indexSet(0, "isHawkeyed", this.isHawkeyed);
      t1.$indexSet(0, "isStrong", this.isStrong);
      t1.$indexSet(0, "knowsJapanese", this.knowsJapanese);
      t1.$indexSet(0, "understandsAnimals", this.understandsAnimals);
      t1.$indexSet(0, "understandsAI", this.understandsAI);
      t1.$indexSet(0, "hasScienceEducation", this.hasScienceEducation);
      t1.$indexSet(0, "understandsElectronics", this.understandsElectronics);
      t1.$indexSet(0, "isHandy", this.isHandy);
      t1.$indexSet(0, "isLimping", this.isLimping);
      t1.$indexSet(0, "hasLameHand", this.hasLameHand);
      t1.$indexSet(0, "pulledLever", this.pulledLever);
      t1.$indexSet(0, "pickedUpIntercom", this.pickedUpIntercom);
      t1.$indexSet(0, "snappedAtGorilla", this.snappedAtGorilla);
      t1.$indexSet(0, "corridorLeftDoorRepaired", this.corridorLeftDoorRepaired);
      t1.$indexSet(0, "miseryPoursPhrase", this.miseryPoursPhrase);
      t1.$indexSet(0, "firstShutUp", this.firstShutUp);
      t1.$indexSet(0, "secondShutUp", this.secondShutUp);
      t1.$indexSet(0, "stoleOfficersBanana", this.stoleOfficersBanana);
      t1.$indexSet(0, "hullBreachRepaired", this.hullBreachRepaired);
      t1.$indexSet(0, "scannerRepaired", this.scannerRepaired);
      t1.$indexSet(0, "hasCaptainGun", this.hasCaptainGun);
      t1.$indexSet(0, "junctionExplained", this.junctionExplained);
      t1.$indexSet(0, "cargoBayExplained", this.cargoBayExplained);
      t1.$indexSet(0, "hasSteelRod", this.hasSteelRod);
      t1.$indexSet(0, "currentlyInJump", this.currentlyInJump);
      t1.$indexSet(0, "jumpedToUnity", this.jumpedToUnity);
      t1.$indexSet(0, "justArrivedAtUnity", this.justArrivedAtUnity);
      t1.$indexSet(0, "knowsAboutEleanor", this.knowsAboutEleanor);
      t1.$indexSet(0, "siftedThroughLockers", this.siftedThroughLockers);
      t1.$indexSet(0, "currentlyHighOnShabu", this.currentlyHighOnShabu);
      t1.$indexSet(0, "roomBeforeOvercameBySleepiness", this.roomBeforeOvercameBySleepiness);
      t1.$indexSet(0, "gorillaAttitude", this.gorillaAttitude);
      t1.$indexSet(0, "unityOperatorAttitude", this.unityOperatorAttitude);
      t1.$indexSet(0, "afterEleanorFirstChatGoto", this.afterEleanorFirstChatGoto);
      t1.$indexSet(0, "getInformalRole", this.getInformalRole);
      t1.$indexSet(0, "getRoleAdjective", this.getRoleAdjective);
      t1.$indexSet(0, "manOrWoman", this.manOrWoman);
      t1.$indexSet(0, "isMan", this.isMan);
      t1.$indexSet(0, "isWoman", this.isWoman);
      t1.$indexSet(0, "isStuttering", this.isStuttering);
      t1.$indexSet(0, "pointsToDistribute", this.pointsToDistribute);
      t1.$indexSet(0, "madeFunOfDrunkednessOnFuneral", this.madeFunOfDrunkednessOnFuneral);
      t1.$indexSet(0, "name", this.name);
      t1.$indexSet(0, "bodegaAttitude", this.bodegaAttitude);
      t1.$indexSet(0, "title", this.title);
      t1.$indexSet(0, "conceitedness", this.conceitedness);
      t1.$indexSet(0, "clock", this.clock);
      t1.$indexSet(0, "bodegaShip", this.bodegaShip);
      t1.$indexSet(0, "messengerShip", this.messengerShip);
      t1.$indexSet(0, "firstCombat", this.firstCombat);
      t1.$indexSet(0, "bodegaTopics", this.bodegaTopics);
      t1.$indexSet(0, "b", this.b);
      t1.$indexSet(0, "zil", this.zil);
      t1.$indexSet(0, "exploration", this.exploration);
      t1.$indexSet(0, "gorilla", this.gorilla);
      t1.$indexSet(0, "printSleepiness", this.printSleepiness);
      t1.$indexSet(0, "getHoursToHyperdrive", this.getHoursToHyperdrive);
      t1.$indexSet(0, "powerCellsTotal", this.powerCellsTotal);
      t1.$indexSet(0, "energyReserve", this.energyReserve);
      t1.$indexSet(0, "cargoBayGravity", this.cargoBayGravity);
      t1.$indexSet(0, "unityTopics", this.unityTopics);
      t1.$indexSet(0, "lastSymptoms", this.lastSymptoms);
    },
    extractStateFromVars$0: function() {
      var t1 = $.get$vars();
      this.barbrawl = H.interceptedTypeCast(t1.$index(0, "barbrawl"), "$isBarBrawl");
      this.bodega = H.interceptedTypeCast(t1.$index(0, "bodega"), "$isSpaceshipMock");
      this.isEngineer = H.boolTypeCast(t1.$index(0, "isEngineer"));
      this.isMedic = H.boolTypeCast(t1.$index(0, "isMedic"));
      this.isSpaceman = H.boolTypeCast(t1.$index(0, "isSpaceman"));
      this.maxPhysicalPoints = H.intTypeCast(t1.$index(0, "maxPhysicalPoints"));
      this.maxMentalPoints = H.intTypeCast(t1.$index(0, "maxMentalPoints"));
      this.set$physicalPoints(H.interceptedTypeCast(t1.$index(0, "physicalPoints"), "$isStat"));
      this.set$mentalPoints(H.interceptedTypeCast(t1.$index(0, "mentalPoints"), "$isStat"));
      this.isHawkeyed = H.boolTypeCast(t1.$index(0, "isHawkeyed"));
      this.isStrong = H.boolTypeCast(t1.$index(0, "isStrong"));
      this.knowsJapanese = H.boolTypeCast(t1.$index(0, "knowsJapanese"));
      this.understandsAnimals = H.boolTypeCast(t1.$index(0, "understandsAnimals"));
      this.understandsAI = H.boolTypeCast(t1.$index(0, "understandsAI"));
      this.hasScienceEducation = H.boolTypeCast(t1.$index(0, "hasScienceEducation"));
      this.understandsElectronics = H.boolTypeCast(t1.$index(0, "understandsElectronics"));
      this.isHandy = H.boolTypeCast(t1.$index(0, "isHandy"));
      this.isLimping = H.boolTypeCast(t1.$index(0, "isLimping"));
      this.hasLameHand = H.boolTypeCast(t1.$index(0, "hasLameHand"));
      this.pulledLever = H.boolTypeCast(t1.$index(0, "pulledLever"));
      this.pickedUpIntercom = H.boolTypeCast(t1.$index(0, "pickedUpIntercom"));
      this.snappedAtGorilla = H.boolTypeCast(t1.$index(0, "snappedAtGorilla"));
      this.corridorLeftDoorRepaired = H.boolTypeCast(t1.$index(0, "corridorLeftDoorRepaired"));
      this.miseryPoursPhrase = H.boolTypeCast(t1.$index(0, "miseryPoursPhrase"));
      this.firstShutUp = H.boolTypeCast(t1.$index(0, "firstShutUp"));
      this.secondShutUp = H.boolTypeCast(t1.$index(0, "secondShutUp"));
      this.stoleOfficersBanana = H.boolTypeCast(t1.$index(0, "stoleOfficersBanana"));
      this.hullBreachRepaired = H.boolTypeCast(t1.$index(0, "hullBreachRepaired"));
      this.scannerRepaired = H.boolTypeCast(t1.$index(0, "scannerRepaired"));
      this.hasCaptainGun = H.boolTypeCast(t1.$index(0, "hasCaptainGun"));
      this.junctionExplained = H.boolTypeCast(t1.$index(0, "junctionExplained"));
      this.cargoBayExplained = H.boolTypeCast(t1.$index(0, "cargoBayExplained"));
      this.hasSteelRod = H.boolTypeCast(t1.$index(0, "hasSteelRod"));
      this.currentlyInJump = H.boolTypeCast(t1.$index(0, "currentlyInJump"));
      this.jumpedToUnity = H.boolTypeCast(t1.$index(0, "jumpedToUnity"));
      this.justArrivedAtUnity = H.boolTypeCast(t1.$index(0, "justArrivedAtUnity"));
      this.knowsAboutEleanor = H.boolTypeCast(t1.$index(0, "knowsAboutEleanor"));
      this.siftedThroughLockers = H.boolTypeCast(t1.$index(0, "siftedThroughLockers"));
      this.currentlyHighOnShabu = H.boolTypeCast(t1.$index(0, "currentlyHighOnShabu"));
      this.roomBeforeOvercameBySleepiness = H.stringTypeCast(t1.$index(0, "roomBeforeOvercameBySleepiness"));
      this.gorillaAttitude = H.intTypeCast(t1.$index(0, "gorillaAttitude"));
      this.unityOperatorAttitude = H.intTypeCast(t1.$index(0, "unityOperatorAttitude"));
      this.afterEleanorFirstChatGoto = H.stringTypeCast(t1.$index(0, "afterEleanorFirstChatGoto"));
      this.getInformalRole = H.interceptedTypeCast(t1.$index(0, "getInformalRole"), "$isFunction");
      this.getRoleAdjective = H.interceptedTypeCast(t1.$index(0, "getRoleAdjective"), "$isFunction");
      this.manOrWoman = H.stringTypeCast(t1.$index(0, "manOrWoman"));
      this.isMan = H.interceptedTypeCast(t1.$index(0, "isMan"), "$isFunction");
      this.isWoman = H.interceptedTypeCast(t1.$index(0, "isWoman"), "$isFunction");
      this.isStuttering = t1.$index(0, "isStuttering");
      this.pointsToDistribute = H.intTypeCast(t1.$index(0, "pointsToDistribute"));
      this.madeFunOfDrunkednessOnFuneral = H.boolTypeCast(t1.$index(0, "madeFunOfDrunkednessOnFuneral"));
      this.name = H.stringTypeCast(t1.$index(0, "name"));
      this.bodegaAttitude = H.intTypeCast(t1.$index(0, "bodegaAttitude"));
      this.title = H.stringTypeCast(t1.$index(0, "title"));
      this.conceitedness = H.intTypeCast(t1.$index(0, "conceitedness"));
      this.set$clock(H.interceptedTypeCast(t1.$index(0, "clock"), "$isStat"));
      this.bodegaShip = H.interceptedTypeCast(t1.$index(0, "bodegaShip"), "$isBodegaShip");
      this.messengerShip = H.interceptedTypeCast(t1.$index(0, "messengerShip"), "$isMessengerShip");
      this.firstCombat = H.interceptedTypeCast(t1.$index(0, "firstCombat"), "$isFirstCombat");
      this.set$bodegaTopics(H.listTypeCast(t1.$index(0, "bodegaTopics")));
      this.b = H.interceptedTypeCast(t1.$index(0, "b"), "$isBodegaZil");
      this.zil = t1.$index(0, "zil");
      this.exploration = t1.$index(0, "exploration");
      this.gorilla = t1.$index(0, "gorilla");
      this.printSleepiness = H.interceptedTypeCast(t1.$index(0, "printSleepiness"), "$isFunction");
      this.getHoursToHyperdrive = H.interceptedTypeCast(t1.$index(0, "getHoursToHyperdrive"), "$isFunction");
      this.powerCellsTotal = H.intTypeCast(t1.$index(0, "powerCellsTotal"));
      this.set$energyReserve(H.interceptedTypeCast(t1.$index(0, "energyReserve"), "$isStat"));
      this.cargoBayGravity = H.intTypeCast(t1.$index(0, "cargoBayGravity"));
      this.set$unityTopics(H.listTypeCast(t1.$index(0, "unityTopics")));
      this.lastSymptoms = H.interceptedTypeCast(t1.$index(0, "lastSymptoms"), "$isTimeline");
    },
    initBlock$0: function() {
      var t1, t2, t3, t4, t5, t6;
      this.barbrawl = null;
      this.bodega = new F.SpaceshipMock(true, F.ShipComponentCollection$(), "Spaceship");
      this.isEngineer = false;
      this.isMedic = false;
      this.isSpaceman = false;
      this.maxPhysicalPoints = 2;
      this.maxMentalPoints = 2;
      this.set$physicalPoints(Z.Stat_Stat("Physical pool", new N.ScripterImpl_initBlock_closure(), "#CCCCCC", "Spare physical energy", 0, 0, false, P.$int));
      this.set$mentalPoints(Z.Stat_Stat("Mental pool", new N.ScripterImpl_initBlock_closure0(), "#CCCCCC", "Spare mental energy", 0, 0, false, P.$int));
      this.isHawkeyed = false;
      this.isStrong = false;
      this.knowsJapanese = false;
      this.understandsAnimals = false;
      this.understandsAI = false;
      this.hasScienceEducation = false;
      this.understandsElectronics = false;
      this.isHandy = false;
      this.isLimping = false;
      this.hasLameHand = false;
      this.pulledLever = false;
      this.pickedUpIntercom = false;
      this.snappedAtGorilla = false;
      this.corridorLeftDoorRepaired = false;
      this.miseryPoursPhrase = false;
      this.firstShutUp = false;
      this.secondShutUp = false;
      this.stoleOfficersBanana = false;
      this.hullBreachRepaired = false;
      this.scannerRepaired = false;
      this.hasCaptainGun = false;
      this.junctionExplained = false;
      this.cargoBayExplained = false;
      this.hasSteelRod = false;
      this.currentlyInJump = false;
      this.jumpedToUnity = false;
      this.justArrivedAtUnity = false;
      this.knowsAboutEleanor = false;
      this.siftedThroughLockers = false;
      this.currentlyHighOnShabu = false;
      this.roomBeforeOvercameBySleepiness = null;
      this.gorillaAttitude = 0;
      this.unityOperatorAttitude = 0;
      this.afterEleanorFirstChatGoto = null;
      this.getInformalRole = null;
      this.getRoleAdjective = null;
      this.manOrWoman = "man";
      this.isMan = null;
      this.isWoman = null;
      this.isStuttering = new N.ScripterImpl_initBlock_closure1();
      this.pointsToDistribute = 0;
      this.madeFunOfDrunkednessOnFuneral = false;
      this.name = "Slim";
      this.bodegaAttitude = 0;
      this.title = "Captain";
      this.conceitedness = 0;
      this.set$clock(Z.Stat_Stat("Time", new N.ScripterImpl_initBlock_closure2(), "#CCCCCC", "Time since captain's funeral", 0, 0, false, P.$int));
      this.bodegaShip = E.BodegaShip$();
      this.messengerShip = E.MessengerShip$();
      this.firstCombat = null;
      this.set$bodegaTopics(["Unity", "Explosion"]);
      this.b = null;
      this.zil = null;
      this.exploration = null;
      this.gorilla = null;
      this.printSleepiness = null;
      this.getHoursToHyperdrive = null;
      this.powerCellsTotal = 8;
      this.set$energyReserve(Z.Stat_Stat("Energy reserve", new N.ScripterImpl_initBlock_closure3(), "#CCCCCC", "The number of charged power cells", 8, 0, false, P.$int));
      this.cargoBayGravity = 20;
      this.set$unityTopics(["Organization", "ActiveThreatBlacklist", "AskToDock", "AskToTrade", "WhereToGo"]);
      t1 = H.setRuntimeTypeInfo([], [L.TimedEvent]);
      t2 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, P.$int), "$isMap", [P.$int, P.$int], "$asMap");
      H.assertSubtype(t1, "$isList", [L.TimedEvent], "$asList");
      H.assertSubtype(t2, "$isMap", [P.$int, P.$int], "$asMap");
      O.throwIfNotInInitOrDeclareBlock("");
      this.lastSymptoms = new L.Timeline(-1, null, null, t1, t2, null, false, "Timeline", false);
      t2 = H.getVoidRuntimeType();
      t1 = H.buildInterfaceType(P.String);
      t3 = H.buildFunctionType(t2, [t1]);
      t3._assertCheck$1(O.echo$closure());
      t4 = H.buildInterfaceType(P.bool);
      t1 = H.buildNamedFunctionType(H.buildInterfaceType(L.EgbChoice), [t1], {deferToChoiceList: t4, deferToEndOfPage: t4, goto: t1, script: H.buildInterfaceType(P.Function), submenu: t1});
      t1._assertCheck$1(O.choice$closure());
      t4 = H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, T.BarBrawlOption), "$isSet", [T.BarBrawlOption], "$asSet");
      t5 = H.setRuntimeTypeInfo([], [L.TimedEvent]);
      t6 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, P.$int), "$isMap", [P.$int, P.$int], "$asMap");
      H.assertSubtype(t5, "$isList", [L.TimedEvent], "$asList");
      H.assertSubtype(t6, "$isMap", [P.$int, P.$int], "$asMap");
      O.throwIfNotInInitOrDeclareBlock("");
      t6 = new T.BarBrawl(H.assertSubtype(null, "$isList", [T.BarBrawlOption], "$asList"), H.assertSubtype(t4, "$isSet", [T.BarBrawlOption], "$asSet"), new L.Timeline(-1, null, null, t5, t6, null, false, "Timeline", false), 0, false, false, t3._assertCheck$1(O.echo$closure()), t1._assertCheck$1(O.choice$closure()), false, null, null, H.assertSubtype(C.List_empty, "$isList", [Y.Actor], "$asList"));
      H.assertSubtype(C.List_empty, "$isList", [Y.Actor], "$asList");
      this.barbrawl = t6;
      t6._initOptions$0();
      t6._initTimeline$0();
      this.barbrawl.onFinishedGoto = "Brawl: Finished";
      this.getInformalRole = new N.ScripterImpl_initBlock_closure4(this);
      this.getRoleAdjective = new N.ScripterImpl_initBlock_closure5(this);
      this.isMan = new N.ScripterImpl_initBlock_closure6(this);
      this.isWoman = new N.ScripterImpl_initBlock_closure7(this);
      $.get$_footnotes().$indexSet(0, "funeralInSpace", "This is common practice when a spaceship is stranded and there are casaulties on board. Unless there's a good chance that the bodies can be preserved until a rescue ship comes, bodies are ejected into space. This minimizes the risk of infection and allows the crew to focus on their own survival instead of on ways to preserve bodies.");
      $.get$_footnotes().$indexSet(0, "stationClara", "Clara is a German station orbiting the Epaphus red dwarf. The port is well known for high-quality industrial products and a good shipyard. Once in about 200 earth days (the station's orbital period) they also hold the 'Oktoberfest' \u2013 a beer drinking festival. (This was not the time, though.)");
      $.get$_footnotes().$indexSet(0, "gorillaCargoMove", "Everything in the cargo bay is in containers, but often, parts from containers further from the bay doors need to be offloaded before those closer to the bay doors. And so instead of offloading the whole lot and then re-loading it again, it's more efficient to swap the cargo between containers during the flight. That's where strong \u2013 but sensitive \u2013 arms like those of a gorilla come in handy.");
      $.get$_footnotes().$indexSet(0, "oathFirstExpl", "Under the so-called 'Oath Law' \u2013 which has been adopted by all space-faring nations \u2013 no artificial intelligence beyond a certain level can exist without a human superior. In other words, as a safeguard against a machine rebellion (an entirely plausible scenario), there cannot be a completely autonomous artificial intelligence, and all machines must have a human master, to which they are \u2013 by design \u2013 utterly loyal. The Oath can be transfered, like in this case, but never dropped entirely.");
      $.get$_footnotes().$indexSet(0, "computeUnityJump", " Every hyperjump needs to be precisely computed, which is no small task. (Even military ships with dedicated computing nodes take hours to prepare.) Fortunately for interstellar travel, though, parameters for jumps between known points in space do not change, and so ships normally work with precomputed data. The problem here is that Bodega is now at a point in deep space for which the data simply doesn't exist. The only option is to compute it. ");
      $.get$_footnotes().$indexSet(0, "vitamin", " 'Vitamin' is an addictive, easy to manufacture drug that makes you feel invincible. It also makes you crave blood and violence. Users engage in gory rituals, sadistic orgies and murders.");
      this.firstCombat = E.FirstCombat$(this.bodegaShip, this.messengerShip, "Dogfight: Resolution");
      $.get$_footnotes().$indexSet(0, "khwarizmi", "The al-Khw\u0101rizm\u012b is an African League star system beyond Groombridge 12 (Bodega's destination before the incident). Its largest station, the KHW-1, is an important interstellar trading hub.");
      $.get$_footnotes().$indexSet(0, "shipGraveyard", "The Ship Graveyard is a place in the otherwise uninhabited Theta Cru star system, where decomissioned ships are left for salvage. Sometimes, as a way of punishment, the ship AI is left alive, but all its means of communication and movement are taken a way from it. Such an AI is effectively excommunicated for as long as its power input lasts, which can be hundreds or thousands of years.");
      t3._assertCheck$1(O.$goto$closure());
      t3._assertCheck$1(O.echo$closure());
      t1._assertCheck$1(O.choice$closure());
      t2 = H.buildFunctionType(t2, [H.buildInterfaceType(G.Form)]);
      t2._assertCheck$1(O.showForm$closure());
      t4 = new K.Zil(this, null, null, null, null, null);
      t4.items = new K.ItemPool(t4, H.assertSubtype(H.setRuntimeTypeInfo([], [K.Item]), "$isList", [K.Item], "$asList"));
      t4.rooms = new K.RoomNetwork(t4, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, K.Room), "$isMap", [P.String, K.Room], "$asMap"), "$isMap", [P.String, K.Room], "$asMap"), null, false);
      t4.actors = new K.ActorSociety(t4, H.assertSubtype(H.setRuntimeTypeInfo([], [K.AIActor]), "$isList", [K.AIActor], "$asList"), null, null);
      t5 = H.setRuntimeTypeInfo([], [P.String]);
      t5 = new K.ZilPlayer(null, true, t4, null, H.listSuperNativeTypeCheck(C.List_empty, "$isIterable"), false, "player", H.assertSubtype(t5, "$isList", [P.String], "$asList"), true, 1, true, true, C.Pronoun_you_you_your_yourself);
      t5.ZilActor$8$actions$isPlayer$items$nameIsProperNoun$pronoun$team(t4, "player", C.List_empty, true, C.List_empty, false, C.Pronoun_you_you_your_yourself, 1);
      t4.player = t5;
      if (t4.timeline == null) {
        t5 = H.setRuntimeTypeInfo([], [L.TimedEvent]);
        t6 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, P.$int), "$isMap", [P.$int, P.$int], "$asMap");
        H.assertSubtype(t5, "$isList", [L.TimedEvent], "$asList");
        H.assertSubtype(t6, "$isMap", [P.$int, P.$int], "$asMap");
        O.throwIfNotInInitOrDeclareBlock("");
        t4.timeline = new L.Timeline(-1, null, null, t5, t6, null, false, "Timeline", false);
      }
      t5 = new L.BodegaZil(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, t4, t3._assertCheck$1(O.$goto$closure()), t3._assertCheck$1(O.echo$closure()), t1._assertCheck$1(O.choice$closure()), t2._assertCheck$1(O.showForm$closure()), this, null);
      t3._assertCheck$1(O.$goto$closure());
      t3._assertCheck$1(O.echo$closure());
      t1._assertCheck$1(O.choice$closure());
      t2._assertCheck$1(O.showForm$closure());
      t5.setupTimeline$0();
      t5.setupActors$0();
      t5.setupRooms$0();
      this.b = t5;
      this.zil = t4;
      this.exploration = t5.exploration;
      this.gorilla = t5.gorilla;
      this.printSleepiness = t5.get$printSleepiness();
      this.getHoursToHyperdrive = this.b.get$getHoursToHyperdrive();
      $.get$_footnotes().$indexSet(0, "creditsRing", " The credits rings are worn by their owners on the little finger or the ring finger. They are the standard means of payment on spaceports and almost anywhere else in the universe. Most credit rings are set up with a security measure that prevents anyone other than the original owner from using them. This freeze can usually be lifted on space stations through the financial institution that issued the ring.");
      $.get$_footnotes().$indexSet(0, "shabu", " Shabu is a Japanese variant of thinned methamphetamine \u2013 an old, potent and relatively cheap psychostimulant used all over the universe. It enhances mood, alertness, awareness, wakefulness, endurance, productivity, and motivation, increases arousal, locomotion, heart rate, and blood pressure, and it gives the perception of a diminished requirement for food and sleep. It is also neurotoxic, damaging both dopamine and serotonin neurons, causes brain damage after long-term use, and can induce psychosis and cerebral hemorrhage. Shabu is distributed in bullet-shaped vials and snorted directly from them. The vials are completely sealed before use, which makes them hard to detect by trace sensors. ");
      $.get$_footnotes().$indexSet(0, "planetborn", " Planetborns are people who were born and raised on planets. They are a rare sight in space. Mostly welcome sight, too, since they bring money, although some spacers can't stand them for their snobbery and self-importance. ");
      $.get$_footnotes().$indexSet(0, "superchargeHyperdrive", " ");
      $.get$_footnotes().$indexSet(0, "unityAquarium", " The aquarium is the food source from which the whole station's population could survive indefinitely, if needed. It contains a full ecosystem of creatures \u2013 from plankton to clams to predatory fish \u2013 that have been genetically modified from the sea habitats of Earth (but still look pretty much the same). At the center of the aquarium there is a three dimensional maze of (partly artificial) corals, accessible by long tubes from the outside. This is where most of the fishing takes place. It's also where the tourists sometimes go 'diving'. ");
    },
    ScripterImpl$0: function() {
      var t1, t2;
      t1 = new O.EgbScripterPage([[null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Brawl: Start"], null, null)]], 0, null, false, false);
      t2 = this.pageMap.pages;
      t2.$indexSet(0, "start", t1);
      t1.name = "start";
      t1 = new O.EgbScripterPage(["<p class=\"meta\">This lets you play the combat.</p>", [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure(), "goto", "Start: Funeral"], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure0(), "goto", "DEBUG: CombatSetup"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "DEBUG: Start", t1);
      t1.name = "DEBUG: Start";
      t1 = new O.EgbScripterPage([[null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Dogfight: FirstCombatStart"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "DEBUG: CombatSetup", t1);
      t1.name = "DEBUG: CombatSetup";
      t1 = new O.EgbScripterPage(["## The Brawl", "Let's start in the middle of it: a bar fight at Space Station Clara, two years ago. A short but muscular zero-g farmer just hit you in the face. ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Loop"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Brawl: Start", t1);
      t1.name = "Brawl: Start";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure1(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Brawl: Loop"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Brawl: Loop", t1);
      t1.name = "Brawl: Loop";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure2(this)], 0, null, false, false);
      t2.$indexSet(0, "Brawl: Finished", t1);
      t1.name = "Brawl: Finished";
      t1 = new O.EgbScripterPage(["With that out of the way, you looked around. The bar was a mess \u2014 everyone fighting, ... XXX START HERE", "// You don't need this. You start making your way to the exit. Then you see ..... Captain Kay!", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Start: Funeral"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Brawl: Win", t1);
      t1.name = "Brawl: Win";
      t1 = new O.EgbScripterPage(["That ended the story before it even started. You survived, of course, but you didn't get to meet Captain Kay and you didn't get to board the Bodega. Still an interesting life story, I'm sure, but not the one we want to tell here.", "<p class=\"meta\">Restart and keep trying.</p>"], 0, null, false, false);
      t2.$indexSet(0, "Brawl: Lose", t1);
      t1.name = "Brawl: Lose";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure3(), "## The Funeral", "This story both begins and ends with a death, on a spaceship.", new N.ScripterImpl_closure4(), "The first death is that of the captain, whose body you just finished dragging through the empty ship and laid down in the airlock. When he died a couple of minutes ago, he left you as the last survivor on board of the Bodega.", [new N.ScripterImpl_closure5(), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure6(), "script", new N.ScripterImpl_closure7(this)], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure8(), "script", new N.ScripterImpl_closure9(this)], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure10(), "script", new N.ScripterImpl_closure11(this)], null, null)], new N.ScripterImpl_closure12(this), "Now, the ship is silent and the whole crew is dead. Since the explosion in the cargo bay, the men and women had been taking turns in screaming in pain, then getting uncanilly stiff, then dying. The captain held a memorial service for every one of them, each funeral \u2013 of course \u2013 a little shorter and simpler than the previous. Now it's your turn to be the master of ceremony.", new N.ScripterImpl_closure13(this), new N.ScripterImpl_closure14(), new N.ScripterImpl_closure15(this), new N.ScripterImpl_closure16(this), "The funeral looks like this: You are standing in front of one of the ship's two airlocks. Through the porthole window, you can see the captain's body lying on the floor, naked and reddish and stiff. Just like all the others before him. When you had put him down there a minute ago, you made sure he's lying reasonably straight, like one would do in a coffin. You even put a blanket under him so he doesn't lie on the cold steel of the airlock.", "Not that the dead care much about cold. But that's what you did.", "![Dead captain Kay](img/airlock.jpg)", new N.ScripterImpl_closure17(), "The inner door, through which you're watching, is safely closed and sealed. The only thing that remains is to pull the lever.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Start: Funeral.choice"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Start: Funeral", t1);
      t1.name = "Start: Funeral";
      t1 = new O.EgbScripterPage([[null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure18(), "goto", "SaySomethingNice"], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure19(), "goto", "Pull"], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure20(), "goto", "LeaveBody"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Start: Funeral.choice", t1);
      t1.name = "Start: Funeral.choice";
      t1 = new O.EgbScripterPage(["You clear your throat. ", new N.ScripterImpl_closure21(this), "For some reason, the only things that come to mind right now are _far_ from nice. Your head is full of images of the captain being drunk to the point he couldn't stand up. ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure22(), "script", new N.ScripterImpl_closure23(this)], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure24(), "script", new N.ScripterImpl_closure25(this)], null, null)], "<p class=\"meta\">Note: Decisions like these help define your character.</p>", "You are silent for a few moments, and then you end up saying: \"Captain Kay, you were a great captain.\" And that is definitely true.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Funeral.choice"], null, null)]], 0, null, true, false);
      t2.$indexSet(0, "Start: SaySomethingNice", t1);
      t1.name = "Start: SaySomethingNice";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure26(this), new N.ScripterImpl_closure27(), new N.ScripterImpl_closure28(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Recollections"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Start: Pull", t1);
      t1.name = "Start: Pull";
      t1 = new O.EgbScripterPage(["You withdraw your hand from the lever.", new N.ScripterImpl_closure29(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Recollections"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Start: LeaveBody", t1);
      t1.name = "Start: LeaveBody";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure30(), new N.ScripterImpl_closure31(this), "So you sat alone. And so did the captain, a few tables away \u2013 just another bar patron in a dirty jacket and a glass of German zero-G-hops beer on the table.", new N.ScripterImpl_closure32(this), "That's when you really noticed the captain for the first time. ", "He wasn't fighting. He was standing in the middle of the whole mess, laughing his head off. (You would later learn that this was not at all unusual for him \u2013 he would laugh maniacally at the least opportune of times, even if he was in danger. Especially if he was in danger.) You were ready to go on but then you heard, \"What's so funny, shitface,\" and you noticed a huge, furious warehouseman running straight at the captain with a chair above his head. The chair had a mock-wood finish, like almost everything in the bar, but you knew it was actually metal.", "The captain laughed on, standing with his back to the quickly approaching warehouseman.", "For some reason, in spite of all the good reasons not to, you decided to run towards the captain to defend him against the warehouseman and his crippling blow. You knew full well you'd regret this. ", "\"This is bullshit,\" you said to yourself when you broke into a sprint across the room. ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure33(), "script", new N.ScripterImpl_closure34(this)], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure35(), "script", new N.ScripterImpl_closure36(this)], null, null)], "In shock and still oblivious to the scope of your injury, you watched the captain receive blow after brutal blow from the looming warehouseman (at least it was fists and not a metal chair) and you tried to stand up \u2013 almost managed to pull it off, too \u2013 but then everything went dark and you just plain fainted.", "The next thing you knew, the bar was empty and captain Kay was helping you on your feet. There was blood in his hair. He was laughing again.", "\"What's your name, kid?\" He grinned.", new N.ScripterImpl_closure37(this), new N.ScripterImpl_closure38(this), "You kept looking at him but didn't say anything.", new N.ScripterImpl_closure39(this), "You nodded.", new N.ScripterImpl_closure40(this), "\"Broken, I think. It's fine if I don't move it but\u2013\" You screamed when you touched it. The pain was horrific.", new N.ScripterImpl_closure41(this), new N.ScripterImpl_closure42(this), new N.ScripterImpl_closure43(this), new N.ScripterImpl_closure44(this), new N.ScripterImpl_closure45(this), new N.ScripterImpl_closure46(), "[IMG of intercom]", "The intercom on the wall starts ringing loudly and blinking with a red light. The ringtone and the color-coding means \"to all crew\" \u2013 in other words: \"everyone in their ability should pick this up\".", "The intercom, in this case, is an old school handset wired to the wall with a spiral cable. It's easier to maintain, less faulty, and it only picks up one person's voice, so it's easier to understand the other end. It also makes it possible to have conversations that are meant for a limited audience, as opposed to everyone in the room. Sometimes, it's needed to break news that are not intended for the whole crew.", "The cable is there mostly so that the handset stays put where it belongs (but it does conduct the audio signal to and from the handset).", [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure47(), "goto", "Ignore"], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure48(), "goto", "PickItUp"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Start: Recollections", t1);
      t1.name = "Start: Recollections";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure49(this), "After a while, the intercom goes silent. Instead, PA speakers along the corridor turn on with a crackle. It's the ship computer. She sounds irritated.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "ShipSays"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Start: Ignore", t1);
      t1.name = "Start: Ignore";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure50(this), "You pick the handset up. It's the ship computer.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "ShipSays"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Start: PickItUp", t1);
      t1.name = "Start: PickItUp";
      t1 = new O.EgbScripterPage(["\"To all whom it may concern,\" she says, although she knows there's only you. \"There is a gorilla on the bridge. I repeat, a gorilla. _On the bridge._\" ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure51(), "goto", "Coming"], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure52(), "goto", "CantThisWait"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Start: ShipSays", t1);
      t1.name = "Start: ShipSays";
      t1 = new O.EgbScripterPage(["\"Oh, I'm sorry,\" the ship says. \"I didn't want to ruin the moment by, you know, _trying to stop yet another disaster from happening!_ The bridge, you might recall, is a place with lots of electronics and, interestingly, also the control panels to _the whole goddamned ship._ In summary, this is no place for a stupid gorilla.\" ", new N.ScripterImpl_closure53(), new N.ScripterImpl_closure54(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Coming"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Start: CantThisWait", t1);
      t1.name = "Start: CantThisWait";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure55(this), new N.ScripterImpl_closure56(this), "You follow Corridor Right \u2013 a badly lit tube of dusty cables and fluorescent lamps running along the right side of the Bodega, from the huge cargo bay at the back of the ship all the way to the bridge in the front. The stark white light of the lamps is supplemented by the red bulbs of the ship alarm which have been pulsating since the beginning of the disease 14 days ago. ", "In a few moments, you pass the door to the computer room on your right, and shortly after, you are at your destination.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Bridge: GorillaIncident"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Start: Coming", t1);
      t1.name = "Start: Coming";
      t1 = new O.EgbScripterPage(["## The Gorilla", "There really is a gorilla on the ship's bridge. But it isn't touching any of the electronics, let alone the control panel. It just sits there on the floor, full of melancholy, looking out the window at the distant stars. When you enter, it slowly turns to you and pushes out its huge lower lip.", "![Gorilla](img/gorilla.jpg)", new N.ScripterImpl_closure57(), "The gorilla doesn't have a name. The crew just calls him 'Gorilla', which is a common name for these creatures on most ships. Nobody wants to get too attached to them. They die a lot.", "Right now, Gorilla raises his arms to sign. First, he makes the sign for \"me\" and then he makes the sign for \"sleep\". _Is he trying to say he wants to go to sleep?_ Probably not (although he does look tired). More likely, he's trying to use his limited vocabulary to communicate that he is sad. But you can never be sure.", [new N.ScripterImpl_closure58(), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure59(), "goto", "ItsOkay"], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure60(), "goto", "WhatTheHellGorilla"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Bridge: GorillaIncident", t1);
      t1.name = "Bridge: GorillaIncident";
      t1 = new O.EgbScripterPage(["\"It's okay.\" ", "Gorilla slowly turns his head back to the stars, visibly alleviated. One of the enhancements they did on the Enhanced Gorillas is a deeply rooted fear of people. Of course, it's completely irrational \u2013 Gorilla could squash you or any other human any time \u2013 but the animal can't help it. The fear is in his DNA.", "The fact that you didn't scold him means the world to him. You know he will remember this.", new N.ScripterImpl_closure61(this), new N.ScripterImpl_closure62(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "HateToUnnerveYou"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Bridge: ItsOkay", t1);
      t1.name = "Bridge: ItsOkay";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure63(this), "Gorilla doesn't answer, he only looks at you in sudden terror. One of the enhancements they did on the Enhanced Gorillas is a deeply rooted fear of people. Of course, it's completely irrational \u2013 Gorilla could squash you or any other human any time \u2013 but the animals can't help it. It's in their DNA.", "After a while, Gorilla leaves the bridge with pure horror in its eyes. He goes through the door to Corridor Left, probably heading way back to the cargo bay. You know he will remember this.", new N.ScripterImpl_closure64(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "HateToUnnerveYou"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Bridge: WhatTheHellGorilla", t1);
      t1.name = "Bridge: WhatTheHellGorilla";
      t1 = new O.EgbScripterPage(["The ship is silent for a while.", "\"I would just _hate_ to unnerve you,\" she finally says, \"but considering that there is no reason to believe you are _not_ contaminated with the same illness as everyone else, and that we have no reliable data on the incubation period, I propose we make the jump to Space Station Unity as soon as possible.", new N.ScripterImpl_closure65(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure66(this), "goto", "CrewOfOne", "script", new N.ScripterImpl_closure67(this)], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure68(this), "goto", "CrewOfOne", "script", new N.ScripterImpl_closure69(this)], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Bridge: HateToUnnerveYou", t1);
      t1.name = "Bridge: HateToUnnerveYou";
      t1 = new O.EgbScripterPage(["## The crew of one", "You are dog-tired. You spent the last couple of days slaving away \u2013 together with Gorilla and the late Captain Kay \u2013 to finish the repairs of the hyperdrive. It had broken down in the middle of nowhere after one of the containers in the cargo bay exploded. (Apparently, the explosion was due to some inapt handling by none other than \u2013 Gorilla.) It wasn't a particularly big blast, but the shockwave rippled through the whole ship, and -- among other things -- put the hyperdrive into an invalid state. As it turned out, though, the malfunctioning drive was to be the lesser of your worries.", new N.ScripterImpl_closure70(this), "\"It's not like I _wasn't_ expecting to die out in space one day,\" he said to you from behind glass (back then, the crew still tried to mantain some kind of quarantine). \"It kind of goes with the occupation. But I sure as hell didn't expect it to come _this_ soon.\" He was forty-five, one of the oldest. He died the next day.", "[IMG of a sick, sad medic behind a glass]", "The only thing that has kept you from worrying about your own death so far was work. Anything else leaves too much brain capacity to imagination. Going to sleep has been particularly difficult because of the strange dreams, because of the ambiguous feelings about the whole thing, and because there is always the possibility you'd never. Wake. Up.", "This time, though, you are so unbelievably tired you will probably fall asleep the minute you close your eyes.", new N.ScripterImpl_closure71(this), new N.ScripterImpl_closure72(this), "The thing is: you have a feeling that the disease \u2013 and the consequent high probability that you will die alone, in space, and in horrible pain \u2013 is not your only worry. There is something else. Something bigger. One of Captain Kay's favorite phrases was: \"When misery rains, it pours.\" Also: \"We're in _space_, idiots, what did you expect?\" ", "You can't help but fear that space isn't done with you just yet, and that what is happening right now is just the beginning.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "TimeZero"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Bridge: CrewOfOne", t1);
      t1.name = "Bridge: CrewOfOne";
      t1 = new O.EgbScripterPage(["[IMG watch with 0:00]", new N.ScripterImpl_closure73(this), "You reset your watch to 0:00. In space, with the absence of meaningful days, it's common practice to pick memorable events as milestones and then count hours and days from these. The death of the captain strikes you as one such memorable event.", new N.ScripterImpl_closure74(this), "It's up to you what you do with the time at hand. You look around the bridge.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Explore: Bridge"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Bridge: TimeZero", t1);
      t1.name = "Bridge: TimeZero";
      t1 = new O.EgbScripterPage(["You come back to the bridge, determined to do some more work, but at that exact time, your body just refuses to continue. You can't imagine _walking_ somewhere, let alone trying to _work_.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Nap"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Bridge: OvercomeBySleepiness", t1);
      t1.name = "Bridge: OvercomeBySleepiness";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure75(this), "You spend the time gazing blankly at the distant stars.", new N.ScripterImpl_closure76(this), "You stand up excitedly.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Explore: Bridge"], null, null)]], 0, null, true, false);
      t2.$indexSet(0, "Bridge: WaitForJump", t1);
      t1.name = "Bridge: WaitForJump";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure77(this), new N.ScripterImpl_closure78(), "You have that strange dream again. You are planetside, standing in a _forest_, no less, on the edge of a meadow at night. This is Earth, somehow you know it, and you breathe in slowly and deeply, smelling the moist air as if it was something familiar to you. (You have never been planetside in your entire life. Not on Earth, not anywhere else.) You try to watch the meadow for as long as you can. This is the good part of the dream.", "You hear a twig crack quietly just behind you, and you turn around. It's the worst sight you can imagine. Your parents.", new N.ScripterImpl_closure79(), new N.ScripterImpl_closure80(this), new N.ScripterImpl_closure81(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Dogfight: Start"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Bridge: Nap", t1);
      t1.name = "Bridge: Nap";
      t1 = new O.EgbScripterPage(["## The Encounter", new N.ScripterImpl_closure82(this), "You wake up to regular bleeps of the radar. That's what the rhytmic sound in the dream was.", "\"I repeat,\" the ship says, quite urgently. \"We have a radar contact.\" ", "You look at the radar screen. It seems some smaller vessel is nearing rapidly. It doesn't seem like a pirate (those tend to be bigger or more numerous), but the behaviour is highly unusual. Who would want to get this close to another ship in deep space, without any previous communication? How did they even find you here?", "Shortly afterwards, the vessel is in visual range. It's a Messenger class ship, a fast clipper about tenth of the size of the Bodega. If it's hostile, it could still pose a serious threat, but would probably run a big risk itself.", "[IMG: Bodega and Messenger face-to-face]", "The ship glides to a halt in front of the bridge, face to face with The Bodega. After a while, the communications panel lights up. There is an incoming call from the Messenger. ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Encounter"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Dogfight: Start", t1);
      t1.name = "Dogfight: Start";
      t1 = new O.EgbScripterPage(["The main screen fills with a large, bored face of a pilot with a large jaw and short hair. He's not even looking at the console, being busy with some controls to his lower left. ", "\"Calling the crew of the Bodega,\" he starts reciting, absently. \"This is...\" ", "Then he looks up, sees you on the screen, and stops abruptly.", "\"Oh!\" he says. \"Oh _fuck!_\" ", new N.ScripterImpl_closure83(this), "The pilot begins to frantically push some buttons on the panel in front of him. \"Oh fuck oh fuck oh _fuck!_\" he keeps repeating.", new N.ScripterImpl_closure84(this), "The communications panel goes blank as the pilot closes the connection. The Messenger starts moving to the side. He knows that his best bet is to be moving all over the place.", new N.ScripterImpl_closure85(this), "It's not _all_ bad, though. The Messenger is clearly not a combat vessel. You can only see 2 guns in the front, and those seem pretty weak. The hull is slender. Moreover, according to the markings on the side, the ship is a Sentaco corporate runner. Sentaco \u2013 although one of the biggest corporations out there \u2013 is not one of the militarized ones. It deals in food and consumer goods. ", "The frail Messenger clearly wasn't sent here to fight the huge pile of steel that is the Bodega. But it _is_ fighting it now, for whatever reason, and it's bound to be ugly for both sides.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "FirstCombatStart"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Dogfight: Encounter", t1);
      t1.name = "Dogfight: Encounter";
      t1 = new O.EgbScripterPage(["<p class=\"meta\"><strong>Note:</strong> HERE BE DRAGONS. As much as the previous part of the gamebook is rough, the next parts are <em>plain work-in-progress</em>. You will likely encounter errors and will most definitely run into a dead end. <strong>Continue at your own peril.</strong></p>", new N.ScripterImpl_closure86(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure87(), "goto", "Dogfight: CombatLoop"], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure88(), "goto", "Win"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Dogfight: FirstCombatStart", t1);
      t1.name = "Dogfight: FirstCombatStart";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure89(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Dogfight: CombatLoop"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Dogfight: CombatLoop", t1);
      t1.name = "Dogfight: CombatLoop";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure90(this)], 0, null, false, false);
      t2.$indexSet(0, "Dogfight: Resolution", t1);
      t1.name = "Dogfight: Resolution";
      t1 = new O.EgbScripterPage(["The Bodega goes completely silent in the dead of space. Then there's an extremely loud, metalic noise, as the Bodega gets torn apart. There are explosion on different parts of the ship, loud white noise of inner atmosphere shooting out into space. The computer screams. You know you are going to die soon, but maybe that's for the better. You glance at the Messenger for the last time, and then there's nothing."], 0, null, false, false);
      t2.$indexSet(0, "Dogfight: Lose", t1);
      t1.name = "Dogfight: Lose";
      t1 = new O.EgbScripterPage(["This time, the beam must have drilled through to the core, because there is a violent explosion on the Messenger. Only the skeleton of the ship stays put, the rest is blown away from the inside, in all directions.", "[IMG of messenger exploding]", new N.ScripterImpl_closure91(this), new N.ScripterImpl_closure92(this), new N.ScripterImpl_closure93(this), "On the plus side, though, you _are_ still alive.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Why?"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Dogfight: Win", t1);
      t1.name = "Dogfight: Win";
      t1 = new O.EgbScripterPage(["You try to imagine why the Messenger came here and why the pilot acted the way he acted. Was he just so stupid to try to pick a fight with a much sturdier ship? Was he expecting to find something else here? Or someone else? Did he know about the disease? Was he acting on his own, or was this an official Sentaco run? Is Sentaco a pirate company now? Why would it be interested in the Bodega, of all the ships?", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "AfterMessengerDogfight"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Dogfight: Why?", t1);
      t1.name = "Dogfight: Why?";
      t1 = new O.EgbScripterPage(["## Enemies", new N.ScripterImpl_closure94(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure95(), "script", new N.ScripterImpl_closure96()], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure97(), "script", new N.ScripterImpl_closure98(this)], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure99(), "script", new N.ScripterImpl_closure100(this)], null, null)], new N.ScripterImpl_closure101(), new N.ScripterImpl_closure102(this), new N.ScripterImpl_closure103(), [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure104()], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure105(), "script", new N.ScripterImpl_closure106(this)], null, null)], new N.ScripterImpl_closure107(this), new N.ScripterImpl_closure108(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Explore: Bridge"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Dogfight: AfterMessengerDogfight", t1);
      t1.name = "Dogfight: AfterMessengerDogfight";
      t1 = new O.EgbScripterPage(["You lean on one of the chairs and think about questions to ask. The ship computer listens (as always).", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Choice"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "BodegaQuestions: Start", t1);
      t1.name = "BodegaQuestions: Start";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure109(this), new N.ScripterImpl_closure110(this)], 0, null, false, false);
      t2.$indexSet(0, "BodegaQuestions: Choice", t1);
      t1.name = "BodegaQuestions: Choice";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure111(this), "You were familiar with the name Unity, and you do remember the captain talking about _'Nitty_ the last few days, but that wasn't something you'd try to process. You focused solely on your own work and on not thinking too much about anything else.", "The station's 3D model appears on the main window and starts slowly rotating. You've never been to Unity, but you can tell from the visualization that it is huge. There's a giant spherical fishery \u2013 an aquarium with fish that serves as a renewable source of high quality food \u2013 at its center. The station itself is a thick band slowly rotating around it.", "In a condescending monotone, the Bodega starts explaining: \"Space Station Unity was established by UNSA 74 years ago, in deep space, 0.21 lightyears away from the Groombridge star system. It serves as a trading and international administration hub for the surrounding sector, notably for the Japanese Shisuteki station (Gl 83.1, _ light years away), the German stations Bollwerk and Struve (Kruger 60, 24Eta Cas, _ and _ light years away, respectively) and the Russian station Golitsyn (Gl 873, _ light years away).\" ", "\"It currently houses a population of about 60,000. Facilities include a cargo port, four different warehouses, a dry dock, a medical center, an arboretum, and a communication beacon. A task force of about 20 UNSA ships is stationed at Space Station Unity.\" ", "Bodega pauses. \"I hope that clears things up.\" The visualization disappears.", new N.ScripterImpl_closure112(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Choice"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "BodegaQuestions: Unity", t1);
      t1.name = "BodegaQuestions: Unity";
      t1 = new O.EgbScripterPage(["You stop yourself from asking \u2013 you realize that what Bodega pronounces as \"oonzah\" is in fact U.N.S.A. The actronym stands for _United Nations Space Administration_.", "U.N.S.A. is the ancient intergovernmental organization that was behind much of the early interstellar space exploration, and still holds quite some influence in deep space. With the recent expansion-fed rebirth of nationalism, its role is both more needed and less accepted by the governments of space.", "U.N.S.A. means neutrality, and \u2013 more often than not \u2013 relative safety. It also means lower taxes and a little more corporate influence than what is usual on government worlds and stations.", new N.ScripterImpl_closure113(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Choice"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "BodegaQuestions: UNSA", t1);
      t1.name = "BodegaQuestions: UNSA";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure114(this), "A visualization of the cargo bay appears on the monitor. \"There is no camera coverage of the location. We know Gorilla was in the general area at that time, but since he wasn't injured, he couldn't have been very close when the explosion happened. The blast was not big, but sizeable. It nearly destroyed the container of its origin and damaged several others around it.\" ", "\"Yes, I know all this.\" ", "\"So, why are you asking, I wonder?\" ", "\"The investigation. I know Mitsuyo was running around getting information. He made notes and everything.\" ", "\"Officer Mitsuyo _and_ the captain. _And_ me. We worked as a team on this. I provided the necessary contextual data and I analyzed\u2013\" ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure115(), "script", new N.ScripterImpl_closure116(this)], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure117(), "script", new N.ScripterImpl_closure118(this)], null, null)], "The Bodega lists some tabular data on the main window. ", "\"Before we could arrive at a final conclusion, the first symptoms of the contagion arrived, and repairing the hyperdrive became the top priority. The consensus between captain Kay and officer Mitsuyo seemed to be that this wasn't any of the usual suspects. No badly secured gas tank, no illicit mining explosives, no chemical batteries. It was something else.\" ", "\"So, a sabotage? A terrorist attack? In a freighter's _cargo bay?_ That doesn't make sense.\" ", "\"As I already said, the investigation was inconclusive. I can display the whole report, including the chemistry drill-down of the collected samples, but I doubt you will understand any of that.\" ", new N.ScripterImpl_closure119(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Choice"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "BodegaQuestions: Explosion", t1);
      t1.name = "BodegaQuestions: Explosion";
      t1 = new O.EgbScripterPage([], 0, null, false, false);
      t2.$indexSet(0, "Explore: ONLY_VARIABLES (PAGE NOT USED)", t1);
      t1.name = "Explore: ONLY_VARIABLES (PAGE NOT USED)";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure120(this), new N.ScripterImpl_closure121(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: Bridge", t1);
      t1.name = "Explore: Bridge";
      t1 = new O.EgbScripterPage(["The bridge is a large room at the front of the ship with two rows of computer terminals and controls \u2013 and a big window in the front. The window is, of course, fake. Having such a big window on a spaceship would not only be expensive, but also extremely dangerous. What you're actually looking at is a big monitor which is nevertheless _designed_ to look exactly like a window, and which usually shows what you would see if there _was_ a window. Even depth is simulated. It makes navigating the ship a little more intuitive, and prevents claustrophobia. And since it looks so much like a window, most people just call it 'the main window' instead of the more accurate 'the main monitor'.", "[IMG bridge]", "The bridge is where the captain spent most of his days, which is evidenced by the fact that there are several rows of empty bottles laid down below one of the walls. There is still an half empty bottle of Ishtar Nook vodka sitting next to the captain's seat. To be fair, though, the captain wasn't the only one drinking here: three other crew members had their posts on the bridge, and they were drinking with him.", new N.ScripterImpl_closure122(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Bridge"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: Bridge.description", t1);
      t1.name = "Explore: Bridge.description";
      t1 = new O.EgbScripterPage(["The object from the Messenger crashed into the right side of the cargo bay. It seems it managed to drill through the hull, sealing the breach behind itself \u2013 there is almost no drop of air pressure in the cargo bay. This device, whatever it is, was clearly designed to get into a ship while keeping its atmosphere more or less intact.", "One of the automatic hull-repair bots is already crawling on the outside of the cargo bay to reinforce the device's seal. You let it do its job because there is no way of telling how strong or permanent the device's own seal is made to be.", new N.ScripterImpl_closure123(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Bridge"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: LookAtHullBreachFromBridge", t1);
      t1.name = "Explore: LookAtHullBreachFromBridge";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure124(this), new N.ScripterImpl_closure125(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: Nose", t1);
      t1.name = "Explore: Nose";
      t1 = new O.EgbScripterPage(["The utility corridor is so narrow and low that you have to walk crouched and a little bit sideways. The walls and the ceiling are packed with cables, pipes, gauges, valves. There are little nooks here and there that allow physical maintenance of some of the subsystems present in this part of the ship.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Nose"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: Nose.description", t1);
      t1.name = "Explore: Nose.description";
      t1 = new O.EgbScripterPage(["The scanner has been shaky for several weeks now, but nobody gave it much attention. A cargo ship such as the Bodega doesn't have much use of it most of the time \u2013 it travels between known space stations via relatively safe routes. Nothing needs to be scanned when everything is business as usual. And when the scanner went completely down after the explosion in the cargo bay, there were much more pressing issues than that.", new N.ScripterImpl_closure126(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Nose"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: Nose.ScannerLook", t1);
      t1.name = "Explore: Nose.ScannerLook";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure127(this), "After you find a spare transformer in the engine room and install it, the scanner comes back online, fully operational.", new N.ScripterImpl_closure128(this), new N.ScripterImpl_closure129(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Nose"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: Nose.ScannerRepair", t1);
      t1.name = "Explore: Nose.ScannerRepair";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure130(this), new N.ScripterImpl_closure131(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: CorridorLeftNextToCaptainsCabin", t1);
      t1.name = "Explore: CorridorLeftNextToCaptainsCabin";
      t1 = new O.EgbScripterPage(["Not so long ago, you were dragging the captain's body through here. You had found him dead inside, in front of his computer.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CorridorLeftNextToCaptainsCabin"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CorridorLeftNextToCaptainsCabin.description", t1);
      t1.name = "Explore: CorridorLeftNextToCaptainsCabin.description";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure132(this), new N.ScripterImpl_closure133(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: CaptainsCabin", t1);
      t1.name = "Explore: CaptainsCabin";
      t1 = new O.EgbScripterPage(["[IMG captain's cabin]", "It's quite spacious \u2013 for a cabin on a spaceship, that is. It's not luxurious, but the bunks everyone else is living in definitely don't compare to this. The walls are paneled with faux wood and the room's light source is \u2013 instead of the ubiquitous fluroscent lamps \u2013 a round, dimmed chandelier.", "The bed doubles as a sofa, with a little coffee table that opens from one of the walls. On the other end of the room, there is the workstation. The computer screen is still on.", "Of course, this wouldn't be captain Kay's room if there wasn't alcohol around. Bottles are all over the place \u2013 empty ones on the floor and half empty ones everywhere else. The places that aren't covered with bottles are covered with crumpled clothes, empty cardboard boxes, and general garbage.", "It's not that the captain was more of a pig than everyone else on board. It's just that there was nobody who would yell at him to clean up. It was _his_ ship, after all.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CaptainsCabin"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CaptainsCabin.description", t1);
      t1.name = "Explore: CaptainsCabin.description";
      t1 = new O.EgbScripterPage(["You start sifting through all the garbage in the room. The plastiglass bottles clank as you accidentaly kick them around, and you move, methodically, from the bed-sofa to the door. Apart from the alcohol, there are tossed clothes, lowbrow magazines, memory sticks, cardboard boxes, used handkerchiefs, and lots of cheap entertainment gadgets. Mostly game consoles and video players. Anything that can keep a person's mind occupied. During the long hauls, boredom is the biggest enemy.", new N.ScripterImpl_closure134(this), "You take a break after some fifteen minutes of searching. You haven't found anything interesting. You've covered about one third of the room, but you've also become quite efficient in making your way through the garbage now.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CaptainsCabin"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CaptainsCabinLookAround", t1);
      t1.name = "Explore: CaptainsCabinLookAround";
      t1 = new O.EgbScripterPage(["You get back to work. The items get familiar. Issues of Space Slam magazine. Cheap plastic game controllers of different kinds. Dirty sweatshirts of the same cut and color. You're throwing everything towards one corner of the room so you don't need to go through one thing twice.", new N.ScripterImpl_closure135(this), "Then, you pick up yet another plastic device from under a pair of trousers, and as you are ready to throw it, you realize it's much heavier than the others, and that it's not plastic at all. It's black steel and it's a gun.", "[IMG of gun laid in hand]", "The captain had a gun? Why? You stand there for a while, looking at the weapon in your hand.", new N.ScripterImpl_closure136(this), "You realize another 15 minutes passed and there is still around a quarter of the room left. You lay the gun back on the ground.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CaptainsCabin"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CaptainsCabinLookAroundContinue", t1);
      t1.name = "Explore: CaptainsCabinLookAroundContinue";
      t1 = new O.EgbScripterPage(["You search the rest of the room, but there's nothing interesting left, nor nothing that would explain the gun.", new N.ScripterImpl_closure137(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CaptainsCabin"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CaptainsCabinLookAroundTheRest", t1);
      t1.name = "Explore: CaptainsCabinLookAroundTheRest";
      t1 = new O.EgbScripterPage(["\"There's no doubt this is the best thing that has ever happened to me \u2013 death.\" The computer screen is filled with text, and this is the sentence at the top. You realize you are reading the last paragraph of a log record that is dated a couple of hours ago. ", "It continues: \"I want to be dying forever. It makes me happy. Happier than anything. It hurts like hell, yes, but I am hooked. Truly. I never had any idea! It's ecstatic. So focused and discrete and full of memories and _hope_ it makes me laugh. I loathe my recent stupid, stupid fear of death and my clinging on something as worthless and _selfish_ as life. I was living a lie \u2013 and now I am dying the truth. Why did I never allow myself to see this before? What the hell was I afraid of?\" ", "That's the end of the log entry. You can see there are some paragraphs before this one, but you know that touching the computer \u2013 after such a long time of inactivity \u2013 would cause it to ask for the captain's password. Which you don't know and have no way of guessing.", new N.ScripterImpl_closure138(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CaptainsCabin"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CaptainsComputerFirst", t1);
      t1.name = "Explore: CaptainsComputerFirst";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure139(this), new N.ScripterImpl_closure140(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: CorridorLeftNextToAirlock", t1);
      t1.name = "Explore: CorridorLeftNextToAirlock";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure141(this), "The second door, oposite the airlock, leads to the staff room.", "Corridor Left stretches to the distance in both directions.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CorridorLeftNextToAirlock"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CorridorLeftNextToAirlock.description", t1);
      t1.name = "Explore: CorridorLeftNextToAirlock.description";
      t1 = new O.EgbScripterPage(["This is the airlock that is always used when the Bodega is moored at a space station or when another ship is docked with the Bodega. All personnel come and go through it. This is probably why the captain chose the other, Corridor Right, airlock for funerals. That one is less worn out, less _everyday_. It seemed more proper for a memorial service.", "It would appear that this airlock is for the living, and the other one is for the dead.", "There is a little rack next to the airlock with little information flyers. These are standard and mandatory on every bigger ship \u2013 for the police, for rescue workers, and for visitors. They contain the basic data about the ship as well as a schematic plan. But the police almost never take them, as they have their own maps that are projected right onto their visors; rescue workers almost always know exactly where to go in advance; and visitors are rare and mostly content with being shown around. This is why the topmost flyer on the rack is covered in dust.", new N.ScripterImpl_closure142(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CorridorLeftNextToAirlock"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: LeftAirlock.Look", t1);
      t1.name = "Explore: LeftAirlock.Look";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure143(this), new N.ScripterImpl_closure144(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: StaffRoom", t1);
      t1.name = "Explore: StaffRoom";
      t1 = new O.EgbScripterPage(["This is where the architects of the ship imagined the crew would spend most of their free time.", "The staff room is painted white and green. There's a kitchenette, a white oval table, and a large video screen. The usual plumbing and electric wiring that protrudes from the walls everywhere else on the ship is notably missing here. Everything is smooth and secure, and there is almost no wear and tear here. It's like a room from another ship.", "The crew almost never came here, except to pick up instant food, to get coffee, or to fill a bottle from the drinking fountain. Nobody felt comfortable here. The one room on the ship _designed_ for social interactions \u2013 was usually as empty as it is now. And whenever someone seeked solitude from the others, they went to the staff room. That's what _you_ did, anyway (this was one of your two favorite hiding places). The others didn't seem to mind each other's company that much.", "Just opposite the entrance, there's a little door that you know leads to the medical bay (and through it, to the opposite side of the ship, to Corridor Right).", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "StaffRoom"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: StaffRoom.description", t1);
      t1.name = "Explore: StaffRoom.description";
      t1 = new O.EgbScripterPage(["The kitchenette has a cabinet with foodstuff. Most of its contents are packs of long-life gingerbread and cups of instant noodles. A freezer next to the cabinet contains heaps of fish fillets (fish being the only generally available meat source in deep space - there are zero gravity fish-farms on every bigger space station). None of this whets your appetite.", "Then you remember the officers' locker. There's a small refridgerated box above the freezer that contains high quality food for officers and for special occasions. It isn't locked, but it's also understood that when you're not one of the officers, you don't touch its contents.", "You open it. There's a half-eaten turkey sandwitch on the lowest rack, and a single banana on the highest one.", new N.ScripterImpl_closure145(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "StaffRoom"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: StaffRoom.findFood", t1);
      t1.name = "Explore: StaffRoom.findFood";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure146(this), new N.ScripterImpl_closure147(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: CorridorLeftNextToBunks", t1);
      t1.name = "Explore: CorridorLeftNextToBunks";
      t1 = new O.EgbScripterPage(["This is one of those places where you can really appreciate the true length of the corridor. On both directions, the passageway subtly fades in mist.", "The entrance to the bunks (or \"Living Quarters\" as they are labeled here) is to the side.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CorridorLeftNextToBunks"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CorridorLeftNextToBunks.description", t1);
      t1.name = "Explore: CorridorLeftNextToBunks.description";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure148(this), new N.ScripterImpl_closure149(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: Bunks", t1);
      t1.name = "Explore: Bunks";
      t1 = new O.EgbScripterPage(["The bunks is a large, smelly, dark room with many bunk beds scattered around and not much else. Each bunk bed comes with tall personal lockers on each side. The only crewmember not housed here was the captain (and of course Gorilla, who has his den in the cargo bay).", new N.ScripterImpl_closure150(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Bunks"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: Bunks.description", t1);
      t1.name = "Explore: Bunks.description";
      t1 = new O.EgbScripterPage(["You come up to the first of the personal lockers on your left. It's open. (Several of them are \u2013 there is little need to lock up your stuff on a long-haul freighter like this, especially when you don't _have_ that much stuff, and even less so when everybody on the ship faces imminent death.)", new N.ScripterImpl_closure151(this), new N.ScripterImpl_closure152(), "XXX actually give money", new N.ScripterImpl_closure153(this), "Next, you open Cooper's locker. Cooper was another ablebodied spaceman \u2013 the most experienced of all. His clothes are neatly stacked and there are dozens of tools and a couple of dumbbells here. In contrast to Mwenye's locker, Cooper's doesn't show any sign of his origin or citizenship. (Which is not surprising because most people on independent trading ships such as the Bodega are not very attached to their origins. If they were, they probably wouldn't be living a life on the constant move.) You find Cooper's credits ring and place it on top of a stack of clothes so it'll be easier for you to find it later.", "You move on. You skip two bigger lockers belonging to Michael Irwin (senior medic) and Par Nabiyeva (senior engineer) \u2013 they are locked. You have better luck with a couple of other lockers, and again you mostly find clothes and little of value, save for the occassional credits ring. You don't expect any of them to be loaded with lots of money. But it's good to know they're there \u2013 on the off chance you survive all this.", new N.ScripterImpl_closure154(this), "The last locker you open is Mitsuyo's. As the first officer, she had a double-sized locker but despite the extra space it seems to have _less_ stuff in it than the others. It's strange. Yes, there are the very neatly stacked clothes, sorted by color, on one of the shelves. The neatness seems typical to the methodical Mitsuyo \u2013 if the whole locker was like this, you wouldn't be surprised. But then there are the other shelves. They are full of junk and empty booze bottles. Many of the shelves are damaged, as if Mitsuyo had been hitting them. A rotten piece of food is decaying on the top shelf.", "This is where you also find her Japanese passport. It's damp from the mush it's been sitting in, so you wipe it on the clothes and open it. It says there that she was born on Shitsuteki station. You have to check twice, but it really does say Shitsuteki, and the date of birth is 35 years ago (which is 10 years more than you would say from Mitsuyo's face). This means she must have been 7 years old when the drugged and delirious spacemen of the San Lorenzo Martir came and razed the station in one of the most brutal mass murders in the history of space exploration. Mitsuyo had either moved to another station by then or she was one of the very few Japanese survivors.", new N.ScripterImpl_closure155(), "The rest of the personal lockers are locked.", new N.ScripterImpl_closure156(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Bunks"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: Bunks.SiftThroughLockers", t1);
      t1.name = "Explore: Bunks.SiftThroughLockers";
      t1 = new O.EgbScripterPage(["// TODO: needed?", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Bunks"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: Bunks.BreakIntoLockedBoxes", t1);
      t1.name = "Explore: Bunks.BreakIntoLockedBoxes";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure157(this), new N.ScripterImpl_closure158(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: CorridorLeftJunction", t1);
      t1.name = "Explore: CorridorLeftJunction";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure159(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CorridorLeftJunction"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CorridorLeftJunction.description", t1);
      t1.name = "Explore: CorridorLeftJunction.description";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure160(this), new N.ScripterImpl_closure161(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: Guts", t1);
      t1.name = "Explore: Guts";
      t1 = new O.EgbScripterPage(["The guts is an intricate maze of little passageways between most of the ship's internal systems. When everything works, there is no reason for anyone to come here, and so the area is not particularly comfortable or even well lit. Many passageways are too narrow even for a body as thin as yours, and most are too low for any person to stand straight.", "After the explosion, this place is even less welcoming. The negative effects of the shockwave are more visible here than anywhere else \u2013 each few steps you can see a loosened cable, a leaking pipe or an awry rack. You hear the crackle and smell the pungent scent of the occasional electrical discharge. It's amazing that the Bodega is still mostly functional even with all those little malfunctions.", "[IMG]", "You quickly make your way to what the crew had called 'the heart' of the guts. A hub of several passageways with lots of gauges, valves and pipes, it sits more or less in the center of the habitable part of the ship. ", "There's a simple sitting bench here on which you have spent quite some time. Not that you have had any practical reason to be here, but as someone who prefers being alone to the awkwardness of social interactions, this was your best bet when you wanted to keep out of everyone's way and out of sight. Not even Bodega sees here.", "From this place, you can easily make your way to both corridors and to the different systems housed in the guts.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Guts"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: Guts.description", t1);
      t1.name = "Explore: Guts.description";
      t1 = new O.EgbScripterPage(["Climbing up the ladder from the 'heart', you get to the base of the defensive turret. It's the oldest weapon system the Bodega has, and it most probably dates the few decades to when the ship left the docks for the first time. (In contrast, the front utility laser was installed quite recently, and mostly for the occasional asteroid mining \u2013 not so much for self-defense.) ", "But despite its age and limited firepower, the turret is still the best insurance against small-time gangsters and opportunist criminals. It's fully automatic \u2013 it will track a given target and shoot at it until told otherwise \u2013 so it doesn't require a trained weapons man to be effective. ", "What it requires now, though, is repair. The turret itself was obviously made quite resilient, but its age combined with the recent shockwave (and the fact it happened during a hyper jump) have done considerable damage. One of the components is buzzing so loudly you could hear it back from the 'heart'. There's a flicker of sparks coming from the inside and a red pilot light is blinking on the wall nearby.", "You can't see the turret from the outside, but you don't expect any damage there.", new N.ScripterImpl_closure162(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Guts"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: Guts.TurretLook", t1);
      t1.name = "Explore: Guts.TurretLook";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure163(this), new N.ScripterImpl_closure164(this), new N.ScripterImpl_closure165(this), "After a tiring and seemingly never-ending stretch of work, you look at the electronics and realize all the faulty components have been repaired or replaced. You link them together with new cables and turn the turret's power input back on, half-expecting another failure. But the turret just whirls to life, performing a quick self-test and switching on a green pilot light afterwards.", "The turret is back online.", new N.ScripterImpl_closure166(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Guts"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: Guts.TurretRepair", t1);
      t1.name = "Explore: Guts.TurretRepair";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure167(this), new N.ScripterImpl_closure168(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: EngineRoom", t1);
      t1.name = "Explore: EngineRoom";
      t1 = new O.EgbScripterPage(["[IMG of room and big window to the machine area]", new N.ScripterImpl_closure169(this), new N.ScripterImpl_closure170(this), "[IMG]", new N.ScripterImpl_closure171(this), new N.ScripterImpl_closure172(this), "The whole area is pulsating and strobing with lights and diodes.", "The right part of the room is a lot less busy. In the center of an almost empty space, there is a large cigar-shaped device: the hyperdrive. From this far, the only indication that it's doing something is a few blinking status lights.", new N.ScripterImpl_closure173(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "EngineRoom"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: EngineRoom.description", t1);
      t1.name = "Explore: EngineRoom.description";
      t1 = new O.EgbScripterPage(["The engine is your domain, so even though there is nothing apparently wrong with the engine, you are quite confident you'll be able to bring it to 100% in a couple of hours. After working so long on the hyperdrive, you are actually somewhat looking forward to it.", new N.ScripterImpl_closure174(this), "You go through the usual output optimization routines. The shockwave from the explosion hit this part of the ship quite strongly. Some of the fission cores went off axis and shut down automatically. You start going through them, one by one, resetting them, making sure they're stable and manually turning them on again.", new N.ScripterImpl_closure175(this), "Two of the cores are considerably harder to set right, but you succeed in the end. By all this, you bring the engine output to 96%. The last 4% turns out to be a matter of precisely syncing the cores' output phases.", "The engine is now 100% operational and working like clockwork.", new N.ScripterImpl_closure176(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Explore: EngineRoom"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: EngineRoom.RepairEngine", t1);
      t1.name = "Explore: EngineRoom.RepairEngine";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure177(this), new N.ScripterImpl_closure178(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: CorridorRightNextToComputerRoom", t1);
      t1.name = "Explore: CorridorRightNextToComputerRoom";
      t1 = new O.EgbScripterPage(["On the side, a modest door is labeled \"Computer Room\". It's where the Bodega's hardware is. The fact that it is placed on the exact same place as the captain's cabin, only on the opposite corridor, is very probably not a coincidence. Captain is the human brain of the ship. The machine brain is behind this door.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CorridorRightNextToComputerRoom"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CorridorRightNextToComputerRoom.description", t1);
      t1.name = "Explore: CorridorRightNextToComputerRoom.description";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure179(this), new N.ScripterImpl_closure180(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: ComputerRoom", t1);
      t1.name = "Explore: ComputerRoom";
      t1 = new O.EgbScripterPage(["The Computer Room is a grid of narrow alleys between 25 black, humming cuboids. Pipes of coolant are running from the ceiling to the floor, intertwining with the electronics like veins in muscles. ", "The 25 blocks are the different modules of Bodega's brain, almost each of which is inspired by a part of the human brain. The big difference is that these are neatly organized by function and imbedded in separate blocks. The one closest to the door is labeled 'Visual Perception'. Another one has 'Sensors Perception' written on it. From previous visits to this room, you remember a couple of 'Speech' modules, something called 'Hierarchy', and the 'Mother', sitting in the center of the room, perfectly surrounded by all the other modules.  ", "One of the outer walls is studded with rade drawers \u2013 the memory modules. Some of them are blinking red, indicating the inevitable data corruption. It is the honorary, almost ceremonial role of the captain to swap these with new modules, and when this is being done, the officers, and sometimes the whole crew, is watching. A long time ago, you saw captain Kay do this \u2013 and it was one of the few times he was sober and solemn.", "The rade drawers ceremony is said to be a symbolic way for thanking the ship for its service (while also hinting on the power the human crew has over it). It's something like scratching a pet on its belly. Apparently, from the point of view of the pet, this is supposed to feel both pleasant and dangerous at the same time.", "Next to the rade drawer wall, there's a large locker with spare parts. Only the captain and the first officer have the key to that one.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "ComputerRoom"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: ComputerRoom.description", t1);
      t1.name = "Explore: ComputerRoom.description";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure181(this), new N.ScripterImpl_closure182(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: CorridorRightNextToAirlock", t1);
      t1.name = "Explore: CorridorRightNextToAirlock";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure183(this), "Directly opposite the airlock, there is also a second door which leads to the Medical Bay.", "Corridor Right stretches to the distance in both directions.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CorridorRightNextToAirlock"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CorridorRightNextToAirlock.description", t1);
      t1.name = "Explore: CorridorRightNextToAirlock.description";
      t1 = new O.EgbScripterPage(["You approach the airlock and look through the porthole window.", new N.ScripterImpl_closure184(this), "The outer door is sealed shut.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CorridorRightNextToAirlock"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CorridorRightNextToAirlock.Look", t1);
      t1.name = "Explore: CorridorRightNextToAirlock.Look";
      t1 = new O.EgbScripterPage(["You pull the lever, and as the outer door opens, all the air in the airlock shoots out \u2013 with a loud hiss \u2013 into the vacuum of space. The body is now moving in that direction, too, though much slower. It's no longer pulled towards the floor with artificial gravity \u2013 that was automatically turned off when you pulled that lever \u2013 so the body kind of tumbles towards the door.", new N.ScripterImpl_closure185(), new N.ScripterImpl_closure186(this), "You close the outside door again by putting the lever back into the original position.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CorridorRightNextToAirlock"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CorridorRightNextToAirlock.PullLever", t1);
      t1.name = "Explore: CorridorRightNextToAirlock.PullLever";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure187(this), new N.ScripterImpl_closure188(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: MedicalBay", t1);
      t1.name = "Explore: MedicalBay";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure189(this), "One of the walls is lined with cabinets, drawers and a long counter with equipment. There are surgical tools, forceps, needles, weaves, flasks, pillboxes, petri dishes, various measuring instruments and a microscope. ", new N.ScripterImpl_closure190(), new N.ScripterImpl_closure191(this), "With an amused smile on his face, Trukhin nodded and carried on with his tour of the ship.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "MedicalBay"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: MedicalBay.description", t1);
      t1.name = "Explore: MedicalBay.description";
      t1 = new O.EgbScripterPage([[null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "MedicalBay"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: MedicalBay.LookAtCounter", t1);
      t1.name = "Explore: MedicalBay.LookAtCounter";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure192(this), new N.ScripterImpl_closure193(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: CorridorRightNextToBunks", t1);
      t1.name = "Explore: CorridorRightNextToBunks";
      t1 = new O.EgbScripterPage(["On the side here, you see the entrance to the bunks.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CorridorRightNextToBunks"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CorridorRightNextToBunks.description", t1);
      t1.name = "Explore: CorridorRightNextToBunks.description";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure194(this), new N.ScripterImpl_closure195(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: CorridorRightJunction", t1);
      t1.name = "Explore: CorridorRightJunction";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure196(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CorridorRightJunction"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CorridorRightJunction.description", t1);
      t1.name = "Explore: CorridorRightJunction.description";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure197(this), new N.ScripterImpl_closure198(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: CargoBayLeft", t1);
      t1.name = "Explore: CargoBayLeft";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure199(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CargoBayLeft"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CargoBayLeft.description", t1);
      t1.name = "Explore: CargoBayLeft.description";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure200(this), new N.ScripterImpl_closure201(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: ExplodedContainer", t1);
      t1.name = "Explore: ExplodedContainer";
      t1 = new O.EgbScripterPage(["// TODO", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "ExplodedContainer"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: ExplodedContainer.description", t1);
      t1.name = "Explore: ExplodedContainer.description";
      t1 = new O.EgbScripterPage(["// TODO", new N.ScripterImpl_closure202(this), "// ...", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "ExplodedContainer"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: ExplodedContainer.search", t1);
      t1.name = "Explore: ExplodedContainer.search";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure203(this), new N.ScripterImpl_closure204(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: CargoCenter", t1);
      t1.name = "Explore: CargoCenter";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure205(this), "The console is located exactly half way between the two entrances to the cargo bay.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CargoCenter"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CargoCenter.description", t1);
      t1.name = "Explore: CargoCenter.description";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure206(this), new N.ScripterImpl_closure207(this), new N.ScripterImpl_closure208(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CargoCenter"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CargoCenter.console", t1);
      t1.name = "Explore: CargoCenter.console";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure209(this), new N.ScripterImpl_closure210(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: CargoBayRight", t1);
      t1.name = "Explore: CargoBayRight";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure211(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "CargoBayRight"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: CargoBayRight.description", t1);
      t1.name = "Explore: CargoBayRight.description";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure212(this), new N.ScripterImpl_closure213(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: PlaceOfBreach", t1);
      t1.name = "Explore: PlaceOfBreach";
      t1 = new O.EgbScripterPage(["// TODO", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "PlaceOfBreach"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: PlaceOfBreach.description", t1);
      t1.name = "Explore: PlaceOfBreach.description";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure214(this), new N.ScripterImpl_closure215(this)], 0, null, false, false);
      t2.$indexSet(0, "Explore: GorillasDen", t1);
      t1.name = "Explore: GorillasDen";
      t1 = new O.EgbScripterPage(["TODO", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "GorillasDen"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Explore: GorillasDen.description", t1);
      t1.name = "Explore: GorillasDen.description";
      t1 = new O.EgbScripterPage(["You take the captain's seat and buckle up. With hyperdrive jumps, there's a slight chance of glitches in the ship's artificial gravity (among other things) \u2013 so buckling up is standard procedure.", "\"Is our course set for Space Station Unity?\" you ask.", "\"Affirmative. We are ready to initiate the sequence.\" The ship computer draws a circle in the middle of the main window. Unity is somewhere that way.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure216(), "script", new N.ScripterImpl_closure217(this)], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure218()], null, null)], new N.ScripterImpl_closure219(), "\"Yes.\" There really is no reason to conserve energy at this point. A few more reserve energy cells will not do you any good if you're dead by the time you reach Unity. Supercharging saves 36% of the jump time (and takes twice the energy). \"Yes, let's supercharge.\" ", new N.ScripterImpl_closure220(this), "\"Initiating hyperdrive sequence.\" You can feel and hear the main thrusters quickly coming to life, propelling the ship forward. Hyperdrives need the ship to be accellerating forward so they can warp its speed by several magnitudes. That's what is going to come next.", "\"Energy accumulated.\" While accelerating by traditional means, the hyperdrive builds up an extremely high energy charge. That energy will be discharged through the hyperdrive, creating a controlled space-time distortion around the ship. Moving through and within the bubble allows the ship to effectively cheat uncle Einstein. \"Discharging,\" the Bodega says.", "A couple of things happen at the same time. A violent glitch in the artificial gravity almost makes you vomit as it feels like the whole ship does a completely unnecessary barrel roll. The straps keep you in place, but the freestanding bottles fly in a swarm accross the bridge and fall crashing to the ground near the entrance to Corridor Right. A few red lights blink all over the bridge as other systems experience temporary glitches. And, finally, the main window goes blue and bright. Then violet and white. And finally, the visual feed is replaced by a computer visualization (during faster-than-light travel, external cameras aren't very useful \u2013 they are overwhelmed by the bright disc of light in front of the ship).", new N.ScripterImpl_closure221(this), "You are now on your way to Space Station Unity and you expect to warp through the XXX light years in XXX hours. There could still be some gravity glitches along the way, so the official guidelines are to stay put during the jump, but most spacemen just ignore those and hope for the best. The slight chance that you'll get slammed on the ceiling are more than balanced by not having to sit or stand strapped for hours on end.", new N.ScripterImpl_closure222(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Explore: Bridge"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Unity: Jump", t1);
      t1.name = "Unity: Jump";
      t1 = new O.EgbScripterPage(["The main window is filled with white and red and blue. You're looking at Unity, one of the 6 largest space stations in all of the known universe.", "[IMG]", new N.ScripterImpl_closure223(), "Unity is very old, and it shows. Although the outside paint is bright, even around the docks (where stations are normally dark with burn marks), the symetry of the disc is corrupted by numerous attachments, growths and outbuildings all over the place. As with anything else in space, the initial design of the station just couldn't cope with all the new and unpredicted things that interstellar travel was yet to bring.", "The misfortune of Unity is that while most other man-made objects in space are ugly and indented from the very start, this station was obviously once elegant and _clean_. So now, all the additional construction looks like tumors on a ballerina's leg.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Preview: End"], null, null)], "// - [Unity: Approach]"], 0, null, false, false);
      t2.$indexSet(0, "Unity: Arrival", t1);
      t1.name = "Unity: Arrival";
      t1 = new O.EgbScripterPage(["\"Open the communications link with tower,\" you tell Bodega as you sit down at the captain's seat again. The comms monitor comes alive and after a few seconds, an operator's face appears. He looks tired, but tries to smile.", "\"Zis is Space stationion Unity dock tower.\" He's German, with the dark blond hair, the straight nose, the accent and everything. \"Please provide callsign and intention.\" There's the tired smile again.", "\"Callsign Bodega, freighter,\" the Bodega answers. \"Request expedite docking.\" ", "The operator's eyebrows go up. \"Expedite? What is the emergency?\" ", "\"I am dying,\" you say plainly. \"The rest of the crew is dead already.\" ", new N.ScripterImpl_closure224(this), "\"Okay, umm, Bodega, we will need to quarantine ze arrival...\" The operator stops and frowns. \"Wait. Can you confirm your full id?\" ", "\"Complete ID is CH/C/740-22K,\" the Bodega answers.", "The operator freezes, looking at something at his side. This takes several seconds. He then straightens, bites his lip and looks directly into the camera.", "\"Bodega, I'm afraid I cannot let you dock.\" He waits for you to react.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure225(), "script", new N.ScripterImpl_closure226(this)], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure227(), "script", new N.ScripterImpl_closure228()], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure229(), "script", new N.ScripterImpl_closure230(this)], null, null)], "\"But look,\" he says after biting his lip some more. \"You really shouldn't be around here. If I am understanding this correctly, you are on the Active Threat blacklist. I don't know how that's possible, for a cargo freighter I mean, and especially when you only have one soul on board, but the fact is you are listed. And that means, since I identified you just now, your position is broadcasted to anyone interested through the station's beacon. So that means that the organization that blacklisted you \u2013 and I assume you know who that is \u2013 is probably jumping a ship or two to this location right now.\" ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "UnityQuestion: Choice"], null, null)]], 0, null, true, false);
      t2.$indexSet(0, "Unity: Approach", t1);
      t1.name = "Unity: Approach";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure231(this), new N.ScripterImpl_closure232(this)], 0, null, false, false);
      t2.$indexSet(0, "UnityQuestion: Choice", t1);
      t1.name = "UnityQuestion: Choice";
      t1 = new O.EgbScripterPage(["\"I told you,\" the operator says.", "// Let player use mental points to get the operator to blunder and reveal some information (Pruitt? Sentaco?)", new N.ScripterImpl_closure233(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Choice"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "UnityQuestion: Organization", t1);
      t1.name = "UnityQuestion: Organization";
      t1 = new O.EgbScripterPage(["TBD", new N.ScripterImpl_closure234(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Choice"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "UnityQuestion: ActiveThreatBlacklist", t1);
      t1.name = "UnityQuestion: ActiveThreatBlacklist";
      t1 = new O.EgbScripterPage(["TBD", new N.ScripterImpl_closure235(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Choice"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "UnityQuestion: AskToDock", t1);
      t1.name = "UnityQuestion: AskToDock";
      t1 = new O.EgbScripterPage(["TBD", new N.ScripterImpl_closure236(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Choice"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "UnityQuestion: WhereToGo", t1);
      t1.name = "UnityQuestion: WhereToGo";
      t1 = new O.EgbScripterPage(["You examine the radar view. There's the Space Station, the Bodega, and a few of other ships (mostly traders, but also two UNSA defensive force gunships) that are either in the process of docking or on their way to a jump point. None of them seem to be interested in you, much less approaching you.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "MainChoice"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Unity: DisconnectFromTower", t1);
      t1.name = "Unity: DisconnectFromTower";
      t1 = new O.EgbScripterPage([[new N.ScripterImpl_closure237(), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure238(), "goto", "UseUnityBeacon"], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure239(), "goto", "OpenFire"], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure240(), "goto", "Negotiate"], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure241(), "goto", "Wait"], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure242(), "goto", "JumpToSafety"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Unity: MainChoice", t1);
      t1.name = "Unity: MainChoice";
      t1 = new O.EgbScripterPage(["The close proximity to Space Station Unity allows you to use their beacon, which in turn makes it possible for you to make realtime calls to anyone who is close to any other beacon, even if they are light years away.", new N.ScripterImpl_closure243(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "MainChoice"], null, null)]], 0, null, true, false);
      t2.$indexSet(0, "Unity: UseUnityBeacon", t1);
      t1.name = "Unity: UseUnityBeacon";
      t1 = new O.EgbScripterPage(["// TODO: if bodegaShip weapon isAliveAndActive", "// TODO: Either full-blown SpaceshipCombat (Unity is a special ship that doesn't have maneuvres, but has lots of weapons) or a simplified version.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "MainChoice"], null, null)]], 0, null, true, false);
      t2.$indexSet(0, "Unity: OpenFire", t1);
      t1.name = "Unity: OpenFire";
      t1 = new O.EgbScripterPage(["// TODO: sentaco mercenary ship jumps into system => fight with opportunity to jump away"], 0, null, true, false);
      t2.$indexSet(0, "Unity: SentacoShipArrival", t1);
      t1.name = "Unity: SentacoShipArrival";
      t1 = new O.EgbScripterPage(["// TODO: jump back to afterEleanorFirstChatGoto\n// \n// TODO: create two calls - first one is more questions than answers (only needs knowsAboutEleanor), second is encrypted and comes from her (during this player 'dies')", "You tell Bodega to call Eleanor Wells and the monitor starts filling with information about the connection being established. The handle 'ewells' shows up. It's hers.", new N.ScripterImpl_closure244(this), "A chime sounds and Dr. Eleanor Wells is on the main screen. She looks tired and angry. The room she's sitting in is dim.", "\"Look, it's 4am and I wake up in 2 hours from now. I'm too old for this.\" She pauses for a moment. \"Who the hell are you?\" ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure245(), "script", new N.ScripterImpl_closure246(this)], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure247()], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure248()], null, null)], "Before you can reply, another seizure strikes.", new N.ScripterImpl_closure249(this), "Dr. Wells eyes are now wide open. She looks around herself, checking that no one else is present, then she comes closer to her comms panel.", "\"Are you... have you taken Rescin?\" ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure250(), "goto", "ItWasAccident"], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure251(), "goto", "WtfIsRescin"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Eleanor: FirstCall", t1);
      t1.name = "Eleanor: FirstCall";
      t1 = new O.EgbScripterPage(["\"You don't _know?_ But how... You're obviously in the last stage. Someone had to contaminate you. Was it Pruitt?\" ", "You say: \"I have no idea who it was, if anyone. There was an explosion on the ship.\" ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "ItWasAccident"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "End: WtfIsRescin", t1);
      t1.name = "End: WtfIsRescin";
      t1 = new O.EgbScripterPage(["\"What happened?\" ", "\"A container exploded in the cargo bay. It damaged some research equipment from Ithaka, among other things. Then people started dying.\" ", new N.ScripterImpl_closure252(this), "Dr. Wells watches you in horror. \"Dying? People started _dying?_ How many?\" ", "\"Eleven.\" ", "All color leaves Dr. Wells' face. \"Eleven,\" she repeats. Her face is torn in a terrified grimace. \"How. How did they die?\" ", "\"Like I'm dying now. They got sicker and sicker, and then they just stopped breathing.\" ", "\"And then?\" ", "\"What do you mean, 'then'?\" Every word you say, every breath you take, hurts. \"They. Fucking. Died!\" // TODO: choice", "\"But what did you do with the bodies? Where are they now?\" ", "\"Don't worry,\" you lower your voice. \"We're not that stupid. We airlock'd them. But even without the bodies, others got sick.\" ", "\"Airlock'd?\" ", "\"We let them out. To outer space.\" ", "\"Jesus Christ,\" Dr. Wells says. Her mouth stays open, her eyes absently roam over her room. \"Jesus Christ.\" She thinks for a minute, then suddenly springs into action and starts writing something on a keyboard that's out of view. ", "\"I am sending you some of the research we did on Rescin. You'll need it later. Now, listen,\" she looks back at the camera. \"Do not fight it. I know it hurts, but do _not_ fight it. Is there anyone else on the ship?\" ", "\"No.\" ", "\"Good.\" ", new N.ScripterImpl_closure253(this), "\"This is normal,\" Dr. Wells says. \"We were not able to make these side effects disappear. That's why the research was scrapped. We knew we would never be able to pass the regulations for human testing, and without that, we could never hope for Rescin to help people.\" ", "- \"How does it help?\"\n- \"You call this help? Are you retarded? I'm _dying_.\" ", "\"We developed Rescin \" ", "- How does Rescin work?\n- Why does it hurt so bad?", "// TODO: do NOT let the player know that he will be ressurected - only disclose about the nanobots"], 0, null, false, false);
      t2.$indexSet(0, "End: ItWasAccident", t1);
      t1.name = "End: ItWasAccident";
      t1 = new O.EgbScripterPage(["# Death", "You leave the captain's cabin and head to the bridge, when suddenly you fall to your knees. At first, it's just like your legs temporarily gave out, but then comes the pain. Immense, excruciating pain, coming from the marrow to the skin. You fall on the side and open your mouth to scream, but only a squawk comes out.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure254(), "goto", "WaitIfItFades"], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure255(), "goto", "CallGorilla"], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure256(), "goto", "CrawlTowardsTheBridge"], null, null)], "- Crawl to the right (away from bridge, towards the engine room) // cures for a while"], 0, null, false, false);
      t2.$indexSet(0, "End: GoToBridge", t1);
      t1.name = "End: GoToBridge";
      t1 = new O.EgbScripterPage(["// TODO"], 0, null, false, false);
      t2.$indexSet(0, "End: WaitIfItFades", t1);
      t1.name = "End: WaitIfItFades";
      t1 = new O.EgbScripterPage(["You crawl to the nearest intercom handset and, sorely, you reach up to it and set it to broadcast. You take a few seconds to subdue the pain, then speak.", "\"Gorilla.\" You cringe. \"Go. To. Master.\" ", "// gorilla tries to help, but falls with similar seizure"], 0, null, true, false);
      t2.$indexSet(0, "End: CallGorilla", t1);
      t1.name = "End: CallGorilla";
      t1 = new O.EgbScripterPage(["You crawl along Corridor Left. Every single movement is pure pain, and your whole body perspires with cold sweat. The bright white light and the buzzing of the lamps is unbearable. You squint as much as is possible without losing sight.", "After what feels like hours of hell itself, you look back, and the captain's cabin is just there, a couple of strides behind your feet. You're not even in one tenth of the way.", "// player needs to crawl to engine room, get 'cured', then go to bridge\n// player manages to get to bridge"], 0, null, false, false);
      t2.$indexSet(0, "End: CrawlTowardsTheBridge", t1);
      t1.name = "End: CrawlTowardsTheBridge";
      t1 = new O.EgbScripterPage(["// TODO: start a new timeline with last symptoms", "Still a bit shaken, you arrive at the bridge. The view of outside /* TODO: what is outside? */ is nauseating, so you try to keep it out of your field of vision by bowing your head.", "\"I need to make a call,\" you say. \"I need to get to a comms beacon.\" ", "The Bodega puts up a map on the main monitor, but you can't bear to look at it, it makes you retch. It's too bright and it moves constantly.", "\"The closest FTL beacon is Station Unity. There's also one farther away, at the Belt III Shipyard. We should be able to get there, but it will take at least twenty more minutes.\" ", "\"Is there nothing else around here?\" ", "\"Well, there's the abandoned Station Shannon. They obviously had FTL comms, but that doesn't mean the beacon is still there. I mean, it's still in the directory, but it doesn't seem anyone has made any calls from there lately.\" ", "- Jump to Station Unity\n- Jump to Station Shannon // not working, probably plundered, chance to describe this place\n- Jump to Belt III Shipyard"], 0, null, false, false);
      t2.$indexSet(0, "End: ArriveBridge", t1);
      t1.name = "End: ArriveBridge";
      t1 = new O.EgbScripterPage(["The Bodega starts linking itself to the comms beacon. It takes ages.", new N.ScripterImpl_closure257(this), "Finally, the comms panel goes green. You can make your call.", "- Call Dr. ___ Pruitt\n- Call Dr. Eleanor Wells"], 0, null, false, false);
      t2.$indexSet(0, "End: MakingTheCall", t1);
      t1.name = "End: MakingTheCall";
      t1 = new O.EgbScripterPage(["This time, it's different. Your are losing your peripheral vision. The only thing you see now is the blindingly bright face of Dr. Eleanor Wells. She's saying something to you, but you don't hear it. The only thing you hear is something you've never heard before in your life \u2013 your body. Not just the blood in your veins, but everything. The complex, moist, organic machine that is your physical body. It is slowing down.", "// TODO: make it frightful experience when attitude is too strong (?) (or some other player driven thing)", "All the pain, all the weight is gone. It's beautiful. There's just you, your body, and the shining eyes of Eleanor Wells, who is now also your mother, and she's still talking to you, and you still don't hear, but that doesn't matter, it's so pleasant and charming you just want to snug in the warmth and bathe in the light.", "- Snug in the warmth and bathe in the light\n- Try to stay up"], 0, null, false, false);
      t2.$indexSet(0, "End: NiceDeath", t1);
      t1.name = "End: NiceDeath";
      t1 = new O.EgbScripterPage(["You let the wave of warmth and light that was your mother's eyes just a moment ago come to you and cuddle you and, finally, merge with you. You are the light now.", "And then, peacefully, you fade out.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Death"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "End: Snug", t1);
      t1.name = "End: Snug";
      t1 = new O.EgbScripterPage(["This is the end.", "You die.", "..", "..", "..", "Cold floor.", "No other sensation.", "Then, once again, you hear the blood humming in your veins. ", "The pain is back, too, but this time, it's not entirely unpleasant. It's like the pain is driving the death away, so you welcome it.", [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure258(), "goto", "Ressurection: OpenEyes"], null, null)], "- TODO: something else, like Try to move, Get more rest"], 0, null, false, false);
      t2.$indexSet(0, "End: Death", t1);
      t1.name = "End: Death";
      t1 = new O.EgbScripterPage(["Your eyes open, shakily. ", "You are on the same spot \u2013 haven't moved since you ... died. You lie on the floor, next to the communications panel, and your eyes are still fixed on the main monitor. ", new N.ScripterImpl_closure259(this), "\"You're back,\" she says. \"Good. We don't have much time.\" ", "- \"Why?\"\n- Stand up\n// both fail\n// TODO: monitor \"inquisitive\" - the more inquisitive, the more Eleanor will like player", new N.ScripterImpl_closure260(this), [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure261()], null, null)], "Dr. Wells detects your question. \"What the nanobots do \u2013 after they've gathered data about your body \u2013 is they pretty much rebuild it all, cell by cell. Some of the nanos will merge with a cell, effectively making a cyborg microorganism. Most will use your body's own mechanisms and resources to augment its function. Striking the right balance between the two approaches \u2013 it was pure alchemy. Well, it was all alchemy, mostly.\" ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure262(), "script", new N.ScripterImpl_closure263()], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure264()], null, null)], "Dr. Wells draws closer to the camera. \"Are you familiar with the Verge?\" ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure265(), "goto", "NoNeedToExplainVerge"], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure266(), "goto", "ExplainVerge"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Ressurection: OpenEyes", t1);
      t1.name = "Ressurection: OpenEyes";
      t1 = new O.EgbScripterPage(["// TODO painful to shake"], 0, null, true, false);
      t2.$indexSet(0, "Ressurection: ExplainVerge", t1);
      t1.name = "Ressurection: ExplainVerge";
      t1 = new O.EgbScripterPage(["\"Of course, you're pretty much in it right now. But let me tell you, life on a starship in the Verge is _nothing_ like life on the moons and the planets of the Verge.\" ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "ReminiscingVerge"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Ressurection: NoNeedToExplainVerge", t1);
      t1.name = "Ressurection: NoNeedToExplainVerge";
      t1 = new O.EgbScripterPage(["Dr. Wells leans back and narrows her eyes. \"I was raised on one of the Verge's poorer star systems, Avesta. We lived on a hot, seizmic power-plant of a planet, Avesta II. See, nobody even cared enough to give it a proper name.\" She scoffs. \"The population was fifty thousand. Together, they provided the 'colonization effort' with more energy than the _whole_ Sol system combined.\" ", "She scoffs again. \"And for those fifty thousand people \u2013 who worked twelve hour shifts in artificially lit, hell-hot underground tunnels on a volcanic planet \u2013 there was just one real doctor. My father. And so I lived among broken people. No matter how hard my father tried, there was always screaming and people with dripping burns and with missing limbs.\" ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure267(), "script", new N.ScripterImpl_closure268()], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure269()], null, null)], "\"I eventually got out of Avesta, out of the Verge, to study medicine with some of the most intelligent people I will ever know. Most of them from central systems, of course. And, see, I learnt that these people \u2013 coming from where they do \u2013 these people think it's 'not natural' to help people who are beyond some 'level of damage'. When a worker somewhere in the Verge gets his legs caught in machinery, they say it's 'natural' that he loses the whole lower part of his body, because that would have happened a hundred years ago. Is it possible to help him now? Maybe, but they think it would be crossing a line. Of course, most of them have never even _seen_ anyone lose their legs.\" ", "\"Fortunately, not everyone was so arrogant. We put together a working group and started looking into technologies that were 'beyond the line'. The most promising one turned out to be nanorobotics. We got funded by Sentaco and set up the lab on Ithaka.\" ", "The Bodega jumps in. \"There's a new signal on the radar. A medium sized ship. I just thought you two might want to know.\" ", "\"I'm sure you'll learn that the ship was sent by Pruitt. I told you we don't have much time. How do you feel?\" ", "You don't feel so great, but definitely better than a minute ago.", "- \"Not so great.\"\n- \"Better.\"\n- \"I almost died, that's how I feel.\" // \"No, you actually died.\"\n- \"Why do you care?\" ", "// TODO: I can see your vocal cords are getting better.", "\"Look \u2013 Pruitt's men are coming for you. I'm not entirely sure if this all is an accident or not, but even if it was, Pruitt will definitely want to have you for research. You're the only human in the universe with Rescin treatment. And unless I am mistaken, you'll be the only one for some time to come.\" ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure270(), "goto", "TryToGetUp"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Ressurection: ReminiscingVerge", t1);
      t1.name = "Ressurection: ReminiscingVerge";
      t1 = new O.EgbScripterPage(["You try hard to rise up, but even just moving your arms underneath the body, so that you can push up, turns out to be impossible. You give up and immediately, a tingling sensation overcomes all the muscles you just stressed.", "Dr. Wells nods. \"You're not ready yet, but don't worry, you'll be in a few minutes.\" ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "Questions"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Ressurection: TryToGetUp", t1);
      t1.name = "Ressurection: TryToGetUp";
      t1 = new O.EgbScripterPage([[new N.ScripterImpl_closure271(), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure272(), "goto", "StandUpAgain"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Ressurection: Questions", t1);
      t1.name = "Ressurection: Questions";
      t1 = new O.EgbScripterPage(["// TODO: first 2 attempts in vain (unless all questions have been answered)\n// TODO: one of the attempts: Bodega says how far the incoming ship is", "This time, it works. You push your hands towards the floor and your upper body lifts as easily as if the gravity was turned down. The tingling sensation is all but gone. You stand up and look around. The bridge is as empty as when you got here a few hours back. You notice the radar screen and the highlighted ship that is slowly moving towards the center of it. Amazingly, you can read the distance measurement, although the characters are small and the screen is a few meters away. The ship is 11 kilometers away and approaching the Bodega with an ETA of 5 minutes.", "- \"The ship's here in 5 minutes. All energy to shields and weapons.\"\n- \"Give me a reading of the ship.\" ", "TODO: reading of the ship\nTODO: Dr. Wells disapproves"], 0, null, false, false);
      t2.$indexSet(0, "Ressurection: StandUpAgain", t1);
      t1.name = "Ressurection: StandUpAgain";
      t1 = new O.EgbScripterPage(["\"I'm pretty sure the Bodega is no match for that ship.\" ", "\"Excuse me?\" the Bodega says. ", "\"Look, ship, I know about the Messenger. Good job. But they won't make the same mistake again. That incoming ship is military class. She's smaller than you, I'm sure, but you have absolutely zero chance of beating her in your current setup. You're better off playing dead.\" ", "The Bodega runs through some schematics on the scanner panel for a fraction of a second, then says: \"I'm afraid she's right. That ship appears to be a military-grade vessel. A gunship.\" ", "\"Play to your strengths,\" Dr. Wells says. \"They want you alive.\" ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure273(), "script", new N.ScripterImpl_closure274()], null, null), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure275()], null, null)], "The ship is now 4 minutes away.", "\"Look, I need to disconnect. They traced our call. It's best for me to move and stay hidden now. After this litter encounter is over, you do the same. I'll contact you later.\" Dr. Wells smiles. \"I think I'll have something the Bodega will enjoy. Until then, good luck.\" Dr. Wells nods and the main screen goes blank.", "What do you do?\n- Contact the ship and surrender to them // end\n- Raise shields and prepare for battle // very short battle, incapacitates bodega's weapons, continues with boarding\n- Let the ship approach"], 0, null, false, false);
      t2.$indexSet(0, "Ressurection: EleanorAdvice", t1);
      t1.name = "Ressurection: EleanorAdvice";
      t1 = new O.EgbScripterPage([new N.ScripterImpl_closure276(this), "// TODO: again possible to go around the whole ship\n// TODO: lose most of strength around the engine\n// take weapons \n// find gorilla, still stiff, possibility to move out of the corridor\n// make noise ?\n// hide (some places better than others)\n// mercenaries with masks\n// they go in 2 pairs, clockwise and ccw\n// player can hear them in adjanced rooms\n// walking in to room where they are = even fight\n// hiding in place where they're going = can wait various amounts of time, with more time = more chance of being detected, but also better advantage if not detected and possibility to let them through", "// fight itself is primitive, as they are much weaker - problem would be near engine room or with all 4 of them at once\n// the better the setup, the quicker fight, the better points"], 0, null, false, false);
      t2.$indexSet(0, "Boarding: Start", t1);
      t1.name = "Boarding: Start";
      t1 = new O.EgbScripterPage([], 0, null, false, false);
      t2.$indexSet(0, "Boarding: Fight2Men", t1);
      t1.name = "Boarding: Fight2Men";
      t1 = new O.EgbScripterPage(["The four men are down. You carefully go through the breach and explore the inside of the gunship. There is no one else there, but you find some food and some energy cells. ", "Your current supplies are: TODO.", [new N.ScripterImpl_closure277(), P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure278(), "goto", "GetRidOfTheMen"], null, null)], "You bring the supplies over to the Bodega. The extremely heavy fuel cells don't seem that way anymore. ", "There are now TODO energy cells and food for TODO days on the Bodega. You also scavenge some turret ammunition (TODO?).", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "GetRidOfTheMen"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Boarding: AllMenDown", t1);
      t1.name = "Boarding: AllMenDown";
      t1 = new O.EgbScripterPage(["You carry all the four men over to the gunship and come back to the bridge. The Bodega then pushes the gunship off while sealing the breach. In twenty minutes, the hull is sealed again, and the gunship slowly drifts away a few hundred meters to the right of the Bodega."], 0, null, false, false);
      t2.$indexSet(0, "Boarding: GetRidOfTheMen", t1);
      t1.name = "Boarding: GetRidOfTheMen";
      t1 = new O.EgbScripterPage(["\"We probably shouldn't stay here too much longer,\" the Bodega says. \"The good news is, since you don't need to chat with your doctor girlfriend anymore, we can go pretty much anywhere. Places without comms beacons and outside main official routes seem like a great idea to me right now. We have a few options. Just note that we only have TODO fuel cells right now.\" ", "The Bodega highlights the options on a map on the main screen.", "- A (distance, fuel cells)\n- Outer space just outside effective radar ranges\n- C\n- D", "The Bodega puts in the coordinates for TODO and immediately starts rotating and charging the warp at the same time.", "- Watch\n- Go find Gorilla"], 0, null, false, false);
      t2.$indexSet(0, "Finale: Start", t1);
      t1.name = "Finale: Start";
      t1 = new O.EgbScripterPage(["You go looking for Gorilla to where you last saw him, in TODO, but when you arrive, he's not there. The rebuild phase took longer in his case, for whatever reason (you can assume it's because of the proximity to the engine room and also the sheer mass of his body), but it has clearly passed.", "- Look for him in ___\n- Look for him in ___\n- Look for him in ___"], 0, null, false, false);
      t2.$indexSet(0, "Finale: FindGorilla", t1);
      t1.name = "Finale: FindGorilla";
      t1 = new O.EgbScripterPage(["You enter the captain's cabin and lay your eyes on the most amazing thing you've seen since TODO.", "Gorilla \u2013 the massive monument of muscle and fur \u2013 is slouching on a chair in front of captain's computer. He's not just sitting there, though. He _actively uses the computer_, apparently reading some long article. When he sees you, he turns around and smiles.", "\"I went ahead and read most of what Dr. Wells sent to us,\" Gorilla says with perfect pronounciation and in a pleasant voice. \"It's fascinating.\" ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["string", new N.ScripterImpl_closure279(), "goto", "How?"], null, null)]], 0, null, false, false);
      t2.$indexSet(0, "Finale: GorillaInCaptainsCabin", t1);
      t1.name = "Finale: GorillaInCaptainsCabin";
      t1 = new O.EgbScripterPage(["\"Oh, in many ways,\" says Gorilla. \"\" ", [null, P.LinkedHashMap_LinkedHashMap$_literal(["goto", "QuestionsForGorilla"], null, null)]], 0, null, true, false);
      t2.$indexSet(0, "Finale: How?", t1);
      t1.name = "Finale: How?";
      t1 = new O.EgbScripterPage(["- \"No, I mean, how are you able to talk this well?\" TODO change when not shown for the first time\n- \"How did you get the password?\" // saw captain put in the password countless times."], 0, null, false, false);
      t2.$indexSet(0, "Finale: QuestionsForGorilla", t1);
      t1.name = "Finale: QuestionsForGorilla";
      t1 = new O.EgbScripterPage(["Your jaw is still down in amazement when the Bodega starts talking through the PA. She doesn't bother to use the intercom anymore. ", "\"We just left the detection range of TODO and are on our way to TODO. In other words, you and your pet monkey are safe. You are welcome.\" ", "Gorilla raises his browridge. \"Actually, I am not a monkey. I am an ape. If I was a macaque, or similar, you could refer to me as a monkey. Am I a macaque, though? No. I am a gorilla.\" ", "At that moment, you realize: _this is how it's going to be here from now on._ TODO longer", "And the Bodega says: \"Great, thanks for the lecture.\" And then, after a couple of seconds, she says with a different voice: \"I suggest both of you apes come to the bridge. You might want to see this.\" "], 0, null, false, false);
      t2.$indexSet(0, "Finale: End", t1);
      t1.name = "Finale: End";
      t1 = new O.EgbScripterPage(["<p class=\"meta\">This is the end of the preview. Thank you for playing.</p>"], 0, null, false, false);
      t2.$indexSet(0, "Preview: End", t1);
      t1.name = "Preview: End";
      this.firstPage = H.interceptedTypeCheck(t2.$index(0, "start"), "$isEgbScripterPage");
    },
    getInformalRole$1: function(arg0) {
      return this.getInformalRole.call$1(arg0);
    },
    getRoleAdjective$0: function() {
      return this.getRoleAdjective.call$0();
    },
    isStuttering$0: function() {
      return this.isStuttering.call$0();
    },
    printSleepiness$0: function() {
      return this.printSleepiness.call$0();
    },
    getHoursToHyperdrive$0: function() {
      return this.getHoursToHyperdrive.call$0();
    },
    static: {ScripterImpl$: function() {
        var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11;
        t1 = F.ShipComponentCollection$();
        t2 = Z.Stat_Stat("Physical pool", new N.closure(), "#CCCCCC", "Spare physical energy", 0, 0, false, P.$int);
        t3 = Z.Stat_Stat("Mental pool", new N.closure0(), "#CCCCCC", "Spare mental energy", 0, 0, false, P.$int);
        t4 = Z.Stat_Stat("Time", new N.closure1(), "#CCCCCC", "Time since captain's funeral", 0, 0, false, P.$int);
        t5 = E.BodegaShip$();
        t6 = E.MessengerShip$();
        t7 = Z.Stat_Stat("Energy reserve", new N.closure2(), "#CCCCCC", "The number of charged power cells", 8, 0, false, P.$int);
        t8 = H.setRuntimeTypeInfo([], [L.TimedEvent]);
        t9 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, P.$int), "$isMap", [P.$int, P.$int], "$asMap");
        H.assertSubtype(t8, "$isList", [L.TimedEvent], "$asList");
        H.assertSubtype(t9, "$isMap", [P.$int, P.$int], "$asMap");
        O.throwIfNotInInitOrDeclareBlock("");
        t10 = H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.EgbScripterPage), "$isMap", [P.String, O.EgbScripterPage], "$asMap"), "$isMap", [P.String, O.EgbScripterPage], "$asMap");
        t11 = H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, P.String), "$isSet", [P.String], "$asSet");
        t11 = new N.ScripterImpl(null, new F.SpaceshipMock(true, t1, "Spaceship"), false, false, false, 2, 2, H.assertSubtype(t2, "$isStat", [P.$int], "$asStat"), H.assertSubtype(t3, "$isStat", [P.$int], "$asStat"), false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, null, 0, 0, null, null, null, "man", null, null, new N.closure3(), 0, false, "Slim", 0, "Captain", 0, H.assertSubtype(t4, "$isStat", [P.$int], "$asStat"), t5, t6, null, H.assertSubtype(["Unity", "Explosion"], "$isList", [P.String], "$asList"), null, null, null, null, null, null, 8, H.assertSubtype(t7, "$isStat", [P.$int], "$asStat"), 20, H.assertSubtype(["Organization", "ActiveThreatBlacklist", "AskToDock", "AskToTrade", "WhereToGo"], "$isList", [P.String], "$asList"), new L.Timeline(-1, null, null, t8, t9, null, false, "Timeline", false), null, new O.EgbScripterPageMap(t10), null, null, null, null, H.assertSubtype(t11, "$isSet", [P.String], "$asSet"), false, null, -9999, H.assertSubtype(null, "$isMap", [P.String, P.Function], "$asMap"), null, null, null);
        t11.ScripterImpl$0();
        return t11;
      }}
  },
  closure: {
    "^": "Closure:0;",
    call$1: function(value) {
      return H.S(H.intTypeCheck(value)) + " P";
    }
  },
  closure0: {
    "^": "Closure:0;",
    call$1: function(value) {
      return H.S(H.intTypeCheck(value)) + " M";
    }
  },
  closure3: {
    "^": "Closure:1;",
    call$0: function() {
      return false;
    }
  },
  closure1: {
    "^": "Closure:2;",
    call$1: function(value) {
      var hours, minutes, t1;
      if (typeof value !== "number")
        return value.$div();
      hours = C.JSDouble_methods.toInt$0(H.doubleTypeCheck(Math.floor(value / 60)));
      minutes = H.intTypeCheck(C.JSNumber_methods.$mod(value, 60));
      t1 = "" + hours + ":";
      return t1 + (minutes < 10 ? "0" : "") + minutes;
    }
  },
  closure2: {
    "^": "Closure:2;",
    call$1: function(value) {
      return H.S(value) + " E";
    }
  },
  ScripterImpl_closure: {
    "^": "Closure:1;",
    call$0: function() {
      return "From beginning";
    }
  },
  ScripterImpl_closure0: {
    "^": "Closure:1;",
    call$0: function() {
      return "Spaceship combat";
    }
  },
  ScripterImpl_closure1: {
    "^": "Closure:1;_Scripter_Implementation$_captured_this_0",
    call$0: function() {
      this._Scripter_Implementation$_captured_this_0.barbrawl.run$0();
    }
  },
  ScripterImpl_closure2: {
    "^": "Closure:1;_Scripter_Implementation$_captured_this_1",
    call$0: function() {
      if (this._Scripter_Implementation$_captured_this_1.barbrawl.wasSuccessful)
        $.gotoPageName = "Win";
      else
        $.gotoPageName = "Lose";
    }
  },
  ScripterImpl_closure3: {
    "^": "Closure:1;",
    call$0: function() {
    }
  },
  ScripterImpl_closure4: {
    "^": "Closure:1;",
    call$0: function() {
    }
  },
  ScripterImpl_closure5: {
    "^": "Closure:1;",
    call$0: function() {
      return "You are the ship's:";
    }
  },
  ScripterImpl_closure6: {
    "^": "Closure:1;",
    call$0: function() {
      return "Assistant Engineer, skilled in electronics and machines";
    }
  },
  ScripterImpl_closure7: {
    "^": "Closure:1;_Scripter_Implementation$_captured_this_2",
    call$0: function() {
      var t1 = this._Scripter_Implementation$_captured_this_2;
      t1.isEngineer = true;
      t1.maxPhysicalPoints = 3;
      t1.maxMentalPoints = 3;
    }
  },
  ScripterImpl_closure8: {
    "^": "Closure:1;",
    call$0: function() {
      return "Assistant Medic, skilled in biology and health";
    }
  },
  ScripterImpl_closure9: {
    "^": "Closure:1;_captured_this_3",
    call$0: function() {
      var t1 = this._captured_this_3;
      t1.maxMentalPoints = 4;
      t1.isMedic = true;
    }
  },
  ScripterImpl_closure10: {
    "^": "Closure:1;",
    call$0: function() {
      return "Ablebodied Spaceman, skilled in space travel and spaceship maintenance";
    }
  },
  ScripterImpl_closure11: {
    "^": "Closure:1;_captured_this_4",
    call$0: function() {
      var t1 = this._captured_this_4;
      t1.isSpaceman = true;
      t1.maxPhysicalPoints = 4;
    }
  },
  ScripterImpl_closure12: {
    "^": "Closure:1;_captured_this_5",
    call$0: function() {
      O.echo("Before the incident changed everything, you were nearing two years in your " + H.S(this._captured_this_5.getRoleAdjective$0()) + " service on the Bodega. Everything had become familiar. The smell of polyplastics, human sweat and detergent. The bleak dimness of the interiors. The color-coded ducts and cables on every wall. The way sound carries in a huge, 25 thousand ton cargo ship. Conversations, laughter, and swearing were echoing through the corridors almost constantly.");
    }
  },
  ScripterImpl_closure13: {
    "^": "Closure:1;_captured_this_6",
    call$0: function() {
      O.echo("Two weeks ago, you were little more than a lowly " + H.S(this._captured_this_6.getInformalRole$1("")) + ". Now, you're the acting captain. The last one standing. (Well, almost. But we'll get to that later.)");
    }
  },
  ScripterImpl_closure14: {
    "^": "Closure:1;",
    call$0: function() {
    }
  },
  ScripterImpl_closure15: {
    "^": "Closure:1;_captured_this_7",
    call$0: function() {
      this._captured_this_7.b.createTraitsForm$0();
    }
  },
  ScripterImpl_closure16: {
    "^": "Closure:1;_captured_this_8",
    call$0: function() {
      var t1 = this._captured_this_8;
      t1.b.echoTraits$0();
      t1 = t1.pointsToDistribute;
      if (typeof t1 !== "number")
        return t1.$gt();
      if (t1 > 0)
        $.get$_points().add$2(0, t1 * 10, "not using all the talent points");
    }
  },
  ScripterImpl_closure17: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo("Your hand is on the lever that will open the airlock's outside door. Through that door, once open, the captain's body will be sucked out into outer space. This is how funerals work here on the Bodega." + E.fn("funeralInSpace"));
    }
  },
  ScripterImpl_closure18: {
    "^": "Closure:1;",
    call$0: function() {
      return "Say a few words first";
    }
  },
  ScripterImpl_closure19: {
    "^": "Closure:1;",
    call$0: function() {
      return "Pull the lever";
    }
  },
  ScripterImpl_closure20: {
    "^": "Closure:1;",
    call$0: function() {
      return "Leave the body in the airlock";
    }
  },
  ScripterImpl_closure21: {
    "^": "Closure:1;_captured_this_9",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_9;
      t2 = "\"C" + (H.boolConversionCheck(t1.isStuttering$0()) ? "-c" : "") + "aptain Kay.\" Your voice sounds awkward in the silence of the empty corridor";
      O.echo(t2 + (H.boolConversionCheck(t1.isStuttering$0()) ? ", and your stutter doesn't help" : "") + ".");
    }
  },
  ScripterImpl_closure22: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"Let's just say this is not the first time I see you lying on the floor, naked and reddish and stiff.\" ";
    }
  },
  ScripterImpl_closure23: {
    "^": "Closure:1;_captured_this_10",
    call$0: function() {
      O.echo("It might not be the best topic for anyone's funeral \u2014 but it's true. You are the kind of person who says it how it is.\n");
      this._captured_this_10.madeFunOfDrunkednessOnFuneral = true;
      $.get$_points().add$2(0, 1, "honesty");
    }
  },
  ScripterImpl_closure24: {
    "^": "Closure:1;",
    call$0: function() {
      return "Let it go.";
    }
  },
  ScripterImpl_closure25: {
    "^": "Closure:1;_Scripter_Implementation$_captured_this_11",
    call$0: function() {
      O.echo("You decide this is probably not the best topic for anyone's funeral.\n");
      $.get$_points().add$2(0, 1, "sensitivity");
    }
  },
  ScripterImpl_closure26: {
    "^": "Closure:1;_captured_this_12",
    call$0: function() {
      O.echo((H.boolConversionCheck(this._captured_this_12.isStrong) ? "You" : "With great effort, you") + " pull the lever, and as the outer door opens, all the air in the airlock shoots out \u2013 with a loud hiss \u2013 into the vacuum of space. The body is now moving in that direction, too, though much slower. It's no longer pulled towards the floor with artificial gravity \u2013 that was automatically turned off when you pulled that lever \u2013 so the body kind of tumbles towards the door.");
    }
  },
  ScripterImpl_closure27: {
    "^": "Closure:1;",
    call$0: function() {
      if (S.Randomly_saveAgainst(0.5))
        O.echo("It hits the doorsill on its way out, goes through the door, and starts receding into space while slowly rotating.\n");
      else
        O.echo("It hits the doorsill on its way out and almost stops, hanging midway between the inside and outside. For a while, it almost looks like you'll have to close that outside door and reopen it again, which would cut the captain's body in half. But fortunately, the movement never stops completely, and the body goes through the door and starts slowly receding into space.\n");
    }
  },
  ScripterImpl_closure28: {
    "^": "Closure:1;_captured_this_13",
    call$0: function() {
      $.get$_points().add$2(0, 5, "observing the protocol");
      this._captured_this_13.pulledLever = true;
    }
  },
  ScripterImpl_closure29: {
    "^": "Closure:1;_Scripter_Implementation$_captured_this_14",
    call$0: function() {
      $.get$_points().add$2(0, 2, "respect to the dead");
    }
  },
  ScripterImpl_closure30: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo("You remember the first time you saw the captain \u2013 in a bar on Space Station Clara" + E.fn("stationClara") + ". Both of you were drunk beyond belief, both for different reasons. Come to think of it, _everybody_ in that bar was drunk beyond belief, and probably for different reasons, too. It was like a group therapy session.");
    }
  },
  ScripterImpl_closure31: {
    "^": "Closure:1;_captured_this_15",
    call$0: function() {
      O.echo("You sat alone. Not because of shyness or anything. No, you have just always found it tiring to talk about things that don't matter. And when you talk about things that _do_ matter to you, it's kind of a pain for everyone involved. \"Nobody wants to talk about that, " + H.S(this._captured_this_15.name) + ",\" your psychiatrist had always said. \"The only reason we two talk about it is that I get paid for it.\" (He wasn't a very good psychiatrist.)");
    }
  },
  ScripterImpl_closure32: {
    "^": "Closure:1;_captured_this_16",
    call$0: function() {
      O.echo("Of course, it didn't take long before someone started a fight that night. You don't really remember who it was but it wasn't captain Kay, and it definitely wasn't you. You stood up and started making your way out, avoiding the epicenters of the brawl. You " + (H.boolConversionCheck(this._captured_this_16.isStrong) ? "decided a long time ago that using your pretty decent fighting skills in bar fights is a waste of time and perfectly good teeth" : "were never a good fighter and had no intention of getting the hell beaten out of you for no reason whatsoever") + ". After a few steps, you had to dodge a ginger guy who was thrown by two others across the room and right into another part of the melee. What followed was a surge of yells and roars and a loud clamor of furniture.");
    }
  },
  ScripterImpl_closure33: {
    "^": "Closure:1;",
    call$0: function() {
      return "You ran at the warehouseman trying to kick him off balance, exposing your leg";
    }
  },
  ScripterImpl_closure34: {
    "^": "Closure:1;_captured_this_17",
    call$0: function() {
      O.echo("A few paces away from the captain, you jumped, putting both your legs forward in a kind of an improvized jump kick. The warehouseman saw you coming, though, and he brought the chair down and on your right leg. You heard the muffled scrunch of breaking bone and you flew past the guy into some furniture. \n");
      this._captured_this_17.isLimping = true;
    }
  },
  ScripterImpl_closure35: {
    "^": "Closure:1;",
    call$0: function() {
      return "You tried to parry the chair with your arm";
    }
  },
  ScripterImpl_closure36: {
    "^": "Closure:1;_captured_this_18",
    call$0: function() {
      O.echo("You made it to where the captain was standing just in time to try to block the warehouseman's blow. The chair landed with full force on your left hand and you heard the muffled scrunch of breaking bone. The impact sent you sliding under a table nearby.\n");
      this._captured_this_18.hasLameHand = true;
    }
  },
  ScripterImpl_closure37: {
    "^": "Closure:1;_captured_this_19",
    call$0: function() {
      O.echo("\"" + H.S(this._captured_this_19.name) + ",\" you said.");
    }
  },
  ScripterImpl_closure38: {
    "^": "Closure:1;_captured_this_20",
    call$0: function() {
      O.echo("\"So, uh, " + H.S(this._captured_this_20.name) + ", that was really stupid of you. You know that, right?\" ");
    }
  },
  ScripterImpl_closure39: {
    "^": "Closure:1;_captured_this_21",
    call$0: function() {
      O.echo("\"Idiotic, really. I mean, " + (H.boolConversionCheck(this._captured_this_21.isLimping) ? "jumping" : "running") + " right into the path of a _steel chair_ like that?\" He looked you into the eyes, still smiling. Still dripping with blood. \"But thanks, anyway. You probably saved my life or whatever.\" ");
    }
  },
  ScripterImpl_closure40: {
    "^": "Closure:1;_captured_this_22",
    call$0: function() {
      O.echo("He stood there for a while. \"How's your " + (H.boolConversionCheck(this._captured_this_22.isLimping) ? "leg" : "arm") + "?\" ");
    }
  },
  ScripterImpl_closure41: {
    "^": "Closure:1;_captured_this_23",
    call$0: function() {
      O.echo("\"Alright.\" He stopped grinning. \"" + H.S(this._captured_this_23.name) + ", right? Let me do one thing. I have a ship with a medbay, docked at D-14. I'll take you there and my doc will treat that for you. For free.\" ");
    }
  },
  ScripterImpl_closure42: {
    "^": "Closure:1;_captured_this_24",
    call$0: function() {
      var t1 = this._captured_this_24;
      O.echo("You nodded, carefully got up," + (H.boolConversionCheck(t1.isLimping) ? " grabbed his shoulder for support," : "") + " and let him lead the way. Later in the day, on board of the Bodega, he offered you the " + H.S(t1.getRoleAdjective$0()) + " job that you kept for the past 2 years.");
    }
  },
  ScripterImpl_closure43: {
    "^": "Closure:1;_captured_this_25",
    call$0: function() {
      O.echo("Now, you watch his dead body " + (H.boolConversionCheck(this._captured_this_25.pulledLever) ? "recede into darkness" : "lie on the floor in front of you") + ".");
    }
  },
  ScripterImpl_closure44: {
    "^": "Closure:1;_captured_this_26",
    call$0: function() {
      var t1 = this._captured_this_26;
      if (H.boolConversionCheck(t1.isStrong))
        O.echo("You think about it again. There really is no reason why you should outlive the captain. You are a strong " + H.S(t1.manOrWoman) + ", but your tenacity is nothing compared to the captain's. The contagion, or whatever it is, should have killed you long before him. Then again, there was absolutely no sense in the order in which the crew died. It was random. The healthiest, most vigorous crewmember \u2013 Cooper \u2013 died second. \n");
      else
        O.echo("You think about it again. There is no reason why _you_ should outlive the captain. Or why you should outlive _any other_ crew member, for that matter. You were one of the weakest, least hardened individuals on board. The contagion, or whatever it is, should have killed you long before everyone else. Then again, there was absolutely no sense in the order in which the crew died. It was random. The healthies, most vigorous crewmember \u2013 Cooper \u2013 died second. \n");
    }
  },
  ScripterImpl_closure45: {
    "^": "Closure:1;_captured_this_27",
    call$0: function() {
      if (H.boolConversionCheck(this._captured_this_27.isMedic))
        O.echo("You don't remember ever treating Cooper or seeing him in the medbay. Not even with the common cold.\n");
      else
        O.echo("That guy had never even _sneezed_ before.\n");
    }
  },
  ScripterImpl_closure46: {
    "^": "Closure:1;",
    call$0: function() {
    }
  },
  ScripterImpl_closure47: {
    "^": "Closure:1;",
    call$0: function() {
      return "Ignore it";
    }
  },
  ScripterImpl_closure48: {
    "^": "Closure:1;",
    call$0: function() {
      return "Pick it up";
    }
  },
  ScripterImpl_closure49: {
    "^": "Closure:1;_captured_this_28",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_28;
      t1.pickedUpIntercom = false;
      t2 = t1.bodegaAttitude;
      if (typeof t2 !== "number")
        return t2.$sub();
      t1.bodegaAttitude = t2 - 1;
    }
  },
  ScripterImpl_closure50: {
    "^": "Closure:1;_captured_this_29",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_29;
      t1.pickedUpIntercom = true;
      t2 = t1.bodegaAttitude;
      if (typeof t2 !== "number")
        return t2.$add();
      t1.bodegaAttitude = t2;
    }
  },
  ScripterImpl_closure51: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"I'm coming.\" ";
    }
  },
  ScripterImpl_closure52: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"The funeral hasn't ended yet.\" ";
    }
  },
  ScripterImpl_closure53: {
    "^": "Closure:1;",
    call$0: function() {
    }
  },
  ScripterImpl_closure54: {
    "^": "Closure:1;_captured_this_30",
    call$0: function() {
      if (!H.boolConversionCheck(this._captured_this_30.pickedUpIntercom))
        O.echo("The speakers turn off, then turn on again.\n\n\"And by the way,\" the ship adds, \"I know you're not very bright and all, but by now you should be familiar with the intercom system. A hint: when the red light goes blink, you pick it up.\" The speakers turn off again.\n");
    }
  },
  ScripterImpl_closure55: {
    "^": "Closure:1;_captured_this_31",
    call$0: function() {
      var t1, t2;
      t1 = H.boolConversionCheck(this._captured_this_31.pulledLever);
      t2 = "You give captain Kay's " + (t1 ? "receding" : "") + " body the last glance";
      O.echo(t2 + (t1 ? ", put the airlock lever back to the close position" : "") + ", and set off in the direction of the bridge.");
    }
  },
  ScripterImpl_closure56: {
    "^": "Closure:1;_captured_this_32",
    call$0: function() {
      if (H.boolConversionCheck(this._captured_this_32.isLimping))
        O.echo("The pain in your right leg is back almost immediately, and you automatically start limping so that it doesn't come back in full force. The leg has been a problem since the incident on Space Station Clara, but \u2013 once in a while \u2013 you still have the capacity to forget about how much it hurts to stand on it. The funeral provided one such distraction.\n");
    }
  },
  ScripterImpl_closure57: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo("It's the ship's Enhanced Gorilla. These species are used throughout the universe for hard manual labor: in construction, in the military, and on big tankers and cargo ships like the Bodega. Their intelligence is somewhat improved over what nature has given them -- they can understand basic spoken commands and they have the ability to communicate back via sign language. The vocabulary is very limited, and even then they use mostly just the words \"food\", \"sleep\" and \"want\". But people don't need Enhanced Gorillas to be eloquent or nuanced or poetic. They need them to lift and push and sometimes smash. _This_ gorilla mostly manipulates with heavy objects in the cargo bay." + E.fn("gorillaCargoMove"));
    }
  },
  ScripterImpl_closure58: {
    "^": "Closure:1;",
    call$0: function() {
      return "What do you say to him?";
    }
  },
  ScripterImpl_closure59: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"It's okay.\" ";
    }
  },
  ScripterImpl_closure60: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"What the hell do you think you are doing here, Gorilla?\" ";
    }
  },
  ScripterImpl_closure61: {
    "^": "Closure:1;_captured_this_33",
    call$0: function() {
      O.echo("\"The " + (H.boolConversionCheck(this._captured_this_33.isStuttering$0()) ? "g-g-" : "") + "gorilla stays,\" you say to the ship computer. \"He just sits there. And he definitely won't touch anything while I'm here.\" The Gorilla nods solemnly.");
    }
  },
  ScripterImpl_closure62: {
    "^": "Closure:1;_captured_this_34",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_34;
      t2 = t1.gorillaAttitude;
      if (typeof t2 !== "number")
        return t2.$add();
      t1.gorillaAttitude = t2 + 1;
      $.get$_points().add$2(0, 1, "being kind to animals");
    }
  },
  ScripterImpl_closure63: {
    "^": "Closure:1;_captured_this_35",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_35;
      t2 = "\"What the hell " + (H.boolConversionCheck(t1.isStuttering$0()) ? "d-" : "") + "do you think you are ";
      O.echo(t2 + (H.boolConversionCheck(t1.isStuttering$0()) ? "d-" : "") + "doing here, Gorilla?\" ");
    }
  },
  ScripterImpl_closure64: {
    "^": "Closure:1;_captured_this_36",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_36;
      t2 = t1.gorillaAttitude;
      if (typeof t2 !== "number")
        return t2.$sub();
      t1.gorillaAttitude = t2 - 1;
      t1.snappedAtGorilla = true;
      $.get$_points().add$2(0, 1, "setting boundaries");
      t2 = t1.gorilla;
      t1 = t1.b;
      t2.set$location(S.Randomly_choose([t1.cargoBayLeft, t1.gorillasDen]));
    }
  },
  ScripterImpl_closure65: {
    "^": "Closure:1;_captured_this_37",
    call$0: function() {
      O.echo("\"You are the acting captain of the ship now,\" the Bodega continues matter-of-factly. \"Probably not for long, of course. But to follow the protocol, I will henceforth call you Captain " + H.S(this._captured_this_37.name) + ". It is understood that my Oath" + E.fn("oathFirstExpl") + " now transfers to you.\" ");
    }
  },
  ScripterImpl_closure66: {
    "^": "Closure:1;_captured_this_38",
    call$0: function() {
      return "\"Yes, call me Captain " + H.S(this._captured_this_38.name) + ".\" ";
    }
  },
  ScripterImpl_closure67: {
    "^": "Closure:1;_captured_this_39",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_39;
      t1.title = "Acting Captain";
      t2 = t1.conceitedness;
      if (typeof t2 !== "number")
        return t2.$add();
      t1.conceitedness = t2 + 1;
    }
  },
  ScripterImpl_closure68: {
    "^": "Closure:1;_captured_this_40",
    call$0: function() {
      return "\"Just call me " + H.S(this._captured_this_40.name) + ", no need for formalities.\" ";
    }
  },
  ScripterImpl_closure69: {
    "^": "Closure:1;_captured_this_41",
    call$0: function() {
      this._captured_this_41.title = "";
    }
  },
  ScripterImpl_closure70: {
    "^": "Closure:1;_captured_this_42",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_42;
      t2 = "While the captain" + (H.boolConversionCheck(t1.isEngineer) ? ", the senior engineer and you" : " and the engineers") + " were starting to patch up the drive, the rest of the crew were busy getting sick. One by one. The ship's medic";
      t1 = H.boolConversionCheck(t1.isMedic);
      t2 = t2 + (t1 ? ", your boss," : "") + " was one of the first to go. (";
      O.echo(t2 + (t1 ? "Although he was much more experienced than you were, he also" : "Although he was an experienced medic, he") + " didn't appear to have any idea about what was going on anyway. He was as scared and angry and clueless as anyone else.)");
    }
  },
  ScripterImpl_closure71: {
    "^": "Closure:1;_captured_this_43",
    call$0: function() {
      var t1, t2, t3;
      t1 = this._captured_this_43;
      t2 = t1.physicalPoints;
      t3 = t1.maxPhysicalPoints;
      if (typeof t3 !== "number")
        return t3.$sub();
      t2.set$value(t3 - 2);
      t1.physicalPoints.set$show(true);
      t3 = t1.mentalPoints;
      t2 = t1.maxMentalPoints;
      if (typeof t2 !== "number")
        return t2.$sub();
      t3.set$value(t2 - 2);
      t1.mentalPoints.set$show(true);
    }
  },
  ScripterImpl_closure72: {
    "^": "Closure:1;_captured_this_44",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_44;
      t2 = t1.physicalPoints;
      t2 = "<p class=\"meta\">You still have <em>some</em> spare energy in you, represented by your <strong>physical pool</strong> (currently <em>" + H.S(H.stringTypeCheck(t2.valueToString$1(H.assertSubtypeOfRuntimeType(t2._value, H.getTypeArgumentByIndex(t2, 0))))) + "</em>) and your <strong>mental pool</strong> (currently <em>";
      t1 = t1.mentalPoints;
      O.echo(t2 + H.S(H.stringTypeCheck(t1.valueToString$1(H.assertSubtypeOfRuntimeType(t1._value, H.getTypeArgumentByIndex(t1, 0))))) + "</em>). Spending these points will let you put in an extra effort to increase your chances at different tasks. Both points are normally replenished by sleep and their maximum value varies based on your role.</p>");
    }
  },
  ScripterImpl_closure73: {
    "^": "Closure:1;_captured_this_45",
    call$0: function() {
      O.echo("The captain was able to finish the repairs of the hyperdrive (with your " + (H.boolConversionCheck(this._captured_this_45.isEngineer) ? "" : "modest") + " help) a few hours before he died, but now that it's back online, Bodega needs to compute the jump." + E.fn("computeUnityJump") + " Before that's done, you, Gorilla and the whole ship are sitting ducks.");
    }
  },
  ScripterImpl_closure74: {
    "^": "Closure:1;_captured_this_46",
    call$0: function() {
      this._captured_this_46.clock.set$show(true);
    }
  },
  ScripterImpl_closure75: {
    "^": "Closure:1;_captured_this_47",
    call$0: function() {
      O.echo("There's only " + H.S(this._captured_this_47.getHoursToHyperdrive$0()) + " before the hyperjump parameters are ready, so you decide to wait on the bridge. You sit down and contemplate trying to sleep but soon realize the adrenaline from the Messenger encounter won't let you.");
    }
  },
  ScripterImpl_closure76: {
    "^": "Closure:1;_captured_this_48",
    call$0: function() {
      var t1 = this._captured_this_48.zil;
      t1.update$3$describe$whileString(C.JSInt_methods.$sub(473, t1.get$timeline().time), false, "you are gazing");
    }
  },
  ScripterImpl_closure77: {
    "^": "Closure:1;_captured_this_49",
    call$0: function() {
      O.echo("You slouch into the captain's seat and check the time. You should be ready for the jump in " + H.S(this._captured_this_49.getHoursToHyperdrive$0()) + ". Your eye lids get heavy and you realize that \u2013 by now \u2013 there is no way you can fight this. Soon, the captain's seat feels like the most comfortable bed ever. You drift off to sleep.");
    }
  },
  ScripterImpl_closure78: {
    "^": "Closure:1;",
    call$0: function() {
    }
  },
  ScripterImpl_closure79: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo("Father, with blood on his hands and upper torso, and a huge grin. Mother, with crazy eyes and lipstick all over her face. Her expression a horrid struggle between paternal love and the effects of Vitamin." + E.fn("vitamin"));
    }
  },
  ScripterImpl_closure80: {
    "^": "Closure:1;_captured_this_50",
    call$0: function() {
      var t1 = this._captured_this_50;
      if (H.boolConversionCheck(t1.isMedic))
        t1 = "a scalpel";
      else
        t1 = H.boolConversionCheck(t1.isEngineer) ? "an electrical wire" : "a wire cutter";
      O.echo("But of course the drug wins. Vitamin always wins. Father has " + t1 + " in hand. Mother holds a knife. A strange rhytmic sound resonates throughout the forest. That's new. Bwang. Father eyes your neck. Bwang. Mother's hand is shaking. Bwang. They burst forth. ");
    }
  },
  ScripterImpl_closure81: {
    "^": "Closure:1;_captured_this_51",
    call$0: function() {
      var t1, t2, wentToSleepBeforeForcedNap, t3, t4;
      t1 = this._captured_this_51;
      t2 = t1.zil.get$timeline().time;
      if (typeof t2 !== "number")
        return t2.$lt();
      wentToSleepBeforeForcedNap = t2 < 96;
      t2 = t1.physicalPoints;
      t3 = t1.maxPhysicalPoints;
      t4 = wentToSleepBeforeForcedNap ? 1 : 0;
      if (typeof t3 !== "number")
        return t3.$add();
      t2.set$value(t3 + t4);
      t4 = t1.mentalPoints;
      t1 = t1.maxMentalPoints;
      t2 = wentToSleepBeforeForcedNap ? 1 : 0;
      if (typeof t1 !== "number")
        return t1.$add();
      t4.set$value(t1 + t2);
    }
  },
  ScripterImpl_closure82: {
    "^": "Closure:1;_captured_this_52",
    call$0: function() {
      var t1 = this._captured_this_52;
      t1.exploration.set$time(460);
      t1.clock.set$value(t1.exploration.get$time());
    }
  },
  ScripterImpl_closure83: {
    "^": "Closure:1;_captured_this_53",
    call$0: function() {
      var t1 = this._captured_this_53;
      if (t1.gorilla.isIn$1(t1.b.bridge))
        O.echo("Gorilla, which has been silently sitting on the ground to your left until now, starts hissing through clenched teeth, eyes wide open. It rocks back and forth, visibly disturbed. \n");
    }
  },
  ScripterImpl_closure84: {
    "^": "Closure:1;_captured_this_54",
    call$0: function() {
      var t1, t2, t3;
      O.choice("\"What are you doing? What is happening here?\"", false, false, null, null, null).f = new N.ScripterImpl__closure11();
      O.choice("Watch what he's doing with the controls", false, false, null, null, null).f = new N.ScripterImpl__closure12();
      t1 = this._captured_this_54;
      if (H.boolConversionCheck(t1.scannerRepaired))
        O.choice("Use the repaired scanner", false, false, null, null, null).f = new N.ScripterImpl__closure13();
      t2 = H.interceptedTypeCheck(t1.bodega.components.$index(0, "shield"), "$isShipComponentMock");
      t3 = t2.charge;
      t3 = H.intTypeCheck(R.NumScale.prototype.get$value.call(t3));
      t2 = t2.minimalCharge;
      if (typeof t3 !== "number")
        return t3.$ge();
      if (t3 < t2)
        O.choice("Shields up", false, false, null, null, null).f = new N.ScripterImpl__closure14(t1);
      O.choice("Fire", false, false, null, null, null).f = new N.ScripterImpl__closure15(t1);
    }
  },
  ScripterImpl__closure11: {
    "^": "Closure:1;",
    call$0: function() {
      return O.echo("He doesn't respond.");
    }
  },
  ScripterImpl__closure12: {
    "^": "Closure:1;",
    call$0: function() {
      return O.echo("It takes a while, but you realize he's probably putting his ship into combat mode.");
    }
  },
  ScripterImpl__closure13: {
    "^": "Closure:1;",
    call$0: function() {
      return O.echo("You perform a quick scan of the Messenger. Its energy output is increasing rapidly and a variety of systems are coming alive. Chief among those are the two nose-mounted laser guns. It's beyond doubt that the Messenger is going into full combat mode.");
    }
  },
  ScripterImpl__closure14: {
    "^": "Closure:1;_captured_this_55",
    call$0: function() {
      var t1, t2;
      t1 = H.interceptedTypeCheck(this._captured_this_55.bodega.components.$index(0, "shield"), "$isShipComponentMock").charge;
      t2 = t1.min;
      t1.super$NumScale$set$value(C.JSNumber_methods.toInt$0(t2 + 0.78 * (t1.max - t2)));
    }
  },
  ScripterImpl__closure15: {
    "^": "Closure:1;_captured_this_56",
    call$0: function() {
      var t1, t2;
      O.echo("You take the laser controls, quickly aim at the Messanger and fire. \n");
      if (S.Randomly_saveAgainst(0.6)) {
        t1 = this._captured_this_56.messengerShip.hull.hp;
        t2 = t1.min;
        t1.set$value(t2 + 0.5 * (t1.max - t2));
        O.echo("Boom! It's a hit! The stream of energy hits the Messenger, right in the middle of its belly, and leaves a sizeable hole there. It looks like some serious damage has been dealt.\n");
        $.get$_points().add$2(0, 7, "hitting early and hard");
      } else {
        O.echo("The stream of energy misses the Messenger by a couple of meters. That was unlucky.\n");
        $.get$_points().add$2(0, 5, "not wasting any time");
      }
    }
  },
  ScripterImpl_closure85: {
    "^": "Closure:1;_captured_this_57",
    call$0: function() {
      var t1 = this._captured_this_57;
      if (H.boolConversionCheck(t1.isEngineer))
        t1 = "the engine room";
      else
        t1 = H.boolConversionCheck(t1.isMedic) ? "the medbay" : "the cargo bay";
      O.echo("You try to remember something about spaceship combat, but there's not much you ever knew about the topic in the first place. You never had any ambition to go the the military, not even as a teenager, and you spent the last ten years of your life on cargo ships like the Bodega. Those normally don't get into combat, and if they do, it tends to be over quickly, and not in the cargo ship's favor. Plus, only those on the bridge get involved, whereas you practically live in " + t1 + ".");
    }
  },
  ScripterImpl_closure86: {
    "^": "Closure:1;_captured_this_58",
    call$0: function() {
      var t1 = this._captured_this_58.firstCombat;
      t1.bodega.set$targetShip(t1.messenger);
      t1.messenger.set$targetShip(t1.bodega);
    }
  },
  ScripterImpl_closure87: {
    "^": "Closure:1;",
    call$0: function() {
      return "Fight";
    }
  },
  ScripterImpl_closure88: {
    "^": "Closure:1;",
    call$0: function() {
      return "Win";
    }
  },
  ScripterImpl_closure89: {
    "^": "Closure:1;_captured_this_59",
    call$0: function() {
      this._captured_this_59.firstCombat.run$0();
    }
  },
  ScripterImpl_closure90: {
    "^": "Closure:1;_captured_this_60",
    call$0: function() {
      var t1 = this._captured_this_60.bodegaShip.hull.hp._numscale$_value;
      if (typeof t1 !== "number")
        return t1.$gt();
      if (t1 > 0)
        $.gotoPageName = "Win";
      else
        $.gotoPageName = "Lose";
    }
  },
  ScripterImpl_closure91: {
    "^": "Closure:1;_captured_this_61",
    call$0: function() {
      $.get$_points().add$2(0, 10, "winning your first spaceship battle");
      this._captured_this_61.zil.update$3$describe$interactive(1, false, false);
    }
  },
  ScripterImpl_closure92: {
    "^": "Closure:1;_captured_this_62",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_62;
      t2 = t1.firstCombat;
      if (!t2.spybotManagedToCrashIntoBodega)
        if (!t2.messengerManagedToLaunchSpyBot)
          O.echo("You suddenly realize that one of those pieces of debris is not like the others. It seems to quickly change directions. At first, those vector changes are negligible, but then the object comes around in a neat arch and plunges right into the Bodega's right side hull. Somewhere in the cargo bay.\n\n\"Hull breach,\" the Bodega says.\n");
        else
          O.echo("The Messenger's unidentified object goes straight for the Bodega's hull and crashes itself somewhere into the right side of the cargo bay. \n\n\"Hull breach,\" the Bodega says.\n");
      t1.b.lookAtHullBreachFromBridge.isActive = true;
    }
  },
  ScripterImpl_closure93: {
    "^": "Closure:1;_captured_this_63",
    call$0: function() {
      O.echo("You look at the readings around you. The hull is at " + C.JSNumber_methods.round$0(this._captured_this_63.bodegaShip.hull.hp.get$percentage() * 100) + "% structural integrity. The Bodega is holding together, but it did take _some_ damage.");
    }
  },
  ScripterImpl_closure94: {
    "^": "Closure:1;_captured_this_64",
    call$0: function() {
      O.echo("The Bodega is now running a full system check, all the monitors flicker with information so fast only a computer could make anything of it. \"What the _hell_ is happening?\" the ship says, her voice glitching. \"How does one go from a fully manned, well-preserved, licensed cargo ship to a _ghost_ ship piloted by an untrained " + H.S(this._captured_this_64.getInformalRole$1("")) + " _while_ being attacked by a corporate runner for no apparent reason whatsoever \u2013 all of that in just two weeks!?\" ");
    }
  },
  ScripterImpl_closure95: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"We survived, didn't we?\" ";
    }
  },
  ScripterImpl_closure96: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo("\"Well,\" she replies. \"That's rich coming from someone who is probably going to die in a couple of hours.\" You wish you had something to reply to that, but you don't.\n");
    }
  },
  ScripterImpl_closure97: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"When misery rains, it pours.\" ";
    }
  },
  ScripterImpl_closure98: {
    "^": "Closure:1;_captured_this_65",
    call$0: function() {
      this._captured_this_65.miseryPoursPhrase = true;
    }
  },
  ScripterImpl_closure99: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"Shut up.\" ";
    }
  },
  ScripterImpl_closure100: {
    "^": "Closure:1;_captured_this_66",
    call$0: function() {
      this._captured_this_66.firstShutUp = true;
    }
  },
  ScripterImpl_closure101: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo("\"Okay, this is all so totally outside the protocol,\" the Bodega continues. \"We'd be full speed somewhere long past al-Khw\u0101rizm\u012b" + E.fn("khwarizmi") + " if it wasn't for the idiot Gorilla in the cargo bay. Nobody would be dead. The disease would be someone else's problem. And there would be someone _actually capable_ on the bridge.\" ");
    }
  },
  ScripterImpl_closure102: {
    "^": "Closure:1;_captured_this_67",
    call$0: function() {
      O.echo("The flow of information on the monitors stop, and they all go to their default view. \"Umm, look, " + H.S(this._captured_this_67.b.getInformalSalutation$0()) + ", I have to say you managed the situation very well, given that you don't have any bridge experience whatsoever.\" ");
    }
  },
  ScripterImpl_closure103: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo("\"That doesn't change the fact that we are even more screwed than before,\" she continues. \"We attacked a Sentaco corporate ship, for crying out loud. You are dying anyway, but what about me? If I'm lucky, I get wiped. If not, I am about to spend the next few hundred years in the Graveyard." + E.fn("shipGraveyard") + " And I know what I'm talking about when I say that's _worse_ than dying.\" ");
    }
  },
  ScripterImpl_closure104: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"It attacked us first!\" ";
    }
  },
  ScripterImpl_closure105: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"Shut up.\" ";
    }
  },
  ScripterImpl_closure106: {
    "^": "Closure:1;_captured_this_68",
    call$0: function() {
      this._captured_this_68.secondShutUp = true;
    }
  },
  ScripterImpl_closure107: {
    "^": "Closure:1;_captured_this_69",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_69;
      if (H.boolConversionCheck(t1.secondShutUp)) {
        O.echo(" \"You know what? You shut up.");
        if (H.boolConversionCheck(t1.firstShutUp)) {
          O.echo(" Can you say anything else?\" ");
          t2 = t1.bodegaAttitude;
          if (typeof t2 !== "number")
            return t2.$sub();
          t1.bodegaAttitude = t2 - 1;
        } else
          O.echo("\" ");
      } else
        O.echo(" \"I know that. But I don't think anyone will care. It's Sentaco.\" ");
    }
  },
  ScripterImpl_closure108: {
    "^": "Closure:1;_captured_this_70",
    call$0: function() {
      O.echo("It looks like the Bodega stopped talking, at least for a while. You still have " + H.S(this._captured_this_70.getHoursToHyperdrive$0()) + " before the parameters for the jump to Station Unity are ready, and \u2013 although you're still tired \u2013 at least now you can stand on your feet.");
    }
  },
  ScripterImpl_closure109: {
    "^": "Closure:1;_captured_this_71",
    call$0: function() {
      if (J.get$isEmpty$as(this._captured_this_71.bodegaTopics)) {
        O.echo("There are no more questions to ask right now.\n");
        $.gotoPageName = "Explore: Bridge";
      }
    }
  },
  ScripterImpl_closure110: {
    "^": "Closure:1;_captured_this_72",
    call$0: function() {
      var bodegaQuestions = P.LinkedHashMap_LinkedHashMap$_literal(["Unity", "\"Tell me about Space Station Unity.\"", "UNSA", "\"What's UNSA?\"", "Explosion", "\"What do you know about the explosion?\""], null, null);
      J.forEach$1$a(this._captured_this_72.bodegaTopics, new N.ScripterImpl__closure9(bodegaQuestions));
      O.choice("Stop asking", false, false, null, new N.ScripterImpl__closure10(), null);
    }
  },
  ScripterImpl__closure9: {
    "^": "Closure:3;_captured_bodegaQuestions_73",
    call$1: function(pageName) {
      H.stringTypeCheck(pageName);
      O.choice(this._captured_bodegaQuestions_73.$index(0, pageName), false, false, pageName, null, null);
    }
  },
  ScripterImpl__closure10: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo("There's nothing else you deem worth asking right now.\n");
      $.gotoPageName = "Explore: Bridge";
    }
  },
  ScripterImpl_closure111: {
    "^": "Closure:1;_captured_this_74",
    call$0: function() {
      O.echo("The Bodega pulls off the kind of a synthetic-sounding sigh that she likes to do whenever something annoys her. Which is very often. She says: \"Look, I know you're just a " + H.S(this._captured_this_74.getInformalRole$1("")) + ", but this is _basic_ astronomy. Space Station Unity is one of the big five. It also happens to be the closest hub with a major medical facility.\" ");
    }
  },
  ScripterImpl_closure112: {
    "^": "Closure:1;_captured_this_75",
    call$0: function() {
      var t1 = this._captured_this_75;
      J.remove$1$a(t1.bodegaTopics, "Unity");
      J.insert$2$a(t1.bodegaTopics, 0, "UNSA");
      t1.zil.update$1(2);
    }
  },
  ScripterImpl_closure113: {
    "^": "Closure:1;_captured_this_76",
    call$0: function() {
      var t1 = this._captured_this_76;
      J.remove$1$a(t1.bodegaTopics, "UNSA");
      t1.zil.update$1(1);
    }
  },
  ScripterImpl_closure114: {
    "^": "Closure:1;_captured_this_77",
    call$0: function() {
      var t1 = this._captured_this_77.clock;
      O.echo("\"There's not much data about the explosion,\" the Bodega says. \"It happened deep on the left side of the cargo bay during the jump from Space Station Golitsyn, exactly " + H.S(J.$add$ns(H.assertSubtypeOfRuntimeType(t1._value, H.getTypeArgumentByIndex(t1, 0)), 20736)) + " minutes ago. The jump was immediatelly interrupted because of the shockwave.\" ");
    }
  },
  ScripterImpl_closure115: {
    "^": "Closure:1;",
    call$0: function() {
      return "Let the Bodega tell you all she had done [~5m]";
    }
  },
  ScripterImpl_closure116: {
    "^": "Closure:1;_captured_this_78",
    call$0: function() {
      O.echo("The Bodega goes on for about 5 minutes, describing the different analyses she did for the investigation. You wait patiently until she gets to the results.\n");
      this._captured_this_78.zil.update$4$describe$interactive$whileString(5, false, false, "she is talking");
    }
  },
  ScripterImpl_closure117: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"Great. Are you going to tell me what they found out?\" ";
    }
  },
  ScripterImpl_closure118: {
    "^": "Closure:1;_captured_this_79",
    call$0: function() {
      var t1, t2;
      O.echo("\"Good grief! You _are_ a pain in the ass. No wonder people avoided you.\"\n\n\"It's the other way around. I avoided people.\"\n\n\"Whatever you say.\"\n");
      t1 = this._captured_this_79;
      t2 = t1.bodegaAttitude;
      if (typeof t2 !== "number")
        return t2.$sub();
      t1.bodegaAttitude = t2 - 1;
    }
  },
  ScripterImpl_closure119: {
    "^": "Closure:1;_captured_this_80",
    call$0: function() {
      var t1 = this._captured_this_80;
      J.remove$1$a(t1.bodegaTopics, "Explosion");
      t1.zil.update$1(1);
    }
  },
  ScripterImpl_closure120: {
    "^": "Closure:1;_captured_this_81",
    call$0: function() {
      this._captured_this_81.zil.update$1(1);
    }
  },
  ScripterImpl_closure121: {
    "^": "Closure:1;_captured_this_82",
    call$0: function() {
      this._captured_this_82.zil.createChoices$0();
    }
  },
  ScripterImpl_closure122: {
    "^": "Closure:1;_captured_this_83",
    call$0: function() {
      var t1, t2;
      t1 = H.boolConversionCheck(this._captured_this_83.isSpaceman);
      t2 = "The bridge is connected with the rest of the ship via two main corridors: Corridor Left and Corridor Right (which " + (t1 ? "you were used to call" : "some of the more pretentious crewmembers called") + " 'Port Corridor' and 'Starboard Corridor', respectivelly, but ";
      O.echo(t2 + (t1 ? "most crewmembers on the Bodega didn't, so you gave up and started using 'Left' and 'Right', too" : "that fortunately never caught on") + "). Both corridors lead along their respective side of the ship all the way to the cargo area in the back. There is also a short and very narrow utility corridor leading from under the main window to the nose of the ship.");
    }
  },
  ScripterImpl_closure123: {
    "^": "Closure:1;_captured_this_84",
    call$0: function() {
      this._captured_this_84.zil.update$2$describe(1, false);
    }
  },
  ScripterImpl_closure124: {
    "^": "Closure:1;_captured_this_85",
    call$0: function() {
      this._captured_this_85.zil.update$1(1);
    }
  },
  ScripterImpl_closure125: {
    "^": "Closure:1;_captured_this_86",
    call$0: function() {
      this._captured_this_86.zil.createChoices$0();
    }
  },
  ScripterImpl_closure126: {
    "^": "Closure:1;_captured_this_87",
    call$0: function() {
      var t1 = this._captured_this_87;
      if (H.boolConversionCheck(t1.isEngineer))
        O.echo("As an engineer, you have some idea what could be wrong. You estimate the time needed to repair the scanner to about one hour.\n");
      else
        O.echo("You're not an expert, so it'll take you some time (maybe 1-2 hours), but you expect you'll be able to fix the scanner yourself.\n");
      t1.b.scannerRepair.isActive = true;
    }
  },
  ScripterImpl_closure127: {
    "^": "Closure:1;_captured_this_88",
    call$0: function() {
      var t1 = this._captured_this_88;
      if (H.boolConversionCheck(t1.isEngineer))
        O.echo("Even as you set out to repair the scanner, you can already guess the problem will have something to do with energy input. You remember the captain telling you something in that vein a few weeks ago \u2013 the feed from the scanner was up and down, intermittently.\n\nYour knowledge of power networks (you're a machinist after all) should allow you to find the culprit sooner or later. But maybe there's a shortcut that could save you some time.\n");
      else
        O.echo("After a little bit of poking around and looking at the feed from the scanner, you realize  the scanner itself probably works fine, but it doesn't get enough energy from the network. Or it does, but only intermittently.\n\nWhat probably follows is a lot of trial and error. But maybe there's a shortcut that could save you some time.\n");
      t1.b.createExtraEffortChoiceList$6("Try things one after another (slow but proven way)", new N.ScripterImpl__closure7(t1), "Think hard first", 0, 1, new N.ScripterImpl__closure8(t1));
    }
  },
  ScripterImpl__closure7: {
    "^": "Closure:1;_captured_this_89",
    call$0: function() {
      var t1 = this._captured_this_89;
      t1.zil.update$4$describe$interactive$whileString(C.JSDouble_methods.round$0(92 / t1.b.computeProductivity$1(t1.isEngineer)), false, false, "you are trying out one thing after another");
      O.echo("It takes time, but you find the culprit: it's the transformer. It's completely finished.\n");
    }
  },
  ScripterImpl__closure8: {
    "^": "Closure:1;_captured_this_90",
    call$0: function() {
      O.echo("You decide you could find the faulty component by the amount of ozone you can smell in different parts of the system. If there's an electrical arc somewhere (and, judging by the intermittent power, there is), it should be relatively easy to find it by smell.\n");
      var t1 = this._captured_this_90;
      t1.zil.update$4$describe$interactive$whileString(C.JSDouble_methods.round$0(32 / t1.b.computeProductivity$1(t1.isEngineer)), false, false, "you are carefully putting your nose to different parts of the system");
      O.echo("The approach bears fruit quickly. A faulty transformer is given away by the pungent smell of ozone.\n");
    }
  },
  ScripterImpl_closure128: {
    "^": "Closure:1;_captured_this_91",
    call$0: function() {
      this._captured_this_91.scannerRepaired = true;
      $.get$_points().add$2(0, 2, "expecting the worst");
    }
  },
  ScripterImpl_closure129: {
    "^": "Closure:1;_captured_this_92",
    call$0: function() {
      this._captured_this_92.b.printSleepiness$0();
    }
  },
  ScripterImpl_closure130: {
    "^": "Closure:1;_captured_this_93",
    call$0: function() {
      this._captured_this_93.zil.update$1(1);
    }
  },
  ScripterImpl_closure131: {
    "^": "Closure:1;_captured_this_94",
    call$0: function() {
      this._captured_this_94.zil.createChoices$0();
    }
  },
  ScripterImpl_closure132: {
    "^": "Closure:1;_captured_this_95",
    call$0: function() {
      this._captured_this_95.zil.update$1(1);
    }
  },
  ScripterImpl_closure133: {
    "^": "Closure:1;_captured_this_96",
    call$0: function() {
      this._captured_this_96.zil.createChoices$0();
    }
  },
  ScripterImpl_closure134: {
    "^": "Closure:1;_captured_this_97",
    call$0: function() {
      var t1 = this._captured_this_97;
      t1.zil.update$4$describe$interactive$whileString(C.JSDouble_methods.round$0(15 / t1.b.computeProductivity$1(t1.isHawkeyed)), false, false, "you are searching");
      t1.b.secondLookAround.isActive = true;
    }
  },
  ScripterImpl_closure135: {
    "^": "Closure:1;_captured_this_98",
    call$0: function() {
      var t1 = this._captured_this_98;
      t1.zil.update$4$describe$interactive$whileString(C.JSDouble_methods.round$0(15 / t1.b.computeProductivity$1(t1.isHawkeyed)), false, false, "you are searching");
    }
  },
  ScripterImpl_closure136: {
    "^": "Closure:1;_captured_this_99",
    call$0: function() {
      var t1 = this._captured_this_99.b;
      t1.captainsGun.isActive = true;
      t1.thirdLookAround.isActive = true;
    }
  },
  ScripterImpl_closure137: {
    "^": "Closure:1;_captured_this_100",
    call$0: function() {
      var t1 = this._captured_this_100;
      t1.zil.update$4$describe$interactive$whileString(C.JSDouble_methods.round$0(3 / t1.b.computeProductivity$1(t1.isHawkeyed)), false, false, "you are searching");
    }
  },
  ScripterImpl_closure138: {
    "^": "Closure:1;_captured_this_101",
    call$0: function() {
      this._captured_this_101.zil.update$2$describe(1, false);
    }
  },
  ScripterImpl_closure139: {
    "^": "Closure:1;_captured_this_102",
    call$0: function() {
      this._captured_this_102.zil.update$1(1);
    }
  },
  ScripterImpl_closure140: {
    "^": "Closure:1;_captured_this_103",
    call$0: function() {
      this._captured_this_103.zil.createChoices$0();
    }
  },
  ScripterImpl_closure141: {
    "^": "Closure:1;_captured_this_104",
    call$0: function() {
      O.echo("There is a door on each side of the corridor here. The bulkier one is the Airlock Left. It's identical to the airlock " + (H.boolConversionCheck(this._captured_this_104.pulledLever) ? "from where you let the captain's body out" : "where you left the captain's body") + ", except this one is facing the other way, out the left side of the ship.");
    }
  },
  ScripterImpl_closure142: {
    "^": "Closure:1;_captured_this_105",
    call$0: function() {
      this._captured_this_105.b.infoFlyer.isActive = true;
    }
  },
  ScripterImpl_closure143: {
    "^": "Closure:1;_captured_this_106",
    call$0: function() {
      this._captured_this_106.zil.update$1(1);
    }
  },
  ScripterImpl_closure144: {
    "^": "Closure:1;_captured_this_107",
    call$0: function() {
      this._captured_this_107.zil.createChoices$0();
    }
  },
  ScripterImpl_closure145: {
    "^": "Closure:1;_captured_this_108",
    call$0: function() {
      this._captured_this_108.b.banana.isActive = true;
    }
  },
  ScripterImpl_closure146: {
    "^": "Closure:1;_captured_this_109",
    call$0: function() {
      this._captured_this_109.zil.update$1(1);
    }
  },
  ScripterImpl_closure147: {
    "^": "Closure:1;_captured_this_110",
    call$0: function() {
      this._captured_this_110.zil.createChoices$0();
    }
  },
  ScripterImpl_closure148: {
    "^": "Closure:1;_captured_this_111",
    call$0: function() {
      this._captured_this_111.zil.update$1(1);
    }
  },
  ScripterImpl_closure149: {
    "^": "Closure:1;_captured_this_112",
    call$0: function() {
      this._captured_this_112.zil.createChoices$0();
    }
  },
  ScripterImpl_closure150: {
    "^": "Closure:1;_captured_this_113",
    call$0: function() {
      O.echo("In the last few days \u2013 after it was clear it's too late for quarantine \u2013 at least three or four crewmembers died here on their beds. " + (H.boolConversionCheck(this._captured_this_113.isMedic) ? "As the assistant medic, you personally moved each one from here to the airlock." : "You remember helping the medic move one of them from here to the airlock."));
    }
  },
  ScripterImpl_closure151: {
    "^": "Closure:1;_captured_this_114",
    call$0: function() {
      O.echo("It's Mwenye's locker. He was an ablebodied spaceman" + (H.boolConversionCheck(this._captured_this_114.isSpaceman) ? " like you" : "") + " and spent most of his time in the cargo bay. There was always a lot of work in the cargo bay.");
    }
  },
  ScripterImpl_closure152: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo("The whole inside of Mwenye's locker's door is covered with the African League flag. He was born on Ejeta, an African League space station, and was an avid citizen until his death. This shows even from his abandoned locker \u2013 there are African League pins, an ornamental League calendar with important dates and holidays, some clothes in national colors, and on the top shelf, his passport is propped against the locker's back wall, on display. You sift through the rest of late Mwenye's belongings, and there is nothing of immediate value. You find Mwenye's credits ring," + E.fn("creditsRing") + " but there's no way of getting the money out of it without contacting the issuing bank about his death. So you just make a mental note of its existence and move on.");
    }
  },
  ScripterImpl_closure153: {
    "^": "Closure:1;_captured_this_115",
    call$0: function() {
      var t1 = this._captured_this_115;
      t1.zil.update$3$describe$whileString(C.JSDouble_methods.round$0(15 / t1.b.computeProductivity$1(false)), false, "you are searching for another locker to open");
    }
  },
  ScripterImpl_closure154: {
    "^": "Closure:1;_captured_this_116",
    call$0: function() {
      var t1 = this._captured_this_116;
      t1.zil.update$4$describe$interactive$whileString(C.JSDouble_methods.round$0(15 / t1.b.computeProductivity$1(false)), false, false, "you are checking the few remaining lockers");
    }
  },
  ScripterImpl_closure155: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo("On the bottom-most shelf, you find 2 vials of white crystal powder, hidden under a piece of textile. The bullet-like shape of the vials is unmistakable \u2013 this is shabu." + E.fn("shabu") + " Mitsuyo is _the_ last person on the ship that anyone would suspect of using drugs. But, looking back, this might  explain the merciless pace of work that she was known for, and the occasional episodes of being completely withdrawn. You always thought she's just recharging by being alone \u2013 which you could completely understand \u2013 but it turns out it most probably was withdrawal symptom. This also explains why you have never seen Mitsuyo drunk, although her personal locker is full of empty bottles.");
    }
  },
  ScripterImpl_closure156: {
    "^": "Closure:1;_captured_this_117",
    call$0: function() {
      var t1 = this._captured_this_117;
      t1.b.shabuVials.isActive = true;
      $.get$_points().add$2(0, 5, "getting to know your assets");
      t1.siftedThroughLockers = true;
    }
  },
  ScripterImpl_closure157: {
    "^": "Closure:1;_captured_this_118",
    call$0: function() {
      this._captured_this_118.zil.update$1(1);
    }
  },
  ScripterImpl_closure158: {
    "^": "Closure:1;_captured_this_119",
    call$0: function() {
      this._captured_this_119.zil.createChoices$0();
    }
  },
  ScripterImpl_closure159: {
    "^": "Closure:1;_captured_this_120",
    call$0: function() {
      var t1 = this._captured_this_120;
      if (!H.boolConversionCheck(t1.junctionExplained)) {
        O.echo("The corridor curves here, and at the point of the bend there are two doors. The smaller one leads to the 'guts' of the ship \u2013 a noisy maze of passageways and ducts winding between many of the ship's smaller internal systems. The bigger one leads to the engine room, and, through that, also the hyperdrive.\n\nThis is the final stretch of Corridor Left \u2013 you can almost see the door to the cargo bay from here.\n\nBecause of the two doors to important parts of the ship, and the proximity to the cargo bay, this place has been called 'left junction' by the crew.\n");
        t1.junctionExplained = true;
      } else
        O.echo("The corridor curves here in much the same way as it does on the opposite side of the ship. There are two doors here \u2013 the smaller one leads to the 'guts' of the ship, the bigger one leads to the engine room.\n");
    }
  },
  ScripterImpl_closure160: {
    "^": "Closure:1;_captured_this_121",
    call$0: function() {
      this._captured_this_121.zil.update$1(1);
    }
  },
  ScripterImpl_closure161: {
    "^": "Closure:1;_captured_this_122",
    call$0: function() {
      this._captured_this_122.zil.createChoices$0();
    }
  },
  ScripterImpl_closure162: {
    "^": "Closure:1;_captured_this_123",
    call$0: function() {
      var t1 = this._captured_this_123;
      t1.zil.update$3$describe$interactive(1, false, false);
      t1.b.repairTurret.isActive = true;
    }
  },
  ScripterImpl_closure163: {
    "^": "Closure:1;_captured_this_124",
    call$0: function() {
      O.echo("You cautiously open the turret's panel: the inside is a mess. A pair of loose, sparkling cables has burned through a few others and they now seem to be short-circuiting into " + (H.boolConversionCheck(this._captured_this_124.isEngineer) ? "the control unit" : "one of the components") + ". This will be fun.");
    }
  },
  ScripterImpl_closure164: {
    "^": "Closure:1;_captured_this_125",
    call$0: function() {
      O.echo("You " + (H.boolConversionCheck(this._captured_this_125.isEngineer) ? "" : "manage to ") + "kill the power and start going methodically through the inside of the turret's base, system by system, component by component. The turret was unlucky \u2013 almost everything has been dealt _some_ damage. Fortunately, though, the weapon was made with maintainability in mind: the components are either easy to repair or standard enough that you are able to find spare ones on the ship.");
    }
  },
  ScripterImpl_closure165: {
    "^": "Closure:1;_captured_this_126",
    call$0: function() {
      var t1 = this._captured_this_126;
      t1.b.createExtraEffortChoiceList$6("Work in a normal pace and walk for spare parts", new N.ScripterImpl__closure5(t1), "Work hard and run for spare parts", 1, 0, new N.ScripterImpl__closure6(t1));
    }
  },
  ScripterImpl__closure5: {
    "^": "Closure:1;_captured_this_127",
    call$0: function() {
      var t1 = this._captured_this_127;
      t1.zil.update$4$describe$interactive$whileString(C.JSDouble_methods.round$0(47 / t1.b.computeProductivity$1(t1.isEngineer)), false, false, "you are repairing");
    }
  },
  ScripterImpl__closure6: {
    "^": "Closure:1;_captured_this_128",
    call$0: function() {
      var t1 = this._captured_this_128;
      t1.zil.update$4$describe$interactive$whileString(C.JSDouble_methods.round$0(27 / t1.b.computeProductivity$1(t1.isEngineer)), false, false, "you are frantically repairing");
    }
  },
  ScripterImpl_closure166: {
    "^": "Closure:1;_captured_this_129",
    call$0: function() {
      this._captured_this_129.bodegaShip.turret.isActive = false;
    }
  },
  ScripterImpl_closure167: {
    "^": "Closure:1;_captured_this_130",
    call$0: function() {
      this._captured_this_130.zil.update$1(1);
    }
  },
  ScripterImpl_closure168: {
    "^": "Closure:1;_captured_this_131",
    call$0: function() {
      this._captured_this_131.zil.createChoices$0();
    }
  },
  ScripterImpl_closure169: {
    "^": "Closure:1;_captured_this_132",
    call$0: function() {
      var t1, t2;
      t1 = H.boolConversionCheck(this._captured_this_132.isEngineer);
      t2 = "No matter how filthy the rest of the ship could get, this room was always perfectly clean. That's because officer Par Nabiyeva, the Senior Engineer" + (t1 ? " and your boss" : "") + ", insisted on it. She would force ";
      O.echo(t2 + (t1 ? "you" : "her assistant") + " and Gorilla to brush the whole room, _including the ceiling_, almost every single day.");
    }
  },
  ScripterImpl_closure170: {
    "^": "Closure:1;_captured_this_133",
    call$0: function() {
      O.echo("Even apart from the cleanliness, the engine room is a remarkable sight. Clusters of glistening, color-coded cables and pipes are running everywhere. There are four sturdy, functional terminals in different parts of the room. And at the head of the room, there is a huge window through which you can see both the generators and the hyperdrive in one spacious machine room. It's where you spent the last few days " + (H.boolConversionCheck(this._captured_this_133.isEngineer) ? "finalizing repairs to the hyperdrive with Captain Kay" : "helping Captain Kay finalize repairs to the hyperdrive") + ".");
    }
  },
  ScripterImpl_closure171: {
    "^": "Closure:1;_captured_this_134",
    call$0: function() {
      var t1, t2, t3;
      t1 = this._captured_this_134;
      t2 = "The generators take up the left part of the machine room. They are where the power cells (or, 'the fuel' as " + (H.boolConversionCheck(t1.isEngineer) ? "you engineers call it" : "the engineers call it") + ") are consumed. It's a long line of 8 half-spheres, each of them as tall as a man. The power cells are inserted into them from above by enormous robotic arms, and when their capacity has been depleted, and their energy transfered to different parts of the ship, the robotic arms remove them again and put them into a receptacle at the center of the machine room. There are " + H.S(t1.powerCellsTotal) + " power cells available, and it looks like ";
      t3 = t1.energyReserve;
      if (J.$eq(H.assertSubtypeOfRuntimeType(t3._value, H.getTypeArgumentByIndex(t3, 0)), t1.powerCellsTotal))
        t1 = "all";
      else {
        t1 = t1.energyReserve;
        t1 = H.assertSubtypeOfRuntimeType(t1._value, H.getTypeArgumentByIndex(t1, 0));
      }
      O.echo(t2 + H.S(t1) + " of them are currently charged.");
    }
  },
  ScripterImpl_closure172: {
    "^": "Closure:1;_captured_this_135",
    call$0: function() {
      this._captured_this_135.energyReserve.set$show(true);
    }
  },
  ScripterImpl_closure173: {
    "^": "Closure:1;_captured_this_136",
    call$0: function() {
      if (H.boolConversionCheck(this._captured_this_136.isEngineer))
        ;
    }
  },
  ScripterImpl_closure174: {
    "^": "Closure:1;_captured_this_137",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_137;
      t2 = t1.zil.get$timeline().time;
      if (typeof t2 !== "number")
        return t2.$tdiv();
      if (C.JSInt_methods._tdivFast$1(t2, 60) > 3) {
        t1 = t1.zil.get$timeline().time;
        if (typeof t1 !== "number")
          return t1.$le();
        t1 = t1 <= 96;
      } else
        t1 = false;
      if (t1) {
        O.echo("You start going through the usual output optimization routines, but you can't focus on any of it. After trying for a couple of minutes, you realize you could do more damage than good, and return back to the bridge.\n");
        $.gotoPageName = "Bridge: Nap";
      }
    }
  },
  ScripterImpl_closure175: {
    "^": "Closure:1;_captured_this_138",
    call$0: function() {
      var t1 = this._captured_this_138;
      t1.zil.update$4$describe$interactive$whileString(C.JSDouble_methods.round$0(180 / t1.b.computeProductivity$1(true)), false, false, "you are checking the third core");
    }
  },
  ScripterImpl_closure176: {
    "^": "Closure:1;_captured_this_139",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_139;
      t2 = t1.bodegaShip.engine.hp;
      t2.set$value(t2.max);
      $.get$_points().add$2(0, 2, "doing what you know best");
      t2 = t1.zil.get$timeline().time;
      if (typeof t2 !== "number")
        return t2.$le();
      if (t2 <= 96)
        t1.printSleepiness$0();
    }
  },
  ScripterImpl_closure177: {
    "^": "Closure:1;_captured_this_140",
    call$0: function() {
      this._captured_this_140.zil.update$1(1);
    }
  },
  ScripterImpl_closure178: {
    "^": "Closure:1;_captured_this_141",
    call$0: function() {
      this._captured_this_141.zil.createChoices$0();
    }
  },
  ScripterImpl_closure179: {
    "^": "Closure:1;_captured_this_142",
    call$0: function() {
      this._captured_this_142.zil.update$1(1);
    }
  },
  ScripterImpl_closure180: {
    "^": "Closure:1;_captured_this_143",
    call$0: function() {
      this._captured_this_143.zil.createChoices$0();
    }
  },
  ScripterImpl_closure181: {
    "^": "Closure:1;_captured_this_144",
    call$0: function() {
      this._captured_this_144.zil.update$1(1);
    }
  },
  ScripterImpl_closure182: {
    "^": "Closure:1;_captured_this_145",
    call$0: function() {
      this._captured_this_145.zil.createChoices$0();
    }
  },
  ScripterImpl_closure183: {
    "^": "Closure:1;_captured_this_146",
    call$0: function() {
      O.echo("You are at Airlock Right, which has been serving as the place of funerals lately. " + (H.boolConversionCheck(this._captured_this_146.pulledLever) ? "Not long ago, you ejected captain's body from here to outers space." : "This is where you left the captain's body."));
    }
  },
  ScripterImpl_closure184: {
    "^": "Closure:1;_captured_this_147",
    call$0: function() {
      var t1 = this._captured_this_147;
      if (H.boolConversionCheck(t1.pulledLever))
        if (H.boolConversionCheck(t1.currentlyInJump))
          O.echo("The weird visual effect of the hyperjump makes it look like it's blindingly bright outside, but you know these are photons from stars light years ahead. The space around the ship is completely empty, looking almost sinister. As if it's waiting for you to fill it.\n");
        else
          O.echo("The space around the ship is completely empty, looking almost sinister. As if it's waiting for you to fill it.\n");
      else {
        O.echo("The captain's body is still lying there on a blanket. It looks like the weird red rash is continuing to spread across the naked skin.\n");
        t1.b.pullLever.isActive = true;
      }
    }
  },
  ScripterImpl_closure185: {
    "^": "Closure:1;",
    call$0: function() {
      if (S.Randomly_saveAgainst(0.5))
        O.echo("It hits the doorsill on its way out, goes through the door, and starts receding into space while slowly rotating.\n");
      else
        O.echo("It hits the doorsill on its way out and almost stops, hanging midway between the inside and outside. For a while, it almost looks like you'll have to close that outside door and reopen it again, which would cut the captain's body in half. But fortunately, the movement never stops completely, and the body goes through the door and starts slowly receding into space.\n");
    }
  },
  ScripterImpl_closure186: {
    "^": "Closure:1;_captured_this_148",
    call$0: function() {
      this._captured_this_148.pulledLever = true;
    }
  },
  ScripterImpl_closure187: {
    "^": "Closure:1;_captured_this_149",
    call$0: function() {
      this._captured_this_149.zil.update$1(1);
    }
  },
  ScripterImpl_closure188: {
    "^": "Closure:1;_captured_this_150",
    call$0: function() {
      this._captured_this_150.zil.createChoices$0();
    }
  },
  ScripterImpl_closure189: {
    "^": "Closure:1;_captured_this_151",
    call$0: function() {
      var t1, t2;
      t1 = H.boolConversionCheck(this._captured_this_151.isMedic);
      t2 = (t1 ? "This is the place where you had been spending most of your waking hours on this ship. " : "") + "The room is white and green. There are mobile beds in the middle with an infusion stand next to each of them. A third bed is behind glass in a small quarantine cell in the corner. That is where the first few crewmembers died, including ";
      O.echo(t2 + (t1 ? "your boss, " : "") + "the Senior Medic. After that it was clear the the quarantine doesn't do any good, and that everyone is already sick anyway.");
    }
  },
  ScripterImpl_closure190: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo("You remember a visitor \u2013 some kind of a rich planetborn" + E.fn("planetborn") + " who was apparently interested in buying the Bodega from captain Kay \u2013 wondering about the size of the med bay. \"Seems so me that a medical establishment of this size,\" he said, \"is a little bit of a, hmm, overkill? For a ship with a crew of a dozen, I mean.\" His name was Trukhin. Roman Trukhin. He was a Russian with large eyebrows and very traditional clothing. His blue tie was a subject of jokes for weeks to come.");
    }
  },
  ScripterImpl_closure191: {
    "^": "Closure:1;_captured_this_152",
    call$0: function() {
      O.echo("\"What Mr. Trukhin might not realize,\" " + (H.boolConversionCheck(this._captured_this_152.isMedic) ? "your boss" : "the Senior Medic") + " answered with as much politeness as he could muster, \"is that space is a dangerous place, and that humans aren't particularly well-adapted to live in it. Especially not for long periods of time. There are many illnesses that space dwellers suffer that people on planets don't.\" And he wasn't talking only about physical illnesses, neither. A ship's medic needs to be also trained in psychology. \"The medbay is exactly as big as most nations' regulations require it to be,\" he added.");
    }
  },
  ScripterImpl_closure192: {
    "^": "Closure:1;_captured_this_153",
    call$0: function() {
      this._captured_this_153.zil.update$1(1);
    }
  },
  ScripterImpl_closure193: {
    "^": "Closure:1;_captured_this_154",
    call$0: function() {
      this._captured_this_154.zil.createChoices$0();
    }
  },
  ScripterImpl_closure194: {
    "^": "Closure:1;_captured_this_155",
    call$0: function() {
      this._captured_this_155.zil.update$1(1);
    }
  },
  ScripterImpl_closure195: {
    "^": "Closure:1;_captured_this_156",
    call$0: function() {
      this._captured_this_156.zil.createChoices$0();
    }
  },
  ScripterImpl_closure196: {
    "^": "Closure:1;_captured_this_157",
    call$0: function() {
      var t1 = this._captured_this_157;
      if (!H.boolConversionCheck(t1.junctionExplained)) {
        O.echo("The corridor curves here, and at the point of the bend there are two doors. The smaller one leads to the 'guts' of the ship \u2013 a noisy maze of passageways and ducts winding between many of the ship's smaller internal systems. The bigger one leads to the engine room, and, through that, also the hyperdrive.\n\nThis is the final stretch of Corridor Right \u2013 you can almost see the door to the cargo bay from here.\n\nBecause of the two doors to important parts of the ship, and the proximity to the cargo bay, this place has been called 'right junction' by the crew.\n");
        t1.junctionExplained = true;
      } else
        O.echo("The corridor curves here in much the same way as it does on the opposite side of the ship. There are two doors here \u2013 the smaller one leads to the 'guts' of the ship, the bigger one leads to the engine room.\n");
    }
  },
  ScripterImpl_closure197: {
    "^": "Closure:1;_captured_this_158",
    call$0: function() {
      this._captured_this_158.zil.update$1(1);
    }
  },
  ScripterImpl_closure198: {
    "^": "Closure:1;_captured_this_159",
    call$0: function() {
      this._captured_this_159.zil.createChoices$0();
    }
  },
  ScripterImpl_closure199: {
    "^": "Closure:1;_captured_this_160",
    call$0: function() {
      var t1 = this._captured_this_160;
      if (!H.boolConversionCheck(t1.cargoBayExplained)) {
        O.echo("You are standing in a corner of a huge, _huge_ space filled with hundreds of freight containers. Each of them is exactly the same size (6 meters long, 2\u00bd meters high and 2\u00bd meters wide), but they do differ greatly in color, signage, age \u2013 and contents. They are stacked inside long parallel racks that go all the way to the backside of the cargo bay, and all the way down to the bottom of the space.\n\nThere are long, narrow corridors between the racks \u2013 so that the crew can access each container to help with unloading, check on a container's status, contain leaks. The corridors' floors are nothing more than sheets of perforated steel fixed in between the racks. They are sturdy, replacable, and see-through. \n\n[IMG of cargo bay]\n\nTwo things hit you every time you enter the cargo bay. First, the cold and damp air. The cargo bay is heated _just_ enough so that people can work here for hours \u2013 but not even a degree more. Second, and more profoundly, the artificial gravity here is set to a very low value: only 20% of the standard. The moment you pass the threshold of the cargo bay door, you feel your stomach jump and you have to fight a brief sensation of falling. It's like the whole ship went into an instant dive. Luckily, your brain has learnt to deal with this and in a few seconds, you feel okay. The next step is to start walking and moving in a way that doesn't launch you to the ceiling, but again - you've had enough experience that it comes naturally now.\n\nYou remember a brief stint a few years back at a cargo ship called the Bleeding Edge. Her captain insisted on having _no_ artificial gravity in the cargo bay at all. So the ship saved a little more energy, but the work in the cargo bay was hell. Nothing stayed in place, and every simple thing required much more planning and energy. The spacemen that served on the Bleeding Edge's cargo bay for more than a few years were going mad and sickly. They couldn't even stand straight in normal gravity, and their bones broke too easily. It was evil \u2013 not to mention against regulations. Luckily, you left the Bleeding Edge a few months after joining.\n\nHaving that experience makes the 20% gravity here feel almost like a luxury, especially since anyone working in the cargo bay could directly change the gravity setting himself \u2013 on the console right here in the bay. On the other hand, almost nobody ever took advantage of that. They knew how expensive \u2013 energy wise \u2013 it can get, and they were mostly used to the idea of low gravity by the time they joined the Bodega.\n");
        t1.cargoBayExplained = true;
      } else
        O.echo("You are on the left side of the cargo bay, near the door to Corridor Left.\n");
    }
  },
  ScripterImpl_closure200: {
    "^": "Closure:1;_captured_this_161",
    call$0: function() {
      this._captured_this_161.zil.update$1(1);
    }
  },
  ScripterImpl_closure201: {
    "^": "Closure:1;_captured_this_162",
    call$0: function() {
      this._captured_this_162.zil.createChoices$0();
    }
  },
  ScripterImpl_closure202: {
    "^": "Closure:1;_captured_this_163",
    call$0: function() {
      this._captured_this_163.zil.update$4$describe$interactive$whileString(30, false, false, "you are searching");
    }
  },
  ScripterImpl_closure203: {
    "^": "Closure:1;_captured_this_164",
    call$0: function() {
      this._captured_this_164.zil.update$1(1);
    }
  },
  ScripterImpl_closure204: {
    "^": "Closure:1;_captured_this_165",
    call$0: function() {
      this._captured_this_165.zil.createChoices$0();
    }
  },
  ScripterImpl_closure205: {
    "^": "Closure:1;_captured_this_166",
    call$0: function() {
      O.echo("It's a sturdy computer interface with huge buttons and a reinforced screen. It's designed to be used by big hulks" + (H.boolConversionCheck(this._captured_this_166.isSpaceman) ? " like you" : "") + " with clumsy, gloved fingers, or even by enhanced gorillas.");
    }
  },
  ScripterImpl_closure206: {
    "^": "Closure:1;_captured_this_167",
    call$0: function() {
      var t1 = this._captured_this_167.currentPage.visitCount;
      if (typeof t1 !== "number")
        return t1.$gt();
      if (t1 <= 0)
        O.echo("Although theoretically, the console allows the user to access any function of the Bodega's internal network, its main focus is on the operation of the cargo bay. There are big buttons for changing the artificial gravity of the whole space. There's a master-lock that fixes all the containers in the racks once they're in place. And there's a guarded switch that opens the cargo bay's outside doors which is only supposed to be used when everyone is either outside the bay or in a space suit.\n");
    }
  },
  ScripterImpl_closure207: {
    "^": "Closure:1;_captured_this_168",
    call$0: function() {
      O.echo("The gravity is currently at " + H.S(this._captured_this_168.cargoBayGravity) + "%.");
    }
  },
  ScripterImpl_closure208: {
    "^": "Closure:1;_captured_this_169",
    call$0: function() {
      var t1 = this._captured_this_169;
      if (t1.cargoBayGravity !== 0)
        O.choice("Switch off artificial gravity", false, false, null, new N.ScripterImpl__closure1(t1), null);
      if (t1.cargoBayGravity !== 20)
        O.choice("Set artificial gravity to the ordinary (20%)", false, false, null, new N.ScripterImpl__closure2(t1), null);
      if (t1.cargoBayGravity !== 60)
        O.choice("Set artificial gravity to the max (60%)", false, false, null, new N.ScripterImpl__closure3(t1), null);
      O.choice("Leave it be.", false, false, null, new N.ScripterImpl__closure4(), null);
    }
  },
  ScripterImpl__closure1: {
    "^": "Closure:1;_captured_this_170",
    call$0: function() {
      var t1 = this._captured_this_170;
      t1.cargoBayGravity = 0;
      t1.zil.update$1(1);
    }
  },
  ScripterImpl__closure2: {
    "^": "Closure:1;_captured_this_171",
    call$0: function() {
      var t1 = this._captured_this_171;
      t1.cargoBayGravity = 20;
      t1.zil.update$1(1);
    }
  },
  ScripterImpl__closure3: {
    "^": "Closure:1;_captured_this_172",
    call$0: function() {
      var t1 = this._captured_this_172;
      t1.cargoBayGravity = 60;
      t1.zil.update$1(1);
    }
  },
  ScripterImpl__closure4: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo("You back away from the console.\n");
    }
  },
  ScripterImpl_closure209: {
    "^": "Closure:1;_captured_this_173",
    call$0: function() {
      this._captured_this_173.zil.update$1(1);
    }
  },
  ScripterImpl_closure210: {
    "^": "Closure:1;_captured_this_174",
    call$0: function() {
      this._captured_this_174.zil.createChoices$0();
    }
  },
  ScripterImpl_closure211: {
    "^": "Closure:1;_captured_this_175",
    call$0: function() {
      var t1 = this._captured_this_175;
      if (!H.boolConversionCheck(t1.cargoBayExplained)) {
        O.echo("You are standing in a corner of a huge, _huge_ space filled with hundreds of freight containers. Each of them is exactly the same size (6 meters long, 2\u00bd meters high and 2\u00bd meters wide), but they do differ greatly in color, signage, age \u2013 and contents. They are stacked inside long parallel racks that go all the way to the backside of the cargo bay, and all the way down to the bottom of the space.\n\nThere are long, narrow corridors between the racks \u2013 so that the crew can access each container to help with unloading, check on a container's status, contain leaks. The corridors' floors are nothing more than sheets of perforated steel fixed in between the racks. They are sturdy, replacable, and see-through. \n\n[IMG of cargo bay]\n\nTwo things hit you every time you enter the cargo bay. First, the cold and damp air. The cargo bay is heated _just_ enough so that people can work here for hours. Second, and more profoundly, the artificial gravity here is set to a very low value: only 20% of the standard. The moment you pass the threshold of the cargo bay door, you feel your stomach jump and you have to fight a brief sensation of falling. It's like the whole ship went into an instant dive. Luckily, your brain has learnt to deal with this and in a few seconds, you feel okay. The next step is to start walking and moving in a way that doesn't launch you to the ceiling, but again - you've had enough experience that it comes naturally now.\n\nYou remember a brief stint a few years back at a cargo ship called the Bleeding Edge. Her captain insisted on having _no_ artificial gravity in the cargo bay at all. So the ship saved a little more energy, but the work in the cargo bay was hell. Nothing stayed in place, and every simple thing required much more planning and energy. The spacemen that served on the Bleeding Edge's cargo bay for more than a few years were going mad and sickly. They couldn't even stand straight in normal gravity, and their bones broke too easily. It was evil \u2013 not to mention against regulations. You left the Bleeding Edge a few months after joining.\n\nHaving that experience makes the 20% gravity here feel almost like a luxury, especially since anyone working in the cargo bay could directly change the gravity setting himself \u2013 on the console right here in the bay. On the other hand, almost nobody ever took advantage of that. They knew how expensive \u2013 energy wise \u2013 it can get, and they were mostly used to the idea of low gravity by the time they joined the Bodega.\n");
        t1.cargoBayExplained = true;
      } else
        O.echo("You are on the right side of the cargo bay, near the door to Corridor Right.\n");
    }
  },
  ScripterImpl_closure212: {
    "^": "Closure:1;_captured_this_176",
    call$0: function() {
      this._captured_this_176.zil.update$1(1);
    }
  },
  ScripterImpl_closure213: {
    "^": "Closure:1;_captured_this_177",
    call$0: function() {
      this._captured_this_177.zil.createChoices$0();
    }
  },
  ScripterImpl_closure214: {
    "^": "Closure:1;_captured_this_178",
    call$0: function() {
      this._captured_this_178.zil.update$1(1);
    }
  },
  ScripterImpl_closure215: {
    "^": "Closure:1;_captured_this_179",
    call$0: function() {
      this._captured_this_179.zil.createChoices$0();
    }
  },
  ScripterImpl_closure216: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"Initiate jump sequence.\" ";
    }
  },
  ScripterImpl_closure217: {
    "^": "Closure:1;_captured_this_180",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_180;
      t2 = t1.conceitedness;
      if (typeof t2 !== "number")
        return t2.$add();
      t1.conceitedness = t2 + 1;
    }
  },
  ScripterImpl_closure218: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"Do it.\" ";
    }
  },
  ScripterImpl_closure219: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo("\"I assume we want to supercharge" + E.fn("superchargeHyperdrive") + " the jump,\" the Bodega continues. \"We do have the excess energy cells to spare, and we _are_ in a hurry, aren't we?\" ");
    }
  },
  ScripterImpl_closure220: {
    "^": "Closure:1;_captured_this_181",
    call$0: function() {
      O.echo("The alert signal goes off throughout the ship.\n");
      var t1 = this._captured_this_181;
      if (t1.gorilla.isIn$1(t1.b.bridge))
        O.echo("Gorilla quickly runs up to a pair of straps on the wall behind you. You hear a metallic click and a whoosh as he fastens it.\n");
      else
        O.echo("Somewhere on the ship, Gorilla is (hopefully) buckling into a set of wall-mounted straps.\n");
    }
  },
  ScripterImpl_closure221: {
    "^": "Closure:1;_captured_this_182",
    call$0: function() {
      var t1 = this._captured_this_182;
      t1.jumpedToUnity = true;
      t1.currentlyInJump = true;
    }
  },
  ScripterImpl_closure222: {
    "^": "Closure:1;_captured_this_183",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_183;
      t2 = t1.zil.get$timeline().time;
      if (typeof t2 !== "number")
        return t2.$add();
      t1.exploration.reschedule$2(t1.b.unityArrivalEvent, t2 + 60);
    }
  },
  ScripterImpl_closure223: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo("It's a hollow disc around a huge spherical aquarium. The aquarium is the food source," + E.fn("unityAquarium") + " while the disc is where the population lives and (more importantly for you) where the docks are.");
    }
  },
  ScripterImpl_closure224: {
    "^": "Closure:1;_captured_this_184",
    call$0: function() {
      O.echo("The Bodega displays the crew roster for the operator to see. There are thirteen body outlines on the monitor. Some of them you immediately recognize as anatomy of one of the crew. All of them are red, except for the outline labeled as '" + H.S(this._captured_this_184.name) + " (CONTAMINATED)', which is orange. \"We have reasons to believe it's a contagion.\" ");
    }
  },
  ScripterImpl_closure225: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"Can you clarify?\" ";
    }
  },
  ScripterImpl_closure226: {
    "^": "Closure:1;_captured_this_185",
    call$0: function() {
      var t1, t2;
      O.echo("\"That is exactly what I cannot do, I'm afraid,\" he says. \"According to this.\" He points outside the camera's view, presumably at one of his monitors.\n");
      t1 = this._captured_this_185;
      t2 = t1.unityOperatorAttitude;
      if (typeof t2 !== "number")
        return t2.$add();
      t1.unityOperatorAttitude = t2 + 1;
    }
  },
  ScripterImpl_closure227: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"What do you mean 'I cannot let you dock'?\" ";
    }
  },
  ScripterImpl_closure228: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo("\"I, umm, totally understand your frustration,\" he says. \"But I have my orders.\" He glances to his side again, then returns his empathetic gaze back at you.\n");
    }
  },
  ScripterImpl_closure229: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"Yes you can, and you _will_.\" ";
    }
  },
  ScripterImpl_closure230: {
    "^": "Closure:1;_captured_this_186",
    call$0: function() {
      var t1, t2;
      O.echo(" \"You are angry, and I understand that,\" he says. \"I do. But orders are orders. And you cannot really dock with us unless we open a hatch for you, can you?\"\n");
      t1 = this._captured_this_186;
      t2 = t1.unityOperatorAttitude;
      if (typeof t2 !== "number")
        return t2.$sub();
      t1.unityOperatorAttitude = t2 - 1;
    }
  },
  ScripterImpl_closure231: {
    "^": "Closure:1;_captured_this_187",
    call$0: function() {
      if (J.get$isEmpty$as(this._captured_this_187.unityTopics)) {
        O.echo("There are no more questions to ask right now. You motion towards the console and the connection terminates.\n");
        $.gotoPageName = "Unity: DisconnectFromTower";
      }
    }
  },
  ScripterImpl_closure232: {
    "^": "Closure:1;_captured_this_188",
    call$0: function() {
      var unityQuestions = P.LinkedHashMap_LinkedHashMap$_literal(["Organization", "\"What organization?\"", "ActiveThreatBlacklist", "\"What's the Active Threat blacklist?\"", "AskToDock", "\"What would need to happen for us to dock?\"", "AskToTrade", "\"Can I at least trade with you?\"", "WhereToGo", "\"Where can we go?\""], null, null);
      J.forEach$1$a(this._captured_this_188.unityTopics, new N.ScripterImpl__closure(unityQuestions));
      O.choice("Disconnect", false, false, null, new N.ScripterImpl__closure0(), null);
    }
  },
  ScripterImpl__closure: {
    "^": "Closure:3;_captured_unityQuestions_189",
    call$1: function(pageName) {
      H.stringTypeCheck(pageName);
      O.choice(this._captured_unityQuestions_189.$index(0, pageName), false, false, pageName, null, null);
    }
  },
  ScripterImpl__closure0: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo("You motion towards the console and the connection terminates.\n");
      $.gotoPageName = "Unity: DisconnectFromTower";
    }
  },
  ScripterImpl_closure233: {
    "^": "Closure:1;_captured_this_190",
    call$0: function() {
      var t1 = this._captured_this_190;
      J.remove$1$a(t1.unityTopics, "Organization");
      t1.zil.update$2$describe(1, false);
    }
  },
  ScripterImpl_closure234: {
    "^": "Closure:1;_captured_this_191",
    call$0: function() {
      var t1 = this._captured_this_191;
      J.remove$1$a(t1.unityTopics, "ActiveThreatBlacklist");
      t1.zil.update$2$describe(1, false);
    }
  },
  ScripterImpl_closure235: {
    "^": "Closure:1;_captured_this_192",
    call$0: function() {
      var t1 = this._captured_this_192;
      J.remove$1$a(t1.unityTopics, "AskToDock");
      t1.zil.update$2$describe(1, false);
    }
  },
  ScripterImpl_closure236: {
    "^": "Closure:1;_captured_this_193",
    call$0: function() {
      var t1 = this._captured_this_193;
      J.remove$1$a(t1.unityTopics, "WhereToGo");
      t1.zil.update$2$describe(1, false);
    }
  },
  ScripterImpl_closure237: {
    "^": "Closure:1;",
    call$0: function() {
      return "What do you do?";
    }
  },
  ScripterImpl_closure238: {
    "^": "Closure:1;",
    call$0: function() {
      return "Use the Unity's beacon";
    }
  },
  ScripterImpl_closure239: {
    "^": "Closure:1;",
    call$0: function() {
      return "Open fire at Space Station Unity to force them to let you dock";
    }
  },
  ScripterImpl_closure240: {
    "^": "Closure:1;",
    call$0: function() {
      return "Try to negotiate with the operator, offering something on board";
    }
  },
  ScripterImpl_closure241: {
    "^": "Closure:1;",
    call$0: function() {
      return "Wait";
    }
  },
  ScripterImpl_closure242: {
    "^": "Closure:1;",
    call$0: function() {
      return "Jump to safety";
    }
  },
  ScripterImpl_closure243: {
    "^": "Closure:1;_captured_this_194",
    call$0: function() {
      var t1 = this._captured_this_194;
      if (H.boolConversionCheck(t1.knowsAboutEleanor)) {
        t1.afterEleanorFirstChatGoto = "Unity: SentacoShipArrival";
        $.gotoPageName = "Eleanor: FirstCall";
      } else
        O.echo("But there is currently no single person to try and reach.\n");
    }
  },
  ScripterImpl_closure244: {
    "^": "Closure:1;_captured_this_195",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_195.lastSymptoms;
      t2 = t1.time;
      if (typeof t2 !== "number")
        return t2.$add();
      t1.time = t2 + 1;
    }
  },
  ScripterImpl_closure245: {
    "^": "Closure:1;",
    call$0: function() {
      return "Tell her your name";
    }
  },
  ScripterImpl_closure246: {
    "^": "Closure:1;_captured_this_196",
    call$0: function() {
      $.get$_points().add$2(0, 1, "honesty");
    }
  },
  ScripterImpl_closure247: {
    "^": "Closure:1;",
    call$0: function() {
      return "Tell her a made up name";
    }
  },
  ScripterImpl_closure248: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"It doesn't matter.\" ";
    }
  },
  ScripterImpl_closure249: {
    "^": "Closure:1;_captured_this_197",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_197.lastSymptoms;
      t2 = t1.time;
      if (typeof t2 !== "number")
        return t2.$add();
      t1.time = t2 + 1;
    }
  },
  ScripterImpl_closure250: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"I haven't 'taken' anything. There was an accident.\" ";
    }
  },
  ScripterImpl_closure251: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"What the fuck is Rescin?\" ";
    }
  },
  ScripterImpl_closure252: {
    "^": "Closure:1;_captured_this_198",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_198.lastSymptoms;
      t2 = t1.time;
      if (typeof t2 !== "number")
        return t2.$add();
      t1.time = t2 + 1;
    }
  },
  ScripterImpl_closure253: {
    "^": "Closure:1;_captured_this_199",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_199.lastSymptoms;
      t2 = t1.time;
      if (typeof t2 !== "number")
        return t2.$add();
      t1.time = t2 + 1;
    }
  },
  ScripterImpl_closure254: {
    "^": "Closure:1;",
    call$0: function() {
      return "Wait if it fades // doesn't work";
    }
  },
  ScripterImpl_closure255: {
    "^": "Closure:1;",
    call$0: function() {
      return "Try to call Gorilla";
    }
  },
  ScripterImpl_closure256: {
    "^": "Closure:1;",
    call$0: function() {
      return "Try to crawl towards the bridge // works";
    }
  },
  ScripterImpl_closure257: {
    "^": "Closure:1;_captured_this_200",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_this_200.lastSymptoms;
      t2 = t1.time;
      if (typeof t2 !== "number")
        return t2.$add();
      t1.time = t2 + 1;
    }
  },
  ScripterImpl_closure258: {
    "^": "Closure:1;",
    call$0: function() {
      return "Open eyes";
    }
  },
  ScripterImpl_closure259: {
    "^": "Closure:1;_captured_this_201",
    call$0: function() {
      O.echo("Dr. Eleanor Wells is there. She's no longer in a dim lit room, it's day at wherever she is right now. She raises her eyebrows" + (this._captured_this_201.get$attitude().$gt(0, -1) ? " and smiles" : "") + ".");
    }
  },
  ScripterImpl_closure260: {
    "^": "Closure:1;_captured_this_202",
    call$0: function() {
      O.echo("\"You're still weak " + (this._captured_this_202.get$attitude().$gt(0, -1) ? "\u2013" : "\u2013 at least I'll be spared of your brash language for once \u2013") + " but that will pass soon enough. You are through the rebuild phase now.\" ");
    }
  },
  ScripterImpl_closure261: {
    "^": "Closure:1;",
    call$0: function() {
      return "Raise eyebrows";
    }
  },
  ScripterImpl_closure262: {
    "^": "Closure:1;",
    call$0: function() {
      return "Raise eyebrows";
    }
  },
  ScripterImpl_closure263: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo(" \"We had no data that would be indicative of what would happen. Nobody attempted anything close to this before. There were experiments with single cells or primitive organisms, but never with something as complex as a mouse, let alone a human. We spent almost a year trying to create a working model with some predictive accuracy. We never got there. Not even close. In the end, we had to get to the results experimentally. We were like the alchemists in the middle ages, but instead of the philosopher's stone, we were searching for something much more important.\" ");
    }
  },
  ScripterImpl_closure264: {
    "^": "Closure:1;",
    call$0: function() {
      return "Do nothing";
    }
  },
  ScripterImpl_closure265: {
    "^": "Closure:1;",
    call$0: function() {
      return "Nod";
    }
  },
  ScripterImpl_closure266: {
    "^": "Closure:1;",
    call$0: function() {
      return "Shake head";
    }
  },
  ScripterImpl_closure267: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"Who cares?\" ";
    }
  },
  ScripterImpl_closure268: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo("Something akin to \"huh hrrrs\" comes from inside of your throat. Dr. Wells waits for a second to see if you're going to continue, then she gets back to speaking.");
    }
  },
  ScripterImpl_closure269: {
    "^": "Closure:1;",
    call$0: function() {
      return "Listen";
    }
  },
  ScripterImpl_closure270: {
    "^": "Closure:1;",
    call$0: function() {
      return "Try to get up";
    }
  },
  ScripterImpl_closure271: {
    "^": "Closure:1;",
    call$0: function() {
      return "- \"What exactly happened to me?\" // Rescin works to counter any breakages - - \"Why 'Rescin'?\"\n          - \"Why did no one else survive?\" // outer space\n          - \"Why are you helping me?\" // Pruitt will make a project out of you. I feel responsible\n          ";
    }
  },
  ScripterImpl_closure272: {
    "^": "Closure:1;",
    call$0: function() {
      return "Try to stand up again";
    }
  },
  ScripterImpl_closure273: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"So?\" ";
    }
  },
  ScripterImpl_closure274: {
    "^": "Closure:1;",
    call$0: function() {
      O.echo(" \"They'll board the Bodega. They'll expect trouble, but I don't think they fully appreciate the effects  Rescin can have on a healthy body.\" ");
    }
  },
  ScripterImpl_closure275: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"Whatever.\" ";
    }
  },
  ScripterImpl_closure276: {
    "^": "Closure:1;_captured_this_203",
    call$0: function() {
      O.echo("The gunship slowly approaches, all weapons scanning the surface of the Bodega. It seems to be aiming for the right side of the ship, where the airlock " + (H.boolConversionCheck(this._captured_this_203.pulledLever) ? "is" : "was") + ". Meanwhile, the Bodega is completely still. ");
    }
  },
  ScripterImpl_closure277: {
    "^": "Closure:1;",
    call$0: function() {
      return "- Take everything (15 energy cells, food for 70 days)\n          - Leave just enough for them to survive, take the rest (14 energy cells, food for 65 days)\n          ";
    }
  },
  ScripterImpl_closure278: {
    "^": "Closure:1;",
    call$0: function() {
      return "Leave everything";
    }
  },
  ScripterImpl_closure279: {
    "^": "Closure:1;",
    call$0: function() {
      return "\"How?\" ";
    }
  },
  ScripterImpl_initBlock_closure: {
    "^": "Closure:0;",
    call$1: function(value) {
      return H.S(H.intTypeCheck(value)) + " P";
    }
  },
  ScripterImpl_initBlock_closure0: {
    "^": "Closure:0;",
    call$1: function(value) {
      return H.S(H.intTypeCheck(value)) + " M";
    }
  },
  ScripterImpl_initBlock_closure1: {
    "^": "Closure:1;",
    call$0: function() {
      return false;
    }
  },
  ScripterImpl_initBlock_closure2: {
    "^": "Closure:2;",
    call$1: function(value) {
      var hours, minutes, t1;
      if (typeof value !== "number")
        return value.$div();
      hours = C.JSDouble_methods.toInt$0(H.doubleTypeCheck(Math.floor(value / 60)));
      minutes = H.intTypeCheck(C.JSNumber_methods.$mod(value, 60));
      t1 = "" + hours + ":";
      return t1 + (minutes < 10 ? "0" : "") + minutes;
    }
  },
  ScripterImpl_initBlock_closure3: {
    "^": "Closure:2;",
    call$1: function(value) {
      return H.S(value) + " E";
    }
  },
  ScripterImpl_initBlock_closure4: {
    "^": "Closure:3;_Scripter_Implementation$_captured_this_0",
    call$1: function(article) {
      var t1, str;
      H.stringTypeCheck(article);
      t1 = this._Scripter_Implementation$_captured_this_0;
      str = H.boolConversionCheck(t1.isEngineer) ? "machinist" : null;
      if (H.boolConversionCheck(t1.isMedic))
        str = "medic";
      if (H.boolConversionCheck(t1.isSpaceman))
        str = "{spaceman|sailor}";
      return S.Randomly_parse(H.S(article) + " " + H.S(str));
    }
  },
  ScripterImpl_initBlock_closure5: {
    "^": "Closure:1;_Scripter_Implementation$_captured_this_1",
    call$0: function() {
      var t1 = this._Scripter_Implementation$_captured_this_1;
      if (H.boolConversionCheck(t1.isEngineer))
        return "engineering";
      if (H.boolConversionCheck(t1.isMedic))
        return "medical";
      if (H.boolConversionCheck(t1.isSpaceman))
        return "maintenance";
      throw H.wrapException(P.Exception_Exception("Role not defined for getRoleAdjective."));
    }
  },
  ScripterImpl_initBlock_closure6: {
    "^": "Closure:1;_Scripter_Implementation$_captured_this_2",
    call$0: function() {
      return this._Scripter_Implementation$_captured_this_2.manOrWoman === "man";
    }
  },
  ScripterImpl_initBlock_closure7: {
    "^": "Closure:1;_captured_this_3",
    call$0: function() {
      return this._captured_this_3.manOrWoman === "woman";
    }
  }
},
1],
["_foreign_helper", "dart:_foreign_helper", , H, {
  "^": "",
  JS_CONST: {
    "^": "Object;code"
  }
}],
["_interceptors", "dart:_interceptors", , J, {
  "^": "",
  getInterceptor: function(object) {
    return void 0;
  },
  Interceptor: {
    "^": "Object;",
    $eq: function(receiver, other) {
      return receiver === other;
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    toString$0: function(receiver) {
      return H.Primitives_objectToString(receiver);
    }
  },
  JSBool: {
    "^": "Interceptor;",
    toString$0: function(receiver) {
      return String(receiver);
    },
    get$hashCode: function(receiver) {
      return receiver ? 519018 : 218159;
    },
    $isbool: 1
  },
  JSNull: {
    "^": "Interceptor;",
    $eq: function(receiver, other) {
      return null == other;
    },
    toString$0: function(receiver) {
      return "null";
    },
    get$hashCode: function(receiver) {
      return 0;
    }
  },
  JavaScriptObject: {
    "^": "Interceptor;",
    get$hashCode: function(_) {
      return 0;
    },
    $isJSObject: 1
  },
  PlainJavaScriptObject: {
    "^": "JavaScriptObject;"
  },
  UnknownJavaScriptObject: {
    "^": "JavaScriptObject;",
    toString$0: function(receiver) {
      return String(receiver);
    }
  },
  JSArray: {
    "^": "Interceptor;",
    checkMutable$1: function(receiver, reason) {
      if (!!receiver.immutable$list)
        throw H.wrapException(P.UnsupportedError$(reason));
    },
    checkGrowable$1: function(receiver, reason) {
      if (!!receiver.fixed$length)
        throw H.wrapException(P.UnsupportedError$(reason));
    },
    add$1: function(receiver, value) {
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(receiver, 0));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("add"));
      receiver.push(value);
    },
    insert$2: function(receiver, index, value) {
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(receiver, 0));
      if (index > receiver.length)
        throw H.wrapException(P.RangeError$value(index, null, null));
      this.checkGrowable$1(receiver, "insert");
      receiver.splice(index, 0, value);
    },
    remove$1: function(receiver, element) {
      var i;
      this.checkGrowable$1(receiver, "remove");
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], element)) {
          receiver.splice(i, 1);
          return true;
        }
      return false;
    },
    _removeWhere$2: function(receiver, test, removeMatching) {
      var t1, retained, end, i, element;
      t1 = H.buildFunctionType(H.buildInterfaceType(P.bool), [H.convertRtiToRuntimeType(receiver.$builtinTypeInfo && receiver.$builtinTypeInfo[0])])._assertCheck$1(test);
      retained = [];
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        element = receiver[i];
        if (!H.boolConversionCheck(t1.call$1(element)) === removeMatching)
          this.add$1(retained, element);
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      t1 = retained.length;
      if (t1 === end)
        return;
      this.set$length(receiver, t1);
      for (i = 0; i < retained.length; ++i)
        this.$indexSet(receiver, i, retained[i]);
    },
    addAll$1: function(receiver, collection) {
      var t1, t2;
      H.listSuperNativeTypeCheck(collection, "$isIterable");
      for (t1 = H.getTypeArgumentByIndex(collection, 0), H.assertSubtype(collection, "$isJSArray", [t1], "$asJSArray"), t2 = collection.length, t1 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(collection, "$isJSArray", [t1], "$asJSArray"), t2, 0, H.assertSubtypeOfRuntimeType(null, t1)), [t1]), "$isIterator", [H.getTypeArgumentByIndex(collection, 0)], "$asIterator"); t1.moveNext$0();)
        this.add$1(receiver, H.assertSubtypeOfRuntimeType(H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0)), H.getTypeArgumentByIndex(receiver, 0)));
    },
    forEach$1: function(receiver, f) {
      var t1, end, i;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [H.convertRtiToRuntimeType(receiver.$builtinTypeInfo && receiver.$builtinTypeInfo[0])])._assertCheck$1(f);
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        t1.call$1(receiver[i]);
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
    },
    map$1: function(receiver, f) {
      var t1, t2;
      t1 = H.buildFunctionType(H.getDynamicRuntimeType(), [H.convertRtiToRuntimeType(receiver.$builtinTypeInfo && receiver.$builtinTypeInfo[0])])._assertCheck$1(f);
      H.listSuperNativeTypeCheck(receiver, "$isIterable");
      t2 = H.buildFunctionType(H.convertRtiToRuntimeType(null), [H.convertRtiToRuntimeType(null)]);
      t2._assertCheck$1(t1);
      return H.setRuntimeTypeInfo(new H.MappedListIterable(H.listSuperNativeTypeCheck(receiver, "$isIterable"), t2._assertCheck$1(t1)), [null, null]);
    },
    join$1: function(receiver, separator) {
      var t1, list, i, t2;
      t1 = receiver.length;
      list = Array(t1);
      list.fixed$length = Array;
      for (i = 0; i < receiver.length; ++i) {
        t2 = H.S(receiver[i]);
        if (i >= t1)
          return H.ioore(list, i);
        list[i] = t2;
      }
      return list.join(separator);
    },
    fold$2: function(receiver, initialValue, combine) {
      var t1, $length, value, i;
      t1 = H.getDynamicRuntimeType();
      t1 = H.buildFunctionType(t1, [t1, H.convertRtiToRuntimeType(receiver.$builtinTypeInfo && receiver.$builtinTypeInfo[0])])._assertCheck$1(combine);
      $length = receiver.length;
      for (value = initialValue, i = 0; i < $length; ++i) {
        value = t1.call$2(value, receiver[i]);
        if (receiver.length !== $length)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return value;
    },
    singleWhere$1: function(receiver, test) {
      var t1, $length, match, matchFound, i, element;
      t1 = H.buildFunctionType(H.buildInterfaceType(P.bool), [H.convertRtiToRuntimeType(receiver.$builtinTypeInfo && receiver.$builtinTypeInfo[0])])._assertCheck$1(test);
      $length = receiver.length;
      H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(receiver, 0));
      for (match = null, matchFound = false, i = 0; i < $length; ++i) {
        element = receiver[i];
        if (H.boolConversionCheck(t1.call$1(element))) {
          if (matchFound)
            throw H.wrapException(H.IterableElementError_tooMany());
          H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(receiver, 0));
          match = element;
          matchFound = true;
        }
        if ($length !== receiver.length)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      if (matchFound)
        return H.assertSubtypeOfRuntimeType(match, H.getTypeArgumentByIndex(receiver, 0));
      throw H.wrapException(H.IterableElementError_noElement());
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return H.assertSubtypeOfRuntimeType(receiver[index], H.getTypeArgumentByIndex(receiver, 0));
    },
    sublist$2: function(receiver, start, end) {
      var t1;
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
      if (end < start || end > receiver.length)
        throw H.wrapException(P.RangeError$range(end, start, receiver.length, null, null));
      if (start === end)
        return H.assertSubtype(H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(receiver, 0)]), "$isList", [H.getTypeArgumentByIndex(receiver, 0)], "$asList");
      t1 = H.getTypeArgumentByIndex(receiver, 0);
      return H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(H.assertSubtype(receiver.slice(start, end), "$isJSArray", [t1], "$asJSArray"), [t1]), "$isJSArray", [t1], "$asJSArray"), "$isList", [H.getTypeArgumentByIndex(receiver, 0)], "$asList");
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return H.assertSubtypeOfRuntimeType(receiver[0], H.getTypeArgumentByIndex(receiver, 0));
      throw H.wrapException(H.IterableElementError_noElement());
    },
    get$last: function(receiver) {
      var t1 = receiver.length;
      if (t1 > 0)
        return H.assertSubtypeOfRuntimeType(receiver[t1 - 1], H.getTypeArgumentByIndex(receiver, 0));
      throw H.wrapException(H.IterableElementError_noElement());
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      var $length, i, t1;
      H.listSuperNativeTypeCheck(iterable, "$isIterable");
      this.checkMutable$1(receiver, "set range");
      P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
      $length = end - start;
      if ($length === 0)
        return;
      if (skipCount < 0)
        H.throwExpression(P.RangeError$range(skipCount, 0, null, "skipCount", null));
      if (skipCount + $length > iterable.length)
        throw H.wrapException(H.IterableElementError_tooFew());
      if (skipCount < start)
        for (i = $length - 1; i >= 0; --i) {
          t1 = skipCount + i;
          if (t1 < 0 || t1 >= iterable.length)
            return H.ioore(iterable, t1);
          receiver[start + i] = H.assertSubtypeOfRuntimeType(iterable[t1], H.getTypeArgumentByIndex(receiver, 0));
        }
      else
        for (i = 0; i < $length; ++i) {
          t1 = skipCount + i;
          if (t1 < 0 || t1 >= iterable.length)
            return H.ioore(iterable, t1);
          receiver[start + i] = H.assertSubtypeOfRuntimeType(iterable[t1], H.getTypeArgumentByIndex(receiver, 0));
        }
    },
    any$1: function(receiver, test) {
      var t1, end, i;
      t1 = H.buildFunctionType(H.buildInterfaceType(P.bool), [H.convertRtiToRuntimeType(receiver.$builtinTypeInfo && receiver.$builtinTypeInfo[0])])._assertCheck$1(test);
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        if (H.boolConversionCheck(t1.call$1(receiver[i])))
          return true;
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return false;
    },
    sort$1: function(receiver, compare) {
      var t1, t2, t3;
      t1 = H.buildInterfaceType(P.$int);
      t2 = H.convertRtiToRuntimeType(receiver.$builtinTypeInfo && receiver.$builtinTypeInfo[0]);
      t2 = H.buildFunctionType(t1, [t2, t2])._assertCheck$1(compare);
      this.checkMutable$1(receiver, "sort");
      if (t2 == null)
        t2 = P.Comparable_compare$closure();
      t3 = H.getDynamicRuntimeType();
      H.buildFunctionType(t1, [t3, t3])._assertCheck$1(t2);
      H.Sort__doSort(receiver, 0, receiver.length - 1, t2);
    },
    sort$0: function($receiver) {
      return this.sort$1($receiver, null);
    },
    indexOf$2: function(receiver, element, start) {
      var i;
      if (start >= receiver.length)
        return -1;
      for (i = start; i < receiver.length; ++i)
        if (J.$eq(receiver[i], element))
          return i;
      return -1;
    },
    indexOf$1: function($receiver, element) {
      return this.indexOf$2($receiver, element, 0);
    },
    lastIndexOf$2: function(receiver, element, startIndex) {
      var t1, i;
      if (startIndex == null)
        startIndex = receiver.length - 1;
      else {
        if (startIndex < 0)
          return -1;
        t1 = receiver.length;
        if (startIndex >= t1)
          startIndex = t1 - 1;
      }
      for (i = startIndex; i >= 0; --i) {
        if (i >= receiver.length)
          return H.ioore(receiver, i);
        if (J.$eq(receiver[i], element))
          return i;
      }
      return -1;
    },
    lastIndexOf$1: function($receiver, element) {
      return this.lastIndexOf$2($receiver, element, null);
    },
    contains$1: function(receiver, other) {
      var i;
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], other))
          return true;
      return false;
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.length !== 0;
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    get$iterator: function(receiver) {
      var t1, t2;
      t1 = H.getTypeArgumentByIndex(receiver, 0);
      H.assertSubtype(receiver, "$isJSArray", [t1], "$asJSArray");
      t2 = receiver.length;
      return H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(receiver, "$isJSArray", [t1], "$asJSArray"), t2, 0, H.assertSubtypeOfRuntimeType(null, t1)), [t1]), "$isIterator", [H.getTypeArgumentByIndex(receiver, 0)], "$asIterator");
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    set$length: function(receiver, newLength) {
      if (newLength < 0)
        throw H.wrapException(P.RangeError$value(newLength, null, null));
      this.checkGrowable$1(receiver, "set length");
      receiver.length = newLength;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      return H.assertSubtypeOfRuntimeType(receiver[index], H.getTypeArgumentByIndex(receiver, 0));
    },
    $indexSet: function(receiver, index, value) {
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(receiver, 0));
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("indexed set"));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      receiver[index] = value;
    },
    $isJSIndexable: 1,
    $isList: 1,
    $isEfficientLength: 1,
    $isIterable: 1
  },
  ArrayIterator: {
    "^": "Object;_iterable,_length,_index,_current",
    set$_current: function(_current) {
      this._current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    get$current: function() {
      return H.assertSubtypeOfRuntimeType(this._current, H.getTypeArgumentByIndex(this, 0));
    },
    moveNext$0: function() {
      var t1, $length, t2;
      t1 = this._iterable;
      $length = t1.length;
      if (this._length !== $length)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t2 = this._index;
      if (t2 >= $length) {
        this.set$_current(null);
        return false;
      }
      this.set$_current(t1[t2]);
      ++this._index;
      return true;
    },
    $isIterator: 1
  },
  JSNumber: {
    "^": "Interceptor;",
    compareTo$1: function(receiver, b) {
      var bIsNegative;
      H.numTypeCheck(b);
      if (typeof b !== "number")
        throw H.wrapException(P.ArgumentError$(b));
      if (receiver < b)
        return -1;
      else if (receiver > b)
        return 1;
      else if (receiver === b) {
        if (receiver === 0) {
          bIsNegative = this.get$isNegative(b);
          if (this.get$isNegative(receiver) === bIsNegative)
            return 0;
          if (this.get$isNegative(receiver))
            return -1;
          return 1;
        }
        return 0;
      } else if (isNaN(receiver)) {
        if (this.get$isNaN(b))
          return 0;
        return 1;
      } else
        return -1;
    },
    get$isNegative: function(receiver) {
      return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
    },
    get$isNaN: function(receiver) {
      return isNaN(receiver);
    },
    get$isFinite: function(receiver) {
      return isFinite(receiver);
    },
    remainder$1: function(receiver, b) {
      return receiver % b;
    },
    toInt$0: function(receiver) {
      var t1;
      if (receiver >= -2147483648 && receiver <= 2147483647)
        return receiver | 0;
      if (isFinite(receiver)) {
        t1 = receiver < 0 ? H.doubleTypeCheck(Math.ceil(receiver)) : H.doubleTypeCheck(Math.floor(receiver));
        return t1 + 0;
      }
      throw H.wrapException(P.UnsupportedError$("" + receiver));
    },
    round$0: function(receiver) {
      if (receiver > 0) {
        if (receiver !== 1 / 0)
          return Math.round(receiver);
      } else if (receiver > -1 / 0)
        return 0 - Math.round(0 - receiver);
      throw H.wrapException(P.UnsupportedError$("" + receiver));
    },
    toRadixString$1: function(receiver, radix) {
      var result, match, t1, exponent;
      H.checkInt(radix);
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$range(radix, 2, 36, "radix", null));
      result = receiver.toString(radix);
      if (C.JSString_methods.codeUnitAt$1(result, result.length - 1) !== 41)
        return result;
      match = /^([\da-z]+)(?:\.([\da-z]+))?\(e\+(\d+)\)$/.exec(result);
      if (match == null)
        H.throwExpression(P.UnsupportedError$("Unexpected toString result: " + result));
      t1 = J.getInterceptor$as(match);
      result = t1.$index(match, 1);
      exponent = +t1.$index(match, 3);
      if (t1.$index(match, 2) != null) {
        result += t1.$index(match, 2);
        exponent -= t1.$index(match, 2).length;
      }
      return result + C.JSString_methods.$mul("0", exponent);
    },
    toString$0: function(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    get$hashCode: function(receiver) {
      return receiver & 0x1FFFFFFF;
    },
    $add: function(receiver, other) {
      H.numTypeCheck(other);
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    $sub: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver - other;
    },
    $mul: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver * other;
    },
    $mod: function(receiver, other) {
      var result;
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      result = receiver % other;
      if (result === 0)
        return 0;
      if (result > 0)
        return result;
      if (other < 0)
        return result - other;
      else
        return result + other;
    },
    $tdiv: function(receiver, other) {
      if ((receiver | 0) === receiver && (other | 0) === other && 0 !== other && -1 !== other)
        return receiver / other | 0;
      else
        return this.toInt$0(receiver / other);
    },
    _tdivFast$1: function(receiver, other) {
      return (receiver | 0) === receiver ? receiver / other | 0 : this.toInt$0(receiver / other);
    },
    _shrOtherPositive$1: function(receiver, other) {
      var t1;
      if (receiver > 0)
        t1 = other > 31 ? 0 : receiver >>> other;
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    $xor: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return (receiver ^ other) >>> 0;
    },
    $lt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver < other;
    },
    $gt: function(receiver, other) {
      H.numTypeCheck(other);
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver > other;
    },
    $le: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver <= other;
    },
    $ge: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver >= other;
    },
    $isnum: 1,
    $isComparable: 1,
    $asComparable: function() {
      return [P.num];
    }
  },
  JSInt: {
    "^": "JSNumber;",
    $is$double: 1,
    $isnum: 1,
    $isComparable: 1,
    $asComparable: function() {
      return [P.num];
    },
    $is$int: 1
  },
  JSDouble: {
    "^": "JSNumber;",
    $is$double: 1,
    $isnum: 1,
    $isComparable: 1,
    $asComparable: function() {
      return [P.num];
    }
  },
  JSString: {
    "^": "Interceptor;",
    codeUnitAt$1: function(receiver, index) {
      if (index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      if (index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index, null, null));
      return receiver.charCodeAt(index);
    },
    allMatches$2: function(receiver, string, start) {
      H.checkString(string);
      H.checkInt(start);
      if (start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      return H.listSuperNativeTypeCheck(H.allMatchesInStringUnchecked(receiver, string, start), "$isIterable");
    },
    allMatches$1: function($receiver, string) {
      return this.allMatches$2($receiver, string, 0);
    },
    matchAsPrefix$2: function(receiver, string, start) {
      var t1, i;
      if (start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      t1 = receiver.length;
      if (start + t1 > string.length)
        return;
      for (i = 0; i < t1; ++i)
        if (this.codeUnitAt$1(string, start + i) !== this.codeUnitAt$1(receiver, i))
          return;
      return new H.StringMatch(start, string, receiver);
    },
    $add: function(receiver, other) {
      H.stringTypeCheck(other);
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    endsWith$1: function(receiver, other) {
      var otherLength, t1;
      H.checkString(other);
      otherLength = other.length;
      t1 = receiver.length;
      if (otherLength > t1)
        return false;
      return other === this.substring$1(receiver, t1 - otherLength);
    },
    replaceAll$2: function(receiver, from, to) {
      H.checkString(to);
      return H.stringReplaceAllUnchecked(receiver, from, to);
    },
    replaceFirst$3: function(receiver, from, to, startIndex) {
      H.checkString(to);
      H.checkInt(startIndex);
      P.RangeError_checkValueInInterval(startIndex, 0, receiver.length, "startIndex", null);
      return H.stringReplaceFirstUnchecked(receiver, from, to, startIndex);
    },
    replaceFirst$2: function($receiver, from, to) {
      return this.replaceFirst$3($receiver, from, to, 0);
    },
    startsWith$2: function(receiver, pattern, index) {
      var endIndex;
      H.checkInt(index);
      if (index > receiver.length)
        throw H.wrapException(P.RangeError$range(index, 0, receiver.length, null, null));
      if (typeof pattern === "string") {
        endIndex = index + pattern.length;
        if (endIndex > receiver.length)
          return false;
        return pattern === receiver.substring(index, endIndex);
      }
      return J.matchAsPrefix$2$s(pattern, receiver, index) != null;
    },
    startsWith$1: function($receiver, pattern) {
      return this.startsWith$2($receiver, pattern, 0);
    },
    substring$2: function(receiver, startIndex, endIndex) {
      H.intTypeCheck(endIndex);
      H.checkInt(startIndex);
      if (endIndex == null)
        endIndex = receiver.length;
      H.checkInt(endIndex);
      if (startIndex < 0)
        throw H.wrapException(P.RangeError$value(startIndex, null, null));
      if (C.JSInt_methods.$gt(startIndex, endIndex))
        throw H.wrapException(P.RangeError$value(startIndex, null, null));
      if (typeof endIndex !== "number")
        return endIndex.$gt();
      if (endIndex > receiver.length)
        throw H.wrapException(P.RangeError$value(endIndex, null, null));
      return receiver.substring(startIndex, endIndex);
    },
    substring$1: function($receiver, startIndex) {
      return this.substring$2($receiver, startIndex, null);
    },
    trim$0: function(receiver) {
      var result, endIndex, startIndex, t1, endIndex0;
      result = receiver.trim();
      endIndex = result.length;
      if (endIndex === 0)
        return result;
      if (this.codeUnitAt$1(result, 0) === 133) {
        startIndex = J.JSString__skipLeadingWhitespace(result, 1);
        if (startIndex === endIndex)
          return "";
      } else
        startIndex = 0;
      t1 = endIndex - 1;
      endIndex0 = this.codeUnitAt$1(result, t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
      if (startIndex === 0 && endIndex0 === endIndex)
        return result;
      return result.substring(startIndex, endIndex0);
    },
    trimLeft$0: function(receiver) {
      var result, startIndex;
      if (typeof receiver.trimLeft != "undefined") {
        result = receiver.trimLeft();
        if (result.length === 0)
          return result;
        startIndex = this.codeUnitAt$1(result, 0) === 133 ? J.JSString__skipLeadingWhitespace(result, 1) : 0;
      } else {
        startIndex = J.JSString__skipLeadingWhitespace(receiver, 0);
        result = receiver;
      }
      if (startIndex === 0)
        return result;
      if (startIndex === result.length)
        return "";
      return result.substring(startIndex);
    },
    $mul: function(receiver, times) {
      var s, result;
      if (0 >= times)
        return "";
      if (times === 1 || receiver.length === 0)
        return receiver;
      if (times !== times >>> 0)
        throw H.wrapException(C.C_OutOfMemoryError);
      for (s = receiver, result = ""; true;) {
        if ((times & 1) === 1)
          result = s + result;
        times = times >>> 1;
        if (times === 0)
          break;
        s += s;
      }
      return result;
    },
    indexOf$2: function(receiver, pattern, start) {
      if (start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
      return receiver.indexOf(pattern, start);
    },
    indexOf$1: function($receiver, pattern) {
      return this.indexOf$2($receiver, pattern, 0);
    },
    contains$2: function(receiver, other, startIndex) {
      if (startIndex > receiver.length)
        throw H.wrapException(P.RangeError$range(startIndex, 0, receiver.length, null, null));
      return H.stringContainsUnchecked(receiver, other, startIndex);
    },
    contains$1: function($receiver, other) {
      return this.contains$2($receiver, other, 0);
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    compareTo$1: function(receiver, other) {
      var t1;
      H.stringTypeCheck(other);
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      if (receiver === other)
        t1 = 0;
      else
        t1 = receiver < other ? -1 : 1;
      return t1;
    },
    toString$0: function(receiver) {
      return receiver;
    },
    get$hashCode: function(receiver) {
      var t1, hash, i;
      for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
        hash = 536870911 & hash + receiver.charCodeAt(i);
        hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
        hash ^= hash >> 6;
      }
      hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
      hash ^= hash >> 11;
      return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      return receiver[index];
    },
    $isJSIndexable: 1,
    $isString: 1,
    $isPattern: 1,
    $isComparable: 1,
    $asComparable: function() {
      return [P.String];
    },
    static: {JSString__isWhitespace: function(codeUnit) {
        if (codeUnit < 256)
          switch (codeUnit) {
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 32:
            case 133:
            case 160:
              return true;
            default:
              return false;
          }
        switch (codeUnit) {
          case 5760:
          case 6158:
          case 8192:
          case 8193:
          case 8194:
          case 8195:
          case 8196:
          case 8197:
          case 8198:
          case 8199:
          case 8200:
          case 8201:
          case 8202:
          case 8232:
          case 8233:
          case 8239:
          case 8287:
          case 12288:
          case 65279:
            return true;
          default:
            return false;
        }
      }, JSString__skipLeadingWhitespace: function(string, index) {
        var t1, codeUnit;
        for (t1 = string.length; index < t1;) {
          codeUnit = C.JSString_methods.codeUnitAt$1(string, index);
          if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
            break;
          ++index;
        }
        return index;
      }, JSString__skipTrailingWhitespace: function(string, index) {
        var index0, codeUnit;
        for (; index > 0; index = index0) {
          index0 = index - 1;
          codeUnit = C.JSString_methods.codeUnitAt$1(string, index0);
          if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
            break;
        }
        return index;
      }}
  }
}],
["_isolate_helper", "dart:_isolate_helper", , H, {
  "^": "",
  _callInIsolate: function(isolate, $function) {
    var result = isolate.eval$1($function);
    if (!init.globalState.currentContext._isExecutingEvent)
      init.globalState.topEventLoop.run$0();
    return result;
  },
  leaveJsAsync: function() {
    --init.globalState.topEventLoop._activeJsAsyncCount;
    H.assertHelper(init.globalState.topEventLoop._activeJsAsyncCount >= 0);
  },
  startRootIsolate: function(entry, args) {
    var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, rootContext;
    t1 = {};
    t1._captured_args_0 = args;
    args = args;
    t1._captured_args_0 = args;
    if (args == null) {
      args = [];
      t1._captured_args_0 = args;
      t2 = args;
    } else
      t2 = args;
    if (!J.getInterceptor(t2).$isList)
      throw H.wrapException(P.ArgumentError$("Arguments to main must be a List: " + H.S(t2)));
    t2 = new H._Manager(0, 0, 1, null, null, null, null, null, null, H.assertSubtype(null, "$isMap", [P.$int, H._IsolateContext], "$asMap"), null, H.assertSubtype(null, "$isMap", [P.$int, null], "$asMap"), entry);
    t2._nativeDetectEnvironment$0();
    t2.topEventLoop = new H._EventLoop(H.assertSubtype(H.assertSubtype(P.ListQueue$(null, H._IsolateEvent), "$isQueue", [H._IsolateEvent], "$asQueue"), "$isQueue", [H._IsolateEvent], "$asQueue"), 0);
    t2.set$isolates(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H._IsolateContext), "$isMap", [P.$int, H._IsolateContext], "$asMap"));
    t2.set$managers(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, null), "$isMap", [P.$int, null], "$asMap"));
    if (H.boolConversionCheck(t2.isWorker)) {
      t2.mainManager = new H._MainManagerStub();
      t2._nativeInitWorkerMessageHandler$0();
    }
    init.globalState = t2;
    if (H.boolConversionCheck(init.globalState.isWorker))
      return;
    t2 = init.globalState.nextIsolateId++;
    t3 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H.RawReceivePortImpl), "$isMap", [P.$int, H.RawReceivePortImpl], "$asMap");
    t4 = H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int), "$isSet", [P.$int], "$asSet");
    t5 = init.createNewIsolate();
    t6 = new H.RawReceivePortImpl(0, null, false);
    t7 = H.random64();
    t8 = H.random64();
    t9 = P.LinkedHashSet_LinkedHashSet(null, null, null, null);
    t10 = P.LinkedHashSet_LinkedHashSet(null, null, null, null);
    H.assertSubtype(t3, "$isMap", [P.$int, H.RawReceivePortImpl], "$asMap");
    H.assertSubtype(t4, "$isSet", [P.$int], "$asSet");
    rootContext = new H._IsolateContext(t2, t3, t4, t5, t6, new H.CapabilityImpl(t7), new H.CapabilityImpl(t8), false, false, H.assertSubtype([], "$isList", [H._IsolateEvent], "$asList"), H.assertSubtype(t9, "$isSet", [P.Capability], "$asSet"), null, null, false, true, H.assertSubtype(t10, "$isSet", [P.SendPort], "$asSet"));
    t4.add$1(0, 0);
    rootContext._addRegistration$2(0, t6);
    init.globalState.rootContext = rootContext;
    init.globalState.currentContext = rootContext;
    t2 = H.getDynamicRuntimeType();
    t3 = H.buildFunctionType(t2, [t2])._isTest$1(entry);
    if (t3)
      rootContext.eval$1(new H.startRootIsolate_closure(t1, entry));
    else {
      t2 = H.buildFunctionType(t2, [t2, t2])._isTest$1(entry);
      if (t2)
        rootContext.eval$1(new H.startRootIsolate_closure0(t1, entry));
      else
        rootContext.eval$1(entry);
    }
    init.globalState.topEventLoop.run$0();
  },
  IsolateNatives_computeThisScript: function() {
    var currentScript = init.currentScript;
    if (currentScript != null)
      return String(currentScript.src);
    if (typeof version == "function" && typeof os == "object" && "setenv" in os)
      return H.IsolateNatives_computeThisScriptFromTrace();
    if (typeof version == "function" && typeof os == "object" && "getenv" in os)
      return thisFilename();
    if (H.boolConversionCheck(init.globalState.isWorker))
      return H.IsolateNatives_computeThisScriptFromTrace();
    return;
  },
  IsolateNatives_computeThisScriptFromTrace: function() {
    var stack, matches;
    stack = new Error().stack;
    if (stack == null) {
      stack = function() {
        try {
          throw new Error();
        } catch (e) {
          return e.stack;
        }
      }();
      if (stack == null)
        throw H.wrapException(P.UnsupportedError$("No stack trace"));
    }
    matches = stack.match(new RegExp("^ *at [^(]*\\((.*):[0-9]*:[0-9]*\\)$", "m"));
    if (matches != null)
      return matches[1];
    matches = stack.match(new RegExp("^[^@]*@(.*):[0-9]*$", "m"));
    if (matches != null)
      return matches[1];
    throw H.wrapException(P.UnsupportedError$("Cannot extract URI from \"" + H.S(stack) + "\""));
  },
  IsolateNatives__processWorkerMessage: function(sender, e) {
    var msg, t1, functionName, entryPoint, args, message, isSpawnUri, startPaused, replyTo, t2, t3, t4, t5, t6, t7, t8, t9, context;
    msg = new H._Deserializer(true, []).deserialize$1(e.data);
    t1 = J.getInterceptor$as(msg);
    switch (t1.$index(msg, "command")) {
      case "start":
        init.globalState.currentManagerId = H.intTypeCheck(t1.$index(msg, "id"));
        functionName = H.stringTypeCheck(t1.$index(msg, "functionName"));
        entryPoint = H.interceptedTypeCheck(functionName == null ? init.globalState.entry : H.IsolateNatives__getJSFunctionFromName(functionName), "$isFunction");
        args = t1.$index(msg, "args");
        message = new H._Deserializer(true, []).deserialize$1(t1.$index(msg, "msg"));
        isSpawnUri = t1.$index(msg, "isSpawnUri");
        startPaused = t1.$index(msg, "startPaused");
        replyTo = new H._Deserializer(true, []).deserialize$1(t1.$index(msg, "replyTo"));
        t1 = init.globalState.nextIsolateId++;
        t2 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H.RawReceivePortImpl), "$isMap", [P.$int, H.RawReceivePortImpl], "$asMap");
        t3 = H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int), "$isSet", [P.$int], "$asSet");
        t4 = init.createNewIsolate();
        t5 = new H.RawReceivePortImpl(0, null, false);
        t6 = H.random64();
        t7 = H.random64();
        t8 = P.LinkedHashSet_LinkedHashSet(null, null, null, null);
        t9 = P.LinkedHashSet_LinkedHashSet(null, null, null, null);
        H.assertSubtype(t2, "$isMap", [P.$int, H.RawReceivePortImpl], "$asMap");
        H.assertSubtype(t3, "$isSet", [P.$int], "$asSet");
        context = new H._IsolateContext(t1, t2, t3, t4, t5, new H.CapabilityImpl(t6), new H.CapabilityImpl(t7), false, false, H.assertSubtype([], "$isList", [H._IsolateEvent], "$asList"), H.assertSubtype(t8, "$isSet", [P.Capability], "$asSet"), null, null, false, true, H.assertSubtype(t9, "$isSet", [P.SendPort], "$asSet"));
        t3.add$1(0, 0);
        context._addRegistration$2(0, t5);
        t5 = init.globalState.topEventLoop.events;
        t3 = new H._IsolateEvent(context, new H.IsolateNatives__processWorkerMessage_closure(entryPoint, args, message, isSpawnUri, startPaused, replyTo), "worker-start");
        H.assertSubtypeOfRuntimeType(t3, H.getTypeArgumentByIndex(t5, 0));
        t5._add$1(t3);
        init.globalState.currentContext = context;
        init.globalState.topEventLoop.run$0();
        break;
      case "spawn-worker":
        break;
      case "message":
        if (H.interceptedTypeCheck(t1.$index(msg, "port"), "$isSendPort") != null)
          t1.$index(msg, "port").send$1(t1.$index(msg, "msg"));
        init.globalState.topEventLoop.run$0();
        break;
      case "close":
        init.globalState.managers.remove$1(0, $.get$IsolateNatives_workerIds().$index(0, sender));
        sender.terminate();
        init.globalState.topEventLoop.run$0();
        break;
      case "log":
        H.IsolateNatives__log(t1.$index(msg, "msg"));
        break;
      case "print":
        if (H.boolConversionCheck(init.globalState.isWorker)) {
          t1 = init.globalState.mainManager;
          t2 = P.LinkedHashMap_LinkedHashMap$_literal(["command", "print", "msg", msg], null, null);
          t2 = new H._Serializer(true, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$identity(null, P.$int), "$isMap", [null, P.$int], "$asMap"), "$isMap", [null, P.$int], "$asMap")).serialize$1(t2);
          t1.toString;
          self.postMessage(t2);
        } else
          P.print(t1.$index(msg, "msg"));
        break;
      case "error":
        throw H.wrapException(t1.$index(msg, "msg"));
    }
  },
  IsolateNatives__log: function(msg) {
    var trace, t1, t2, exception;
    if (H.boolConversionCheck(init.globalState.isWorker)) {
      t1 = init.globalState.mainManager;
      t2 = P.LinkedHashMap_LinkedHashMap$_literal(["command", "log", "msg", msg], null, null);
      t2 = new H._Serializer(true, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$identity(null, P.$int), "$isMap", [null, P.$int], "$asMap"), "$isMap", [null, P.$int], "$asMap")).serialize$1(t2);
      t1.toString;
      self.postMessage(t2);
    } else
      try {
        self.console.log(msg);
      } catch (exception) {
        H.unwrapException(exception);
        trace = H.getTraceFromException(exception);
        throw H.wrapException(P.Exception_Exception(trace));
      }
  },
  IsolateNatives__getJSFunctionFromName: function(functionName) {
    return init.globalFunctions[functionName]();
  },
  IsolateNatives__startIsolate: function(topLevel, args, message, isSpawnUri, startPaused, replyTo) {
    var context, t1, t2, t3;
    H.interceptedTypeCheck(topLevel, "$isFunction");
    H.assertSubtype(args, "$isList", [P.String], "$asList");
    H.boolTypeCheck(isSpawnUri);
    H.boolTypeCheck(startPaused);
    H.interceptedTypeCheck(replyTo, "$isSendPort");
    context = init.globalState.currentContext;
    t1 = context.id;
    $.Primitives_mirrorFunctionCacheName = $.Primitives_mirrorFunctionCacheName + ("_" + t1);
    $.Primitives_mirrorInvokeCacheName = $.Primitives_mirrorInvokeCacheName + ("_" + t1);
    t1 = context.controlPort;
    t2 = init.globalState.currentContext.id;
    t3 = context.pauseCapability;
    replyTo.send$1(["spawned", new H._NativeJsSendPort(t1, t2), t3, context.terminateCapability]);
    t2 = new H.IsolateNatives__startIsolate_runStartFunction(topLevel, args, message, isSpawnUri, context);
    if (startPaused) {
      context.addPause$2(t3, t3);
      t1 = init.globalState.topEventLoop.events;
      t2 = new H._IsolateEvent(context, t2, "start isolate");
      H.assertSubtypeOfRuntimeType(t2, H.getTypeArgumentByIndex(t1, 0));
      t1._add$1(t2);
    } else
      t2.call$0();
  },
  _clone: function(message) {
    return new H._Deserializer(true, []).deserialize$1(new H._Serializer(false, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$identity(null, P.$int), "$isMap", [null, P.$int], "$asMap"), "$isMap", [null, P.$int], "$asMap")).serialize$1(message));
  },
  startRootIsolate_closure: {
    "^": "Closure:1;__isolate_helper$_box_0,_captured_entry_1",
    call$0: function() {
      this._captured_entry_1.call$1(this.__isolate_helper$_box_0._captured_args_0);
    }
  },
  startRootIsolate_closure0: {
    "^": "Closure:1;__isolate_helper$_box_0,_captured_entry_2",
    call$0: function() {
      this._captured_entry_2.call$2(this.__isolate_helper$_box_0._captured_args_0, null);
    }
  },
  _Manager: {
    "^": "Object;nextIsolateId,currentManagerId,nextManagerId,currentContext,rootContext,topEventLoop,fromCommandLine,isWorker,supportsWorkers,isolates,mainManager,managers,entry",
    set$isolates: function(isolates) {
      this.isolates = H.assertSubtype(isolates, "$isMap", [P.$int, H._IsolateContext], "$asMap");
    },
    set$managers: function(managers) {
      this.managers = H.assertSubtype(managers, "$isMap", [P.$int, null], "$asMap");
    },
    _nativeDetectEnvironment$0: function() {
      var t1, t2, t3;
      t1 = self.window == null;
      t2 = self.Worker;
      t3 = t1 && !!self.postMessage;
      this.isWorker = t3;
      if (!t3)
        t2 = t2 != null && $.get$IsolateNatives_thisScript() != null;
      else
        t2 = true;
      this.supportsWorkers = t2;
      this.fromCommandLine = t1 && !t3;
    },
    _nativeInitWorkerMessageHandler$0: function() {
      self.onmessage = function(f, a) {
        return function(e) {
          f(a, e);
        };
      }(H.IsolateNatives__processWorkerMessage, this.mainManager);
      self.dartPrint = self.dartPrint || function(serialize) {
        return function(object) {
          if (self.console && self.console.log)
            self.console.log(object);
          else
            self.postMessage(serialize(object));
        };
      }(H._Manager__serializePrintMessage);
    },
    static: {_Manager__serializePrintMessage: function(object) {
        var t1 = P.LinkedHashMap_LinkedHashMap$_literal(["command", "print", "msg", object], null, null);
        return new H._Serializer(true, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$identity(null, P.$int), "$isMap", [null, P.$int], "$asMap"), "$isMap", [null, P.$int], "$asMap")).serialize$1(t1);
      }}
  },
  _IsolateContext: {
    "^": "Object;id,ports,weakPorts,isolateStatics<,controlPort<,pauseCapability,terminateCapability,initialized,isPaused,delayedEvents,pauseTokens,doneHandlers,_scheduledControlEvents,_isExecutingEvent,errorsAreFatal,errorPorts",
    addPause$2: function(authentification, resume) {
      H.interceptedTypeCheck(authentification, "$isCapability");
      H.interceptedTypeCheck(resume, "$isCapability");
      if (!this.pauseCapability.$eq(0, authentification))
        return;
      if (this.pauseTokens.add$1(0, resume) && !this.isPaused)
        this.isPaused = true;
      this._updateGlobalState$0();
    },
    removePause$1: function(resume) {
      var t1, t2, $event, t3, t4, t5;
      H.interceptedTypeCheck(resume, "$isCapability");
      if (!this.isPaused)
        return;
      t1 = this.pauseTokens;
      t1.remove$1(0, resume);
      if (t1._collection$_length === 0) {
        for (t1 = this.delayedEvents; t2 = t1.length, t2 !== 0;) {
          if (0 >= t2)
            return H.ioore(t1, 0);
          $event = t1.pop();
          t2 = init.globalState.topEventLoop.events;
          H.assertSubtypeOfRuntimeType($event, H.getTypeArgumentByIndex(t2, 0));
          t3 = t2._head;
          t4 = t2._table;
          t5 = t4.length;
          t3 = (t3 - 1 & t5 - 1) >>> 0;
          t2._head = t3;
          if (t3 < 0 || t3 >= t5)
            return H.ioore(t4, t3);
          t4[t3] = $event;
          if (t3 === t2._tail)
            t2._grow$0();
          ++t2._modificationCount;
        }
        this.isPaused = false;
      }
      this._updateGlobalState$0();
    },
    addDoneListener$1: function(responsePort) {
      var t1;
      H.interceptedTypeCheck(responsePort, "$isSendPort");
      t1 = this.doneHandlers;
      if (t1 == null) {
        t1 = [];
        this.doneHandlers = t1;
      }
      if ((t1 && C.JSArray_methods).contains$1(t1, responsePort))
        return;
      t1 = this.doneHandlers;
      (t1 && C.JSArray_methods).add$1(t1, responsePort);
    },
    removeDoneListener$1: function(responsePort) {
      var t1;
      H.interceptedTypeCheck(responsePort, "$isSendPort");
      t1 = this.doneHandlers;
      if (t1 == null)
        return;
      (t1 && C.JSArray_methods).remove$1(t1, responsePort);
    },
    setErrorsFatal$2: function(authentification, errorsAreFatal) {
      H.interceptedTypeCheck(authentification, "$isCapability");
      H.boolTypeCheck(errorsAreFatal);
      if (!this.terminateCapability.$eq(0, authentification))
        return;
      this.errorsAreFatal = errorsAreFatal;
    },
    handlePing$2: function(responsePort, pingType) {
      var t1, t2;
      H.interceptedTypeCheck(responsePort, "$isSendPort");
      H.intTypeCheck(pingType);
      if (pingType !== 0)
        t1 = pingType === 1 && !this._isExecutingEvent;
      else
        t1 = true;
      if (t1) {
        responsePort.send$1(null);
        return;
      }
      t1 = new H._IsolateContext_handlePing_respond(responsePort);
      if (pingType === 2) {
        t2 = init.globalState.topEventLoop.events;
        t1 = new H._IsolateEvent(this, t1, "ping");
        H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(t2, 0));
        t2._add$1(t1);
        return;
      }
      H.assertHelper(pingType === 1);
      t2 = this._scheduledControlEvents;
      if (t2 == null) {
        t2 = P.ListQueue$(null, null);
        this._scheduledControlEvents = t2;
      }
      t2.toString;
      H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(t2, 0));
      t2._add$1(t1);
    },
    handleKill$2: function(authentification, priority) {
      var t1, t2;
      H.interceptedTypeCheck(authentification, "$isCapability");
      H.intTypeCheck(priority);
      if (!this.terminateCapability.$eq(0, authentification))
        return;
      if (priority !== 0)
        t1 = priority === 1 && !this._isExecutingEvent;
      else
        t1 = true;
      if (t1) {
        this.kill$0();
        return;
      }
      if (priority === 2) {
        t1 = init.globalState.topEventLoop;
        t2 = this.get$kill();
        t1 = t1.events;
        t2 = new H._IsolateEvent(this, t2, "kill");
        H.assertSubtypeOfRuntimeType(t2, H.getTypeArgumentByIndex(t1, 0));
        t1._add$1(t2);
        return;
      }
      H.assertHelper(priority === 1);
      t1 = this._scheduledControlEvents;
      if (t1 == null) {
        t1 = P.ListQueue$(null, null);
        this._scheduledControlEvents = t1;
      }
      t2 = this.get$kill();
      t1.toString;
      H.assertSubtypeOfRuntimeType(t2, H.getTypeArgumentByIndex(t1, 0));
      t1._add$1(t2);
    },
    handleUncaughtError$2: function(error, stackTrace) {
      var t1, message, t2;
      t1 = this.errorPorts;
      if (t1._collection$_length === 0) {
        if (H.boolConversionCheck(this.errorsAreFatal) && this === init.globalState.rootContext)
          return;
        if (self.console && self.console.error)
          self.console.error(error, stackTrace);
        else {
          P.print(error);
          if (stackTrace != null)
            P.print(stackTrace);
        }
        return;
      }
      message = Array(2);
      message.fixed$length = Array;
      message[0] = J.toString$0(error);
      message[1] = stackTrace == null ? null : stackTrace.toString$0(0);
      for (t2 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._collection$_modifications, null, H.assertSubtypeOfRuntimeType(null, null)), [null]), t2._collection$_cell = t2._set._collection$_first, H.assertSubtype(t2, "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"); t2.moveNext$0();)
        H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t2._collection$_current, H.getTypeArgumentByIndex(t2, 0)), "$isSendPort").send$1(message);
    },
    eval$1: function(code) {
      var old, result, oldIsExecutingEvent, e, s, exception, t1;
      old = init.globalState.currentContext;
      init.globalState.currentContext = this;
      $ = this.isolateStatics;
      result = null;
      oldIsExecutingEvent = this._isExecutingEvent;
      this._isExecutingEvent = true;
      try {
        result = code.call$0();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        this.handleUncaughtError$2(e, s);
        if (H.boolConversionCheck(this.errorsAreFatal)) {
          this.kill$0();
          if (this === init.globalState.rootContext)
            throw exception;
        }
      } finally {
        this._isExecutingEvent = H.boolTypeCheck(oldIsExecutingEvent);
        init.globalState.currentContext = H.interceptedTypeCheck(old, "$is_IsolateContext");
        if (old != null)
          $ = old.get$isolateStatics();
        if (this._scheduledControlEvents != null)
          for (; t1 = this._scheduledControlEvents, !t1.get$isEmpty(t1);)
            this._scheduledControlEvents.removeFirst$0().call$0();
      }
      return result;
    },
    lookup$1: function(portId) {
      return H.interceptedTypeCheck(this.ports.$index(0, portId), "$isRawReceivePortImpl");
    },
    _addRegistration$2: function(portId, port) {
      var t1 = this.ports;
      if (t1.containsKey$1(portId))
        throw H.wrapException(P.Exception_Exception("Registry: ports must be registered only once."));
      t1.$indexSet(0, portId, port);
    },
    _updateGlobalState$0: function() {
      if (this.ports.__js_helper$_length - this.weakPorts._collection$_length > 0 || this.isPaused || !this.initialized)
        init.globalState.isolates.$indexSet(0, this.id, this);
      else
        this.kill$0();
    },
    kill$0: [function() {
      var t1, t2, t3, t4, t5, t6, t7;
      t1 = this._scheduledControlEvents;
      if (t1 != null)
        t1.clear$0(0);
      for (t1 = this.ports, t2 = t1.get$values(), t3 = J.get$iterator$a(t2.__internal$_iterable), t4 = t2._f, t5 = H.getTypeArgumentByIndex(t2, 0), t6 = H.getTypeArgumentByIndex(t2, 1), H.assertSubtype(t3, "$isIterator", [t5], "$asIterator"), t7 = H.buildFunctionType(H.convertRtiToRuntimeType(t6), [H.convertRtiToRuntimeType(t5)]), t7._assertCheck$1(t4), t2 = H.assertSubtype(H.setRuntimeTypeInfo(new H.MappedIterator(H.assertSubtypeOfRuntimeType(null, t6), H.assertSubtype(t3, "$isIterator", [t5], "$asIterator"), t7._assertCheck$1(t4)), [t5, t6]), "$isIterator", [H.getTypeArgumentByIndex(t2, 1)], "$asIterator"); t2.moveNext$0();)
        H.assertSubtypeOfRuntimeType(t2.__internal$_current, H.getTypeArgumentByIndex(t2, 1)).__isolate_helper$_close$0();
      t1.clear$0(0);
      this.weakPorts.clear$0(0);
      init.globalState.isolates.remove$1(0, this.id);
      this.errorPorts.clear$0(0);
      t1 = this.doneHandlers;
      if (t1 != null) {
        for (t1.toString, t2 = H.getTypeArgumentByIndex(t1, 0), H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3 = t1.length, t1 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"); t1.moveNext$0();)
          H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0)), "$isSendPort").send$1(null);
        this.doneHandlers = null;
      }
    }, "call$0", "get$kill", 0, 0, 4]
  },
  _IsolateContext_handlePing_respond: {
    "^": "Closure:4;_captured_responsePort_0",
    call$0: function() {
      this._captured_responsePort_0.send$1(null);
    }
  },
  _EventLoop: {
    "^": "Object;events,_activeJsAsyncCount",
    dequeue$0: function() {
      var t1 = this.events;
      if (t1._head === t1._tail)
        return;
      return H.interceptedTypeCheck(t1.removeFirst$0(), "$is_IsolateEvent");
    },
    runIteration$0: function() {
      var $event, t1, t2;
      $event = this.dequeue$0();
      if ($event == null) {
        if (init.globalState.rootContext != null && init.globalState.isolates.containsKey$1(init.globalState.rootContext.id) && H.boolConversionCheck(init.globalState.fromCommandLine) && init.globalState.rootContext.ports.__js_helper$_length === 0)
          H.throwExpression(P.Exception_Exception("Program exited with open ReceivePorts."));
        t1 = init.globalState;
        if (H.boolConversionCheck(t1.isWorker) && t1.isolates.__js_helper$_length === 0 && t1.topEventLoop._activeJsAsyncCount === 0) {
          t1 = t1.mainManager;
          t2 = P.LinkedHashMap_LinkedHashMap$_literal(["command", "close"], null, null);
          t2 = new H._Serializer(true, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$identity(null, P.$int), "$isMap", [null, P.$int], "$asMap"), "$isMap", [null, P.$int], "$asMap")).serialize$1(t2);
          t1.toString;
          self.postMessage(t2);
        }
        return false;
      }
      $event.process$0();
      return true;
    },
    _runHelper$0: function() {
      if (self.window != null)
        new H._EventLoop__runHelper_next(this).call$0();
      else
        for (; this.runIteration$0();)
          ;
    },
    run$0: function() {
      var e, trace, exception, t1, t2;
      if (!H.boolConversionCheck(init.globalState.isWorker))
        this._runHelper$0();
      else
        try {
          this._runHelper$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          trace = H.getTraceFromException(exception);
          t1 = init.globalState.mainManager;
          t2 = P.LinkedHashMap_LinkedHashMap$_literal(["command", "error", "msg", H.S(e) + "\n" + H.S(trace)], null, null);
          t2 = new H._Serializer(true, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$identity(null, P.$int), "$isMap", [null, P.$int], "$asMap"), "$isMap", [null, P.$int], "$asMap")).serialize$1(t2);
          t1.toString;
          self.postMessage(t2);
        }
    }
  },
  _EventLoop__runHelper_next: {
    "^": "Closure:4;_captured_this_0",
    call$0: function() {
      if (!this._captured_this_0.runIteration$0())
        return;
      H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(this);
      P.Timer_Timer(C.Duration_0, this);
    }
  },
  _IsolateEvent: {
    "^": "Object;isolate,fn,message",
    process$0: function() {
      var t1 = this.isolate;
      if (t1.isPaused) {
        C.JSArray_methods.add$1(t1.delayedEvents, this);
        return;
      }
      t1.eval$1(this.fn);
    }
  },
  _MainManagerStub: {
    "^": "Object;"
  },
  IsolateNatives__processWorkerMessage_closure: {
    "^": "Closure:1;_captured_entryPoint_0,_captured_args_1,_captured_message_2,_captured_isSpawnUri_3,_captured_startPaused_4,_captured_replyTo_5",
    call$0: function() {
      H.IsolateNatives__startIsolate(this._captured_entryPoint_0, this._captured_args_1, this._captured_message_2, this._captured_isSpawnUri_3, this._captured_startPaused_4, this._captured_replyTo_5);
    }
  },
  IsolateNatives__startIsolate_runStartFunction: {
    "^": "Closure:4;_captured_topLevel_0,_captured_args_1,_captured_message_2,_captured_isSpawnUri_3,_captured_context_4",
    call$0: function() {
      var t1, t2, t3;
      this._captured_context_4.initialized = true;
      if (!H.boolConversionCheck(this._captured_isSpawnUri_3))
        this._captured_topLevel_0.call$1(this._captured_message_2);
      else {
        t1 = this._captured_topLevel_0;
        t2 = H.getDynamicRuntimeType();
        t3 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
        if (t3)
          t1.call$2(this._captured_args_1, this._captured_message_2);
        else {
          t2 = H.buildFunctionType(t2, [t2])._isTest$1(t1);
          if (t2)
            t1.call$1(this._captured_args_1);
          else
            t1.call$0();
        }
      }
    }
  },
  _BaseSendPort: {
    "^": "Object;",
    $isSendPort: 1,
    $isCapability: 1
  },
  _NativeJsSendPort: {
    "^": "_BaseSendPort;_receivePort,_isolateId",
    send$1: function(message) {
      var isolate, t1, msg, t2;
      isolate = init.globalState.isolates.$index(0, this._isolateId);
      if (isolate == null)
        return;
      t1 = this._receivePort;
      if (t1._isClosed)
        return;
      msg = H._clone(message);
      if (isolate.get$controlPort() === t1) {
        t1 = J.getInterceptor$as(msg);
        switch (t1.$index(msg, 0)) {
          case "pause":
            isolate.addPause$2(t1.$index(msg, 1), t1.$index(msg, 2));
            break;
          case "resume":
            isolate.removePause$1(t1.$index(msg, 1));
            break;
          case "add-ondone":
            isolate.addDoneListener$1(t1.$index(msg, 1));
            break;
          case "remove-ondone":
            isolate.removeDoneListener$1(t1.$index(msg, 1));
            break;
          case "set-errors-fatal":
            isolate.setErrorsFatal$2(t1.$index(msg, 1), t1.$index(msg, 2));
            break;
          case "ping":
            isolate.handlePing$2(t1.$index(msg, 1), t1.$index(msg, 2));
            break;
          case "kill":
            isolate.handleKill$2(t1.$index(msg, 1), t1.$index(msg, 2));
            break;
          case "getErrors":
            t1 = H.interceptedTypeCheck(t1.$index(msg, 1), "$isSendPort");
            isolate.errorPorts.add$1(0, t1);
            break;
          case "stopErrors":
            t1 = H.interceptedTypeCheck(t1.$index(msg, 1), "$isSendPort");
            isolate.errorPorts.remove$1(0, t1);
            break;
        }
        return;
      }
      t1 = init.globalState.topEventLoop;
      t2 = "receive " + H.S(message);
      t1 = t1.events;
      t2 = new H._IsolateEvent(isolate, new H._NativeJsSendPort_send_closure(this, msg), t2);
      H.assertSubtypeOfRuntimeType(t2, H.getTypeArgumentByIndex(t1, 0));
      t1._add$1(t2);
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (other instanceof H._NativeJsSendPort) {
        t1 = this._receivePort;
        t2 = other._receivePort;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return this._receivePort._id;
    },
    $isSendPort: 1,
    $isCapability: 1
  },
  _NativeJsSendPort_send_closure: {
    "^": "Closure:1;_captured_this_0,_captured_msg_1",
    call$0: function() {
      var t1 = this._captured_this_0._receivePort;
      if (!t1._isClosed)
        t1.__isolate_helper$_add$1(this._captured_msg_1);
    }
  },
  _WorkerSendPort: {
    "^": "_BaseSendPort;_workerId,_receivePortId,_isolateId",
    send$1: function(message) {
      var t1, workerMessage, manager;
      t1 = P.LinkedHashMap_LinkedHashMap$_literal(["command", "message", "port", this, "msg", message], null, null);
      workerMessage = new H._Serializer(true, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$identity(null, P.$int), "$isMap", [null, P.$int], "$asMap"), "$isMap", [null, P.$int], "$asMap")).serialize$1(t1);
      if (H.boolConversionCheck(init.globalState.isWorker)) {
        init.globalState.mainManager.toString;
        self.postMessage(workerMessage);
      } else {
        manager = init.globalState.managers.$index(0, this._workerId);
        if (manager != null)
          manager.postMessage(workerMessage);
      }
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (other instanceof H._WorkerSendPort) {
        t1 = this._workerId;
        t2 = other._workerId;
        if (t1 == null ? t2 == null : t1 === t2) {
          t1 = this._isolateId;
          t2 = other._isolateId;
          if (t1 == null ? t2 == null : t1 === t2) {
            t1 = this._receivePortId;
            t2 = other._receivePortId;
            t2 = t1 == null ? t2 == null : t1 === t2;
            t1 = t2;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1, t2;
      t1 = this._workerId;
      if (typeof t1 !== "number")
        return t1.$shl();
      t2 = this._isolateId;
      if (typeof t2 !== "number")
        return t2.$shl();
      return C.JSInt_methods.$xor((t1 << 16 ^ t2 << 8) >>> 0, this._receivePortId);
    },
    $isSendPort: 1,
    $isCapability: 1
  },
  RawReceivePortImpl: {
    "^": "Object;_id,_handler,_isClosed",
    __isolate_helper$_close$0: function() {
      this._isClosed = true;
      this._handler = null;
    },
    close$0: function() {
      var t1, t2;
      if (this._isClosed)
        return;
      this._isClosed = true;
      this._handler = null;
      t1 = init.globalState.currentContext;
      t2 = this._id;
      t1.ports.remove$1(0, t2);
      t1.weakPorts.remove$1(0, t2);
      t1._updateGlobalState$0();
    },
    __isolate_helper$_add$1: function(dataEvent) {
      if (this._isClosed)
        return;
      this._handler$1(dataEvent);
    },
    _handler$1: function(arg0) {
      return this._handler.call$1(arg0);
    },
    $isRawReceivePort: 1
  },
  ReceivePortImpl: {
    "^": "Stream;_rawPort,_controller",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1, t2, t3;
      t1 = H.getVoidRuntimeType();
      t2 = H.buildFunctionType(t1, [H.getDynamicRuntimeType()])._assertCheck$1(onData);
      t1 = H.buildFunctionType(t1)._assertCheck$1(onDone);
      t3 = this._controller;
      t3.toString;
      H.assertSubtype(t3, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle");
      return H.assertSubtype(H.setRuntimeTypeInfo(new P._ControllerStream(H.assertSubtype(t3, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle")), [null]), "$isStream", [H.getRuntimeTypeArgument(t3, "_StreamController", 0)], "$asStream").listen$4$cancelOnError$onDone$onError(t2, cancelOnError, t1, onError);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    close$0: [function() {
      this._rawPort.close$0();
      this._controller.close$0();
    }, "call$0", "get$close", 0, 0, 4],
    ReceivePortImpl$fromRawReceivePort$1: function(_rawPort) {
      var t1 = P.StreamController_StreamController(this.get$close(), null, null, null, true, null);
      this._controller = t1;
      this._rawPort._handler = t1.get$add(t1);
    },
    T0: function() {
      return H.convertRtiToRuntimeType($.functionThatReturnsNull.apply(null, this.$builtinTypeInfo));
    },
    $asStream: $.functionThatReturnsNull,
    $isReceivePort: 1
  },
  TimerImpl: {
    "^": "Object;_once,_inEventLoop,_handle",
    get$isActive: function() {
      return this._handle != null;
    },
    TimerImpl$2: function(milliseconds, callback) {
      var t1, t2, t3;
      t1 = H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(callback);
      if (milliseconds === 0)
        t2 = self.setTimeout == null || H.boolConversionCheck(init.globalState.isWorker);
      else
        t2 = false;
      if (t2) {
        this._handle = 1;
        t2 = init.globalState.topEventLoop;
        t3 = init.globalState.currentContext;
        t2 = t2.events;
        t1 = new H._IsolateEvent(t3, new H.TimerImpl_internalCallback(this, t1), "timer");
        H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(t2, 0));
        t2._add$1(t1);
        this._inEventLoop = true;
      } else if (self.setTimeout != null) {
        ++init.globalState.topEventLoop._activeJsAsyncCount;
        this._handle = self.setTimeout(H.convertDartClosureToJS(new H.TimerImpl_internalCallback0(this, t1), 0), milliseconds);
      } else {
        H.assertHelper(milliseconds > 0);
        throw H.wrapException(P.UnsupportedError$("Timer greater than 0."));
      }
    },
    $isTimer: 1,
    static: {TimerImpl$: function(milliseconds, callback) {
        var t1 = new H.TimerImpl(true, false, null);
        t1.TimerImpl$2(milliseconds, H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(callback));
        return t1;
      }}
  },
  TimerImpl_internalCallback: {
    "^": "Closure:4;_captured_this_0,_captured_callback_1",
    call$0: function() {
      this._captured_this_0._handle = null;
      this._captured_callback_1.call$0();
    }
  },
  TimerImpl_internalCallback0: {
    "^": "Closure:4;_captured_this_2,_captured_callback_3",
    call$0: function() {
      this._captured_this_2._handle = null;
      H.leaveJsAsync();
      this._captured_callback_3.call$0();
    }
  },
  CapabilityImpl: {
    "^": "Object;_id",
    get$hashCode: function(_) {
      var hash = this._id;
      hash = C.JSInt_methods._shrOtherPositive$1(hash, 0) ^ C.JSInt_methods._tdivFast$1(hash, 4294967296);
      hash = (~hash >>> 0) + (hash << 15 >>> 0) & 4294967295;
      hash = ((hash ^ hash >>> 12) >>> 0) * 5 & 4294967295;
      hash = ((hash ^ hash >>> 4) >>> 0) * 2057 & 4294967295;
      return (hash ^ hash >>> 16) >>> 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (other === this)
        return true;
      if (other instanceof H.CapabilityImpl)
        return this._id === other._id;
      return false;
    },
    $isCapability: 1
  },
  _Serializer: {
    "^": "Object;_serializeSendPorts,serializedObjectIds",
    serialize$1: [function(x) {
      var t1, serializationId, serializeTearOff, t2, t3, $name;
      if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
        return x;
      t1 = this.serializedObjectIds;
      serializationId = H.intTypeCheck(t1.$index(0, x));
      if (serializationId != null)
        return ["ref", serializationId];
      t1.$indexSet(0, x, t1.__js_helper$_length);
      t1 = J.getInterceptor(x);
      if (!!t1.$isJSIndexable)
        return this.serializeJSIndexable$1(x);
      if (!!t1.$isInternalMap) {
        H.interceptedTypeCheck(x, "$isMap");
        serializeTearOff = this.get$serialize();
        t1 = new H.LinkedHashMapKeyIterable(x);
        H.assertHelper(true);
        t1.$builtinTypeInfo = [H.getTypeArgumentByIndex(x, 0)];
        H.listSuperNativeTypeCheck(t1, "$isIterable");
        t2 = H.getDynamicRuntimeType();
        H.buildFunctionType(t2, [t1.E()])._assertCheck$1(serializeTearOff);
        t1 = H.MappedIterable_MappedIterable(t1, serializeTearOff, H.getRuntimeTypeArgument(t1, "IterableBase", 0), null);
        t1 = H.assertSubtype(P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0)), "$isList", [H.getRuntimeTypeArgument(t1, "IterableBase", 0)], "$asList");
        t3 = x.get$values();
        H.buildFunctionType(t2, [t3.E()])._assertCheck$1(serializeTearOff);
        t3 = H.MappedIterable_MappedIterable(t3, serializeTearOff, H.getRuntimeTypeArgument(t3, "IterableBase", 0), null);
        return ["map", t1, H.assertSubtype(P.List_List$from(t3, true, H.getRuntimeTypeArgument(t3, "IterableBase", 0)), "$isList", [H.getRuntimeTypeArgument(t3, "IterableBase", 0)], "$asList")];
      }
      if (!!t1.$isJSObject)
        return this.serializeJSObject$1(x);
      if (!!t1.$isInterceptor)
        this.unsupported$1(x);
      if (!!t1.$isRawReceivePort)
        this.unsupported$2(x, "RawReceivePorts can't be transmitted:");
      if (!!t1.$is_NativeJsSendPort)
        return this.serializeJsSendPort$1(x);
      if (!!t1.$is_WorkerSendPort)
        return this.serializeWorkerSendPort$1(x);
      if (!!t1.$isClosure) {
        $name = x.$name;
        if ($name == null)
          this.unsupported$2(x, "Closures can't be transmitted:");
        return ["function", $name];
      }
      return ["dart", init.classIdExtractor(x), this.serializeArrayInPlace$1(init.classFieldsExtractor(x))];
    }, "call$1", "get$serialize", 2, 0, 2],
    unsupported$2: function(x, message) {
      throw H.wrapException(P.UnsupportedError$(H.S(message == null ? "Can't transmit:" : message) + " " + H.S(x)));
    },
    unsupported$1: function(x) {
      return this.unsupported$2(x, null);
    },
    serializeJSIndexable$1: function(indexable) {
      var serialized;
      H.assertHelper(typeof indexable !== "string");
      serialized = this.serializeArray$1(indexable);
      if (!!indexable.fixed$length)
        return ["fixed", serialized];
      if (!indexable.fixed$length)
        return ["extendable", serialized];
      if (!indexable.immutable$list)
        return ["mutable", serialized];
      if (indexable.constructor === Array)
        return ["const", serialized];
      this.unsupported$2(indexable, "Can't serialize indexable: ");
    },
    serializeArray$1: function(x) {
      var serialized, i, t1;
      H.listTypeCheck(x);
      serialized = [];
      C.JSArray_methods.set$length(serialized, x.length);
      for (i = 0; i < x.length; ++i) {
        t1 = this.serialize$1(x[i]);
        if (i >= serialized.length)
          return H.ioore(serialized, i);
        serialized[i] = t1;
      }
      return serialized;
    },
    serializeArrayInPlace$1: function(x) {
      var i;
      for (i = 0; i < x.length; ++i)
        C.JSArray_methods.$indexSet(x, i, this.serialize$1(x[i]));
      return x;
    },
    serializeJSObject$1: function(x) {
      var keys, values, i, t1;
      if (!!x.constructor && x.constructor !== Object)
        this.unsupported$2(x, "Only plain JS Objects are supported:");
      keys = Object.keys(x);
      values = [];
      C.JSArray_methods.set$length(values, keys.length);
      for (i = 0; i < keys.length; ++i) {
        t1 = this.serialize$1(x[keys[i]]);
        if (i >= values.length)
          return H.ioore(values, i);
        values[i] = t1;
      }
      return ["js-object", keys, values];
    },
    serializeWorkerSendPort$1: function(x) {
      if (this._serializeSendPorts)
        return ["sendport", x._workerId, x._isolateId, x._receivePortId];
      return ["raw sendport", x];
    },
    serializeJsSendPort$1: function(x) {
      if (this._serializeSendPorts)
        return ["sendport", init.globalState.currentManagerId, x._isolateId, x._receivePort._id];
      return ["raw sendport", x];
    }
  },
  _Deserializer: {
    "^": "Object;_adjustSendPorts,deserializedObjects",
    deserialize$1: [function(x) {
      var result, t1, classId, fields, emptyInstance;
      if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
        return x;
      if (typeof x !== "object" || x === null || x.constructor !== Array)
        throw H.wrapException(P.ArgumentError$("Bad serialized message: " + H.S(x)));
      switch (C.JSArray_methods.get$first(x)) {
        case "ref":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "ref"));
          if (1 >= x.length)
            return H.ioore(x, 1);
          return C.JSArray_methods.$index(this.deserializedObjects, H.intTypeCheck(x[1]));
        case "buffer":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "buffer"));
          if (1 >= x.length)
            return H.ioore(x, 1);
          result = H.interceptedTypeCheck(x[1], "$isNativeByteBuffer");
          C.JSArray_methods.add$1(this.deserializedObjects, result);
          return result;
        case "typed":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "typed"));
          if (1 >= x.length)
            return H.ioore(x, 1);
          result = H.interceptedTypeCheck(x[1], "$isNativeTypedData");
          C.JSArray_methods.add$1(this.deserializedObjects, result);
          return result;
        case "fixed":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "fixed"));
          if (1 >= x.length)
            return H.ioore(x, 1);
          result = H.listTypeCheck(x[1]);
          C.JSArray_methods.add$1(this.deserializedObjects, result);
          t1 = H.assertSubtype(this.deserializeArrayInPlace$1(result), "$isJSArray", [null], "$asJSArray");
          H.assertHelper(true);
          t1.$builtinTypeInfo = [null];
          t1.fixed$length = Array;
          return H.assertSubtype(t1, "$isJSArray", [null], "$asJSArray");
        case "extendable":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "extendable"));
          if (1 >= x.length)
            return H.ioore(x, 1);
          result = H.listTypeCheck(x[1]);
          C.JSArray_methods.add$1(this.deserializedObjects, result);
          t1 = H.assertSubtype(this.deserializeArrayInPlace$1(result), "$isJSArray", [null], "$asJSArray");
          H.assertHelper(true);
          t1.$builtinTypeInfo = [null];
          return H.assertSubtype(t1, "$isJSArray", [null], "$asJSArray");
        case "mutable":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "mutable"));
          if (1 >= x.length)
            return H.ioore(x, 1);
          result = H.listTypeCheck(x[1]);
          C.JSArray_methods.add$1(this.deserializedObjects, result);
          return this.deserializeArrayInPlace$1(result);
        case "const":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "const"));
          if (1 >= x.length)
            return H.ioore(x, 1);
          result = H.listTypeCheck(x[1]);
          C.JSArray_methods.add$1(this.deserializedObjects, result);
          t1 = H.assertSubtype(this.deserializeArrayInPlace$1(result), "$isJSArray", [null], "$asJSArray");
          H.assertHelper(true);
          t1.$builtinTypeInfo = [null];
          t1.fixed$length = Array;
          return H.assertSubtype(t1, "$isJSArray", [null], "$asJSArray");
        case "map":
          return this.deserializeMap$1(x);
        case "sendport":
          return this.deserializeSendPort$1(x);
        case "raw sendport":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "raw sendport"));
          if (1 >= x.length)
            return H.ioore(x, 1);
          result = H.interceptedTypeCheck(x[1], "$isSendPort");
          C.JSArray_methods.add$1(this.deserializedObjects, result);
          return result;
        case "js-object":
          return this.deserializeJSObject$1(x);
        case "function":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "function"));
          if (1 >= x.length)
            return H.ioore(x, 1);
          result = H.interceptedTypeCheck(init.globalFunctions[H.stringTypeCheck(x[1])](), "$isFunction");
          C.JSArray_methods.add$1(this.deserializedObjects, result);
          return result;
        case "dart":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "dart"));
          t1 = x.length;
          if (1 >= t1)
            return H.ioore(x, 1);
          classId = H.stringTypeCheck(x[1]);
          if (2 >= t1)
            return H.ioore(x, 2);
          fields = H.listTypeCheck(x[2]);
          emptyInstance = init.instanceFromClassId(classId);
          C.JSArray_methods.add$1(this.deserializedObjects, emptyInstance);
          this.deserializeArrayInPlace$1(fields);
          return init.initializeEmptyInstance(classId, emptyInstance, fields);
        default:
          throw H.wrapException("couldn't deserialize: " + H.S(x));
      }
    }, "call$1", "get$deserialize", 2, 0, 2],
    deserializeArrayInPlace$1: function(x) {
      var i;
      H.listTypeCheck(x);
      for (i = 0; i < x.length; ++i)
        C.JSArray_methods.$indexSet(x, i, this.deserialize$1(x[i]));
      return x;
    },
    deserializeMap$1: function(x) {
      var t1, keys, values, result, i;
      if (0 >= x.length)
        return H.ioore(x, 0);
      H.assertHelper(J.$eq(x[0], "map"));
      t1 = x.length;
      if (1 >= t1)
        return H.ioore(x, 1);
      keys = H.listTypeCheck(x[1]);
      if (2 >= t1)
        return H.ioore(x, 2);
      values = H.listTypeCheck(x[2]);
      result = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      C.JSArray_methods.add$1(this.deserializedObjects, result);
      keys = J.map$1$a(keys, this.get$deserialize()).toList$0(0);
      for (t1 = J.getInterceptor$as(values), i = 0; i < keys.length; ++i)
        result.$indexSet(0, keys[i], this.deserialize$1(t1.$index(values, i)));
      return result;
    },
    deserializeSendPort$1: function(x) {
      var t1, managerId, isolateId, receivePortId, isolate, receivePort, result;
      if (0 >= x.length)
        return H.ioore(x, 0);
      H.assertHelper(J.$eq(x[0], "sendport"));
      t1 = x.length;
      if (1 >= t1)
        return H.ioore(x, 1);
      managerId = H.intTypeCheck(x[1]);
      if (2 >= t1)
        return H.ioore(x, 2);
      isolateId = H.intTypeCheck(x[2]);
      if (3 >= t1)
        return H.ioore(x, 3);
      receivePortId = H.intTypeCheck(x[3]);
      t1 = init.globalState.currentManagerId;
      if (managerId == null ? t1 == null : managerId === t1) {
        isolate = init.globalState.isolates.$index(0, isolateId);
        if (isolate == null)
          return;
        receivePort = isolate.lookup$1(receivePortId);
        if (receivePort == null)
          return;
        result = new H._NativeJsSendPort(H.interceptedTypeCheck(receivePort, "$isRawReceivePortImpl"), isolateId);
      } else
        result = new H._WorkerSendPort(managerId, receivePortId, isolateId);
      C.JSArray_methods.add$1(this.deserializedObjects, result);
      return result;
    },
    deserializeJSObject$1: function(x) {
      var t1, keys, values, o, t2, i;
      if (0 >= x.length)
        return H.ioore(x, 0);
      H.assertHelper(J.$eq(x[0], "js-object"));
      t1 = x.length;
      if (1 >= t1)
        return H.ioore(x, 1);
      keys = H.listTypeCheck(x[1]);
      if (2 >= t1)
        return H.ioore(x, 2);
      values = H.listTypeCheck(x[2]);
      o = {};
      C.JSArray_methods.add$1(this.deserializedObjects, o);
      for (t1 = J.getInterceptor$as(keys), t2 = J.getInterceptor$as(values), i = 0; i < t1.get$length(keys); ++i)
        o[t1.$index(keys, i)] = this.deserialize$1(t2.$index(values, i));
      return o;
    }
  }
}],
["_js_helper", "dart:_js_helper", , H, {
  "^": "",
  S: function(value) {
    var res;
    if (typeof value === "string")
      return value;
    if (typeof value === "number") {
      if (value !== 0)
        return "" + value;
    } else if (true === value)
      return "true";
    else if (false === value)
      return "false";
    else if (value == null)
      return "null";
    res = J.toString$0(value);
    if (typeof res !== "string")
      throw H.wrapException(P.ArgumentError$(value));
    return res;
  },
  Primitives_objectHashCode: function(object) {
    var hash = object.$identityHash;
    if (hash == null) {
      hash = Math.random() * 0x3fffffff | 0;
      object.$identityHash = hash;
    }
    return hash;
  },
  Primitives__parseIntError: function(source, handleError) {
    H.buildFunctionType(H.buildInterfaceType(P.$int), [H.buildInterfaceType(P.String)])._assertCheck$1(handleError);
    throw H.wrapException(P.FormatException$(source, null, null));
  },
  Primitives_parseInt: function(source, radix, handleError) {
    var t1, match, decimalMatch;
    t1 = H.buildFunctionType(H.buildInterfaceType(P.$int), [H.buildInterfaceType(P.String)])._assertCheck$1(handleError);
    H.checkString(source);
    match = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(source);
    if (match == null)
      return H.Primitives__parseIntError(source, t1);
    if (3 >= match.length)
      return H.ioore(match, 3);
    decimalMatch = H.stringTypeCheck(match[3]);
    if (decimalMatch != null)
      return parseInt(source, 10);
    if (match[2] != null)
      return parseInt(source, 16);
    return H.Primitives__parseIntError(source, t1);
  },
  Primitives_objectTypeName: function(object) {
    var $name, decompiled;
    $name = C.JS_CONST_8ZY(J.getInterceptor(object));
    if ($name === "Object") {
      decompiled = String(object.constructor).match(/^\s*function\s*(\S*)\s*\(/)[1];
      if (typeof decompiled === "string")
        $name = /^\w+$/.test(decompiled) ? decompiled : $name;
    }
    if ($name.length > 1 && C.JSString_methods.codeUnitAt$1($name, 0) === 36)
      $name = C.JSString_methods.substring$1($name, 1);
    return ($name + H.joinArguments(H.listTypeCheck(H.getRuntimeTypeInfo(object)), 0, null)).replace(/[^<,> ]+/g, function(m) {
      return init.mangledGlobalNames[m] || m;
    });
  },
  Primitives_objectToString: function(object) {
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Primitives_stringFromCharCode: function(charCode) {
    var bits;
    if (charCode <= 65535)
      return String.fromCharCode(charCode);
    if (charCode <= 1114111) {
      bits = charCode - 65536;
      return String.fromCharCode((55296 | C.JSInt_methods._shrOtherPositive$1(bits, 10)) >>> 0, 56320 | bits & 1023);
    }
    throw H.wrapException(P.RangeError$range(charCode, 0, 1114111, null, null));
  },
  Primitives_getProperty: function(object, key) {
    if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
      throw H.wrapException(P.ArgumentError$(object));
    return object[key];
  },
  Primitives_setProperty: function(object, key, value) {
    if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
      throw H.wrapException(P.ArgumentError$(object));
    object[key] = value;
  },
  iae: function(argument) {
    throw H.wrapException(P.ArgumentError$(argument));
  },
  ioore: function(receiver, index) {
    if (receiver == null)
      J.get$length$as(receiver);
    if (typeof index !== "number" || Math.floor(index) !== index)
      H.iae(index);
    throw H.wrapException(P.RangeError$value(index, null, null));
  },
  checkInt: function(value) {
    return value;
  },
  checkString: function(value) {
    if (typeof value !== "string")
      throw H.wrapException(P.ArgumentError$(value));
    return value;
  },
  wrapException: function(ex) {
    var wrapper;
    if (ex == null)
      ex = new P.NullThrownError();
    wrapper = new Error();
    wrapper.dartException = ex;
    if ("defineProperty" in Object) {
      Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
      wrapper.name = "";
    } else
      wrapper.toString = H.toStringWrapper;
    return wrapper;
  },
  toStringWrapper: function() {
    return J.toString$0(this.dartException);
  },
  throwExpression: function(ex) {
    throw H.wrapException(ex);
  },
  unwrapException: function(ex) {
    var t1, message, number, ieErrorCode, t2, t3, t4, nullLiteralCall, t5, t6, t7, t8, t9, match;
    t1 = new H.unwrapException_saveStackTrace(ex);
    if (ex == null)
      return;
    if (typeof ex !== "object")
      return ex;
    if ("dartException" in ex)
      return t1.call$1(ex.dartException);
    else if (!("message" in ex))
      return ex;
    message = ex.message;
    if ("number" in ex && typeof ex.number == "number") {
      number = ex.number;
      ieErrorCode = number & 65535;
      if ((C.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
        switch (ieErrorCode) {
          case 438:
            return t1.call$1(H.JsNoSuchMethodError$(H.S(message) + " (Error " + ieErrorCode + ")", null));
          case 445:
          case 5007:
            t2 = H.S(message) + " (Error " + ieErrorCode + ")";
            return t1.call$1(new H.NullError(t2, null));
        }
    }
    if (ex instanceof TypeError) {
      t2 = $.get$TypeErrorDecoder_noSuchMethodPattern();
      t3 = $.get$TypeErrorDecoder_notClosurePattern();
      t4 = $.get$TypeErrorDecoder_nullCallPattern();
      nullLiteralCall = $.get$TypeErrorDecoder_nullLiteralCallPattern();
      t5 = $.get$TypeErrorDecoder_undefinedCallPattern();
      t6 = $.get$TypeErrorDecoder_undefinedLiteralCallPattern();
      t7 = $.get$TypeErrorDecoder_nullPropertyPattern();
      $.get$TypeErrorDecoder_nullLiteralPropertyPattern();
      t8 = $.get$TypeErrorDecoder_undefinedPropertyPattern();
      t9 = $.get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
      match = t2.matchTypeError$1(message);
      if (match != null)
        return t1.call$1(H.JsNoSuchMethodError$(message, match));
      else {
        match = t3.matchTypeError$1(message);
        if (match != null) {
          match.method = "call";
          return t1.call$1(H.JsNoSuchMethodError$(message, match));
        } else {
          match = t4.matchTypeError$1(message);
          if (match == null) {
            match = nullLiteralCall.matchTypeError$1(message);
            if (match == null) {
              match = t5.matchTypeError$1(message);
              if (match == null) {
                match = t6.matchTypeError$1(message);
                if (match == null) {
                  match = t7.matchTypeError$1(message);
                  if (match == null) {
                    match = nullLiteralCall.matchTypeError$1(message);
                    if (match == null) {
                      match = t8.matchTypeError$1(message);
                      if (match == null) {
                        match = t9.matchTypeError$1(message);
                        t2 = match != null;
                      } else
                        t2 = true;
                    } else
                      t2 = true;
                  } else
                    t2 = true;
                } else
                  t2 = true;
              } else
                t2 = true;
            } else
              t2 = true;
          } else
            t2 = true;
          if (t2) {
            H.stringTypeCheck(message);
            return t1.call$1(new H.NullError(message, H.stringTypeCheck(match == null ? null : match.method)));
          }
        }
      }
      return t1.call$1(new H.UnknownJsTypeError(H.stringTypeCheck(typeof message === "string" ? message : "")));
    }
    if (ex instanceof RangeError) {
      if (typeof message === "string" && message.indexOf("call stack") !== -1)
        return new P.StackOverflowError();
      return t1.call$1(new P.ArgumentError(false, null, null, null));
    }
    if (typeof InternalError == "function" && ex instanceof InternalError)
      if (typeof message === "string" && message === "too much recursion")
        return new P.StackOverflowError();
    return ex;
  },
  getTraceFromException: function(exception) {
    return new H._StackTrace(exception, null);
  },
  objectHashCode: function(object) {
    if (object == null || typeof object != 'object')
      return J.get$hashCode$(object);
    else
      return H.Primitives_objectHashCode(object);
  },
  fillLiteralMap: function(keyValuePairs, result) {
    var t1, $length, index, index0, key;
    t1 = typeof keyValuePairs === "object" && keyValuePairs !== null && keyValuePairs.constructor === Array;
    H.assertHelper(t1);
    $length = keyValuePairs.length;
    for (index = 0; index < $length;) {
      index0 = index + 1;
      H.assertHelper(t1);
      key = keyValuePairs[index];
      index = index0 + 1;
      H.assertHelper(t1);
      result.$indexSet(0, key, keyValuePairs[index0]);
    }
    return result;
  },
  invokeClosure: function(closure, isolate, numberOfArguments, arg1, arg2, arg3, arg4) {
    H.interceptedTypeCheck(closure, "$isFunction");
    H.intTypeCheck(numberOfArguments);
    if (numberOfArguments === 0)
      return H._callInIsolate(isolate, new H.invokeClosure_closure(closure));
    else if (numberOfArguments === 1)
      return H._callInIsolate(isolate, new H.invokeClosure_closure0(closure, arg1));
    else if (numberOfArguments === 2)
      return H._callInIsolate(isolate, new H.invokeClosure_closure1(closure, arg1, arg2));
    else if (numberOfArguments === 3)
      return H._callInIsolate(isolate, new H.invokeClosure_closure2(closure, arg1, arg2, arg3));
    else if (numberOfArguments === 4)
      return H._callInIsolate(isolate, new H.invokeClosure_closure3(closure, arg1, arg2, arg3, arg4));
    else
      throw H.wrapException(P.Exception_Exception("Unsupported number of arguments for wrapped closure"));
  },
  convertDartClosureToJS: function(closure, arity) {
    var $function = closure.$identity;
    if (!!$function)
      return $function;
    $function = function(closure, arity, context, invoke) {
      return function(a1, a2, a3, a4) {
        return invoke(closure, context, arity, a1, a2, a3, a4);
      };
    }(closure, arity, init.globalState.currentContext, H.invokeClosure);
    closure.$identity = $function;
    return $function;
  },
  Closure_fromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, propertyName) {
    var $function, callName, functionType, $prototype, $constructor, t1, isIntercepted, trampoline, signatureFunction, getReceiver, i, stub, stubCallName, t2;
    $function = functions[0];
    $function.$stubName;
    callName = $function.$callName;
    if (!!J.getInterceptor(reflectionInfo).$isList) {
      $function.$reflectionInfo = reflectionInfo;
      functionType = H.ReflectionInfo_ReflectionInfo($function).functionType;
    } else
      functionType = reflectionInfo;
    $prototype = isStatic ? Object.create(new H.TearOffClosure().constructor.prototype) : Object.create(new H.BoundClosure(null, null, null, null).constructor.prototype);
    $prototype.$initialize = $prototype.constructor;
    if (isStatic)
      $constructor = function() {
        this.$initialize();
      };
    else {
      t1 = $.Closure_functionCounter;
      if (typeof t1 !== "number")
        return t1.$add();
      $.Closure_functionCounter = t1 + 1;
      t1 = new Function("a", "b", "c", "d", "this.$initialize(a,b,c,d);" + t1);
      $constructor = t1;
    }
    $prototype.constructor = $constructor;
    $constructor.prototype = $prototype;
    t1 = !isStatic;
    if (t1) {
      isIntercepted = jsArguments.length == 1 && true;
      trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
      trampoline.$reflectionInfo = reflectionInfo;
    } else {
      $prototype.$name = propertyName;
      trampoline = $function;
      isIntercepted = false;
    }
    if (typeof functionType == "number")
      signatureFunction = function(s) {
        return function() {
          return init.types[s];
        };
      }(functionType);
    else if (t1 && typeof functionType == "function") {
      getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
      signatureFunction = function(f, r) {
        return function() {
          return f.apply({$receiver: r(this)}, arguments);
        };
      }(functionType, getReceiver);
    } else
      throw H.wrapException("Error in reflectionInfo.");
    $prototype.$signature = signatureFunction;
    $prototype[callName] = trampoline;
    for (t1 = functions.length, i = 1; i < t1; ++i) {
      stub = functions[i];
      stubCallName = stub.$callName;
      if (stubCallName != null) {
        t2 = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
        $prototype[stubCallName] = t2;
      }
    }
    $prototype["call*"] = trampoline;
    $prototype.$requiredArgCount = $function.$requiredArgCount;
    $prototype.$defaultValues = $function.$defaultValues;
    return $constructor;
  },
  Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
    var getSelf = H.BoundClosure_selfOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        return function(n, S) {
          return function() {
            return S(this)[n]();
          };
        }(stubName, getSelf);
      case 1:
        return function(n, S) {
          return function(a) {
            return S(this)[n](a);
          };
        }(stubName, getSelf);
      case 2:
        return function(n, S) {
          return function(a, b) {
            return S(this)[n](a, b);
          };
        }(stubName, getSelf);
      case 3:
        return function(n, S) {
          return function(a, b, c) {
            return S(this)[n](a, b, c);
          };
        }(stubName, getSelf);
      case 4:
        return function(n, S) {
          return function(a, b, c, d) {
            return S(this)[n](a, b, c, d);
          };
        }(stubName, getSelf);
      case 5:
        return function(n, S) {
          return function(a, b, c, d, e) {
            return S(this)[n](a, b, c, d, e);
          };
        }(stubName, getSelf);
      default:
        return function(f, s) {
          return function() {
            return f.apply(s(this), arguments);
          };
        }($function, getSelf);
    }
  },
  Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
    var stubName, arity, lookedUpFunction, t1, t2, $arguments;
    if (isIntercepted)
      return H.Closure_forwardInterceptedCallTo(receiver, $function);
    stubName = $function.$stubName;
    arity = $function.length;
    lookedUpFunction = receiver[stubName];
    t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    t2 = !t1 || arity >= 27;
    if (t2)
      return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
    if (arity === 0) {
      t1 = $.BoundClosure_selfFieldNameCache;
      if (t1 == null) {
        t1 = H.BoundClosure_computeFieldNamed("self");
        $.BoundClosure_selfFieldNameCache = t1;
      }
      t1 = "return function(){return this." + H.S(t1) + "." + H.S(stubName) + "();";
      t2 = $.Closure_functionCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.Closure_functionCounter = t2 + 1;
      return new Function(t1 + t2 + "}")();
    }
    H.assertHelper(1 <= arity && arity < 27);
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
    t1 = "return function(" + $arguments + "){return this.";
    t2 = $.BoundClosure_selfFieldNameCache;
    if (t2 == null) {
      t2 = H.BoundClosure_computeFieldNamed("self");
      $.BoundClosure_selfFieldNameCache = t2;
    }
    t2 = t1 + H.S(t2) + "." + H.S(stubName) + "(" + $arguments + ");";
    t1 = $.Closure_functionCounter;
    if (typeof t1 !== "number")
      return t1.$add();
    $.Closure_functionCounter = t1 + 1;
    return new Function(t2 + t1 + "}")();
  },
  Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
    var getSelf, getReceiver;
    getSelf = H.BoundClosure_selfOf;
    getReceiver = H.BoundClosure_receiverOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        throw H.wrapException(H.RuntimeError$("Intercepted function with no arguments."));
      case 1:
        return function(n, s, r) {
          return function() {
            return s(this)[n](r(this));
          };
        }($name, getSelf, getReceiver);
      case 2:
        return function(n, s, r) {
          return function(a) {
            return s(this)[n](r(this), a);
          };
        }($name, getSelf, getReceiver);
      case 3:
        return function(n, s, r) {
          return function(a, b) {
            return s(this)[n](r(this), a, b);
          };
        }($name, getSelf, getReceiver);
      case 4:
        return function(n, s, r) {
          return function(a, b, c) {
            return s(this)[n](r(this), a, b, c);
          };
        }($name, getSelf, getReceiver);
      case 5:
        return function(n, s, r) {
          return function(a, b, c, d) {
            return s(this)[n](r(this), a, b, c, d);
          };
        }($name, getSelf, getReceiver);
      case 6:
        return function(n, s, r) {
          return function(a, b, c, d, e) {
            return s(this)[n](r(this), a, b, c, d, e);
          };
        }($name, getSelf, getReceiver);
      default:
        return function(f, s, r, a) {
          return function() {
            a = [r(this)];
            Array.prototype.push.apply(a, arguments);
            return f.apply(s(this), a);
          };
        }($function, getSelf, getReceiver);
    }
  },
  Closure_forwardInterceptedCallTo: function(receiver, $function) {
    var selfField, t1, stubName, arity, lookedUpFunction, t2, t3, $arguments;
    selfField = H.BoundClosure_selfFieldName();
    t1 = $.BoundClosure_receiverFieldNameCache;
    if (t1 == null) {
      t1 = H.BoundClosure_computeFieldNamed("receiver");
      $.BoundClosure_receiverFieldNameCache = t1;
    }
    stubName = $function.$stubName;
    arity = $function.length;
    lookedUpFunction = receiver[stubName];
    t2 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    t3 = !t2 || arity >= 28;
    if (t3)
      return H.Closure_cspForwardInterceptedCall(arity, !t2, stubName, $function);
    if (arity === 1) {
      t1 = "return function(){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ");";
      t2 = $.Closure_functionCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.Closure_functionCounter = t2 + 1;
      return new Function(t1 + t2 + "}")();
    }
    H.assertHelper(1 < arity && arity < 28);
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
    t1 = "return function(" + $arguments + "){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ", " + $arguments + ");";
    t2 = $.Closure_functionCounter;
    if (typeof t2 !== "number")
      return t2.$add();
    $.Closure_functionCounter = t2 + 1;
    return new Function(t1 + t2 + "}")();
  },
  closureFromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, $name) {
    var t1;
    H.listTypeCheck(functions);
    functions.fixed$length = Array;
    if (!!J.getInterceptor(reflectionInfo).$isList) {
      reflectionInfo.fixed$length = Array;
      t1 = reflectionInfo;
    } else
      t1 = reflectionInfo;
    return H.Closure_fromTearOff(receiver, functions, t1, !!isStatic, jsArguments, $name);
  },
  boolConversionCheck: function(value) {
    if (typeof value === "boolean")
      return value;
    H.boolTypeCheck(value);
    H.assertHelper(value != null);
    return false;
  },
  stringTypeCheck: function(value) {
    if (value == null)
      return value;
    if (typeof value === "string")
      return value;
    throw H.wrapException(H.TypeErrorImplementation$(value, "String"));
  },
  stringTypeCast: function(value) {
    if (typeof value === "string" || value == null)
      return value;
    throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), "String"));
  },
  doubleTypeCheck: function(value) {
    if (value == null)
      return value;
    if (typeof value === "number")
      return value;
    throw H.wrapException(H.TypeErrorImplementation$(value, "double"));
  },
  numTypeCheck: function(value) {
    if (value == null)
      return value;
    if (typeof value === "number")
      return value;
    throw H.wrapException(H.TypeErrorImplementation$(value, "num"));
  },
  boolTypeCheck: function(value) {
    if (value == null)
      return value;
    if (typeof value === "boolean")
      return value;
    throw H.wrapException(H.TypeErrorImplementation$(value, "bool"));
  },
  boolTypeCast: function(value) {
    if (typeof value === "boolean" || value == null)
      return value;
    throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), "bool"));
  },
  intTypeCheck: function(value) {
    if (value == null)
      return value;
    if (typeof value === "number" && Math.floor(value) === value)
      return value;
    throw H.wrapException(H.TypeErrorImplementation$(value, "int"));
  },
  intTypeCast: function(value) {
    if (typeof value === "number" && Math.floor(value) === value || value == null)
      return value;
    throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), "int"));
  },
  propertyTypeError: function(value, property) {
    var t1 = J.getInterceptor$as(property);
    throw H.wrapException(H.TypeErrorImplementation$(value, t1.substring$2(property, 3, t1.get$length(property))));
  },
  propertyTypeCastError: function(value, property) {
    var t1 = J.getInterceptor$as(property);
    throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), t1.substring$2(property, 3, t1.get$length(property))));
  },
  interceptedTypeCheck: function(value, property) {
    if (value == null)
      return value;
    if (typeof value === "object" && J.getInterceptor(value)[property])
      return value;
    H.propertyTypeError(value, property);
  },
  interceptedTypeCast: function(value, property) {
    var t1;
    if (value != null)
      t1 = typeof value === "object" && J.getInterceptor(value)[property];
    else
      t1 = true;
    if (t1)
      return value;
    H.propertyTypeCastError(value, property);
  },
  numberOrStringSuperNativeTypeCheck: function(value, property) {
    if (value == null)
      return value;
    if (typeof value === "string")
      return value;
    if (typeof value === "number")
      return value;
    if (J.getInterceptor(value)[property])
      return value;
    H.propertyTypeError(value, property);
  },
  stringSuperNativeTypeCheck: function(value, property) {
    if (value == null)
      return value;
    if (typeof value === "string")
      return value;
    if (J.getInterceptor(value)[property])
      return value;
    H.propertyTypeError(value, property);
  },
  listTypeCheck: function(value) {
    if (value == null)
      return value;
    if (!!J.getInterceptor(value).$isList)
      return value;
    throw H.wrapException(H.TypeErrorImplementation$(value, "List"));
  },
  listTypeCast: function(value) {
    if (!!J.getInterceptor(value).$isList || value == null)
      return value;
    throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), "List"));
  },
  listSuperNativeTypeCheck: function(value, property) {
    if (value == null)
      return value;
    if (!!J.getInterceptor(value).$isList)
      return value;
    if (J.getInterceptor(value)[property])
      return value;
    H.propertyTypeError(value, property);
  },
  voidTypeCheck: function(value) {
    if (value == null)
      return value;
    throw H.wrapException(H.TypeErrorImplementation$(value, "void"));
  },
  assertHelper: function(condition) {
    if (typeof condition !== "boolean") {
      if (!!J.getInterceptor(condition).$isFunction)
        condition = condition.call$0();
      if (typeof condition !== "boolean")
        throw H.wrapException(H.TypeErrorImplementation$(condition, "bool"));
    }
    if (true !== condition)
      throw H.wrapException(new P.AssertionError());
  },
  throwCyclicInit: function(staticName) {
    throw H.wrapException(new P.CyclicInitializationError("Cyclic initialization for static " + H.S(H.stringTypeCheck(staticName))));
  },
  buildFunctionType: function(returnType, parameterTypes, optionalParameterTypes) {
    H.interceptedTypeCheck(returnType, "$isRuntimeType");
    H.assertSubtype(parameterTypes, "$isList", [H.RuntimeType], "$asList");
    H.assertSubtype(optionalParameterTypes, "$isList", [H.RuntimeType], "$asList");
    return new H.RuntimeFunctionType(returnType, H.assertSubtype(parameterTypes, "$isList", [H.RuntimeType], "$asList"), H.assertSubtype(optionalParameterTypes, "$isList", [H.RuntimeType], "$asList"), null);
  },
  buildNamedFunctionType: function(returnType, parameterTypes, namedParameters) {
    H.interceptedTypeCheck(returnType, "$isRuntimeType");
    H.assertSubtype(parameterTypes, "$isList", [H.RuntimeType], "$asList");
    H.assertSubtype(null, "$isList", [H.RuntimeType], "$asList");
    return new H.RuntimeFunctionType(returnType, H.assertSubtype(parameterTypes, "$isList", [H.RuntimeType], "$asList"), H.assertSubtype(null, "$isList", [H.RuntimeType], "$asList"), namedParameters);
  },
  buildInterfaceType: function(rti, typeArguments) {
    var $name = rti.name;
    if (typeArguments == null || typeArguments.length === 0)
      return new H.RuntimeTypePlain($name);
    H.assertSubtype(typeArguments, "$isList", [H.RuntimeType], "$asList");
    return new H.RuntimeTypeGeneric($name, H.assertSubtype(typeArguments, "$isList", [H.RuntimeType], "$asList"), null);
  },
  getDynamicRuntimeType: function() {
    return C.C_DynamicRuntimeType;
  },
  getVoidRuntimeType: function() {
    return C.C_VoidRuntimeType;
  },
  convertRtiToRuntimeType: function(rti) {
    var list, t1, $name, $arguments, i;
    if (rti == null)
      return C.C_DynamicRuntimeType;
    else if (typeof rti == "function")
      return new H.RuntimeTypePlain(rti.name);
    else if (rti.constructor == Array) {
      list = rti;
      t1 = list.length;
      if (0 >= t1)
        return H.ioore(list, 0);
      $name = list[0].name;
      $arguments = [];
      for (i = 1; i < t1; ++i)
        C.JSArray_methods.add$1($arguments, H.convertRtiToRuntimeType(list[i]));
      H.assertSubtype($arguments, "$isList", [H.RuntimeType], "$asList");
      return new H.RuntimeTypeGeneric($name, H.assertSubtype($arguments, "$isList", [H.RuntimeType], "$asList"), rti);
    } else if ("func" in rti)
      return C.C_DynamicRuntimeType;
    else
      throw H.wrapException(H.RuntimeError$("Cannot convert '" + JSON.stringify(rti) + "' to RuntimeType."));
  },
  random64: function() {
    return (Math.random() * 0x100000000 >>> 0) + (Math.random() * 0x100000000 >>> 0) * 4294967296;
  },
  setRuntimeTypeInfo: function(target, typeInfo) {
    H.assertHelper(typeInfo == null || typeof typeInfo === "object" && typeInfo !== null && typeInfo.constructor === Array);
    if (target != null)
      target.$builtinTypeInfo = typeInfo;
    return target;
  },
  getRuntimeTypeInfo: function(target) {
    if (target == null)
      return;
    return target.$builtinTypeInfo;
  },
  getRuntimeTypeArguments: function(target, substitutionName) {
    return H.substitute(target["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
  },
  getRuntimeTypeArgument: function(target, substitutionName, index) {
    var $arguments, t1;
    H.stringTypeCheck(substitutionName);
    H.intTypeCheck(index);
    $arguments = H.getRuntimeTypeArguments(target, substitutionName);
    if ($arguments == null)
      t1 = null;
    else {
      H.assertHelper(typeof $arguments === "object" && $arguments !== null && $arguments.constructor === Array);
      t1 = $arguments[index];
    }
    return t1;
  },
  getTypeArgumentByIndex: function(target, index) {
    var rti, t1;
    H.intTypeCheck(index);
    rti = H.getRuntimeTypeInfo(target);
    if (rti == null)
      t1 = null;
    else {
      H.assertHelper(typeof rti === "object" && rti !== null && rti.constructor === Array);
      t1 = rti[index];
    }
    return t1;
  },
  runtimeTypeToString: function(type, onTypeVariable) {
    var t1, t2;
    t1 = H.buildFunctionType(H.buildInterfaceType(P.String), [H.buildInterfaceType(P.$int)]);
    t2 = t1._assertCheck$1(onTypeVariable);
    if (type == null)
      return "dynamic";
    else if (typeof type === "object" && type !== null && type.constructor === Array) {
      t1._assertCheck$1(t2);
      H.assertHelper(true);
      H.assertHelper(true);
      return type[0].builtin$cls + H.joinArguments(type, 1, t2);
    } else if (typeof type == "function")
      return type.builtin$cls;
    else if (typeof type === "number" && Math.floor(type) === type)
      return C.JSInt_methods.toString$0(type);
    else
      return;
  },
  joinArguments: function(types, startIndex, onTypeVariable) {
    var t1, t2, buffer, index, firstArgument, allDynamic, argument;
    t1 = H.buildFunctionType(H.buildInterfaceType(P.String), [H.buildInterfaceType(P.$int)])._assertCheck$1(onTypeVariable);
    if (types == null)
      return "";
    t2 = typeof types === "object" && types !== null && types.constructor === Array;
    H.assertHelper(t2);
    buffer = new P.StringBuffer("");
    for (index = startIndex, firstArgument = true, allDynamic = true; H.assertHelper(t2), index < types.length; ++index) {
      if (firstArgument)
        firstArgument = false;
      else
        buffer._contents += ", ";
      H.assertHelper(t2);
      argument = types[index];
      if (argument != null)
        allDynamic = false;
      buffer._contents += H.S(H.runtimeTypeToString(argument, t1));
    }
    return allDynamic ? "" : "<" + H.S(buffer) + ">";
  },
  getRuntimeTypeString: function(object) {
    var className = J.getInterceptor(object).constructor.builtin$cls;
    if (object == null)
      return className;
    return className + H.joinArguments(object.$builtinTypeInfo, 0, null);
  },
  getRuntimeType: function(object) {
    return new H.TypeImpl(H.getRuntimeTypeString(object), null);
  },
  substitute: function(substitution, $arguments) {
    H.assertHelper(substitution == null || typeof substitution == "function");
    H.assertHelper($arguments == null || typeof $arguments === "object" && $arguments !== null && $arguments.constructor === Array);
    if (typeof substitution == "function") {
      substitution = H.invokeOn(substitution, null, $arguments);
      if (substitution == null || typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
        $arguments = substitution;
      else if (typeof substitution == "function")
        $arguments = H.invokeOn(substitution, null, $arguments);
    }
    return $arguments;
  },
  checkSubtype: function(object, isField, checks, asField) {
    var $arguments, interceptor;
    H.stringTypeCheck(isField);
    H.listTypeCheck(checks);
    H.stringTypeCheck(asField);
    if (object == null)
      return false;
    $arguments = H.getRuntimeTypeInfo(object);
    interceptor = J.getInterceptor(object);
    if (interceptor[isField] == null)
      return false;
    return H.areSubtypes(H.substitute(interceptor[asField], $arguments), checks);
  },
  computeTypeName: function(isField, $arguments) {
    return (J.substring$2$s(isField, 3, isField.length) + H.joinArguments($arguments, 0, null)).replace(/[^<,> ]+/g, function(m) {
      return init.mangledGlobalNames[m] || m;
    });
  },
  subtypeCast: function(object, isField, checks, asField) {
    H.stringTypeCheck(isField);
    H.listTypeCheck(checks);
    H.stringTypeCheck(asField);
    if (object != null && !H.checkSubtype(object, isField, checks, asField))
      throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(object), H.computeTypeName(isField, checks)));
    return object;
  },
  assertSubtype: function(object, isField, checks, asField) {
    H.stringTypeCheck(isField);
    H.listTypeCheck(checks);
    H.stringTypeCheck(asField);
    if (object != null && !H.checkSubtype(object, isField, checks, asField))
      throw H.wrapException(H.TypeErrorImplementation$(object, H.computeTypeName(isField, checks)));
    return object;
  },
  areSubtypes: function(s, t) {
    var t1, t2, t3, len, i;
    if (s == null || t == null)
      return true;
    t1 = typeof s === "object" && s !== null && s.constructor === Array;
    H.assertHelper(t1);
    t2 = typeof t === "object" && t !== null && t.constructor === Array;
    H.assertHelper(t2);
    H.assertHelper(t1);
    t3 = s.length;
    H.assertHelper(t2);
    H.assertHelper(t3 === t.length);
    H.assertHelper(t1);
    len = s.length;
    for (i = 0; i < len; ++i) {
      H.assertHelper(t1);
      t3 = s[i];
      H.assertHelper(t2);
      if (!H.isSubtype(t3, t[i]))
        return false;
    }
    return true;
  },
  computeSignature: function(signature, context, contextName) {
    return H.invokeOn(signature, context, H.getRuntimeTypeArguments(context, contextName));
  },
  checkSubtypeOfRuntimeType: function(o, t) {
    var rti, type, targetSignatureFunction;
    if (o == null)
      return t == null || t.builtin$cls === "Object" || t.builtin$cls === "Null";
    if (t == null)
      return true;
    rti = H.getRuntimeTypeInfo(o);
    o = J.getInterceptor(o);
    type = o.constructor;
    if (rti != null) {
      rti = rti.slice();
      rti.splice(0, 0, type);
      type = rti;
    } else if ("func" in t) {
      if ("$is_" + H.S(t.func) in o)
        return true;
      targetSignatureFunction = o.$signature;
      if (targetSignatureFunction == null)
        return false;
      return H.isFunctionSubtype(H.invokeOn(targetSignatureFunction, o, null), t);
    }
    return H.isSubtype(type, t);
  },
  assertSubtypeOfRuntimeType: function(object, type) {
    if (object != null && !H.checkSubtypeOfRuntimeType(object, type))
      throw H.wrapException(H.TypeErrorImplementation$(object, H.runtimeTypeToString(type, null)));
    return object;
  },
  isSubtype: function(s, t) {
    var t1, typeOfS, t2, typeOfT, $name, test, typeOfSPrototype, substitution;
    if (s === t)
      return true;
    if (s == null || t == null)
      return true;
    if ("func" in t)
      return H.isFunctionSubtype(s, t);
    if ("func" in s)
      return t.builtin$cls === "Function";
    t1 = typeof s === "object" && s !== null && s.constructor === Array;
    if (t1) {
      H.assertHelper(true);
      typeOfS = s[0];
    } else
      typeOfS = s;
    t2 = typeof t === "object" && t !== null && t.constructor === Array;
    if (t2) {
      H.assertHelper(true);
      typeOfT = t[0];
    } else
      typeOfT = t;
    $name = H.runtimeTypeToString(typeOfT, null);
    if (typeOfT !== typeOfS) {
      test = "$is" + H.S($name);
      typeOfSPrototype = typeOfS.prototype;
      if (!(test in typeOfSPrototype))
        return false;
      substitution = typeOfSPrototype["$as" + H.S(H.runtimeTypeToString(typeOfT, null))];
    } else
      substitution = null;
    if (!t1 && substitution == null || !t2)
      return true;
    t1 = t1 ? s.slice(1) : null;
    t2 = t2 ? t.slice(1) : null;
    return H.areSubtypes(H.substitute(substitution, t1), t2);
  },
  areAssignable: function(s, t, allowShorter) {
    var t1, t2, sLength, tLength, i, t3, t4;
    H.listTypeCheck(s);
    H.listTypeCheck(t);
    t1 = t == null;
    if (t1 && s == null)
      return true;
    if (t1)
      return allowShorter;
    if (s == null)
      return false;
    t1 = typeof s === "object" && s !== null && s.constructor === Array;
    H.assertHelper(t1);
    t2 = typeof t === "object" && t !== null && t.constructor === Array;
    H.assertHelper(t2);
    H.assertHelper(t1);
    sLength = s.length;
    H.assertHelper(t2);
    tLength = t.length;
    if (allowShorter) {
      if (sLength < tLength)
        return false;
    } else if (sLength !== tLength)
      return false;
    for (i = 0; i < tLength; ++i) {
      H.assertHelper(t1);
      t3 = s[i];
      H.assertHelper(t2);
      t4 = t[i];
      if (!(H.isSubtype(t3, t4) || H.isSubtype(t4, t3)))
        return false;
    }
    return true;
  },
  areAssignableMaps: function(s, t) {
    var t1, names, i, $name, tType, sType;
    if (t == null)
      return true;
    if (s == null)
      return false;
    H.assertHelper(typeof s == 'object');
    H.assertHelper(typeof t == 'object');
    t1 = H.listTypeCheck(Object.getOwnPropertyNames(t));
    t1.fixed$length = Array;
    names = t1;
    for (t1 = names.length, i = 0; i < t1; ++i) {
      $name = names[i];
      if (!Object.hasOwnProperty.call(s, $name))
        return false;
      tType = t[$name];
      sType = s[$name];
      if (!(H.isSubtype(tType, sType) || H.isSubtype(sType, tType)))
        return false;
    }
    return true;
  },
  isFunctionSubtype: function(s, t) {
    var sReturnType, tReturnType, sParameterTypes, tParameterTypes, sOptionalParameterTypes, tOptionalParameterTypes, sParametersLen, tParametersLen, sOptionalParametersLen, tOptionalParametersLen, t1, t2, pos, t3, t4, tPos, sPos;
    H.assertHelper("func" in t);
    if (!("func" in s))
      return false;
    if ("void" in s) {
      if (!("void" in t) && "ret" in t)
        return false;
    } else if (!("void" in t)) {
      sReturnType = s.ret;
      tReturnType = t.ret;
      if (!(H.isSubtype(sReturnType, tReturnType) || H.isSubtype(tReturnType, sReturnType)))
        return false;
    }
    sParameterTypes = s.args;
    tParameterTypes = t.args;
    sOptionalParameterTypes = s.opt;
    tOptionalParameterTypes = t.opt;
    if (sParameterTypes != null) {
      H.assertHelper(typeof sParameterTypes === "object" && sParameterTypes !== null && sParameterTypes.constructor === Array);
      sParametersLen = sParameterTypes.length;
    } else
      sParametersLen = 0;
    if (tParameterTypes != null) {
      H.assertHelper(typeof tParameterTypes === "object" && tParameterTypes !== null && tParameterTypes.constructor === Array);
      tParametersLen = tParameterTypes.length;
    } else
      tParametersLen = 0;
    if (sOptionalParameterTypes != null) {
      H.assertHelper(typeof sOptionalParameterTypes === "object" && sOptionalParameterTypes !== null && sOptionalParameterTypes.constructor === Array);
      sOptionalParametersLen = sOptionalParameterTypes.length;
    } else
      sOptionalParametersLen = 0;
    if (tOptionalParameterTypes != null) {
      H.assertHelper(typeof tOptionalParameterTypes === "object" && tOptionalParameterTypes !== null && tOptionalParameterTypes.constructor === Array);
      tOptionalParametersLen = tOptionalParameterTypes.length;
    } else
      tOptionalParametersLen = 0;
    if (sParametersLen > tParametersLen)
      return false;
    if (sParametersLen + sOptionalParametersLen < tParametersLen + tOptionalParametersLen)
      return false;
    if (sParametersLen === tParametersLen) {
      if (!H.areAssignable(sParameterTypes, tParameterTypes, false))
        return false;
      if (!H.areAssignable(sOptionalParameterTypes, tOptionalParameterTypes, true))
        return false;
    } else {
      for (t1 = typeof sParameterTypes === "object" && sParameterTypes !== null && sParameterTypes.constructor === Array, t2 = typeof tParameterTypes === "object" && tParameterTypes !== null && tParameterTypes.constructor === Array, pos = 0; pos < sParametersLen; ++pos) {
        H.assertHelper(t1);
        t3 = sParameterTypes[pos];
        H.assertHelper(t2);
        t4 = tParameterTypes[pos];
        if (!(H.isSubtype(t3, t4) || H.isSubtype(t4, t3)))
          return false;
      }
      for (t1 = typeof sOptionalParameterTypes === "object" && sOptionalParameterTypes !== null && sOptionalParameterTypes.constructor === Array, tPos = pos, sPos = 0; tPos < tParametersLen; ++sPos, ++tPos) {
        H.assertHelper(t1);
        t3 = sOptionalParameterTypes[sPos];
        H.assertHelper(t2);
        t4 = tParameterTypes[tPos];
        if (!(H.isSubtype(t3, t4) || H.isSubtype(t4, t3)))
          return false;
      }
      for (t2 = typeof tOptionalParameterTypes === "object" && tOptionalParameterTypes !== null && tOptionalParameterTypes.constructor === Array, tPos = 0; tPos < tOptionalParametersLen; ++sPos, ++tPos) {
        H.assertHelper(t1);
        t3 = sOptionalParameterTypes[sPos];
        H.assertHelper(t2);
        t4 = tOptionalParameterTypes[tPos];
        if (!(H.isSubtype(t3, t4) || H.isSubtype(t4, t3)))
          return false;
      }
    }
    return H.areAssignableMaps(s.named, t.named);
  },
  invokeOn: function($function, receiver, $arguments) {
    H.assertHelper(typeof $function == "function");
    H.assertHelper($arguments == null || typeof $arguments === "object" && $arguments !== null && $arguments.constructor === Array);
    return $function.apply(receiver, $arguments);
  },
  defineProperty: function(obj, property, value) {
    Object.defineProperty(obj, H.stringTypeCheck(property), {value: value, enumerable: false, writable: true, configurable: true});
  },
  allMatchesInStringUnchecked: function(pattern, string, startIndex) {
    var result, $length, patternLength, position, endIndex;
    result = H.assertSubtype(H.setRuntimeTypeInfo([], [P.Match]), "$isList", [P.Match], "$asList");
    $length = string.length;
    patternLength = pattern.length;
    for (; true;) {
      position = string.indexOf(pattern, startIndex);
      if (position === -1)
        break;
      C.JSArray_methods.add$1(result, new H.StringMatch(position, string, pattern));
      endIndex = position + patternLength;
      if (endIndex === $length)
        break;
      else
        startIndex = position === endIndex ? startIndex + 1 : endIndex;
    }
    return H.assertSubtype(result, "$isList", [P.Match], "$asList");
  },
  stringContainsUnchecked: function(receiver, other, startIndex) {
    var t1;
    if (typeof other === "string")
      return receiver.indexOf(other, startIndex) >= 0;
    else {
      t1 = J.getInterceptor(other);
      if (!!t1.$isJSSyntaxRegExp)
        return other._nativeRegExp.test(H.checkString(C.JSString_methods.substring$1(receiver, startIndex)));
      else
        return J.get$isNotEmpty$as(t1.allMatches$1(other, C.JSString_methods.substring$1(receiver, startIndex)));
    }
  },
  stringReplaceAllUnchecked: function(receiver, pattern, replacement) {
    var result, $length, t1, i;
    H.checkString(replacement);
    if (pattern === "")
      if (receiver === "")
        return replacement;
      else {
        result = new P.StringBuffer("");
        $length = receiver.length;
        t1 = H.S(replacement);
        result._contents = t1;
        for (i = 0; i < $length; ++i) {
          result._contents = t1 + receiver[i];
          t1 = result._contents += H.S(replacement);
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
    else
      return receiver.replace(new RegExp(pattern.replace(new RegExp("[[\\]{}()*+?.\\\\^$|]", 'g'), "\\$&"), 'g'), replacement.replace(/\$/g, "$$$$"));
  },
  _matchString: [function(match) {
    return match.$index(0, 0);
  }, "call$1", "_matchString$closure", 2, 0, 61],
  _stringIdentity: [function(string) {
    return string;
  }, "call$1", "_stringIdentity$closure", 2, 0, 44],
  stringReplaceAllFuncUnchecked: function(receiver, pattern, onMatch, onNonMatch) {
    var t1, buffer, startIndex, match, t2, t3;
    onNonMatch = H._stringIdentity$closure();
    t1 = J.getInterceptor(pattern);
    if (!t1.$isPattern)
      throw H.wrapException(P.ArgumentError$(t1.toString$0(pattern) + " is not a Pattern"));
    buffer = new P.StringBuffer("");
    for (t1 = t1.allMatches$1(pattern, receiver), t1 = H.assertSubtype(new H._AllMatchesIterator(t1._re, t1._string, t1._start, null), "$isIterator", [P.Match], "$asIterator"), startIndex = 0; t1.moveNext$0();) {
      match = t1.__js_helper$_current;
      t2 = match._match;
      buffer._contents += H.S(onNonMatch.call$1(C.JSString_methods.substring$2(receiver, startIndex, t2.index)));
      buffer._contents += H.S(onMatch.call$1(match));
      t3 = t2.index;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      startIndex = H.intTypeCheck(C.JSInt_methods.$add(t3, J.get$length$as(t2[0])));
    }
    t1 = buffer._contents += H.S(onNonMatch.call$1(C.JSString_methods.substring$1(receiver, startIndex)));
    return t1.charCodeAt(0) == 0 ? t1 : t1;
  },
  stringReplaceFirstUnchecked: function(receiver, pattern, replacement, startIndex) {
    var index, t1, t2, t3, matches, match, end;
    if (typeof pattern === "string") {
      index = receiver.indexOf(pattern, startIndex);
      if (index < 0)
        return receiver;
      return H.stringReplaceRangeUnchecked(receiver, index, index + pattern.length, replacement);
    }
    if (pattern == null)
      H.throwExpression(P.ArgumentError$(null));
    t1 = J.allMatches$2$s(pattern, receiver, startIndex);
    t2 = H.getTypeArgumentByIndex(t1, 0);
    H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray");
    t3 = t1.length;
    matches = H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"), "$isIterator", [P.Match], "$asIterator");
    if (!matches.moveNext$0())
      return receiver;
    match = H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(matches._current, H.getTypeArgumentByIndex(matches, 0)), "$isMatch");
    t1 = match.get$start();
    t2 = match.get$end();
    H.checkString(replacement);
    H.checkInt(t1);
    end = P.RangeError_checkValidRange(t1, t2, receiver.length, null, null, null);
    H.checkInt(end);
    return H.stringReplaceRangeUnchecked(receiver, t1, end, replacement);
  },
  stringReplaceRangeUnchecked: function(receiver, start, end, replacement) {
    var prefix, suffix;
    prefix = receiver.substring(0, start);
    suffix = receiver.substring(end);
    return prefix + H.S(replacement) + suffix;
  },
  ReflectionInfo: {
    "^": "Object;jsFunction,data,isAccessor,requiredParameterCount,optionalParameterCount,areOptionalParametersNamed,functionType,cachedSortedIndices",
    static: {ReflectionInfo_ReflectionInfo: function(jsFunction) {
        var data, requiredParametersInfo, optionalParametersInfo;
        data = jsFunction.$reflectionInfo;
        if (data == null)
          return;
        data.fixed$length = Array;
        data = data;
        requiredParametersInfo = data[0];
        optionalParametersInfo = data[1];
        return new H.ReflectionInfo(jsFunction, data, (requiredParametersInfo & 1) === 1, requiredParametersInfo >> 1, optionalParametersInfo >> 1, (optionalParametersInfo & 1) === 1, data[2], null);
      }}
  },
  TypeErrorDecoder: {
    "^": "Object;_pattern,_arguments,_argumentsExpr,_expr,_method,_receiver",
    matchTypeError$1: function(message) {
      var match, result, t1;
      match = new RegExp(this._pattern).exec(message);
      if (match == null)
        return;
      result = Object.create(null);
      t1 = this._arguments;
      if (t1 !== -1)
        result.arguments = match[t1 + 1];
      t1 = this._argumentsExpr;
      if (t1 !== -1)
        result.argumentsExpr = match[t1 + 1];
      t1 = this._expr;
      if (t1 !== -1)
        result.expr = match[t1 + 1];
      t1 = this._method;
      if (t1 !== -1)
        result.method = match[t1 + 1];
      t1 = this._receiver;
      if (t1 !== -1)
        result.receiver = match[t1 + 1];
      return result;
    },
    static: {TypeErrorDecoder_extractPattern: function(message) {
        var match, $arguments, argumentsExpr, expr, method, receiver;
        message = message.replace(String({}), '$receiver$').replace(new RegExp("[[\\]{}()*+?.\\\\^$|]", 'g'), '\\$&');
        match = H.assertSubtype(message.match(/\\\$[a-zA-Z]+\\\$/g), "$isList", [P.String], "$asList");
        if (match == null)
          match = H.assertSubtype([], "$isList", [P.String], "$asList");
        $arguments = match.indexOf("\\$arguments\\$");
        argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
        expr = match.indexOf("\\$expr\\$");
        method = match.indexOf("\\$method\\$");
        receiver = match.indexOf("\\$receiver\\$");
        return new H.TypeErrorDecoder(message.replace('\\$arguments\\$', '((?:x|[^x])*)').replace('\\$argumentsExpr\\$', '((?:x|[^x])*)').replace('\\$expr\\$', '((?:x|[^x])*)').replace('\\$method\\$', '((?:x|[^x])*)').replace('\\$receiver\\$', '((?:x|[^x])*)'), $arguments, argumentsExpr, expr, method, receiver);
      }, TypeErrorDecoder_provokeCallErrorOn: function(expression) {
        return function($expr$) {
          var $argumentsExpr$ = '$arguments$';
          try {
            $expr$.$method$($argumentsExpr$);
          } catch (e) {
            return e.message;
          }
        }(expression);
      }, TypeErrorDecoder_provokePropertyErrorOn: function(expression) {
        return function($expr$) {
          try {
            $expr$.$method$;
          } catch (e) {
            return e.message;
          }
        }(expression);
      }}
  },
  NullError: {
    "^": "Error;_message,_method",
    toString$0: function(_) {
      var t1 = this._method;
      if (t1 == null)
        return "NullError: " + H.S(this._message);
      return "NullError: Cannot call \"" + H.S(t1) + "\" on null";
    }
  },
  JsNoSuchMethodError: {
    "^": "Error;_message,_method,_receiver",
    toString$0: function(_) {
      var t1, t2;
      t1 = this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + H.S(this._message);
      t2 = this._receiver;
      if (t2 == null)
        return "NoSuchMethodError: Cannot call \"" + H.S(t1) + "\" (" + H.S(this._message) + ")";
      return "NoSuchMethodError: Cannot call \"" + H.S(t1) + "\" on \"" + H.S(t2) + "\" (" + H.S(this._message) + ")";
    },
    static: {JsNoSuchMethodError$: function(_message, match) {
        var t1, t2;
        H.stringTypeCheck(_message);
        t1 = match == null;
        t2 = t1 ? null : match.method;
        return new H.JsNoSuchMethodError(_message, t2, t1 ? null : match.receiver);
      }}
  },
  UnknownJsTypeError: {
    "^": "Error;_message",
    toString$0: function(_) {
      var t1 = this._message;
      return C.JSString_methods.get$isEmpty(t1) ? "Error" : "Error: " + t1;
    }
  },
  unwrapException_saveStackTrace: {
    "^": "Closure:2;_captured_ex_0",
    call$1: function(error) {
      if (!!J.getInterceptor(error).$isError)
        if (error.$thrownJsError == null)
          error.$thrownJsError = this._captured_ex_0;
      return error;
    }
  },
  _StackTrace: {
    "^": "Object;_exception,_trace",
    toString$0: function(_) {
      var t1, trace;
      t1 = this._trace;
      if (t1 != null)
        return t1;
      t1 = this._exception;
      trace = t1 !== null && typeof t1 === "object" ? t1.stack : null;
      t1 = trace == null ? "" : trace;
      this._trace = t1;
      return t1;
    },
    $isStackTrace: 1
  },
  invokeClosure_closure: {
    "^": "Closure:1;_captured_closure_0",
    call$0: function() {
      return this._captured_closure_0.call$0();
    }
  },
  invokeClosure_closure0: {
    "^": "Closure:1;_captured_closure_1,_captured_arg1_2",
    call$0: function() {
      return this._captured_closure_1.call$1(this._captured_arg1_2);
    }
  },
  invokeClosure_closure1: {
    "^": "Closure:1;_captured_closure_3,_captured_arg1_4,_captured_arg2_5",
    call$0: function() {
      return this._captured_closure_3.call$2(this._captured_arg1_4, this._captured_arg2_5);
    }
  },
  invokeClosure_closure2: {
    "^": "Closure:1;_captured_closure_6,_captured_arg1_7,_captured_arg2_8,_captured_arg3_9",
    call$0: function() {
      return this._captured_closure_6.call$3(this._captured_arg1_7, this._captured_arg2_8, this._captured_arg3_9);
    }
  },
  invokeClosure_closure3: {
    "^": "Closure:1;_captured_closure_10,_captured_arg1_11,_captured_arg2_12,_captured_arg3_13,_captured_arg4_14",
    call$0: function() {
      return this._captured_closure_10.call$4(this._captured_arg1_11, this._captured_arg2_12, this._captured_arg3_13, this._captured_arg4_14);
    }
  },
  Closure: {
    "^": "Object;",
    toString$0: function(_) {
      return "Closure";
    },
    get$$call: function() {
      return this;
    },
    $isFunction: 1,
    get$$call: function() {
      return this;
    }
  },
  TearOffClosure: {
    "^": "Closure;"
  },
  BoundClosure: {
    "^": "TearOffClosure;_self,_target,_receiver,__js_helper$_name",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!(other instanceof H.BoundClosure))
        return false;
      return this._self === other._self && this._target === other._target && this._receiver === other._receiver;
    },
    get$hashCode: function(_) {
      var t1, receiverHashCode;
      t1 = this._receiver;
      if (t1 == null)
        receiverHashCode = H.Primitives_objectHashCode(this._self);
      else
        receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
      return (receiverHashCode ^ H.Primitives_objectHashCode(this._target)) >>> 0;
    },
    static: {BoundClosure_selfOf: function(closure) {
        return closure._self;
      }, BoundClosure_receiverOf: function(closure) {
        return closure._receiver;
      }, BoundClosure_selfFieldName: function() {
        var t1 = $.BoundClosure_selfFieldNameCache;
        if (t1 == null) {
          t1 = H.BoundClosure_computeFieldNamed("self");
          $.BoundClosure_selfFieldNameCache = t1;
        }
        return t1;
      }, BoundClosure_computeFieldNamed: function(fieldName) {
        var template, t1, names, i, $name;
        template = new H.BoundClosure("self", "target", "receiver", "name");
        t1 = H.listTypeCheck(Object.getOwnPropertyNames(template));
        t1.fixed$length = Array;
        names = t1;
        for (t1 = names.length, i = 0; i < t1; ++i) {
          $name = names[i];
          if (template[$name] === fieldName)
            return $name;
        }
      }}
  },
  TypeErrorImplementation: {
    "^": "Error;message",
    toString$0: function(_) {
      return this.message;
    },
    static: {TypeErrorImplementation$: function(value, type) {
        return new H.TypeErrorImplementation("type '" + H.Primitives_objectTypeName(value) + "' is not a subtype of type '" + H.S(type) + "'");
      }}
  },
  CastErrorImplementation: {
    "^": "Error;message",
    toString$0: function(_) {
      return this.message;
    },
    static: {CastErrorImplementation$: function(actualType, expectedType) {
        return new H.CastErrorImplementation("CastError: Casting value of type " + H.S(actualType) + " to incompatible type " + H.S(expectedType));
      }}
  },
  RuntimeError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "RuntimeError: " + H.S(this.message);
    },
    static: {RuntimeError$: function(message) {
        return new H.RuntimeError(message);
      }}
  },
  RuntimeType: {
    "^": "Object;"
  },
  RuntimeFunctionType: {
    "^": "RuntimeType;returnType,parameterTypes,optionalParameterTypes,namedParameters",
    _isTest$1: function(expression) {
      var functionTypeObject = this._extractFunctionTypeObjectFrom$1(expression);
      return functionTypeObject == null ? false : H.isFunctionSubtype(functionTypeObject, this.toRti$0());
    },
    _assertCheck$1: function(expression) {
      var t1;
      if ($.RuntimeFunctionType_inAssert)
        return;
      $.RuntimeFunctionType_inAssert = true;
      try {
        t1 = this._check$2(expression, false);
        return t1;
      } finally {
        $.RuntimeFunctionType_inAssert = false;
      }
    },
    _check$2: function(expression, isCast) {
      var $self, functionTypeObject;
      if (expression == null)
        return;
      if (this._isTest$1(expression))
        return expression;
      $self = new H.FunctionTypeInfoDecoderRing(this.toRti$0(), null).toString$0(0);
      if (isCast) {
        functionTypeObject = this._extractFunctionTypeObjectFrom$1(expression);
        throw H.wrapException(H.CastErrorImplementation$(functionTypeObject != null ? new H.FunctionTypeInfoDecoderRing(functionTypeObject, null).toString$0(0) : H.Primitives_objectTypeName(expression), $self));
      } else
        throw H.wrapException(H.TypeErrorImplementation$(expression, $self));
    },
    _extractFunctionTypeObjectFrom$1: function(o) {
      var interceptor = J.getInterceptor(o);
      return "$signature" in interceptor ? interceptor.$signature() : null;
    },
    toRti$0: function() {
      var result, t1, t2, namedRti, keys, i, $name;
      result = {func: "dynafunc"};
      t1 = this.returnType;
      t2 = J.getInterceptor(t1);
      if (!!t2.$isVoidRuntimeType)
        result.void = true;
      else if (!t2.$isDynamicRuntimeType)
        result.ret = t1.toRti$0();
      t1 = this.parameterTypes;
      if (t1 != null && t1.length !== 0)
        result.args = H.RuntimeFunctionType_listToRti(t1);
      t1 = this.optionalParameterTypes;
      if (t1 != null && t1.length !== 0)
        result.opt = H.RuntimeFunctionType_listToRti(t1);
      t1 = this.namedParameters;
      if (t1 != null) {
        namedRti = Object.create(null);
        keys = H.extractKeys(t1);
        for (t2 = keys.length, i = 0; i < t2; ++i) {
          $name = keys[i];
          namedRti[$name] = t1[$name].toRti$0();
        }
        result.named = namedRti;
      }
      return result;
    },
    toString$0: function(_) {
      var t1, t2, result, needsComma, i, type, keys, $name;
      t1 = this.parameterTypes;
      if (t1 != null)
        for (t2 = t1.length, result = "(", needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
          type = H.interceptedTypeCheck(t1[i], "$isRuntimeType");
          if (needsComma)
            result += ", ";
          result = C.JSString_methods.$add(result, J.toString$0(type));
        }
      else {
        result = "(";
        needsComma = false;
      }
      t1 = this.optionalParameterTypes;
      if (t1 != null && t1.length !== 0) {
        result = (needsComma ? result + ", " : result) + "[";
        for (t2 = t1.length, needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
          type = H.interceptedTypeCheck(t1[i], "$isRuntimeType");
          if (needsComma)
            result += ", ";
          result = C.JSString_methods.$add(result, J.toString$0(type));
        }
        result += "]";
      } else {
        t1 = this.namedParameters;
        if (t1 != null) {
          result = (needsComma ? result + ", " : result) + "{";
          keys = H.extractKeys(t1);
          for (t2 = keys.length, needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
            $name = keys[i];
            if (needsComma)
              result += ", ";
            result += H.S(t1[$name].toRti$0()) + " " + $name;
          }
          result += "}";
        }
      }
      return result + (") -> " + J.toString$0(this.returnType));
    },
    static: {RuntimeFunctionType_listToRti: function(list) {
        var result, t1, i;
        list = list;
        result = [];
        for (t1 = list.length, i = 0; i < t1; ++i)
          result.push(list[i].toRti$0());
        return result;
      }}
  },
  DynamicRuntimeType: {
    "^": "RuntimeType;",
    toString$0: function(_) {
      return "dynamic";
    },
    toRti$0: function() {
      return;
    }
  },
  VoidRuntimeType: {
    "^": "RuntimeType;",
    toString$0: function(_) {
      return "void";
    },
    toRti$0: function() {
      return H.throwExpression("internal error");
    }
  },
  RuntimeTypePlain: {
    "^": "RuntimeType;name<",
    toRti$0: function() {
      var t1, rti;
      t1 = this.name;
      rti = init.getTypeFromName(t1);
      if (rti == null)
        throw H.wrapException("no type for '" + H.S(t1) + "'");
      return rti;
    },
    toString$0: function(_) {
      return this.name;
    }
  },
  RuntimeTypeGeneric: {
    "^": "RuntimeType;name<,$arguments,rti",
    toRti$0: function() {
      var t1, result, t2, t3;
      t1 = this.rti;
      if (t1 != null)
        return t1;
      t1 = this.name;
      result = [init.getTypeFromName(t1)];
      if (0 >= result.length)
        return H.ioore(result, 0);
      if (result[0] == null)
        throw H.wrapException("no type for '" + H.S(t1) + "<...>'");
      for (t1 = this.$arguments, t1.toString, t2 = H.getTypeArgumentByIndex(t1, 0), H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3 = t1.length, t1 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"); t1.moveNext$0();)
        result.push(H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0)), "$isRuntimeType").toRti$0());
      this.rti = result;
      return result;
    },
    toString$0: function(_) {
      var t1 = this.$arguments;
      return H.S(this.name) + "<" + (t1 && C.JSArray_methods).join$1(t1, ", ") + ">";
    }
  },
  FunctionTypeInfoDecoderRing: {
    "^": "Object;_typeData,_cachedToString",
    _convert$1: function(type) {
      var result = H.runtimeTypeToString(type, null);
      if (result != null)
        return result;
      if ("func" in type)
        return new H.FunctionTypeInfoDecoderRing(type, null).toString$0(0);
      else
        throw H.wrapException("bad type");
    },
    toString$0: function(_) {
      var t1, t2, t3, t4, s, sep, argument, $name;
      t1 = this._cachedToString;
      if (t1 != null)
        return t1;
      t1 = this._typeData;
      if ("args" in t1)
        for (t2 = t1.args, t3 = H.getTypeArgumentByIndex(t2, 0), H.assertSubtype(t2, "$isJSArray", [t3], "$asJSArray"), t4 = t2.length, t2 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t2, "$isJSArray", [t3], "$asJSArray"), t4, 0, H.assertSubtypeOfRuntimeType(null, t3)), [t3]), "$isIterator", [H.getTypeArgumentByIndex(t2, 0)], "$asIterator"), s = "(", sep = ""; t2.moveNext$0(); sep = ", ") {
          argument = H.assertSubtypeOfRuntimeType(t2._current, H.getTypeArgumentByIndex(t2, 0));
          s = C.JSString_methods.$add(s + sep, this._convert$1(argument));
        }
      else {
        s = "(";
        sep = "";
      }
      if ("opt" in t1) {
        s += sep + "[";
        for (t2 = t1.opt, t3 = H.getTypeArgumentByIndex(t2, 0), H.assertSubtype(t2, "$isJSArray", [t3], "$asJSArray"), t4 = t2.length, t2 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t2, "$isJSArray", [t3], "$asJSArray"), t4, 0, H.assertSubtypeOfRuntimeType(null, t3)), [t3]), "$isIterator", [H.getTypeArgumentByIndex(t2, 0)], "$asIterator"), sep = ""; t2.moveNext$0(); sep = ", ") {
          argument = H.assertSubtypeOfRuntimeType(t2._current, H.getTypeArgumentByIndex(t2, 0));
          s = C.JSString_methods.$add(s + sep, this._convert$1(argument));
        }
        s += "]";
      }
      if ("named" in t1) {
        s += sep + "{";
        for (t2 = H.extractKeys(t1.named), t3 = H.getTypeArgumentByIndex(t2, 0), H.assertSubtype(t2, "$isJSArray", [t3], "$asJSArray"), t2 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t2, "$isJSArray", [t3], "$asJSArray"), t2.length, 0, H.assertSubtypeOfRuntimeType(null, t3)), [t3]), "$isIterator", [H.getTypeArgumentByIndex(t2, 0)], "$asIterator"), sep = ""; t2.moveNext$0(); sep = ", ") {
          $name = H.assertSubtypeOfRuntimeType(t2._current, H.getTypeArgumentByIndex(t2, 0));
          s = C.JSString_methods.$add(s + sep + (H.S($name) + ": "), this._convert$1(t1.named[$name]));
        }
        s += "}";
      }
      s += ") -> ";
      if (!!t1.void)
        s += "void";
      else
        s = "ret" in t1 ? C.JSString_methods.$add(s, this._convert$1(t1.ret)) : s + "dynamic";
      this._cachedToString = s;
      return s;
    }
  },
  TypeImpl: {
    "^": "Object;_typeName,_unmangledName",
    toString$0: function(_) {
      var t1, unmangledName;
      t1 = this._unmangledName;
      if (t1 != null)
        return t1;
      unmangledName = this._typeName.replace(/[^<,> ]+/g, function(m) {
        return init.mangledGlobalNames[m] || m;
      });
      this._unmangledName = unmangledName;
      return unmangledName;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this._typeName);
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (other instanceof H.TypeImpl) {
        t1 = this._typeName;
        t2 = other._typeName;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    $isType: 1
  },
  JsLinkedHashMap: {
    "^": "Object;__js_helper$_length,_strings,_nums,_rest,_first,_last,_modifications",
    get$length: function(_) {
      return this.__js_helper$_length;
    },
    get$values: function() {
      return H.listSuperNativeTypeCheck(H.MappedIterable_MappedIterable(H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.LinkedHashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]), "$isIterable"), new H.JsLinkedHashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)), "$isIterable");
    },
    containsKey$1: function(key) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return false;
        return H.interceptedTypeCheck(strings[key], "$isLinkedHashMapCell") != null;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return false;
        return H.interceptedTypeCheck(nums[key], "$isLinkedHashMapCell") != null;
      } else
        return this.internalContainsKey$1(key);
    },
    internalContainsKey$1: function(key) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this.internalFindBucketIndex$2(H.listTypeCheck(rest[this.internalComputeHashCode$1(key)]), key) >= 0;
    },
    addAll$1: function(_, other) {
      H.assertSubtype(other, "$isMap", [H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)], "$asMap").forEach$1(0, new H.JsLinkedHashMap_addAll_closure(this));
    },
    $index: function(_, key) {
      var strings, cell, t1, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 1));
        cell = H.interceptedTypeCheck(strings[key], "$isLinkedHashMapCell");
        t1 = cell == null ? null : cell.hashMapCellValue;
        return H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(this, 1));
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 1));
        cell = H.interceptedTypeCheck(nums[key], "$isLinkedHashMapCell");
        t1 = cell == null ? null : cell.hashMapCellValue;
        return H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(this, 1));
      } else
        return H.assertSubtypeOfRuntimeType(this.internalGet$1(key), H.getTypeArgumentByIndex(this, 1));
    },
    internalGet$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 1));
      bucket = H.listTypeCheck(rest[this.internalComputeHashCode$1(key)]);
      index = this.internalFindBucketIndex$2(bucket, key);
      if (index < 0)
        return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 1));
      return H.assertSubtypeOfRuntimeType(H.interceptedTypeCheck(bucket[index], "$isLinkedHashMapCell").hashMapCellValue, H.getTypeArgumentByIndex(this, 1));
    },
    $indexSet: function(_, key, value) {
      var strings, nums;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1));
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          strings = H.JsLinkedHashMap__newHashTable();
          this._strings = strings;
        }
        this._addHashTableEntry$3(strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null) {
          nums = H.JsLinkedHashMap__newHashTable();
          this._nums = nums;
        }
        this._addHashTableEntry$3(nums, key, value);
      } else
        this.internalSet$2(key, value);
    },
    internalSet$2: function(key, value) {
      var rest, hash, bucket, t1, index;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1));
      rest = this._rest;
      if (rest == null) {
        rest = H.JsLinkedHashMap__newHashTable();
        this._rest = rest;
      }
      hash = this.internalComputeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null) {
        t1 = [this._newLinkedCell$2(key, value)];
        H.assertHelper(t1 != null);
        rest[hash] = t1;
      } else {
        index = this.internalFindBucketIndex$2(bucket, key);
        if (index >= 0)
          H.interceptedTypeCheck(bucket[index], "$isLinkedHashMapCell").hashMapCellValue = value;
        else
          bucket.push(this._newLinkedCell$2(key, value));
      }
    },
    remove$1: function(_, key) {
      if (typeof key === "string" && key !== "__proto__")
        return H.assertSubtypeOfRuntimeType(this.__js_helper$_removeHashTableEntry$2(this._strings, key), H.getTypeArgumentByIndex(this, 1));
      else if (typeof key === "number" && (key & 0x3ffffff) === key)
        return H.assertSubtypeOfRuntimeType(this.__js_helper$_removeHashTableEntry$2(this._nums, key), H.getTypeArgumentByIndex(this, 1));
      else
        return H.assertSubtypeOfRuntimeType(this.internalRemove$1(key), H.getTypeArgumentByIndex(this, 1));
    },
    internalRemove$1: function(key) {
      var rest, bucket, index, cell;
      rest = this._rest;
      if (rest == null)
        return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 1));
      bucket = H.listTypeCheck(rest[this.internalComputeHashCode$1(key)]);
      index = this.internalFindBucketIndex$2(bucket, key);
      if (index < 0)
        return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 1));
      cell = H.interceptedTypeCheck(bucket.splice(index, 1)[0], "$isLinkedHashMapCell");
      this.__js_helper$_unlinkCell$1(cell);
      return H.assertSubtypeOfRuntimeType(cell.hashMapCellValue, H.getTypeArgumentByIndex(this, 1));
    },
    clear$0: function(_) {
      if (this.__js_helper$_length > 0) {
        this._last = null;
        this._first = null;
        this._rest = null;
        this._nums = null;
        this._strings = null;
        this.__js_helper$_length = 0;
        this._modifications = this._modifications + 1 & 67108863;
      }
    },
    forEach$1: function(_, action) {
      var t1, cell, modifications;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [this.K(), this.V()])._assertCheck$1(action);
      cell = this._first;
      modifications = this._modifications;
      for (; cell != null;) {
        t1.call$2(cell.hashMapCellKey, cell.hashMapCellValue);
        if (modifications !== this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        cell = cell._next;
      }
    },
    _addHashTableEntry$3: function(table, key, value) {
      var cell, t1;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1));
      cell = H.interceptedTypeCheck(table[key], "$isLinkedHashMapCell");
      if (cell == null) {
        t1 = this._newLinkedCell$2(key, value);
        H.assertHelper(true);
        table[key] = t1;
      } else
        cell.hashMapCellValue = value;
    },
    __js_helper$_removeHashTableEntry$2: function(table, key) {
      var cell;
      if (table == null)
        return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 1));
      cell = H.interceptedTypeCheck(table[key], "$isLinkedHashMapCell");
      if (cell == null)
        return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 1));
      this.__js_helper$_unlinkCell$1(cell);
      delete table[key];
      return H.assertSubtypeOfRuntimeType(cell.hashMapCellValue, H.getTypeArgumentByIndex(this, 1));
    },
    _newLinkedCell$2: function(key, value) {
      var cell, last;
      cell = new H.LinkedHashMapCell(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1)), null, null);
      if (this._first == null) {
        this._last = cell;
        this._first = cell;
      } else {
        last = this._last;
        cell._previous = last;
        last._next = cell;
        this._last = cell;
      }
      ++this.__js_helper$_length;
      this._modifications = this._modifications + 1 & 67108863;
      return cell;
    },
    __js_helper$_unlinkCell$1: function(cell) {
      var previous, next, t1;
      previous = cell._previous;
      next = cell._next;
      if (previous == null) {
        t1 = this._first;
        H.assertHelper(cell == null ? t1 == null : cell === t1);
        this._first = next;
      } else
        previous._next = next;
      if (next == null) {
        t1 = this._last;
        H.assertHelper(cell == null ? t1 == null : cell === t1);
        this._last = previous;
      } else
        next._previous = previous;
      --this.__js_helper$_length;
      this._modifications = this._modifications + 1 & 67108863;
    },
    internalComputeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    internalFindBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(H.interceptedTypeCheck(bucket[i], "$isLinkedHashMapCell").hashMapCellKey, key))
          return i;
      return -1;
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    K: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    V: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[1]);
    },
    $isInternalMap: 1,
    $isLinkedHashMap: 1,
    $isMap: 1,
    static: {JsLinkedHashMap__newHashTable: function() {
        var table = Object.create(null);
        H.assertHelper(table != null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  JsLinkedHashMap_values_closure: {
    "^": "Closure:2;__js_helper$_captured_this_0",
    call$1: function(each) {
      return this.__js_helper$_captured_this_0.$index(0, each);
    }
  },
  JsLinkedHashMap_addAll_closure: {
    "^": "Closure;__js_helper$_captured_this_0",
    call$2: function(key, value) {
      var t1 = this.__js_helper$_captured_this_0;
      t1.$indexSet(0, H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(t1, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(t1, 1)));
    },
    $signature: function() {
      return H.computeSignature(function(K, V) {
        return {func: "", args: [K, V]};
      }, this.__js_helper$_captured_this_0, "JsLinkedHashMap");
    }
  },
  LinkedHashMapCell: {
    "^": "Object;hashMapCellKey,hashMapCellValue,_next,_previous"
  },
  LinkedHashMapKeyIterable: {
    "^": "IterableBase;_map",
    get$length: function(_) {
      return this._map.__js_helper$_length;
    },
    get$isEmpty: function(_) {
      return this._map.__js_helper$_length === 0;
    },
    get$iterator: function(_) {
      var t1, t2;
      t1 = this._map;
      t2 = new H.LinkedHashMapKeyIterator(t1, t1._modifications, null, H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 0)));
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      t2._cell = t1._first;
      return H.assertSubtype(t2, "$isIterator", [H.getTypeArgumentByIndex(this, 0)], "$asIterator");
    },
    forEach$1: function(_, f) {
      var t1, t2, cell, modifications;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [this.E2()])._assertCheck$1(f);
      t2 = this._map;
      cell = t2._first;
      modifications = t2._modifications;
      for (; cell != null;) {
        t1.call$1(cell.hashMapCellKey);
        if (modifications !== t2._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(t2));
        cell = cell._next;
      }
    },
    E2: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    E: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isEfficientLength: 1
  },
  LinkedHashMapKeyIterator: {
    "^": "Object;_map,_modifications,_cell,__js_helper$_current",
    set$__js_helper$_current: function(_current) {
      this.__js_helper$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    get$current: function() {
      return H.assertSubtypeOfRuntimeType(this.__js_helper$_current, H.getTypeArgumentByIndex(this, 0));
    },
    moveNext$0: function() {
      var t1 = this._map;
      if (this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = this._cell;
        if (t1 == null) {
          this.set$__js_helper$_current(null);
          return false;
        } else {
          this.set$__js_helper$_current(t1.hashMapCellKey);
          this._cell = this._cell._next;
          return true;
        }
      }
    },
    $isIterator: 1
  },
  JSSyntaxRegExp: {
    "^": "Object;pattern,_nativeRegExp,_nativeGlobalRegExp,_nativeAnchoredRegExp",
    toString$0: function(_) {
      return "RegExp/" + this.pattern + "/";
    },
    get$_nativeGlobalVersion: function() {
      var t1 = this._nativeGlobalRegExp;
      if (t1 != null)
        return t1;
      t1 = this._nativeRegExp;
      t1 = H.JSSyntaxRegExp_makeNative(this.pattern, t1.multiline, !t1.ignoreCase, true);
      this._nativeGlobalRegExp = t1;
      return t1;
    },
    get$_nativeAnchoredVersion: function() {
      var t1 = this._nativeAnchoredRegExp;
      if (t1 != null)
        return t1;
      t1 = this._nativeRegExp;
      t1 = H.JSSyntaxRegExp_makeNative(this.pattern + "|()", t1.multiline, !t1.ignoreCase, true);
      this._nativeAnchoredRegExp = t1;
      return t1;
    },
    allMatches$2: function(_, string, start) {
      H.checkString(string);
      H.checkInt(start);
      if (start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      return H.listSuperNativeTypeCheck(new H._AllMatchesIterable(this, string, start), "$isIterable");
    },
    allMatches$1: function($receiver, string) {
      return this.allMatches$2($receiver, string, 0);
    },
    _execGlobal$2: function(string, start) {
      var regexp, match;
      regexp = this.get$_nativeGlobalVersion();
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return;
      return H._MatchImplementation$(this, match);
    },
    _execAnchored$2: function(string, start) {
      var regexp, match, t1, t2;
      regexp = this.get$_nativeAnchoredVersion();
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return;
      t1 = match.length;
      t2 = t1 - 1;
      if (t2 < 0)
        return H.ioore(match, t2);
      if (match[t2] != null)
        return;
      C.JSArray_methods.set$length(match, t2);
      return H._MatchImplementation$(this, match);
    },
    matchAsPrefix$2: function(_, string, start) {
      if (start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      return this._execAnchored$2(string, start);
    },
    $isRegExp: 1,
    $isPattern: 1,
    static: {JSSyntaxRegExp_makeNative: function(source, multiLine, caseSensitive, global) {
        var m, i, g, regexp;
        H.checkString(source);
        m = multiLine ? "m" : "";
        i = caseSensitive ? "" : "i";
        g = global ? "g" : "";
        regexp = function() {
          try {
            return new RegExp(source, m + i + g);
          } catch (e) {
            return e;
          }
        }();
        if (regexp instanceof RegExp)
          return regexp;
        throw H.wrapException(P.FormatException$("Illegal RegExp pattern (" + String(regexp) + ")", source, null));
      }}
  },
  _MatchImplementation: {
    "^": "Object;pattern,_match",
    get$start: function() {
      return this._match.index;
    },
    get$end: function() {
      var t1, t2;
      t1 = this._match;
      t2 = t1.index;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return H.intTypeCheck(C.JSInt_methods.$add(t2, J.get$length$as(t1[0])));
    },
    $index: function(_, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = this._match;
      if (index >= t1.length)
        return H.ioore(t1, index);
      return H.stringTypeCheck(t1[index]);
    },
    _MatchImplementation$2: function(pattern, _match) {
      var t1, t2;
      H.assertSubtype(_match, "$isList", [P.String], "$asList");
      t1 = this._match;
      t2 = t1.input;
      H.assertHelper(typeof t2 === "string");
      t1 = t1.index;
      H.assertHelper(typeof t1 === "number" && Math.floor(t1) === t1);
    },
    $isMatch: 1,
    static: {_MatchImplementation$: function(pattern, _match) {
        var t1;
        H.assertSubtype(_match, "$isList", [P.String], "$asList");
        t1 = new H._MatchImplementation(pattern, H.assertSubtype(_match, "$isList", [P.String], "$asList"));
        t1._MatchImplementation$2(pattern, _match);
        return t1;
      }}
  },
  _AllMatchesIterable: {
    "^": "IterableBase;_re,_string,_start",
    get$iterator: function(_) {
      return H.assertSubtype(new H._AllMatchesIterator(this._re, this._string, this._start, null), "$isIterator", [P.Match], "$asIterator");
    },
    E: function() {
      return H.convertRtiToRuntimeType(function() {
        return P.Match;
      }.apply(null, this.$builtinTypeInfo));
    },
    $asIterableBase: function() {
      return [P.Match];
    },
    $asIterable: function() {
      return [P.Match];
    }
  },
  _AllMatchesIterator: {
    "^": "Object;_regExp,_string,_nextIndex,__js_helper$_current",
    get$current: function() {
      return this.__js_helper$_current;
    },
    moveNext$0: function() {
      var t1, t2, match, nextIndex;
      t1 = this._string;
      if (t1 == null)
        return false;
      t2 = this._nextIndex;
      if (t2 <= t1.length) {
        match = this._regExp._execGlobal$2(t1, t2);
        if (match != null) {
          this.__js_helper$_current = match;
          t1 = match._match;
          t2 = t1.index;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          nextIndex = H.intTypeCheck(C.JSInt_methods.$add(t2, J.get$length$as(t1[0])));
          this._nextIndex = t1.index === nextIndex ? nextIndex + 1 : nextIndex;
          return true;
        }
      }
      this.__js_helper$_current = null;
      this._string = null;
      return false;
    },
    $isIterator: 1,
    $asIterator: function() {
      return [P.Match];
    }
  },
  StringMatch: {
    "^": "Object;start<,input,pattern",
    get$end: function() {
      return this.start + this.pattern.length;
    },
    $index: function(_, g) {
      H.intTypeCheck(g);
      if (g !== 0)
        H.throwExpression(P.RangeError$value(g, null, null));
      return this.pattern;
    },
    $isMatch: 1
  }
}],
["a_star", "package:a_star/a_star.dart", , S, {
  "^": "",
  Node: {
    "^": "Object;"
  },
  AStar: {
    "^": "Object;graph,_zeroed,NO_VALID_PATH"
  }
}],
["author_script_exception", "package:egamebook/src/book/author_script_exception.dart", , M, {
  "^": "",
  AuthorScriptException: {
    "^": "Object;message,pageName,blockIndex",
    toString$0: function(_) {
      return "AuthorScriptException at page '" + H.S(this.pageName) + "', block #" + H.S(this.blockIndex) + ": " + H.S(this.message);
    },
    $isException: 1,
    static: {AuthorScriptException$: function(message) {
        return new M.AuthorScriptException(message, null, null);
      }}
  }
}],
["barbrawl", "bodega_barbrawl.dart", , T, {
  "^": "",
  BarBrawl: {
    "^": "LoopedEvent;startingOptions,allOptions,timeline:BarBrawl_timeline<,failures,additionalParagraphPresent,wasSuccessful,echo,choice,finished,onFinishedGoto,timeline,actors",
    set$startingOptions: function(startingOptions) {
      this.startingOptions = H.assertSubtype(startingOptions, "$isList", [T.BarBrawlOption], "$asList");
    },
    _initOptions$0: function() {
      var t1, whyDoThat, whyDoThat2, stopIt, hitHimBack, hitFace, hitStomach, raiseArms, sidestep, behindPilot, lookAround, useBottle;
      t1 = {};
      t1._captured_whyDoThat2_0 = null;
      whyDoThat = T.BarBrawlOption$("\"Why would you do that?\"", new T.BarBrawl__initOptions_closure(this), null, null, null, new T.BarBrawl__initOptions_closure0(t1, this), false);
      whyDoThat2 = T.BarBrawlOption$("\"\u2014ou do that?\"", new T.BarBrawl__initOptions_closure1(this, whyDoThat), null, null, null, new T.BarBrawl__initOptions_closure2(this), false);
      t1._captured_whyDoThat2_0 = whyDoThat2;
      stopIt = T.BarBrawlOption$("\"Stop it!\"", new T.BarBrawl__initOptions_closure3(this, whyDoThat), null, null, null, new T.BarBrawl__initOptions_closure4(this), false);
      hitHimBack = T.BarBrawlOption$("Hit him back", new T.BarBrawl__initOptions_closure5(this), null, null, null, new T.BarBrawl__initOptions_closure6(this), false);
      hitFace = T.BarBrawlOption$("Hit him in the face", new T.BarBrawl__initOptions_closure7(this), new T.BarBrawl__initOptions_closure8(this), null, new T.BarBrawl__initOptions_closure9(this), null, false);
      hitStomach = T.BarBrawlOption$("Hit him in the stomach", new T.BarBrawl__initOptions_closure10(this), new T.BarBrawl__initOptions_closure11(this), null, new T.BarBrawl__initOptions_closure12(this), null, false);
      raiseArms = T.BarBrawlOption$("Raise arms in defense", null, new T.BarBrawl__initOptions_closure13(this), null, new T.BarBrawl__initOptions_closure14(this), null, false);
      sidestep = T.BarBrawlOption$("Sidestep", new T.BarBrawl__initOptions_closure15(this), new T.BarBrawl__initOptions_closure16(this), new T.BarBrawl__initOptions_closure17(this), new T.BarBrawl__initOptions_closure18(this), null, false);
      behindPilot = T.BarBrawlOption$("Hide behind the pilot", new T.BarBrawl__initOptions_closure19(this), new T.BarBrawl__initOptions_closure20(this), new T.BarBrawl__initOptions_closure21(this), new T.BarBrawl__initOptions_closure22(this), null, false);
      t1._captured_useBottle_1 = null;
      lookAround = T.BarBrawlOption$("Look around for objects to hit him with", null, null, null, null, new T.BarBrawl__initOptions_closure23(t1, this), false);
      useBottle = T.BarBrawlOption$("Hit him with the bottle", new T.BarBrawl__initOptions_closure24(lookAround), new T.BarBrawl__initOptions_closure25(this), null, new T.BarBrawl__initOptions_closure26(this), null, false);
      t1._captured_useBottle_1 = useBottle;
      this.allOptions.addAll$1(0, H.setRuntimeTypeInfo([whyDoThat, hitHimBack, whyDoThat2, stopIt, hitFace, hitStomach, raiseArms, sidestep, behindPilot, lookAround, useBottle, T.BarBrawlOption$("Knee him in the crotch", null, null, null, null, new T.BarBrawl__initOptions_closure27(this), false), T.BarBrawlOption$("Undercut his legs", null, new T.BarBrawl__initOptions_closure28(this), new T.BarBrawl__initOptions_closure29(this), new T.BarBrawl__initOptions_closure30(this), null, false)], [T.BarBrawlOption]));
      this.set$startingOptions(H.setRuntimeTypeInfo([whyDoThat, hitHimBack], [T.BarBrawlOption]));
      this.additionalParagraphPresent = true;
    },
    _initTimeline$0: function() {
      var t1 = this.BarBrawl_timeline;
      t1.schedule$2(2, new T.BarBrawl__initTimeline_closure(this));
      t1.time = 0;
    },
    update$0: function() {
      var t1, t2, t3, t4, t5, t6, current, t7, additionals, added, opt;
      t1 = this.allOptions;
      t2 = new T.BarBrawl_update_closure();
      t3 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t3, [t1.E3()])._assertCheck$1(t2);
      t4 = H.getTypeArgumentByIndex(t1, 0);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
      t5 = H.getDynamicRuntimeType();
      t6 = H.buildFunctionType(t3, [t5]);
      t2 = new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), t6._assertCheck$1(t2));
      H.assertHelper(true);
      t2.$builtinTypeInfo = [t4];
      t2 = H.listSuperNativeTypeCheck(H.listSuperNativeTypeCheck(t2, "$isIterable"), "$isIterable");
      current = this.startingOptions;
      current = current != null ? current : [];
      H.assertSubtype(current, "$isList", [T.BarBrawlOption], "$asList");
      this.set$startingOptions(null);
      for (; current.length < 3;) {
        t1 = P.LinkedHashSet_LinkedHashSet$from(t2, null).difference$1(P.LinkedHashSet_LinkedHashSet$from(current, null));
        t4 = new T.BarBrawl_update_closure0(this);
        H.buildFunctionType(t3, [t1.E3()])._assertCheck$1(t4);
        t7 = H.getTypeArgumentByIndex(t1, 0);
        H.listSuperNativeTypeCheck(t1, "$isIterable");
        H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t7)])._assertCheck$1(t4);
        t4 = new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), t6._assertCheck$1(t4));
        H.assertHelper(true);
        t4.$builtinTypeInfo = [t7];
        H.listSuperNativeTypeCheck(t4, "$isIterable");
        additionals = H.assertSubtype(H.assertSubtype(P.List_List$from(t4, true, H.getRuntimeTypeArgument(t4, "IterableBase", 0)), "$isList", [H.getRuntimeTypeArgument(t4, "IterableBase", 0)], "$asList"), "$isList", [T.BarBrawlOption], "$asList");
        if (additionals.length === 0)
          break;
        added = H.interceptedTypeCheck(S.Randomly_choose(additionals), "$isBarBrawlOption");
        C.JSArray_methods.add$1(current, added);
        if (added.onSetup != null) {
          this.additionalParagraphPresent = true;
          this.echo$1("\n\n");
          added.onSetup$0();
        }
      }
      t1 = new T.BarBrawl_update_closure1();
      t2 = H.buildInterfaceType(P.$int);
      t3 = H.convertRtiToRuntimeType(current.$builtinTypeInfo && current.$builtinTypeInfo[0]);
      H.buildFunctionType(t2, [t3, t3])._assertCheck$1(t1);
      t2 = H.buildFunctionType(t2, [t5, t5]);
      t2._assertCheck$1(t1);
      t3 = current.length - 1;
      t2._assertCheck$1(t1);
      if (t3 - 0 <= 32)
        H.Sort__insertionSort(current, 0, t3, t1);
      else
        H.Sort__dualPivotQuicksort(current, 0, t3, t1);
      t1 = H.getTypeArgumentByIndex(current, 0);
      H.assertSubtype(current, "$isJSArray", [t1], "$asJSArray");
      t2 = current.length;
      t2 = new J.ArrayIterator(H.assertSubtype(current, "$isJSArray", [t1], "$asJSArray"), t2, 0, H.assertSubtypeOfRuntimeType(null, t1));
      H.assertHelper(true);
      t2.$builtinTypeInfo = [t1];
      H.assertSubtype(t2, "$isIterator", [H.getTypeArgumentByIndex(current, 0)], "$asIterator");
      for (; t2.moveNext$0();) {
        opt = H.assertSubtypeOfRuntimeType(t2._current, H.getTypeArgumentByIndex(t2, 0));
        this.choice$2$script(opt.get$name(), new T.BarBrawl_update_closure2(this, opt));
      }
    },
    echo$1: function(arg0) {
      return this.echo.call$1(arg0);
    },
    choice$2$script: function(arg0, arg1) {
      return this.choice.call$2$script(arg0, arg1);
    }
  },
  BarBrawl__initOptions_closure: {
    "^": "Closure:1;_barbrawl$_captured_this_1",
    call$0: function() {
      return this._barbrawl$_captured_this_1.BarBrawl_timeline.time === 0;
    }
  },
  BarBrawl__initOptions_closure0: {
    "^": "Closure:1;_barbrawl$_box_0,_barbrawl$_captured_this_2",
    call$0: function() {
      var t1 = this._barbrawl$_captured_this_2;
      t1.echo$1("\"Why would y\u2014\"\n\n");
      t1.echo$1("He hit you again. From the other side. Before you managed to turn your head back towards him, he had raised his fist again.");
      t1.set$startingOptions([this._barbrawl$_box_0._captured_whyDoThat2_0]);
    }
  },
  BarBrawl__initOptions_closure1: {
    "^": "Closure:1;_barbrawl$_captured_this_3,_captured_whyDoThat_4",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_whyDoThat_4.timeLastFired;
      t2 = this._barbrawl$_captured_this_3.BarBrawl_timeline.time;
      return t1 == null ? t2 == null : t1 === t2;
    }
  },
  BarBrawl__initOptions_closure2: {
    "^": "Closure:1;_barbrawl$_captured_this_5",
    call$0: function() {
      var t1 = this._barbrawl$_captured_this_5;
      t1.echo$1("Another punch in the face. This time it landed so hard it knocked you off.");
      t1.finished = true;
    }
  },
  BarBrawl__initOptions_closure3: {
    "^": "Closure:1;_barbrawl$_captured_this_6,_captured_whyDoThat_7",
    call$0: function() {
      var t1, t2;
      t1 = this._captured_whyDoThat_7.timeLastFired;
      t2 = this._barbrawl$_captured_this_6.BarBrawl_timeline.time;
      if (t1 == null ? t2 != null : t1 !== t2) {
        if (typeof t2 !== "number")
          return t2.$gt();
        t1 = t2 > 0;
      } else
        t1 = false;
      return t1;
    }
  },
  BarBrawl__initOptions_closure4: {
    "^": "Closure:1;_barbrawl$_captured_this_8",
    call$0: function() {
      var t1 = this._barbrawl$_captured_this_8;
      t1.echo$1("\"Stop it!\"\n\n");
      t1.echo$1("There was a smirk on his face. He hit you in the stomach. You bent forward, gulping for air.\n\n");
      t1.echo$1("\"Why should I?\" The last thing you saw was his knee flying straight towards your face.");
      t1.finished = true;
    }
  },
  BarBrawl__initOptions_closure5: {
    "^": "Closure:1;_barbrawl$_captured_this_9",
    call$0: function() {
      return this._barbrawl$_captured_this_9.BarBrawl_timeline.time === 0;
    }
  },
  BarBrawl__initOptions_closure6: {
    "^": "Closure:1;_barbrawl$_captured_this_10",
    call$0: function() {
      this._barbrawl$_captured_this_10.echo$1("You threw a punch in his general direction but missed. He jabbed at your jaw.");
    }
  },
  BarBrawl__initOptions_closure7: {
    "^": "Closure:1;_captured_this_11",
    call$0: function() {
      var t1 = this._captured_this_11.BarBrawl_timeline.time;
      if (typeof t1 !== "number")
        return t1.$gt();
      return t1 > 0;
    }
  },
  BarBrawl__initOptions_closure9: {
    "^": "Closure:1;_barbrawl$_captured_this_12",
    call$0: function() {
      this._barbrawl$_captured_this_12.echo$1("He tried to deflect it but failed miserably. With all your strength, you landed your fist directly in the middle of his face. You felt the shattering power of the impact through your hand. The farmer flew backwards and landed on a table, unconscious.");
    }
  },
  BarBrawl__initOptions_closure8: {
    "^": "Closure:1;_barbrawl$_captured_this_13",
    call$0: function() {
      this._barbrawl$_captured_this_13.echo$1("Your right hook was deflected and he headbutted you. You took two steps back and barely regained your balance.");
    }
  },
  BarBrawl__initOptions_closure10: {
    "^": "Closure:1;_barbrawl$_captured_this_14",
    call$0: function() {
      var t1 = this._barbrawl$_captured_this_14.BarBrawl_timeline.time;
      if (typeof t1 !== "number")
        return t1.$gt();
      return t1 > 0;
    }
  },
  BarBrawl__initOptions_closure12: {
    "^": "Closure:1;_barbrawl$_captured_this_15",
    call$0: function() {
      this._barbrawl$_captured_this_15.echo$1("Your fist lands right in his solar plexus. The farmer lets out a gurgling sound and bends over your arm. You kneel him in the face and he sagged on the floor, unconscious.");
    }
  },
  BarBrawl__initOptions_closure11: {
    "^": "Closure:1;_barbrawl$_captured_this_16",
    call$0: function() {
      this._barbrawl$_captured_this_16.echo$1("He dodged your stomach punch and put his right elbow in your face.");
    }
  },
  BarBrawl__initOptions_closure14: {
    "^": "Closure:1;_barbrawl$_captured_this_17",
    call$0: function() {
      this._barbrawl$_captured_this_17.echo$1("Your arms deflected a haymaker that would definitely send you to the floor. The farmer's face was now open to your left hand. You hit him hard. Then again in the stomach. And then again, with a powerful haymaker of your own. He flew towards the floor, unconscious.");
    }
  },
  BarBrawl__initOptions_closure13: {
    "^": "Closure:1;_barbrawl$_captured_this_18",
    call$0: function() {
      this._barbrawl$_captured_this_18.echo$1("Your arms deflected a haymaker that would definitely send you to the floor. But before you could do anything to retaliate, the farmer slipped a painful uppercut punch between your arms.");
    }
  },
  BarBrawl__initOptions_closure15: {
    "^": "Closure:1;_barbrawl$_captured_this_19",
    call$0: function() {
      var t1 = this._barbrawl$_captured_this_19.BarBrawl_timeline.time;
      if (typeof t1 !== "number")
        return t1.$gt();
      return t1 > 0;
    }
  },
  BarBrawl__initOptions_closure17: {
    "^": "Closure:1;_barbrawl$_captured_this_20",
    call$0: function() {
      this._barbrawl$_captured_this_20.echo$1("You thought you could see how he was going to hit next.");
    }
  },
  BarBrawl__initOptions_closure18: {
    "^": "Closure:1;_barbrawl$_captured_this_21",
    call$0: function() {
      this._barbrawl$_captured_this_21.echo$1("You guessed well. You dodged the punch and the farmer tried to keep his balance \u2014 his right arm still extended forward. That's when you landed a well placed blow to his flank. He shrieked. An elbow to the face sent him to the ground, unconscious.");
    }
  },
  BarBrawl__initOptions_closure16: {
    "^": "Closure:1;_barbrawl$_captured_this_22",
    call$0: function() {
      this._barbrawl$_captured_this_22.echo$1("You guessed wrong. You sidestepped right into his blow. The impact almost sent you to the ground.");
    }
  },
  BarBrawl__initOptions_closure19: {
    "^": "Closure:1;_barbrawl$_captured_this_23",
    call$0: function() {
      var t1 = this._barbrawl$_captured_this_23.BarBrawl_timeline.time;
      if (typeof t1 !== "number")
        return t1.$gt();
      return t1 > 0;
    }
  },
  BarBrawl__initOptions_closure21: {
    "^": "Closure:1;_barbrawl$_captured_this_24",
    call$0: function() {
      this._barbrawl$_captured_this_24.echo$1("A heavily built guy in a pilot overall backed into your field of vision. He had probably got hit by someone and looked a bit disoriented. The farmer didn't notice. His eyes were laser focused on you.");
    }
  },
  BarBrawl__initOptions_closure22: {
    "^": "Closure:1;_barbrawl$_captured_this_25",
    call$0: function() {
      var t1 = this._barbrawl$_captured_this_25;
      t1.echo$1("You sidestepped so that the pilot was now almost between the farmer and you. The farmer was just in the middle of throwing a hook so he missed you and weakly hit the pilot on the back of the head instead. The pilot, still desoriented, blindly swung his fist at him and landed it squarely on the farmer's ear.\n\n");
      t1.echo$1("That was your cue. You lunged at the farmer with everything you got and landed a blow first in his chest, then in the face, and finaly in the stomach. The farmer went to the ground, unconscious.");
    }
  },
  BarBrawl__initOptions_closure20: {
    "^": "Closure:1;_barbrawl$_captured_this_26",
    call$0: function() {
      this._barbrawl$_captured_this_26.echo$1("You sidestepped so that the pilot was now almost between the farmer and you. The farmer saw this, though, lunged forward, avoiding the pilot, then landed an uppercut right in your jaw. ");
    }
  },
  BarBrawl__initOptions_closure23: {
    "^": "Closure:1;_barbrawl$_box_0,_barbrawl$_captured_this_27",
    call$0: function() {
      var t1 = this._barbrawl$_captured_this_27;
      t1.echo$1("From the corner of your eye you saw the bottle of Golitsyn vodka from which you had been drinking just minutes ago. It was still standing on your table behind you.");
      t1.set$startingOptions([this._barbrawl$_box_0._captured_useBottle_1]);
    }
  },
  BarBrawl__initOptions_closure24: {
    "^": "Closure:1;_captured_lookAround_28",
    call$0: function() {
      return this._captured_lookAround_28._firedCount > 0;
    }
  },
  BarBrawl__initOptions_closure26: {
    "^": "Closure:1;_barbrawl$_captured_this_29",
    call$0: function() {
      this._barbrawl$_captured_this_29.echo$1("You quickly grabbed the bottle and smashed it over the top of the farmer's head. He plummeted to the floor, unconscious.");
    }
  },
  BarBrawl__initOptions_closure25: {
    "^": "Closure:1;_barbrawl$_captured_this_30",
    call$0: function() {
      this._barbrawl$_captured_this_30.echo$1("You quickly looked behind and grabbed the bottle, but when you turned back towards the farmer, you were greeted with a direct punch in the eye. You let go of the bottle and it dropped to the floor, shattering.");
    }
  },
  BarBrawl__initOptions_closure27: {
    "^": "Closure:1;_barbrawl$_captured_this_31",
    call$0: function() {
      var t1 = this._barbrawl$_captured_this_31;
      t1.echo$1("He didn't expect that. Your knee landed squarely in the groin and the farmer keeled over.\n\n");
      t1.echo$1("The fights closest to you were now stopping. People started alternately looking at you and at the farmer who was now lying on his side, both hands in the lap, unconsciouss.\n\n");
      t1.echo$1("You hadn't known about the no-groin-attack rule but that wasn't going to absolve you. There are very few rules in bar fight, but those that exist are enforced with violent fervor. After a thunderous scream, at least four guys (you didn't really have the time to count them) jumped you and beat you into unconsciousness.");
      t1.wasSuccessful = false;
      t1.finished = true;
    }
  },
  BarBrawl__initOptions_closure29: {
    "^": "Closure:1;_barbrawl$_captured_this_32",
    call$0: function() {
      this._barbrawl$_captured_this_32.echo$1("He tried to kick you but lost balance while doing so and aborted.");
    }
  },
  BarBrawl__initOptions_closure30: {
    "^": "Closure:1;_barbrawl$_captured_this_33",
    call$0: function() {
      this._barbrawl$_captured_this_33.echo$1("Seeing that he barely stood on one foot, you swept his legs. The farmer wasn't ready, hitting his head hard on the floor while falling. When he weakly started to get up, you punched him from above. That sent him back to the ground, unconscious.");
    }
  },
  BarBrawl__initOptions_closure28: {
    "^": "Closure:1;_barbrawl$_captured_this_34",
    call$0: function() {
      this._barbrawl$_captured_this_34.echo$1("Seeing that he barely stood on one foot, you tried to sweep his legs. But by the time your leg hit his, the farmer had already regained his balance. Your leg just stopped there and you were lucky to withdraw before he was able to stamp on your knee.");
    }
  },
  BarBrawl__initTimeline_closure: {
    "^": "Closure:1;_barbrawl$_captured_this_0",
    call$0: function() {
      var t1 = this._barbrawl$_captured_this_0;
      t1.echo$1("\n\nAt the other end of the bar, you heard someone laughing. Laughing! A strange sound to hear during a full scale bar fight. But you didn't exactly have the time to investigate. The farmer was a pressing issue.");
      t1.additionalParagraphPresent = true;
    }
  },
  BarBrawl_update_closure: {
    "^": "Closure:2;",
    call$1: function(o) {
      var t1;
      if (o.get$isAvailableByDefault())
        t1 = o.getAvailability == null || H.boolConversionCheck(o.getAvailability$0());
      else
        t1 = false;
      return t1;
    }
  },
  BarBrawl_update_closure0: {
    "^": "Closure:5;_barbrawl$_captured_this_0",
    call$1: function(o) {
      H.interceptedTypeCheck(o, "$isBarBrawlOption");
      return !this._barbrawl$_captured_this_0.additionalParagraphPresent || o.onSetup == null;
    }
  },
  BarBrawl_update_closure1: {
    "^": "Closure:6;",
    call$2: function(a, b) {
      return J.compareTo$1$ns(a.get$name(), b.get$name());
    }
  },
  BarBrawl_update_closure2: {
    "^": "Closure:1;_barbrawl$_captured_this_1,_captured_opt_2",
    call$0: function() {
      var t1, t2;
      t1 = this._barbrawl$_captured_this_1;
      t1.additionalParagraphPresent = false;
      if (t1.failures < 3) {
        t2 = this._captured_opt_2;
        if (t2.get$onFailure() != null)
          t2.onFailure$0();
        else
          t2.onSuccessOrFailure$0();
        ++t1.failures;
        if (t1.finished)
          return;
        t1.BarBrawl_timeline.elapse$1(1);
      } else {
        t2 = this._captured_opt_2;
        if (t2.get$onSuccess() != null) {
          t2.onSuccess$0();
          t1.wasSuccessful = true;
          t1.finished = true;
        } else
          t2.onSuccessOrFailure$0();
      }
      t2.set$timeLastFired(t1.BarBrawl_timeline.time);
    }
  },
  BarBrawlOption: {
    "^": "Object;name<,getAvailability,onSetup,_onSuccess,_onFailure,_onSuccessOrFailure,repeatable,_firedCount,timeLastFired",
    set$timeLastFired: function(timeLastFired) {
      this.timeLastFired = H.intTypeCheck(timeLastFired);
    },
    get$onSuccess: function() {
      return H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(this._wrapWithFiredCounter$1(this._onSuccess));
    },
    get$onFailure: function() {
      return H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(this._wrapWithFiredCounter$1(this._onFailure));
    },
    get$onSuccessOrFailure: function() {
      return H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(this._wrapWithFiredCounter$1(this._onSuccessOrFailure));
    },
    _wrapWithFiredCounter$1: function(f) {
      var t1, t2;
      t1 = H.buildFunctionType(H.getVoidRuntimeType());
      t2 = t1._assertCheck$1(f);
      if (t2 == null)
        return t1._assertCheck$1(null);
      return t1._assertCheck$1(new T.BarBrawlOption__wrapWithFiredCounter_closure(this, t2));
    },
    get$isAvailableByDefault: function() {
      return this.repeatable || this._firedCount === 0;
    },
    toString$0: function(_) {
      return this.name;
    },
    BarBrawlOption$7$getAvailability$onFailure$onSetup$onSuccess$onSuccessOrFailure$repeatable: function($name, getAvailability, onFailure, onSetup, onSuccess, onSuccessOrFailure, repeatable) {
      var t1;
      H.buildFunctionType(H.buildInterfaceType(P.bool))._assertCheck$1(getAvailability);
      t1 = H.buildFunctionType(H.getVoidRuntimeType());
      t1._assertCheck$1(onFailure);
      t1._assertCheck$1(onSetup);
      t1._assertCheck$1(onSuccess);
      t1._assertCheck$1(onSuccessOrFailure);
      if ((this._onSuccess == null || this._onFailure == null) && this._onSuccessOrFailure == null)
        throw H.wrapException(P.StateError$("If you don't set one or both of onSuccess and onFailure, you must set onSuccessOrFailure to cover for them."));
    },
    getAvailability$0: function() {
      return this.getAvailability.call$0();
    },
    onSetup$0: function() {
      return this.onSetup.call$0();
    },
    onSuccess$0: function() {
      return this.get$onSuccess().call$0();
    },
    onFailure$0: function() {
      return this.get$onFailure().call$0();
    },
    onSuccessOrFailure$0: function() {
      return this.get$onSuccessOrFailure().call$0();
    },
    static: {BarBrawlOption$: function($name, getAvailability, onFailure, onSetup, onSuccess, onSuccessOrFailure, repeatable) {
        var t1, t2, t3, t4, t5, t6, t7;
        t1 = H.buildFunctionType(H.buildInterfaceType(P.bool));
        t2 = t1._assertCheck$1(getAvailability);
        t3 = H.buildFunctionType(H.getVoidRuntimeType());
        t4 = t3._assertCheck$1(onFailure);
        t5 = t3._assertCheck$1(onSetup);
        t6 = t3._assertCheck$1(onSuccess);
        t7 = t3._assertCheck$1(onSuccessOrFailure);
        t3 = new T.BarBrawlOption($name, t1._assertCheck$1(t2), t3._assertCheck$1(t5), t3._assertCheck$1(t6), t3._assertCheck$1(t4), t3._assertCheck$1(t7), repeatable, 0, null);
        t3.BarBrawlOption$7$getAvailability$onFailure$onSetup$onSuccess$onSuccessOrFailure$repeatable($name, t2, t4, t5, t6, t7, repeatable);
        return t3;
      }}
  },
  BarBrawlOption__wrapWithFiredCounter_closure: {
    "^": "Closure:1;_barbrawl$_captured_this_0,_barbrawl$_captured_f_1",
    call$0: function() {
      ++this._barbrawl$_captured_this_0._firedCount;
      this._barbrawl$_captured_f_1.call$0();
    }
  }
}],
["bodega_shipcombat", "bodega_shipcombat.dart", , E, {
  "^": "",
  BodegaShip: {
    "^": "Spaceship;turret,currentCombat,availableMoves,currentMove,pilot,_targetShip,hull,shield,engine,thrusters,weapons,systems,_positionMap,stringReportDestroy,nameIsProperNoun,name,categories,alreadyMentioned,team,isActive,isPlayer,pronoun",
    BodegaShip$0: function() {
      var t1, v;
      t1 = this.hull.hp;
      v = t1._clamp$1(47);
      t1._numscale$_value = v;
      t1._lastValue = v;
      t1 = this.weapons;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      this.turret = H.interceptedTypeCheck(t1[1], "$isWeapon");
    },
    static: {BodegaShip$: function() {
        var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11;
        t1 = $.get$playerPilot();
        t2 = M.Hull$(50, "hull");
        t3 = M.Shield$(0, 2, 10, "shields", C.Pronoun_they_them_their_themselves, null);
        t3.isActive = false;
        t4 = {};
        t4._captured_hp_0 = null;
        t5 = H.setRuntimeTypeInfo([], [P.String]);
        t5 = new M.Engine(10, "engine", null, null, null, false, H.assertSubtype([], "$isList", [M.CombatMove], "$asList"), null, "<owner's> <subject> <is> now {{fully|} repaired|fully operational}", "<owner's> <subject> {blow<s> {up|apart}|<is> {destroyed|no more}}", false, null, H.assertSubtype(t5, "$isList", [P.String], "$asList"), true, 0, true, false, C.Pronoun_it_it_its_itself);
        t5.ShipSystem$5$hp$maxHp$maxPowerInput$pronoun("engine", 2, 1, C.Pronoun_it_it_its_itself, t4);
        t4 = [M.Thruster$("main jet", null, 100, 5, 4, 5, C.Pronoun_it_it_its_itself), M.Thruster$("left side thruster", null, 0, 2, 2, 1, C.Pronoun_it_it_its_itself), M.Thruster$("right side thruster", null, 0, 2, 2, 1, C.Pronoun_it_it_its_itself)];
        t6 = M.Weapon$("front laser", 1, null, 1, 1000, 1, new Y.Entity(false, "laser beam", H.assertSubtype(H.setRuntimeTypeInfo([], [P.String]), "$isList", [P.String], "$asList"), true, 0, true, false, C.Pronoun_it_it_its_itself), C.Pronoun_it_it_its_itself, 0);
        t6.damage = 2;
        t7 = H.assertSubtype(H.setRuntimeTypeInfo([], [P.String]), "$isList", [P.String], "$asList");
        t8 = H.assertSubtype(H.setRuntimeTypeInfo([], [P.String]), "$isList", [P.String], "$asList");
        t9 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, M.Spaceship, P.$int), "$isMap", [M.Spaceship, P.$int], "$asMap");
        t10 = {};
        t10._captured_hp_0 = null;
        t11 = H.setRuntimeTypeInfo([], [P.String]);
        t11 = new M.AutoWeapon(true, null, null, null, new Y.Entity(false, "projectile", t8, true, 0, true, false, C.Pronoun_it_it_its_itself), 1, 0, 1, null, null, H.assertSubtype(t9, "$isMap", [M.Spaceship, P.$int], "$asMap"), "defensive turret", null, null, null, false, H.assertSubtype([], "$isList", [M.CombatMove], "$asList"), null, "<owner's> <subject> <is> now {{fully|} repaired|fully operational}", "<owner's> <subject> {blow<s> {up|apart}|<is> {destroyed|no more}}", false, null, H.assertSubtype(t11, "$isList", [P.String], "$asList"), true, 0, true, false, C.Pronoun_it_it_its_itself);
        t11.ShipSystem$5$hp$maxHp$maxPowerInput$pronoun("defensive turret", 1, 1, C.Pronoun_it_it_its_itself, t10);
        t11.Weapon$9$accuracyModifier$ammo$damage$maxAmmo$maxHp$projectile$pronoun$shieldPenetration("defensive turret", 1, null, 1, 1000, 1, new Y.Entity(false, "shot", t7, true, 0, true, false, C.Pronoun_it_it_its_itself), C.Pronoun_it_it_its_itself, 0);
        t11.set$availableMoves(H.setRuntimeTypeInfo([new M.AutoGunStart(true, true, true, false, 1, 4, null, 0.2, 0.2, 0.8, null, null, null, true, false, "<subject> {initiate|start}<s> the undefined move", "", "<subject> successfully finish<es> undefined move", "<subject> successfully finish<es> undefined move", "<subject> fail<s> to perform undefined move", "", true, true, false, false, 1, null, null, null, null, false)], [M.CombatMove]));
        t11 = [t6, t11];
        t6 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, M.Spaceship, P.$int), "$isMap", [M.Spaceship, P.$int], "$asMap");
        t7 = H.setRuntimeTypeInfo([], [P.String]);
        t7 = new E.BodegaShip(null, null, H.assertSubtype([], "$isList", [M.CombatMove], "$asList"), null, t1, null, t2, t3, t5, H.assertSubtype(t4, "$isList", [M.Thruster], "$asList"), H.assertSubtype(t11, "$isList", [M.Weapon], "$asList"), H.assertSubtype(C.List_empty, "$isList", [M.SpecialSystems], "$asList"), H.assertSubtype(t6, "$isMap", [M.Spaceship, P.$int], "$asMap"), "<subject> {{violently|} explode<s>|blow<s> {up|apart} {violently|}|fl<ies> apart in a {bright|powerful|violent} explosion}", false, "Bodega", H.assertSubtype(t7, "$isList", [P.String], "$asList"), true, 0, true, false, C.Pronoun_it_it_its_itself);
        t7.Spaceship$8$engine$hull$pilot$shield$systems$thrusters$weapons("Bodega", t5, t2, t1, t3, C.List_empty, t4, t11);
        t7.BodegaShip$0();
        return t7;
      }}
  },
  MessengerShip: {
    "^": "Spaceship;currentCombat,availableMoves,currentMove,pilot,_targetShip,hull,shield,engine,thrusters,weapons,systems,_positionMap,stringReportDestroy,nameIsProperNoun,name,categories,alreadyMentioned,team,isActive,isPlayer,pronoun",
    static: {MessengerShip$: function() {
        var t1, t2, t3, t4, t5, t6, t7;
        t1 = M.Hull$(5, "hull");
        t2 = M.Shield$(0, 1, 10, "shields", C.Pronoun_they_them_their_themselves, null);
        t3 = {};
        t3._captured_hp_0 = null;
        t4 = H.setRuntimeTypeInfo([], [P.String]);
        t4 = new M.Engine(2, "engine", null, null, null, false, H.assertSubtype([], "$isList", [M.CombatMove], "$asList"), null, "<owner's> <subject> <is> now {{fully|} repaired|fully operational}", "<owner's> <subject> {blow<s> {up|apart}|<is> {destroyed|no more}}", false, null, H.assertSubtype(t4, "$isList", [P.String], "$asList"), true, 0, true, false, C.Pronoun_it_it_its_itself);
        t4.ShipSystem$5$hp$maxHp$maxPowerInput$pronoun("engine", 10, 1, C.Pronoun_it_it_its_itself, t3);
        t3 = [M.Thruster$("main jet", null, 10, 2, 10, 1, C.Pronoun_it_it_its_itself), M.Thruster$("rotation thrusters", null, 0, 1, 10, 0.5, C.Pronoun_they_them_their_themselves)];
        t5 = [M.Weapon$("blaster", 1, null, 1, 1000, 1, new Y.Entity(false, "blaster beam", H.assertSubtype(H.setRuntimeTypeInfo([], [P.String]), "$isList", [P.String], "$asList"), true, 0, true, false, C.Pronoun_it_it_its_itself), C.Pronoun_it_it_its_itself, 0), M.Weapon$("chain gun", 1, null, 1, 1000, 1, new Y.Entity(false, "burst", H.assertSubtype(H.setRuntimeTypeInfo([], [P.String]), "$isList", [P.String], "$asList"), true, 0, true, false, C.Pronoun_it_it_its_itself), C.Pronoun_it_it_its_itself, 0)];
        t6 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, M.Spaceship, P.$int), "$isMap", [M.Spaceship, P.$int], "$asMap");
        t7 = H.setRuntimeTypeInfo([], [P.String]);
        t7 = new E.MessengerShip(null, H.assertSubtype([], "$isList", [M.CombatMove], "$asList"), null, null, null, t1, t2, t4, H.assertSubtype(t3, "$isList", [M.Thruster], "$asList"), H.assertSubtype(t5, "$isList", [M.Weapon], "$asList"), H.assertSubtype(C.List_empty, "$isList", [M.SpecialSystems], "$asList"), H.assertSubtype(t6, "$isMap", [M.Spaceship, P.$int], "$asMap"), "<subject> {{violently|} explode<s>|blow<s> {up|apart} {violently|}|fl<ies> apart in a {bright|powerful|violent} explosion}", false, "Messenger", H.assertSubtype(t7, "$isList", [P.String], "$asList"), true, 0, true, false, C.Pronoun_it_it_its_itself);
        t7.Spaceship$8$engine$hull$pilot$shield$systems$thrusters$weapons("Messenger", t4, t1, null, t2, C.List_empty, t3, t5);
        return t7;
      }}
  },
  FirstCombat: {
    "^": "SpaceshipCombat;bodega,messenger,spybotObject,messengerManagedToLaunchSpyBot,spybotManagedToCrashIntoBodega,playerSpaceship,finished,onFinishedGoto,timeline,actors",
    FirstCombat$3: function(bodega, messenger, onFinishedGoto) {
      this.bodega = bodega;
      this.messenger = messenger;
      this.onFinishedGoto = onFinishedGoto;
      this.timeline.schedule$2(20, new E.FirstCombat_closure(this, bodega, messenger));
      this.timeline.schedule$2(24, new E.FirstCombat_closure0(this, bodega, messenger));
      this.timeline.schedule$2(25, new E.FirstCombat_closure1(this, bodega));
    },
    static: {FirstCombat$: function(bodega, messenger, onFinishedGoto) {
        var t1, t2, t3, t4;
        t1 = H.assertSubtype(H.setRuntimeTypeInfo([], [P.String]), "$isList", [P.String], "$asList");
        t2 = H.setRuntimeTypeInfo([bodega, messenger], [M.Spaceship]);
        t1 = new E.FirstCombat(null, null, new Y.Entity(false, "object", t1, false, 0, true, false, C.Pronoun_it_it_its_itself), false, false, null, false, null, null, H.assertSubtype(t2, "$isList", [Y.Actor], "$asList"));
        H.assertSubtype(t2, "$isList", [Y.Actor], "$asList");
        t3 = H.setRuntimeTypeInfo([], [L.TimedEvent]);
        t4 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, P.$int), "$isMap", [P.$int, P.$int], "$asMap");
        H.assertSubtype(t3, "$isList", [L.TimedEvent], "$asList");
        H.assertSubtype(t4, "$isMap", [P.$int, P.$int], "$asMap");
        O.throwIfNotInInitOrDeclareBlock("");
        t1.timeline = new L.Timeline(-1, null, null, t3, t4, null, false, "Timeline", false);
        t1.SpaceshipCombat$2$ships$timeline(t2, null);
        t1.FirstCombat$3(bodega, messenger, onFinishedGoto);
        return t1;
      }}
  },
  FirstCombat_closure: {
    "^": "Closure:1;_bodega_shipcombat$_captured_this_0,_captured_bodega_1,_captured_messenger_2",
    call$0: function() {
      var t1, t2, t3, t4;
      t1 = this._captured_messenger_2;
      t2 = this._bodega_shipcombat$_captured_this_0;
      t3 = t2.spybotObject;
      t1.toString;
      t4 = $.get$storyline();
      t4.add$3$object$subject(0, "<subject> launch<es> some kind of an object from <subjectPronoun's> underside", t3, t1);
      t4.add$4$object$subject$wholeSentence(0, "<subject> zip<s> around <object>, but keep<s> <subject's> distance.", this._captured_bodega_1, t3, true);
      t2.messengerManagedToLaunchSpyBot = true;
    }
  },
  FirstCombat_closure0: {
    "^": "Closure:1;_bodega_shipcombat$_captured_this_3,_captured_bodega_4,_captured_messenger_5",
    call$0: function() {
      var t1 = this._captured_bodega_4;
      return $.get$storyline().add$5$object$objectOwner$owner$subject(0, "<owner's> <subject> suddenly plummet<s> towards <object-owner's> <object>", t1.hull, t1, this._captured_messenger_5, this._bodega_shipcombat$_captured_this_3.spybotObject);
    }
  },
  FirstCombat_closure1: {
    "^": "Closure:1;_bodega_shipcombat$_captured_this_6,_captured_bodega_7",
    call$0: function() {
      var t1, t2, t3;
      t1 = $.get$storyline();
      t2 = this._bodega_shipcombat$_captured_this_6;
      t3 = this._captured_bodega_7;
      t1.add$4$object$objectOwner$subject(0, "<subject> crash<es> somewhere into <object-owner's> right side cargo bay", t3.hull, t3, t2.spybotObject);
      t1.add$2$wholeSentence(0, " \"Hull breach,\" the Bodega says. ", true);
      t1.add$2$wholeSentence(0, "It doesn't seem like it has done any major damage, though.", true);
      t2.spybotManagedToCrashIntoBodega = true;
    }
  }
}],
["bodega_zil", "bodega_zil.dart", , L, {
  "^": "",
  BodegaZil: {
    "^": "Object;unityArrivalEvent,gorillasDen,exitToHullBreach,cargoBayLeft,pullLever,repairEngineAction,repairTurret,shabuVials,banana,infoFlyer,captainsGun,gorillaCorpse,firstLookAround,secondLookAround,thirdLookAround,captainsComputerFirst,bridge,lookAtHullBreachFromBridge,askBodegaQuestions,takeANap,waitForJumpToUnity,jumpToSpaceStationUnity,scannerLook,scannerRepair,gorilla,zil,$goto,echo,choice,showForm,scripter,exploration",
    setupTimeline$0: function() {
      var t1 = this.zil.timeline;
      this.exploration = t1;
      t1.toString;
      O.throwIfNotInInitOrDeclareBlock("");
      t1._mainLoop = new L.BodegaZil_setupTimeline_closure(this);
      this.exploration.schedule$2(52, new L.BodegaZil_setupTimeline_closure0(this));
      this.exploration.schedule$3$type(96, new L.BodegaZil_setupTimeline_closure1(this), 3);
      this.exploration.schedule$2(473, new L.BodegaZil_setupTimeline_closure2(this));
      this.unityArrivalEvent = this.exploration.schedule$3$type(null, new L.BodegaZil_setupTimeline_closure3(this), 3);
      this.exploration.schedule$2(465, new L.BodegaZil_setupTimeline_closure4(this));
      this.exploration.schedule$2(482, new L.BodegaZil_setupTimeline_closure5(this));
      this.exploration.schedule$2(508, new L.BodegaZil_setupTimeline_closure6(this));
      this.exploration.schedule$2(515, new L.BodegaZil_setupTimeline_closure7(this));
      this.exploration.schedule$2(530, new L.BodegaZil_setupTimeline_closure8(this));
    },
    setupActors$0: function() {
      var t1, t2;
      t1 = this.zil;
      t2 = H.setRuntimeTypeInfo([], [P.String]);
      t2 = new K.AIActor(null, true, t1, null, H.listSuperNativeTypeCheck(C.List_empty, "$isIterable"), false, "Gorilla", H.assertSubtype(t2, "$isList", [P.String], "$asList"), true, 0, true, false, C.Pronoun_he_him_his_himself);
      t2.ZilActor$8$actions$isPlayer$items$nameIsProperNoun$pronoun$team(t1, "Gorilla", C.List_empty, false, C.List_empty, false, C.Pronoun_he_him_his_himself, 0);
      this.gorilla = t2;
    },
    setupRooms$0: function() {
      var t1, t2, t3, t4, t5, t6, t7, t8, siftThrough, t9, t10, lookAtTurret;
      this.setupBridge$0();
      this.scannerLook = K.Action$Goto("Take a look at the scanner", "Nose.ScannerLook", true, null, null, false, true, null, null, null, null);
      this.scannerRepair = K.Action$Goto("Repair the scanner [~1 hour]", "Nose.ScannerRepair", false, null, null, false, true, null, null, null, null);
      t1 = this.zil;
      t2 = H.buildFunctionType(H.buildInterfaceType(P.bool), [H.buildInterfaceType(Y.Actor)]);
      t2._assertCheck$1(null);
      t3 = H.setRuntimeTypeInfo([], [P.String]);
      t4 = t2._assertCheck$1(null);
      H.assertSubtype(t3, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      K.Room$(t1, "Explore: Nose", "nose of the ship", [new K.Exit(null, null, t4, 1, "Explore: Bridge", "crawl back to the bridge", "<subject> crawl<s> out of the nose hatchway onto the bridge", false, "Exit", t3, true, 0, true, false, C.Pronoun_it_it_its_itself)], [this.scannerLook, this.scannerRepair], C.List_empty, [0, 5, 0], "Nose.description", C.List_empty, false, null);
      t2._assertCheck$1(null);
      t3 = H.setRuntimeTypeInfo([], [P.String]);
      t4 = t2._assertCheck$1(null);
      H.assertSubtype(t3, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t5 = H.setRuntimeTypeInfo([], [P.String]);
      t6 = t2._assertCheck$1(null);
      H.assertSubtype(t5, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t7 = H.setRuntimeTypeInfo([], [P.String]);
      t8 = t2._assertCheck$1(null);
      H.assertSubtype(t7, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      K.Room$(t1, "Explore: CorridorLeftNextToCaptainsCabin", "Corridor Left", [new K.Exit(null, null, t4, 1, "Explore: Bridge", "walk to the bridge", "<subject> {enter<s>|arrive<s> at} the bridge", false, "Exit", t3, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t6, 1, "Explore: CaptainsCabin", "enter Captain's cabin", "<subject> open<s> the door to the Captain's cabin and enter<s>", false, "Exit", t5, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t8, 1, "Explore: CorridorLeftNextToAirlock", "walk {toward the cargo bay|to the {aft|back} of the ship}", "<subject> {stride|walk}<s> towards the {{aft|back} of the ship|cargo bay}", false, "Exit", t7, true, 0, true, false, C.Pronoun_it_it_its_itself)], C.List_empty, C.List_empty, [-5, -10, 0], "CorridorLeftNextToCaptainsCabin.description", C.List_empty, false, null);
      this.setupCaptainsCabin$0();
      this.setupCorridorLeftNextToAirlock$0();
      this.setupStaffRoom$0();
      t2._assertCheck$1(null);
      t7 = H.setRuntimeTypeInfo([], [P.String]);
      t8 = t2._assertCheck$1(null);
      H.assertSubtype(t7, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t5 = H.setRuntimeTypeInfo([], [P.String]);
      t6 = t2._assertCheck$1(null);
      H.assertSubtype(t5, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t3 = H.setRuntimeTypeInfo([], [P.String]);
      t4 = t2._assertCheck$1(null);
      H.assertSubtype(t3, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      K.Room$(t1, "Explore: CorridorLeftNextToBunks", "corridor left", [new K.Exit(null, null, t8, 1, "Explore: CorridorLeftNextToAirlock", "walk towards the bridge", "<subject> arrive<s> to the Corridor Left airlock and the staff room", false, "Exit", t7, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t6, 1, "Explore: Bunks", "enter the bunks", "<subject> step<s> inside the {living quarters|bunks}", false, "Exit", t5, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t4, 2, "Explore: CorridorLeftJunction", "walk {toward the cargo bay|to the {aft|back} of the ship}", "after walking for 3 minutes, <subject> arrive<s> at the left junction", false, "Exit", t3, true, 0, true, false, C.Pronoun_it_it_its_itself)], C.List_empty, C.List_empty, [-5, -25, 0], "CorridorLeftNextToBunks.description", C.List_empty, false, null);
      this.shabuVials = K.Item$(t1, "shabu vials", C.List_empty, 2, null, null, false, false, false, C.Pronoun_they_them_their_themselves, null, null, true);
      siftThrough = K.Action$Goto("sift through lockers [~30 minutes]", "Bunks.SiftThroughLockers", true, null, null, false, true, null, null, null, null);
      t2._assertCheck$1(null);
      t3 = H.setRuntimeTypeInfo([], [P.String]);
      t4 = t2._assertCheck$1(null);
      H.assertSubtype(t3, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t5 = H.setRuntimeTypeInfo([], [P.String]);
      t6 = t2._assertCheck$1(null);
      H.assertSubtype(t5, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      K.Room$(t1, "Explore: Bunks", "bunks", [new K.Exit(null, null, t4, 1, "Explore: CorridorLeftNextToBunks", "exit to Corridor Left", "<subject> {{exit|leave}<s>|step<s> out} to Corridor Left", false, "Exit", t3, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t6, 1, "Explore: CorridorRightNextToBunks", "exit to Corridor Right", "<subject> {{exit|leave}<s>|step<s> out} to Corridor Right", false, "Exit", t5, true, 0, true, false, C.Pronoun_it_it_its_itself)], [siftThrough], C.List_empty, [0, -25, 0], "Bunks.description", [this.shabuVials], false, null);
      t2._assertCheck$1(null);
      t5 = H.setRuntimeTypeInfo([], [P.String]);
      t6 = t2._assertCheck$1(null);
      H.assertSubtype(t5, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t3 = H.setRuntimeTypeInfo([], [P.String]);
      t4 = t2._assertCheck$1(null);
      H.assertSubtype(t3, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t7 = H.setRuntimeTypeInfo([], [P.String]);
      t8 = t2._assertCheck$1(null);
      H.assertSubtype(t7, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t9 = H.setRuntimeTypeInfo([], [P.String]);
      t10 = t2._assertCheck$1(null);
      H.assertSubtype(t9, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      K.Room$(t1, "Explore: CorridorLeftJunction", "left junction", [new K.Exit(null, null, t6, 1, "Explore: CorridorLeftNextToBunks", "walk towards the bridge", "after quite a walk, <subject> arrive<s> to the entrance to the bunks", false, "Exit", t5, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t4, 1, "Explore: Guts", "enter the guts", "<subject> open<s> the door and step<s> through a narrow hatchway", false, "Exit", t3, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t8, 1, "Explore: EngineRoom", "enter the engine room", "<subject> open<s> the bigger door and enter<s> into the engine room", false, "Exit", t7, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t10, 1, "Explore: CargoBayLeft", "go into the cargo bay", "<subject> walk<s> to the very end of Corridor Left and enter<s> the cargo bay through a huge {entrance|door}", false, "Exit", t9, true, 0, true, false, C.Pronoun_it_it_its_itself)], C.List_empty, C.List_empty, [-5, -45, 0], "CorridorLeftJunction.description", C.List_empty, false, null);
      lookAtTurret = K.Action$Goto("look at nonfunctional defensive turret", "Guts.TurretLook", true, null, null, false, true, null, null, null, null);
      this.repairTurret = K.Action$Goto("repair the defensive turret [~45 minutes]", "Guts.TurretRepair", false, null, null, false, true, null, null, null, null);
      t2._assertCheck$1(null);
      t9 = H.setRuntimeTypeInfo([], [P.String]);
      t10 = t2._assertCheck$1(null);
      H.assertSubtype(t9, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t7 = H.setRuntimeTypeInfo([], [P.String]);
      t8 = t2._assertCheck$1(null);
      H.assertSubtype(t7, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      K.Room$(t1, "Explore: Guts", "guts", [new K.Exit(null, null, t10, 1, "Explore: CorridorLeftJunction", "exit to Corridor Left", "<subject> {{exit|leave}<s>|step<s> out} to Corridor Left", false, "Exit", t9, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t8, 1, "Explore: CorridorRightJunction", "exit to Corridor Right", "<subject> {{exit|leave}<s>|step<s> out} to Corridor Right", false, "Exit", t7, true, 0, true, false, C.Pronoun_it_it_its_itself)], [lookAtTurret, this.repairTurret], C.List_empty, [0, -45, 0], "Guts.description", C.List_empty, false, null);
      this.setupEngineRoom$0();
      t2._assertCheck$1(null);
      t7 = H.setRuntimeTypeInfo([], [P.String]);
      t8 = t2._assertCheck$1(null);
      H.assertSubtype(t7, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t9 = H.setRuntimeTypeInfo([], [P.String]);
      t10 = t2._assertCheck$1(null);
      H.assertSubtype(t9, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t3 = H.setRuntimeTypeInfo([], [P.String]);
      t4 = t2._assertCheck$1(null);
      H.assertSubtype(t3, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      K.Room$(t1, "Explore: CorridorRightNextToComputerRoom", "Corridor Right", [new K.Exit(null, null, t8, 1, "Explore: Bridge", "walk to the bridge", "<subject> {enter<s>|arrive<s> at} the bridge", false, "Exit", t7, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t10, 1, "Explore: ComputerRoom", "enter the Computer Room", "<subject> {walk|step}<s> through the door", false, "Exit", t9, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t4, 1, "Explore: CorridorRightNextToAirlock", "walk {toward the cargo bay|to the {aft|back} of the ship}", "<subject> {stride|walk}<s> towards the {{aft|back} of the ship|cargo bay}", false, "Exit", t3, true, 0, true, false, C.Pronoun_it_it_its_itself)], C.List_empty, C.List_empty, [5, -10, 0], "CorridorRightNextToComputerRoom.description", C.List_empty, false, null);
      t2._assertCheck$1(null);
      t3 = H.setRuntimeTypeInfo([], [P.String]);
      t4 = t2._assertCheck$1(null);
      H.assertSubtype(t3, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      K.Room$(t1, "Explore: ComputerRoom", "Computer Room", [new K.Exit(null, null, t4, 1, "Explore: CorridorRightNextToComputerRoom", "leave", "<subject> {walk|step}<s> out to Corridor Right", false, "Exit", t3, true, 0, true, false, C.Pronoun_it_it_its_itself)], C.List_empty, C.List_empty, [7, -10, 0], "ComputerRoom.description", C.List_empty, false, null);
      this.pullLever = K.Action$Goto("pull the lever to let the captain's body out", "CorridorRightNextToAirlock.PullLever", false, null, null, false, true, null, null, null, null);
      t2._assertCheck$1(null);
      t3 = H.setRuntimeTypeInfo([], [P.String]);
      t4 = t2._assertCheck$1(null);
      H.assertSubtype(t3, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t9 = H.setRuntimeTypeInfo([], [P.String]);
      t10 = t2._assertCheck$1(null);
      H.assertSubtype(t9, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t7 = H.setRuntimeTypeInfo([], [P.String]);
      t8 = t2._assertCheck$1(null);
      H.assertSubtype(t7, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      K.Room$(t1, "Explore: CorridorRightNextToAirlock", "Corridor Right", [new K.Exit(null, null, t4, 1, "Explore: CorridorRightNextToComputerRoom", "walk towards the bridge", "<subject> arrive<s> at the door to the computer room", false, "Exit", t3, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t10, 1, "Explore: MedicalBay", "enter the medical bay", "<subject> enter<s> the medical bay", false, "Exit", t9, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t8, 1, "Explore: CorridorRightNextToBunks", "walk {toward the cargo bay|to the {aft|back} of the ship}", "<subject> {stride|walk}<s> towards the {{aft|back} of the ship|cargo bay}", false, "Exit", t7, true, 0, true, false, C.Pronoun_it_it_its_itself)], [K.Action$Goto("look into the airlock", "CorridorRightNextToAirlock.Look", true, null, null, false, true, null, null, null, null), this.pullLever], C.List_empty, [10, -15, 0], "CorridorRightNextToAirlock.description", C.List_empty, false, null);
      t2._assertCheck$1(null);
      t7 = H.setRuntimeTypeInfo([], [P.String]);
      t8 = t2._assertCheck$1(null);
      H.assertSubtype(t7, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t9 = H.setRuntimeTypeInfo([], [P.String]);
      t10 = t2._assertCheck$1(null);
      H.assertSubtype(t9, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      K.Room$(t1, "Explore: MedicalBay", "medical bay", [new K.Exit(null, null, t8, 1, "Explore: StaffRoom", "use the little door", "<subject> walk<s> through a narrow corridor and arrive<s> at the staff room", false, "Exit", t7, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t10, 1, "Explore: CorridorRightNextToAirlock", "exit to Corridor Right", "<subject> walk<s> out of the medical bay onto Corridor Right", false, "Exit", t9, true, 0, true, false, C.Pronoun_it_it_its_itself)], C.List_empty, C.List_empty, [5, -15, 0], "MedicalBay.description", C.List_empty, false, null);
      t2._assertCheck$1(null);
      t9 = H.setRuntimeTypeInfo([], [P.String]);
      t10 = t2._assertCheck$1(null);
      H.assertSubtype(t9, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t7 = H.setRuntimeTypeInfo([], [P.String]);
      t8 = t2._assertCheck$1(null);
      H.assertSubtype(t7, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t3 = H.setRuntimeTypeInfo([], [P.String]);
      t4 = t2._assertCheck$1(null);
      H.assertSubtype(t3, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      K.Room$(t1, "Explore: CorridorRightNextToBunks", "Corridor Right", [new K.Exit(null, null, t10, 1, "Explore: CorridorRightNextToAirlock", "walk towards the {bridge|front of the ship}", "<subject> walk<s> towards the front of the ship", false, "Exit", t9, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t8, 1, "Explore: Bunks", "enter the bunks", "<subject> enter<s> the bunks", false, "Exit", t7, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t4, 2, "Explore: CorridorRightJunction", "walk {toward the cargo bay|to the {aft|back} of the ship}", "after walking for 3 minutes, <subject> arrive<s> at the right junction", false, "Exit", t3, true, 0, true, false, C.Pronoun_it_it_its_itself)], C.List_empty, C.List_empty, [5, -25, 0], "CorridorRightNextToBunks.description", C.List_empty, false, null);
      t2._assertCheck$1(null);
      t3 = H.setRuntimeTypeInfo([], [P.String]);
      t4 = t2._assertCheck$1(null);
      H.assertSubtype(t3, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t7 = H.setRuntimeTypeInfo([], [P.String]);
      t8 = t2._assertCheck$1(null);
      H.assertSubtype(t7, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t9 = H.setRuntimeTypeInfo([], [P.String]);
      t10 = t2._assertCheck$1(null);
      H.assertSubtype(t9, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t5 = H.setRuntimeTypeInfo([], [P.String]);
      t6 = t2._assertCheck$1(null);
      H.assertSubtype(t5, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      K.Room$(t1, "Explore: CorridorRightJunction", "right junction", [new K.Exit(null, null, t4, 1, "Explore: CorridorRightNextToBunks", "walk towards the bridge", "after quite a walk, <subject> arrive<s> to the entrance to the bunks", false, "Exit", t3, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t8, 1, "Explore: Guts", "enter the guts", "<subject> open<s> the door and step<s> through a narrow hatchway", false, "Exit", t7, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t10, 1, "Explore: EngineRoom", "enter the engine room", "<subject> open<s> the bigger door and enter<s> into the engine room", false, "Exit", t9, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t6, 1, "Explore: CargoBayRight", "go into the cargo bay", "<subject> walk<s> to the very end of Corridor Right and enter<s> the cargo bay through a huge {entrance|door}", false, "Exit", t5, true, 0, true, false, C.Pronoun_it_it_its_itself)], C.List_empty, C.List_empty, [5, -45, 0], "CorridorRightJunction.description", C.List_empty, false, null);
      t2._assertCheck$1(null);
      t5 = H.setRuntimeTypeInfo([], [P.String]);
      t6 = t2._assertCheck$1(null);
      H.assertSubtype(t5, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t9 = H.setRuntimeTypeInfo([], [P.String]);
      t10 = t2._assertCheck$1(null);
      H.assertSubtype(t9, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t7 = H.setRuntimeTypeInfo([], [P.String]);
      t8 = t2._assertCheck$1(null);
      H.assertSubtype(t7, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      this.cargoBayLeft = K.Room$(t1, "Explore: CargoBayLeft", "cargo bay", [new K.Exit(null, null, t6, 1, "Explore: CorridorLeftJunction", "enter Corridor Left", "<subject> leave<s> the cargo bay and walk<s> up to the left junction", false, "Exit", t5, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t10, 2, "Explore: CargoCenter", "go to the other side of the cargo bay", "after a few moments, <subject> arrive<s> at the cargo bay console, located at the front center of the bay", false, "Exit", t9, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t8, 2, "Explore: ExplodedContainer", "go to the place of the explosion", "you head deep into the cargo bay and after about 2 minutes, you arrive at the site of the explosion", false, "Exit", t7, true, 0, true, false, C.Pronoun_it_it_its_itself)], C.List_empty, C.List_empty, [-10, -55, 0], "CargoBayLeft.description", C.List_empty, false, null);
      t2._assertCheck$1(null);
      t7 = H.setRuntimeTypeInfo([], [P.String]);
      t8 = t2._assertCheck$1(null);
      H.assertSubtype(t7, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      K.Room$(t1, "Explore: ExplodedContainer", "cargo bay", [new K.Exit(null, null, t8, 2, "Explore: CargoBayLeft", "go to the Corridor Left entrance", "<subject> arrive<s> at the front left side of the cargo bay", false, "Exit", t7, true, 0, true, false, C.Pronoun_it_it_its_itself)], [K.Action$Goto("Search [~30 minutes]", "ExplodedContainer.search", true, null, null, false, true, null, null, null, null)], C.List_empty, [-10, -100, -10], "ExplodedContainer.description", C.List_empty, false, null);
      t2._assertCheck$1(null);
      t7 = H.setRuntimeTypeInfo([], [P.String]);
      t8 = t2._assertCheck$1(null);
      H.assertSubtype(t7, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t9 = H.setRuntimeTypeInfo([], [P.String]);
      t10 = t2._assertCheck$1(null);
      H.assertSubtype(t9, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      K.Room$(t1, "Explore: CargoCenter", "cargo bay", [new K.Exit(null, null, t8, 2, "Explore: CargoBayLeft", "go to the left side of the cargo bay", "<subject> arrive<s> at the left side of the cargo bay", false, "Exit", t7, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t10, 2, "Explore: CargoBayRight", "go to the right side of the cargo bay", "<subject> arrive<s> at the right side of the cargo bay", false, "Exit", t9, true, 0, true, false, C.Pronoun_it_it_its_itself)], [K.Action$Goto("approach the console", "CargoCenter.console", true, null, null, false, false, null, null, null, null)], C.List_empty, [0, -55, 0], "CargoCenter.description", C.List_empty, false, null);
      t2._assertCheck$1(null);
      t9 = H.setRuntimeTypeInfo([], [P.String]);
      t9 = new K.Exit(null, null, t2._assertCheck$1(null), 1, "Explore: PlaceOfBreach", "go to the hull breach", "you arrive at the place of the breach", false, "Exit", H.assertSubtype(t9, "$isList", [P.String], "$asList"), true, 0, true, false, C.Pronoun_it_it_its_itself);
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      this.exitToHullBreach = t9;
      t9.isActive = false;
      t2._assertCheck$1(null);
      t9 = H.setRuntimeTypeInfo([], [P.String]);
      t10 = t2._assertCheck$1(null);
      H.assertSubtype(t9, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2._assertCheck$1(null);
      t7 = H.setRuntimeTypeInfo([], [P.String]);
      t8 = t2._assertCheck$1(null);
      H.assertSubtype(t7, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      K.Room$(t1, "Explore: CargoBayRight", "cargo bay", [new K.Exit(null, null, t10, 1, "Explore: CorridorRightJunction", "enter Corridor Right", "<subject> leave<s> the cargo bay and walk<s> up to the right junction", false, "Exit", t9, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t8, 2, "Explore: CargoCenter", "go to the other side of the cargo bay", "after a few moments, <subject> arrive<s> at the cargo bay console, located at the front center of the bay", false, "Exit", t7, true, 0, true, false, C.Pronoun_it_it_its_itself), this.exitToHullBreach], C.List_empty, C.List_empty, [10, -55, 0], "CargoBayRight.description", C.List_empty, false, null);
      t2._assertCheck$1(null);
      t7 = H.setRuntimeTypeInfo([], [P.String]);
      t8 = t2._assertCheck$1(null);
      H.assertSubtype(t7, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      K.Room$(t1, "Explore: PlaceOfBreach", "cargo bay", [new K.Exit(null, null, t8, 1, "Explore: CargoBayRight", "go back to entrance to Corridor Right", "you arrive at the entrance to Corridor Right", false, "Exit", t7, true, 0, true, false, C.Pronoun_it_it_its_itself)], C.List_empty, C.List_empty, [10, -70, 0], "PlaceOfBreach.description", C.List_empty, false, null);
      t2._assertCheck$1(null);
      t7 = H.setRuntimeTypeInfo([], [P.String]);
      t8 = t2._assertCheck$1(null);
      H.assertSubtype(t7, "$isList", [P.String], "$asList");
      t2._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      this.gorillasDen = K.Room$(t1, "Explore: GorillasDen", "cargo bay", [new K.Exit(null, null, t8, 1, "Explore: CargoBayLeft", "go back to entrance to Corridor Left", "you arrive at the entrance to Corridor Left", false, "Exit", t7, true, 0, true, false, C.Pronoun_it_it_its_itself)], C.List_empty, C.List_empty, [-10, -70, 0], "GorillasDen.description", C.List_empty, false, null);
    },
    setupEngineRoom$0: function() {
      var t1, t2, t3, t4, t5;
      this.repairEngineAction = K.Action$Goto("Take a look at the engine, try to bring output from 89% back to 100% [~3 hours]", "EngineRoom.RepairEngine", true, null, null, false, true, null, new L.BodegaZil_setupEngineRoom_closure(this), null, null);
      t1 = H.buildFunctionType(H.buildInterfaceType(P.bool), [H.buildInterfaceType(Y.Actor)]);
      t1._assertCheck$1(null);
      t2 = H.setRuntimeTypeInfo([], [P.String]);
      t3 = t1._assertCheck$1(null);
      H.assertSubtype(t2, "$isList", [P.String], "$asList");
      t1._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t1._assertCheck$1(null);
      t4 = H.setRuntimeTypeInfo([], [P.String]);
      t5 = t1._assertCheck$1(null);
      H.assertSubtype(t4, "$isList", [P.String], "$asList");
      t1._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      K.Room$(this.zil, "Explore: EngineRoom", "engine room", [new K.Exit(null, null, t3, 1, "Explore: CorridorLeftJunction", "exit to Corridor Left", "<subject> {{exit|leave}<s>|step<s> out} to Corridor Left", false, "Exit", t2, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t5, 1, "Explore: CorridorRightJunction", "exit to Corridor Right", "<subject> {{exit|leave}<s>|step<s> out} to Corridor Right", false, "Exit", t4, true, 0, true, false, C.Pronoun_it_it_its_itself)], [this.repairEngineAction], C.List_empty, [0, -50, 0], "EngineRoom.description", C.List_empty, false, null);
    },
    setupStaffRoom$0: function() {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19;
      t1 = this.zil;
      t2 = new L.BodegaZil_setupStaffRoom_closure(this);
      t3 = H.buildFunctionType(H.getVoidRuntimeType());
      t3._assertCheck$1(t2);
      t4 = H.buildInterfaceType(P.bool);
      t5 = H.buildFunctionType(t4, [H.buildInterfaceType(K.Item)]);
      t5._assertCheck$1(null);
      t6 = H.buildFunctionType(t4, [H.buildInterfaceType(K.ZilActor)]);
      t6._assertCheck$1(null);
      t7 = H.buildFunctionType(t4);
      t7._assertCheck$1(null);
      t8 = H.buildFunctionType(t4, [H.buildInterfaceType(K.Room)]);
      t8._assertCheck$1(null);
      t9 = t3._assertCheck$1(t2);
      t10 = t7._assertCheck$1(null);
      t11 = t8._assertCheck$1(null);
      t12 = t6._assertCheck$1(null);
      t13 = t5._assertCheck$1(null);
      t3._assertCheck$1(t2);
      t5._assertCheck$1(null);
      t6._assertCheck$1(null);
      t7._assertCheck$1(null);
      t8._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2 = new L.BodegaZil_setupStaffRoom_closure0(this);
      t14 = new L.BodegaZil_setupStaffRoom_closure1(this);
      t3._assertCheck$1(t2);
      t5._assertCheck$1(null);
      t6._assertCheck$1(t14);
      t7._assertCheck$1(null);
      t8._assertCheck$1(null);
      t15 = t3._assertCheck$1(t2);
      t16 = t7._assertCheck$1(null);
      t17 = t8._assertCheck$1(null);
      t18 = t6._assertCheck$1(t14);
      t19 = t5._assertCheck$1(null);
      t3._assertCheck$1(t2);
      t5._assertCheck$1(null);
      t6._assertCheck$1(t14);
      t7._assertCheck$1(null);
      t8._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      this.banana = K.Item$(t1, "banana", [new K.Action("eat the banana", t9, null, null, null, t10, t11, t12, t13, true, "\u00b7\u00b7\u00b7", 0, 1, true), new K.Action("give the banana to Gorilla", t15, null, null, null, t16, t17, t18, t19, false, "\u00b7\u00b7\u00b7", 0, null, true)], 1, null, null, false, false, false, C.Pronoun_it_it_its_itself, null, null, true);
      t4 = H.buildFunctionType(t4, [H.buildInterfaceType(Y.Actor)]);
      t4._assertCheck$1(null);
      t19 = H.setRuntimeTypeInfo([], [P.String]);
      t18 = t4._assertCheck$1(null);
      H.assertSubtype(t19, "$isList", [P.String], "$asList");
      t4._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t4._assertCheck$1(null);
      t17 = H.setRuntimeTypeInfo([], [P.String]);
      t16 = t4._assertCheck$1(null);
      H.assertSubtype(t17, "$isList", [P.String], "$asList");
      t4._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t4 = this.banana;
      K.Room$(t1, "Explore: StaffRoom", "staff room", [new K.Exit(null, null, t18, 1, "Explore: MedicalBay", "go through the little door", "<subject> squeeze<s> through a narrow, white passage and <subject> enter<s> the medbay through another small door", false, "Exit", t19, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t16, 1, "Explore: CorridorLeftNextToAirlock", "exit to Corridor Left", "<subject> walk<s> out of the room into Corridor Left", false, "Exit", t17, true, 0, true, false, C.Pronoun_it_it_its_itself)], [K.Action$Goto("look for food", "StaffRoom.findFood", true, null, null, false, true, null, null, null, null)], C.List_empty, [-5, -15, 0], "StaffRoom.description", [t4], false, null);
    },
    setupCorridorLeftNextToAirlock$0: function() {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13;
      t1 = this.zil;
      t2 = new L.BodegaZil_setupCorridorLeftNextToAirlock_closure(this);
      t3 = H.buildFunctionType(H.getVoidRuntimeType());
      t3._assertCheck$1(t2);
      t4 = H.buildInterfaceType(P.bool);
      t5 = H.buildFunctionType(t4, [H.buildInterfaceType(K.Item)]);
      t5._assertCheck$1(null);
      t6 = H.buildFunctionType(t4, [H.buildInterfaceType(K.ZilActor)]);
      t6._assertCheck$1(null);
      t7 = H.buildFunctionType(t4);
      t7._assertCheck$1(null);
      t8 = H.buildFunctionType(t4, [H.buildInterfaceType(K.Room)]);
      t8._assertCheck$1(null);
      t9 = t3._assertCheck$1(t2);
      t10 = t7._assertCheck$1(null);
      t11 = t8._assertCheck$1(null);
      t12 = t6._assertCheck$1(null);
      t13 = t5._assertCheck$1(null);
      t3._assertCheck$1(t2);
      t5._assertCheck$1(null);
      t6._assertCheck$1(null);
      t7._assertCheck$1(null);
      t8._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      this.infoFlyer = K.Item$(t1, "info flyer", [new K.Action("look at info flyer", t9, null, null, null, t10, t11, t12, t13, true, "\u00b7\u00b7\u00b7", 0, null, true)], 1, null, null, false, false, false, C.Pronoun_it_it_its_itself, "<subject> take<s> <object>, fold<s> <objectPronoun> and put<s> <objectPronoun> in a pocket", null, true);
      t4 = H.buildFunctionType(t4, [H.buildInterfaceType(Y.Actor)]);
      t4._assertCheck$1(null);
      t13 = H.setRuntimeTypeInfo([], [P.String]);
      t12 = t4._assertCheck$1(null);
      H.assertSubtype(t13, "$isList", [P.String], "$asList");
      t4._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t4._assertCheck$1(null);
      t11 = H.setRuntimeTypeInfo([], [P.String]);
      t10 = t4._assertCheck$1(null);
      H.assertSubtype(t11, "$isList", [P.String], "$asList");
      t4._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t4._assertCheck$1(null);
      t9 = H.setRuntimeTypeInfo([], [P.String]);
      t8 = t4._assertCheck$1(null);
      H.assertSubtype(t9, "$isList", [P.String], "$asList");
      t4._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t4 = this.infoFlyer;
      K.Room$(t1, "Explore: CorridorLeftNextToAirlock", "Corridor Left", [new K.Exit(null, null, t12, 1, "Explore: CorridorLeftNextToCaptainsCabin", "walk towards the bridge", "<subject> walk<s> towards the bridge up to the point where there is the door to the captain's cabin on the left hand side", false, "Exit", t13, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t10, 1, "Explore: StaffRoom", "enter the staff room", "<subject> enter<s> the staff room", false, "Exit", t11, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t8, 1, "Explore: CorridorLeftNextToBunks", "walk {toward the cargo bay|to the {aft|back} of the ship}", "<subject> arrive<s> at the door to the sleeping quarters", false, "Exit", t9, true, 0, true, false, C.Pronoun_it_it_its_itself)], [K.Action$Goto("examine the airlock", "LeftAirlock.Look", true, null, null, false, true, null, null, null, null)], C.List_empty, [-10, -15, 0], "CorridorLeftNextToAirlock.description", [t4], false, null);
    },
    setupCaptainsCabin$0: function() {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19;
      t1 = this.zil;
      t2 = new L.BodegaZil_setupCaptainsCabin_closure();
      t3 = H.buildFunctionType(H.getVoidRuntimeType());
      t3._assertCheck$1(t2);
      t4 = H.buildInterfaceType(P.bool);
      t5 = H.buildFunctionType(t4, [H.buildInterfaceType(K.Item)]);
      t5._assertCheck$1(null);
      t6 = H.buildFunctionType(t4, [H.buildInterfaceType(K.ZilActor)]);
      t6._assertCheck$1(null);
      t7 = H.buildFunctionType(t4);
      t7._assertCheck$1(null);
      t8 = H.buildFunctionType(t4, [H.buildInterfaceType(K.Room)]);
      t8._assertCheck$1(null);
      t9 = t3._assertCheck$1(t2);
      t10 = t7._assertCheck$1(null);
      t11 = t8._assertCheck$1(null);
      t12 = t6._assertCheck$1(null);
      t13 = t5._assertCheck$1(null);
      t3._assertCheck$1(t2);
      t5._assertCheck$1(null);
      t6._assertCheck$1(null);
      t7._assertCheck$1(null);
      t8._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t2 = new L.BodegaZil_setupCaptainsCabin_closure0(this);
      t14 = new L.BodegaZil_setupCaptainsCabin_closure1(this);
      t3._assertCheck$1(t2);
      t5._assertCheck$1(null);
      t6._assertCheck$1(t14);
      t7._assertCheck$1(null);
      t8._assertCheck$1(null);
      t15 = t3._assertCheck$1(t2);
      t16 = t7._assertCheck$1(null);
      t17 = t8._assertCheck$1(null);
      t18 = t6._assertCheck$1(t14);
      t19 = t5._assertCheck$1(null);
      t3._assertCheck$1(t2);
      t5._assertCheck$1(null);
      t6._assertCheck$1(t14);
      t7._assertCheck$1(null);
      t8._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      this.captainsGun = K.Item$(t1, "captain's gun", [new K.Action("check the gun", t9, null, null, null, t10, t11, t12, t13, true, "\u00b7\u00b7\u00b7", 0, 1, true), new K.Action("shoot the Gorilla", t15, null, null, null, t16, t17, t18, t19, true, "\u00b7\u00b7\u00b7", 0, null, true)], 1, null, null, false, false, false, C.Pronoun_it_it_its_itself, "<subject> lift<s> the <object> and put<s> it in the pocket", null, true);
      this.gorillaCorpse = K.Item$(t1, "Gorilla's body", C.List_empty, 1, null, null, false, false, false, C.Pronoun_it_it_its_itself, null, null, true);
      this.firstLookAround = K.Action$Goto("have a look around [~15 minutes]", "CaptainsCabinLookAround", true, null, null, false, true, null, null, null, null);
      this.secondLookAround = K.Action$Goto("continue with the search [~15 minutes]", "CaptainsCabinLookAroundContinue", false, null, null, false, true, null, null, null, null);
      this.thirdLookAround = K.Action$Goto("search the rest of the room [~5 minutes]", "CaptainsCabinLookAroundTheRest", false, null, null, false, true, null, null, null, null);
      this.captainsComputerFirst = K.Action$Goto("look at captain's computer screen", "CaptainsComputerFirst", true, null, null, false, true, null, null, null, null);
      t4 = H.buildFunctionType(t4, [H.buildInterfaceType(Y.Actor)]);
      t4._assertCheck$1(null);
      t19 = H.setRuntimeTypeInfo([], [P.String]);
      t18 = t4._assertCheck$1(null);
      H.assertSubtype(t19, "$isList", [P.String], "$asList");
      t4._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t4 = this.captainsGun;
      K.Room$(t1, "Explore: CaptainsCabin", "captain's cabin", [new K.Exit(null, null, t18, 1, "Explore: CorridorLeftNextToCaptainsCabin", "exit the room", "<subject> leave<s> into the corridor", false, "Exit", t19, true, 0, true, false, C.Pronoun_it_it_its_itself)], [this.firstLookAround, this.secondLookAround, this.thirdLookAround, this.captainsComputerFirst], C.List_empty, [-10, -10, 0], "CaptainsCabin.description", [t4], false, null);
    },
    setupBridge$0: function() {
      var t1, t2, t3, t4, t5, t6, t7;
      this.lookAtHullBreachFromBridge = K.Action$Goto("put up the hull breach on the screen", "LookAtHullBreachFromBridge", false, null, null, false, true, null, null, null, null);
      this.askBodegaQuestions = K.Action$Goto("ask Bodega some questions", "BodegaQuestions: Start", true, null, null, false, false, null, new L.BodegaZil_setupBridge_closure(this), null, null);
      this.takeANap = K.Action$Goto("Take a nap", "Bridge: Nap", true, null, null, false, true, null, new L.BodegaZil_setupBridge_closure0(this), null, null);
      this.waitForJumpToUnity = K.Action$Goto("Wait until ready to jump to Unity", "Bridge: WaitForJump", true, null, null, false, true, null, new L.BodegaZil_setupBridge_closure1(this), null, null);
      this.jumpToSpaceStationUnity = K.Action$Goto("initiate the jump to Space Station Unity", "Unity: Jump", false, null, null, false, false, null, new L.BodegaZil_setupBridge_closure2(this), null, null);
      t1 = H.buildFunctionType(H.buildInterfaceType(P.bool), [H.buildInterfaceType(Y.Actor)]);
      t1._assertCheck$1(null);
      t2 = H.setRuntimeTypeInfo([], [P.String]);
      t3 = t1._assertCheck$1(null);
      H.assertSubtype(t2, "$isList", [P.String], "$asList");
      t1._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t1._assertCheck$1(null);
      t4 = H.setRuntimeTypeInfo([], [P.String]);
      t5 = t1._assertCheck$1(null);
      H.assertSubtype(t4, "$isList", [P.String], "$asList");
      t1._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t1._assertCheck$1(null);
      t6 = H.setRuntimeTypeInfo([], [P.String]);
      t7 = t1._assertCheck$1(null);
      H.assertSubtype(t6, "$isList", [P.String], "$asList");
      t1._assertCheck$1(null);
      O.throwIfNotInInitOrDeclareBlock("");
      t1 = this.gorilla;
      this.bridge = K.Room$(this.zil, "Explore: Bridge", "the bridge", [new K.Exit(null, null, t3, 1, "Explore: Nose", "use the utility corridor to the nose of the ship", "<subject> squeeze<s> into the narrow space below the main 'window'", false, "Exit", t2, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t5, 1, "Explore: CorridorLeftNextToCaptainsCabin", "leave to Corridor Left", "<subject> {go<es>|walk<s>} through the sliding door into Corridor Left and \u2013 after a few more paces \u2013 arrive<s> at the entrance to the captain's cabin", false, "Exit", t4, true, 0, true, false, C.Pronoun_it_it_its_itself), new K.Exit(null, null, t7, 1, "Explore: CorridorRightNextToComputerRoom", "leave to Corridor Right", "<subject> {go<es>|walk<s>} through the sliding door into Corridor Right and \u2013 after a few more paces \u2013 arrive<s> at the entrance to the computer room", false, "Exit", t6, true, 0, true, false, C.Pronoun_it_it_its_itself)], [this.waitForJumpToUnity, this.jumpToSpaceStationUnity, this.askBodegaQuestions, this.lookAtHullBreachFromBridge, this.takeANap], [t1], [0, 0, 0], "Bridge.description", C.List_empty, false, new L.BodegaZil_setupBridge_closure3(this));
    },
    getHoursToHyperdrive$0: [function() {
      var hours, tenMinutes, t1;
      hours = C.JSInt_methods.$sub(473, this.exploration.time) / 60;
      if (hours < 0)
        throw H.wrapException("getHoursToHyperdrive() called after jump");
      if (hours < 1) {
        tenMinutes = C.JSDouble_methods.round$0(hours * 6);
        if (tenMinutes === 0)
          return "a few minutes";
        return "about " + tenMinutes + "0 minutes";
      }
      t1 = "" + C.JSDouble_methods.round$0(hours) + " hour";
      return t1 + (hours >= 1.5 ? "s" : "");
    }, "call$0", "get$getHoursToHyperdrive", 0, 0, 7],
    printSleepiness$0: [function() {
      var t1 = this.exploration.time;
      if (typeof t1 !== "number")
        return t1.$tdiv();
      t1 = C.JSInt_methods.$tdiv(t1, 19.2);
      if (t1 > 4)
        return;
      if (t1 >>> 0 !== t1 || t1 >= 5)
        return H.ioore(C.List_0, t1);
      this.echo$1("You are feeling " + C.List_0[t1] + ".");
    }, "call$0", "get$printSleepiness", 0, 0, 4],
    getInformalSalutation$0: function() {
      var t1 = this.scripter;
      if (t1.title === "")
        return t1.name;
      else
        return "captain";
    },
    computeProductivity$1: function(skilled) {
      var productivity = H.boolConversionCheck(this.scripter.currentlyHighOnShabu) ? 1.3 : 1;
      return skilled ? productivity + 0.3 : productivity;
    },
    createTraitsForm$0: function() {
      var traitsForm, t1, t2, t3, t4, pointsLeft, t5, t6, isHawkeyedInput, isStrongInput, knowsJapaneseInput, understandsAnimalsInput, understandsAIInput, understandsElectronicsInput, t7, hasScienceEducationInput, isHandyInput;
      traitsForm = G.Form$(null);
      traitsForm.attributes.$indexSet(0, "submitText", ">>");
      t1 = H.buildInterfaceType(P.Object);
      t2 = H.buildFunctionType(H.buildInterfaceType(P.String), [t1]);
      t2._assertCheck$1(null);
      t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t4 = H.setRuntimeTypeInfo([], [B.Node0]);
      t4 = new B.NodeList(null, H.assertSubtype(t4, "$isList", [B.Node0], "$asList"));
      pointsLeft = new G.RangeOutput(t2._assertCheck$1(new G.closure4()), 3, 0, 3, 1, null, null, null, "RangeOutput", null, H.assertSubtype(t3, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap"), t4, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t4._parent = pointsLeft;
      pointsLeft.RangeBase$withConstraints$8("RangeOutput", "Trait points left", 3, 0, 3, 1, null, null);
      t2._assertCheck$1(null);
      t2 = new L.BodegaZil_createTraitsForm_updateTraitPoints(this, traitsForm, pointsLeft, H.assertSubtype(H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, G.CheckboxInput), "$isSet", [G.CheckboxInput], "$asSet"), "$isSet", [G.CheckboxInput], "$asSet"));
      t3 = new L.BodegaZil_createTraitsForm_closure(this, t2);
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [t1]);
      t1._assertCheck$1(t3);
      t4 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t5 = H.setRuntimeTypeInfo([], [B.Node0]);
      t5 = new B.NodeList(null, H.assertSubtype(t5, "$isList", [B.Node0], "$asList"));
      t6 = t1._assertCheck$1(null);
      H.assertSubtype(t4, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      isHawkeyedInput = new G.CheckboxInput(t6, null, null, "CheckboxInput", null, t4, t5, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t5._parent = isHawkeyedInput;
      t4.$indexSet(0, "name", "You have good eyesight and spotting abilities");
      t1._assertCheck$1(t3);
      isHawkeyedInput.set$onInput(t3);
      isHawkeyedInput.current = false;
      t3 = new L.BodegaZil_createTraitsForm_closure0(this, t2);
      t1._assertCheck$1(t3);
      t4 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t5 = H.setRuntimeTypeInfo([], [B.Node0]);
      t5 = new B.NodeList(null, H.assertSubtype(t5, "$isList", [B.Node0], "$asList"));
      t6 = t1._assertCheck$1(null);
      H.assertSubtype(t4, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      isStrongInput = new G.CheckboxInput(t6, null, null, "CheckboxInput", null, t4, t5, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t5._parent = isStrongInput;
      t4.$indexSet(0, "name", "You are physically strong, a good fighter");
      t1._assertCheck$1(t3);
      isStrongInput.set$onInput(t3);
      isStrongInput.current = false;
      t3 = new L.BodegaZil_createTraitsForm_closure1(this, t2);
      t1._assertCheck$1(t3);
      t4 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t5 = H.setRuntimeTypeInfo([], [B.Node0]);
      t5 = new B.NodeList(null, H.assertSubtype(t5, "$isList", [B.Node0], "$asList"));
      t6 = t1._assertCheck$1(null);
      H.assertSubtype(t4, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      knowsJapaneseInput = new G.CheckboxInput(t6, null, null, "CheckboxInput", null, t4, t5, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t5._parent = knowsJapaneseInput;
      t4.$indexSet(0, "name", "You can speak basic Japanese");
      t1._assertCheck$1(t3);
      knowsJapaneseInput.set$onInput(t3);
      knowsJapaneseInput.current = false;
      t3 = new L.BodegaZil_createTraitsForm_closure2(this, t2);
      t1._assertCheck$1(t3);
      t4 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t5 = H.setRuntimeTypeInfo([], [B.Node0]);
      t5 = new B.NodeList(null, H.assertSubtype(t5, "$isList", [B.Node0], "$asList"));
      t6 = t1._assertCheck$1(null);
      H.assertSubtype(t4, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      understandsAnimalsInput = new G.CheckboxInput(t6, null, null, "CheckboxInput", null, t4, t5, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t5._parent = understandsAnimalsInput;
      t4.$indexSet(0, "name", "You are good with animals");
      t1._assertCheck$1(t3);
      understandsAnimalsInput.set$onInput(t3);
      understandsAnimalsInput.current = false;
      t3 = new L.BodegaZil_createTraitsForm_closure3(this, t2);
      t1._assertCheck$1(t3);
      t4 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t5 = H.setRuntimeTypeInfo([], [B.Node0]);
      t5 = new B.NodeList(null, H.assertSubtype(t5, "$isList", [B.Node0], "$asList"));
      t6 = t1._assertCheck$1(null);
      H.assertSubtype(t4, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      understandsAIInput = new G.CheckboxInput(t6, null, null, "CheckboxInput", null, t4, t5, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t5._parent = understandsAIInput;
      t4.$indexSet(0, "name", "You have received a psychology training on artificial intelligence");
      t1._assertCheck$1(t3);
      understandsAIInput.set$onInput(t3);
      understandsAIInput.current = false;
      t3 = new L.BodegaZil_createTraitsForm_closure4(this, t2);
      t1._assertCheck$1(t3);
      t4 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t5 = H.setRuntimeTypeInfo([], [B.Node0]);
      t5 = new B.NodeList(null, H.assertSubtype(t5, "$isList", [B.Node0], "$asList"));
      t6 = t1._assertCheck$1(null);
      H.assertSubtype(t4, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      understandsElectronicsInput = new G.CheckboxInput(t6, null, null, "CheckboxInput", null, t4, t5, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t5._parent = understandsElectronicsInput;
      t4.$indexSet(0, "name", "You understand electronics well and you are proficient in using and repairing them");
      t1._assertCheck$1(t3);
      understandsElectronicsInput.set$onInput(t3);
      understandsElectronicsInput.current = false;
      t3 = new L.BodegaZil_createTraitsForm_closure5(this, t2);
      t1._assertCheck$1(t3);
      t5 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t6 = H.setRuntimeTypeInfo([], [B.Node0]);
      t6 = new B.NodeList(null, H.assertSubtype(t6, "$isList", [B.Node0], "$asList"));
      t7 = t1._assertCheck$1(null);
      H.assertSubtype(t5, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      hasScienceEducationInput = new G.CheckboxInput(t7, null, null, "CheckboxInput", null, t5, t6, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t6._parent = hasScienceEducationInput;
      t5.$indexSet(0, "name", "You have science education");
      t1._assertCheck$1(t3);
      hasScienceEducationInput.set$onInput(t3);
      hasScienceEducationInput.current = false;
      t2 = new L.BodegaZil_createTraitsForm_closure6(this, t2);
      t1._assertCheck$1(t2);
      t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t6 = H.setRuntimeTypeInfo([], [B.Node0]);
      t6 = new B.NodeList(null, H.assertSubtype(t6, "$isList", [B.Node0], "$asList"));
      t7 = t1._assertCheck$1(null);
      H.assertSubtype(t3, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      isHandyInput = new G.CheckboxInput(t7, null, null, "CheckboxInput", null, t3, t6, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t6._parent = isHandyInput;
      t3.$indexSet(0, "name", "You know your way around a spaceship");
      t1._assertCheck$1(t2);
      isHandyInput.set$onInput(t2);
      isHandyInput.current = false;
      t1 = this.scripter;
      if (H.boolConversionCheck(t1.isEngineer)) {
        understandsElectronicsInput.current = true;
        t4.$indexSet(0, "disabled", "true");
      }
      if (H.boolConversionCheck(t1.isMedic)) {
        hasScienceEducationInput.current = true;
        t5.$indexSet(0, "disabled", "true");
      }
      if (H.boolConversionCheck(t1.isSpaceman)) {
        isHandyInput.current = true;
        t3.$indexSet(0, "disabled", "true");
      }
      t1 = traitsForm.nodes;
      H.voidTypeCheck(t1.add$1(0, pointsLeft));
      H.voidTypeCheck(t1.add$1(0, isHawkeyedInput));
      H.voidTypeCheck(t1.add$1(0, isStrongInput));
      H.voidTypeCheck(t1.add$1(0, knowsJapaneseInput));
      H.voidTypeCheck(t1.add$1(0, understandsAnimalsInput));
      H.voidTypeCheck(t1.add$1(0, understandsAIInput));
      H.voidTypeCheck(t1.add$1(0, understandsElectronicsInput));
      H.voidTypeCheck(t1.add$1(0, hasScienceEducationInput));
      H.voidTypeCheck(t1.add$1(0, isHandyInput));
      traitsForm.onSubmit = new L.BodegaZil_createTraitsForm_closure7(this, pointsLeft);
      this.showForm$1(traitsForm);
    },
    echoTraits$0: function() {
      var assets, t1, str, t2, buf;
      assets = H.assertSubtype(P.ListQueue$(null, P.String), "$isQueue", [P.String], "$asQueue");
      t1 = this.scripter;
      if (H.boolConversionCheck(t1.isHawkeyed)) {
        H.assertSubtypeOfRuntimeType("good eyesight", H.getTypeArgumentByIndex(assets, 0));
        assets._add$1("good eyesight");
      }
      if (H.boolConversionCheck(t1.isStrong)) {
        H.assertSubtypeOfRuntimeType("a strong hand", H.getTypeArgumentByIndex(assets, 0));
        assets._add$1("a strong hand");
      }
      if (H.boolConversionCheck(t1.knowsJapanese)) {
        H.assertSubtypeOfRuntimeType("an ability to speak Japanese", H.getTypeArgumentByIndex(assets, 0));
        assets._add$1("an ability to speak Japanese");
      }
      if (H.boolConversionCheck(t1.understandsAnimals)) {
        H.assertSubtypeOfRuntimeType("reasonable animal handling skills", H.getTypeArgumentByIndex(assets, 0));
        assets._add$1("reasonable animal handling skills");
      }
      if (H.boolConversionCheck(t1.understandsAI)) {
        H.assertSubtypeOfRuntimeType("some AI training", H.getTypeArgumentByIndex(assets, 0));
        assets._add$1("some AI training");
      }
      if (H.boolConversionCheck(t1.understandsElectronics) && !H.boolConversionCheck(t1.isEngineer)) {
        H.assertSubtypeOfRuntimeType("decent understanding of electronics", H.getTypeArgumentByIndex(assets, 0));
        assets._add$1("decent understanding of electronics");
      }
      if (H.boolConversionCheck(t1.hasScienceEducation) && !H.boolConversionCheck(t1.isMedic)) {
        H.assertSubtypeOfRuntimeType("good science education", H.getTypeArgumentByIndex(assets, 0));
        assets._add$1("good science education");
      }
      if (H.boolConversionCheck(t1.isHandy) && !H.boolConversionCheck(t1.isSpaceman)) {
        H.assertSubtypeOfRuntimeType("general space savvy", H.getTypeArgumentByIndex(assets, 0));
        assets._add$1("general space savvy");
      }
      str = H.boolConversionCheck(t1.isEngineer) ? "machinist" : null;
      if (H.boolConversionCheck(t1.isMedic))
        str = "medic";
      t2 = "You're not the fastest, smoothest or most experienced of the old crew, but you're a decent " + S.Randomly_parse(" " + H.S(H.boolConversionCheck(t1.isSpaceman) ? "{spaceman|sailor}" : str));
      buf = new P.StringBuffer(t2);
      if (!assets.get$isEmpty(assets)) {
        t1 = t2 + " with ";
        buf._contents = t1;
        buf._contents = t1 + H.S(assets.removeFirst$0());
        for (; !assets.get$isEmpty(assets);) {
          buf._contents += (assets._tail - assets._head & assets._table.length - 1) >>> 0 > 1 ? ", " : " and ";
          buf._contents += H.S(assets.removeFirst$0());
        }
      }
      t1 = buf._contents += ". ";
      t1 += "You've survived this far. There _must_ be a reason you're not dead already.";
      buf._contents = t1;
      this.echo$1(t1.charCodeAt(0) == 0 ? t1 : t1);
    },
    createExtraEffortChoiceList$6: function(normalChoiceString, normalOutcome, extraEffortChoiceString, physicalCost, mentalCost, extraEffortOutcome) {
      var t1, t2;
      this.choice$2$script(normalChoiceString, new L.BodegaZil_createExtraEffortChoiceList_closure(normalOutcome));
      if (physicalCost > 0) {
        t1 = extraEffortChoiceString + (" [-" + physicalCost + " P]");
        t2 = this.scripter.physicalPoints;
        if (C.JSInt_methods.$gt(physicalCost, H.assertSubtypeOfRuntimeType(t2._value, H.getTypeArgumentByIndex(t2, 0))))
          t1 += " [DISABLED]";
      } else
        t1 = extraEffortChoiceString;
      if (mentalCost > 0) {
        t1 += " [-" + mentalCost + " M]";
        t2 = this.scripter.mentalPoints;
        if (C.JSInt_methods.$gt(mentalCost, H.assertSubtypeOfRuntimeType(t2._value, H.getTypeArgumentByIndex(t2, 0))))
          t1 += " [DISABLED]";
      }
      this.choice$2$script(t1.charCodeAt(0) == 0 ? t1 : t1, new L.BodegaZil_createExtraEffortChoiceList_closure0(this, physicalCost, mentalCost, extraEffortOutcome));
    },
    goto$1: function(arg0) {
      return this.$goto.call$1(arg0);
    },
    echo$1: function(arg0) {
      return this.echo.call$1(arg0);
    },
    choice$2$script: function(arg0, arg1) {
      return this.choice.call$2$script(arg0, arg1);
    },
    showForm$1: function(arg0) {
      return this.showForm.call$1(arg0);
    }
  },
  BodegaZil_setupTimeline_closure: {
    "^": "Closure:1;_bodega_zil$_captured_this_0",
    call$0: function() {
      var t1 = this._bodega_zil$_captured_this_0.scripter.clock;
      t1.set$value(J.$add$ns(H.assertSubtypeOfRuntimeType(t1._value, H.getTypeArgumentByIndex(t1, 0)), 1));
    }
  },
  BodegaZil_setupTimeline_closure0: {
    "^": "Closure:1;_bodega_zil$_captured_this_1",
    call$0: function() {
      var t1 = this._bodega_zil$_captured_this_1;
      t1.echo$1("\n\n");
      t1.echo$1(t1.exploration.generateWhileOutput$2("While <whileString> you have a brief sensation of mild tingling in your nose.", "You have a brief sensation of mild tingling in your nose."));
      t1.echo$1("You ascribe it to sleep deprivation.");
      t1.echo$1("\n\n");
    }
  },
  BodegaZil_setupTimeline_closure1: {
    "^": "Closure:1;_bodega_zil$_captured_this_2",
    call$0: function() {
      var t1 = this._bodega_zil$_captured_this_2;
      t1.scripter.roomBeforeOvercameBySleepiness = t1.zil.player.location.name;
      t1.goto$1("Bridge: OvercomeBySleepiness");
    }
  },
  BodegaZil_setupTimeline_closure2: {
    "^": "Closure:1;_bodega_zil$_captured_this_3",
    call$0: function() {
      var t1 = this._bodega_zil$_captured_this_3;
      t1.jumpToSpaceStationUnity.isActive = true;
      t1.echo$1("\n\n");
      t1.echo$1(t1.exploration.generateWhileOutput$2("While <whileString> the ship's PA system makes a short bleep,", "The ship's PA system makes a short bleep,"));
      t1.echo$1("then Bodega says: \"The hyperdrive is fully operational. I am ready to jump, " + H.S(t1.getInformalSalutation$0()) + ".\" \n\n");
    }
  },
  BodegaZil_setupTimeline_closure3: {
    "^": "Closure:1;_bodega_zil$_captured_this_4",
    call$0: function() {
      var t1 = this._bodega_zil$_captured_this_4;
      t1.echo$1("The Bodega says: \"We have arrived to Space Station Unity.\" ");
      t1 = t1.scripter;
      t1.justArrivedAtUnity = true;
      t1.currentlyInJump = false;
    }
  },
  BodegaZil_setupTimeline_closure4: {
    "^": "Closure:1;_bodega_zil$_captured_this_5",
    call$0: function() {
      this._bodega_zil$_captured_this_5.echo$1("\n\n Although you're more or less rested after the short nap, something doesn't feel quite right. You are sweating and you have a strange taste in your mouth. Is it just paranoia? \n\n");
    }
  },
  BodegaZil_setupTimeline_closure5: {
    "^": "Closure:1;_bodega_zil$_captured_this_6",
    call$0: function() {
      var t1 = this._bodega_zil$_captured_this_6;
      t1.echo$1("\n\n");
      t1.echo$1(t1.exploration.generateWhileOutput$2("While <whileString> you have to stop for a moment.", ""));
      t1.echo$1("You have a brief fit of uncontrollable coughing. You stand there for a while, waiting if it comes back but it doesn't. You tell yourself it's nothing. \n\n");
    }
  },
  BodegaZil_setupTimeline_closure6: {
    "^": "Closure:1;_bodega_zil$_captured_this_7",
    call$0: function() {
      var t1 = this._bodega_zil$_captured_this_7;
      t1.echo$1("\n\n");
      t1.echo$1(t1.exploration.generateWhileOutput$2("While <whileString>, you suddenly feel formidable pressure in your chest.", "Suddenly, you feel formidable pressure in your chest."));
      t1.echo$1("In a few seconds, the pressure builds into agonising pain. You fall on your knees and wonder if this is it. If this is the end of the line. The time you die. You can't breathe. You can't scream. You can't even bring your hands up to your face to sink your fingernails into it. \n\n");
      t1.echo$1("But then, in a few seconds time, the pain is gone and so is the pressure. You carefully try to breathe in, and there's nothing. Not even a cough. This thing \u2014 whatever it was \u2014 has passed. \n\n");
    }
  },
  BodegaZil_setupTimeline_closure7: {
    "^": "Closure:1;_bodega_zil$_captured_this_8",
    call$0: function() {
      var t1 = this._bodega_zil$_captured_this_8;
      t1.echo$1("\n\n");
      t1.echo$1(t1.exploration.generateWhileOutput$2("While <whileString>, the cough comes back.", "The cough is back."));
      t1.echo$1("It's stronger and more painful than before, and you have to close your eyes and curl your body to keep on top of it. It feels like your lungs.\n\n");
      t1.echo$1("In a few seconds it fades but if the rest of the crew is any indication, this was just a mild beginning.\n\n");
    }
  },
  BodegaZil_setupTimeline_closure8: {
    "^": "Closure:1;_bodega_zil$_captured_this_9",
    call$0: function() {
      var t1 = this._bodega_zil$_captured_this_9;
      t1.echo$1("\n\n");
      t1.echo$1(t1.exploration.generateWhileOutput$2("While <whileString>, you suddenly feel your muscles getting stiff.", "Suddenly, you feel your muscles getting stiff."));
      t1.echo$1("The more you try to move, the worse it gets. You quickly grab a nearby steel railing and you go to your knees, trying to brace for the pain. You close your eyes. \n\n");
      t1.echo$1("What comes next is unspeakable. Your whole body burns and shakes with wave after wave of excruciating pain, and it just doesn't go away, for what seems like millenia. If you could scream, you would. At one point, you solemnly pray for death. \n\n");
      t1.echo$1("Which is about when the whole thing fades away. The waves of pain get milder until you can sense other things again. You open your eyes and find out you're exactly in the same position, kneeling next to a railing, as when the pain started.");
      t1.echo$1("\n\n ![Hand grabbing a railing IMG] \n\n");
      t1.echo$1("And then you notice your hand on the railing and you realize that what was previously a straight steel pipe is now slightly bent at the point where your hand rests. You just deformed a solid metal railing. With your bare hand. \n\n");
      t1.echo$1("_What?_ You lift your hand and have a better look at the railing below it. It's the same steel as everywhere else. _Am I getting crazy now?_ You try to bend it some more, but the steel doesn't budge. \n\n");
      t1.echo$1("You slowly stand up and shake your head. _I'm definitely getting crazy._ \n\n");
    }
  },
  BodegaZil_setupEngineRoom_closure: {
    "^": "Closure:1;_bodega_zil$_captured_this_0",
    call$0: function() {
      var t1 = this._bodega_zil$_captured_this_0.scripter;
      return H.boolConversionCheck(t1.isEngineer) && !H.boolConversionCheck(t1.currentlyInJump);
    }
  },
  BodegaZil_setupStaffRoom_closure: {
    "^": "Closure:1;_bodega_zil$_captured_this_0",
    call$0: function() {
      $.get$storyline().add$1(0, "You pull the banana out of your pocket, peel it, and eat it. It's delicious. You feel a little bit invigorated.");
      var t1 = this._bodega_zil$_captured_this_0;
      t1.scripter.stoleOfficersBanana = true;
      t1.banana.isActive = false;
    }
  },
  BodegaZil_setupStaffRoom_closure0: {
    "^": "Closure:1;_bodega_zil$_captured_this_1",
    call$0: function() {
      var t1, t2, t3;
      $.get$storyline().add$1(0, "You hand the banana to Gorilla. He watches it with amazement, than proceeds to peel it eagerly. Before he takes the first bite, though, he gives you a thankful look.\n\nAfter only a few seconds, the banana is no more. But Gorilla seems very happy.");
      t1 = this._bodega_zil$_captured_this_1;
      t2 = t1.scripter;
      t3 = t2.gorillaAttitude;
      if (typeof t3 !== "number")
        return t3.$add();
      t2.gorillaAttitude = t3 + 2;
      t2.stoleOfficersBanana = true;
      t1.banana.isActive = false;
      $.get$_points().add$2(0, 5, "making friends");
    }
  },
  BodegaZil_setupStaffRoom_closure1: {
    "^": "Closure:2;_bodega_zil$_captured_this_2",
    call$1: function(actor) {
      var t1, t2, t3;
      t1 = this._bodega_zil$_captured_this_2.gorilla;
      t2 = actor.location;
      t3 = t1.location;
      return (t2 == null ? t3 == null : t2 === t3) && H.boolConversionCheck(actor.isActive) && H.boolConversionCheck(t1.isActive);
    }
  },
  BodegaZil_setupCorridorLeftNextToAirlock_closure: {
    "^": "Closure:1;_bodega_zil$_captured_this_0",
    call$0: function() {
      this._bodega_zil$_captured_this_0.echo$1("You pull the flyer out of your pocket and unfold it. \n\n[IMG]\n\nThen you fold it again and put it back.");
    }
  },
  BodegaZil_setupCaptainsCabin_closure: {
    "^": "Closure:1;",
    call$0: function() {
      return $.get$storyline().add$1(0, "You pull the gun out of your pocket and heft it in your hand. It's heavy, well-built and seems in fine condition. It is loaded.");
    }
  },
  BodegaZil_setupCaptainsCabin_closure0: {
    "^": "Closure:1;_bodega_zil$_captured_this_0",
    call$0: function() {
      $.get$storyline().add$1(0, "You lift the gun and aim at Gorilla. He freezes and looks absolutely horrified.");
      var t1 = this._bodega_zil$_captured_this_0;
      t1.choice$2$script("Pull the trigger", new L.BodegaZil_setupCaptainsCabin__closure(t1));
      t1.choice$2$script("Put the gun down", new L.BodegaZil_setupCaptainsCabin__closure0());
    }
  },
  BodegaZil_setupCaptainsCabin__closure: {
    "^": "Closure:1;_bodega_zil$_captured_this_1",
    call$0: function() {
      var t1, t2, t3;
      t1 = $.get$storyline();
      t1.add$1(0, "You shoot.");
      t2 = this._bodega_zil$_captured_this_1;
      t3 = t2.gorilla;
      t3.isActive = false;
      t2 = t2.gorillaCorpse;
      t2.isActive = true;
      t3 = t3.location;
      t2._carrier = null;
      t2._location = t3;
      t1.add$1(0, "Gorilla takes it in the chest and falls to the ground with a loud thump. A puddle of blood starts forming under him almost immediately.");
    }
  },
  BodegaZil_setupCaptainsCabin__closure0: {
    "^": "Closure:1;",
    call$0: function() {
      $.get$storyline().add$1(0, "You put the gun down. Gorilla doesn't move. He watches you in terror, frozen in place.");
    }
  },
  BodegaZil_setupCaptainsCabin_closure1: {
    "^": "Closure:2;_bodega_zil$_captured_this_2",
    call$1: function(actor) {
      var t1, t2, t3;
      t1 = this._bodega_zil$_captured_this_2.gorilla;
      t2 = actor.location;
      t3 = t1.location;
      return (t2 == null ? t3 == null : t2 === t3) && H.boolConversionCheck(actor.isActive) && H.boolConversionCheck(t1.isActive);
    }
  },
  BodegaZil_setupBridge_closure: {
    "^": "Closure:1;_bodega_zil$_captured_this_0",
    call$0: function() {
      return J.get$length$as(this._bodega_zil$_captured_this_0.scripter.bodegaTopics) > 0;
    }
  },
  BodegaZil_setupBridge_closure0: {
    "^": "Closure:1;_bodega_zil$_captured_this_1",
    call$0: function() {
      var t1 = this._bodega_zil$_captured_this_1.zil.timeline.time;
      if (typeof t1 !== "number")
        return t1.$lt();
      return t1 < 96;
    }
  },
  BodegaZil_setupBridge_closure1: {
    "^": "Closure:1;_bodega_zil$_captured_this_2",
    call$0: function() {
      var t1, t2;
      t1 = this._bodega_zil$_captured_this_2;
      t2 = t1.zil.timeline.time;
      if (typeof t2 !== "number")
        return t2.$ge();
      return t2 >= 460 && t2 < 473 && !H.boolConversionCheck(t1.scripter.jumpedToUnity);
    }
  },
  BodegaZil_setupBridge_closure2: {
    "^": "Closure:1;_bodega_zil$_captured_this_3",
    call$0: function() {
      return !H.boolConversionCheck(this._bodega_zil$_captured_this_3.scripter.jumpedToUnity);
    }
  },
  BodegaZil_setupBridge_closure3: {
    "^": "Closure:1;_bodega_zil$_captured_this_4",
    call$0: function() {
      var t1 = this._bodega_zil$_captured_this_4;
      if (H.boolConversionCheck(t1.scripter.justArrivedAtUnity)) {
        t1.goto$1("Unity: Arrival");
        return false;
      }
      return true;
    }
  },
  BodegaZil_createTraitsForm_updateTraitPoints: {
    "^": "Closure:8;_bodega_zil$_captured_this_0,_captured_traitsForm_1,_captured_pointsLeft_2,_captured_inputsDisabledTemporarily_3",
    call$1: function(checked) {
      var t1, t2, t3, el;
      t1 = this._captured_pointsLeft_2;
      t2 = t1.current;
      t3 = checked ? -1 : 1;
      if (typeof t2 !== "number")
        return t2.$add();
      t3 = t2 + t3;
      t1.current = t3;
      if (t3 === 0)
        for (t1 = this._captured_traitsForm_1.get$formElementChildren(), t2 = H.getTypeArgumentByIndex(t1, 0), H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3 = t1.length, t1 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"), t2 = this._captured_inputsDisabledTemporarily_3; t1.moveNext$0();) {
          el = H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0)), "$isFormElement");
          if (el instanceof G.CheckboxInput && el.current === false) {
            t3 = el.attributes;
            t3.$indexSet(0, "disabled", "true");
            t2.add$1(0, el);
          }
        }
      else {
        for (t1 = this._captured_inputsDisabledTemporarily_3, t2 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._collection$_modifications, null, H.assertSubtypeOfRuntimeType(null, null)), [null]), t2._collection$_cell = t2._set._collection$_first, H.assertSubtype(t2, "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"); t2.moveNext$0();) {
          t3 = H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t2._collection$_current, H.getTypeArgumentByIndex(t2, 0)), "$isCheckboxInput").attributes;
          H.assertHelper(J.$eq(t3.$index(0, "disabled"), "true"));
          t3.$indexSet(0, "disabled", "false");
        }
        t1.clear$0(0);
      }
    }
  },
  BodegaZil_createTraitsForm_closure: {
    "^": "Closure:9;_bodega_zil$_captured_this_4,_captured_updateTraitPoints_5",
    call$1: function(value) {
      H.boolTypeCheck(value);
      this._bodega_zil$_captured_this_4.scripter.isHawkeyed = value;
      this._captured_updateTraitPoints_5.call$1(value);
    }
  },
  BodegaZil_createTraitsForm_closure0: {
    "^": "Closure:9;_bodega_zil$_captured_this_6,_captured_updateTraitPoints_7",
    call$1: function(value) {
      H.boolTypeCheck(value);
      this._bodega_zil$_captured_this_6.scripter.isStrong = value;
      this._captured_updateTraitPoints_7.call$1(value);
    }
  },
  BodegaZil_createTraitsForm_closure1: {
    "^": "Closure:9;_bodega_zil$_captured_this_8,_captured_updateTraitPoints_9",
    call$1: function(value) {
      H.boolTypeCheck(value);
      this._bodega_zil$_captured_this_8.scripter.knowsJapanese = value;
      this._captured_updateTraitPoints_9.call$1(value);
    }
  },
  BodegaZil_createTraitsForm_closure2: {
    "^": "Closure:9;_bodega_zil$_captured_this_10,_captured_updateTraitPoints_11",
    call$1: function(value) {
      H.boolTypeCheck(value);
      this._bodega_zil$_captured_this_10.scripter.understandsAnimals = value;
      this._captured_updateTraitPoints_11.call$1(value);
    }
  },
  BodegaZil_createTraitsForm_closure3: {
    "^": "Closure:9;_bodega_zil$_captured_this_12,_captured_updateTraitPoints_13",
    call$1: function(value) {
      H.boolTypeCheck(value);
      this._bodega_zil$_captured_this_12.scripter.understandsAI = value;
      this._captured_updateTraitPoints_13.call$1(value);
    }
  },
  BodegaZil_createTraitsForm_closure4: {
    "^": "Closure:9;_captured_this_14,_captured_updateTraitPoints_15",
    call$1: function(value) {
      H.boolTypeCheck(value);
      this._captured_this_14.scripter.understandsElectronics = value;
      this._captured_updateTraitPoints_15.call$1(value);
    }
  },
  BodegaZil_createTraitsForm_closure5: {
    "^": "Closure:9;_bodega_zil$_captured_this_16,_captured_updateTraitPoints_17",
    call$1: function(value) {
      H.boolTypeCheck(value);
      this._bodega_zil$_captured_this_16.scripter.hasScienceEducation = value;
      this._captured_updateTraitPoints_17.call$1(value);
    }
  },
  BodegaZil_createTraitsForm_closure6: {
    "^": "Closure:9;_bodega_zil$_captured_this_18,_captured_updateTraitPoints_19",
    call$1: function(value) {
      H.boolTypeCheck(value);
      this._bodega_zil$_captured_this_18.scripter.isHandy = value;
      this._captured_updateTraitPoints_19.call$1(value);
    }
  },
  BodegaZil_createTraitsForm_closure7: {
    "^": "Closure:1;_bodega_zil$_captured_this_20,_captured_pointsLeft_21",
    call$0: function() {
      this._bodega_zil$_captured_this_20.scripter.pointsToDistribute = this._captured_pointsLeft_21.current;
    }
  },
  BodegaZil_createExtraEffortChoiceList_closure: {
    "^": "Closure:1;_captured_normalOutcome_0",
    call$0: function() {
      this._captured_normalOutcome_0.call$0();
    }
  },
  BodegaZil_createExtraEffortChoiceList_closure0: {
    "^": "Closure:1;_bodega_zil$_captured_this_1,_captured_physicalCost_2,_captured_mentalCost_3,_captured_extraEffortOutcome_4",
    call$0: function() {
      var t1, t2;
      t1 = this._bodega_zil$_captured_this_1.scripter;
      t2 = t1.physicalPoints;
      t2.set$value(J.$sub$n(H.assertSubtypeOfRuntimeType(t2._value, H.getTypeArgumentByIndex(t2, 0)), this._captured_physicalCost_2));
      t1 = t1.mentalPoints;
      t1.set$value(J.$sub$n(H.assertSubtypeOfRuntimeType(t1._value, H.getTypeArgumentByIndex(t1, 0)), this._captured_mentalCost_3));
      this._captured_extraEffortOutcome_4.call$0();
    }
  }
}],
["dart._internal", "dart:_internal", , H, {
  "^": "",
  IterableElementError_noElement: function() {
    return new P.StateError("No element");
  },
  IterableElementError_tooMany: function() {
    return new P.StateError("Too many elements");
  },
  IterableElementError_tooFew: function() {
    return new P.StateError("Too few elements");
  },
  Sort__doSort: function(a, left, right, compare) {
    var t1 = H.getDynamicRuntimeType();
    t1 = H.buildFunctionType(H.buildInterfaceType(P.$int), [t1, t1])._assertCheck$1(compare);
    if (right - left <= 32)
      H.Sort__insertionSort(a, left, right, t1);
    else
      H.Sort__dualPivotQuicksort(a, left, right, t1);
  },
  Sort__insertionSort: function(a, left, right, compare) {
    var t1, i, t2, el, j, j0;
    t1 = H.getDynamicRuntimeType();
    t1 = H.buildFunctionType(H.buildInterfaceType(P.$int), [t1, t1])._assertCheck$1(compare);
    for (i = left + 1, t2 = J.getInterceptor$as(a); i <= right; ++i) {
      el = t2.$index(a, i);
      j = i;
      while (true) {
        if (!(j > left && J.$gt$n(t1.call$2(t2.$index(a, j - 1), el), 0)))
          break;
        j0 = j - 1;
        t2.$indexSet(a, j, t2.$index(a, j0));
        j = j0;
      }
      t2.$indexSet(a, j, el);
    }
  },
  Sort__dualPivotQuicksort: function(a, left, right, compare) {
    var t1, t2, sixth, index1, index5, index3, index2, index4, el1, el2, el3, el4, el5, t0, less, great, k, ak, comp, great0, less0, pivots_are_equal, comp_pivot1, comp_pivot2, t3;
    t1 = H.getDynamicRuntimeType();
    t1 = H.buildFunctionType(H.buildInterfaceType(P.$int), [t1, t1])._assertCheck$1(compare);
    t2 = right - left;
    H.assertHelper(t2 > 32);
    sixth = C.JSInt_methods._tdivFast$1(t2 + 1, 6);
    index1 = left + sixth;
    index5 = right - sixth;
    index3 = C.JSInt_methods._tdivFast$1(left + right, 2);
    index2 = index3 - sixth;
    index4 = index3 + sixth;
    t2 = J.getInterceptor$as(a);
    el1 = t2.$index(a, index1);
    el2 = t2.$index(a, index2);
    el3 = t2.$index(a, index3);
    el4 = t2.$index(a, index4);
    el5 = t2.$index(a, index5);
    if (J.$gt$n(t1.call$2(el1, el2), 0)) {
      t0 = el2;
      el2 = el1;
      el1 = t0;
    }
    if (J.$gt$n(t1.call$2(el4, el5), 0)) {
      t0 = el5;
      el5 = el4;
      el4 = t0;
    }
    if (J.$gt$n(t1.call$2(el1, el3), 0)) {
      t0 = el3;
      el3 = el1;
      el1 = t0;
    }
    if (J.$gt$n(t1.call$2(el2, el3), 0)) {
      t0 = el3;
      el3 = el2;
      el2 = t0;
    }
    if (J.$gt$n(t1.call$2(el1, el4), 0)) {
      t0 = el4;
      el4 = el1;
      el1 = t0;
    }
    if (J.$gt$n(t1.call$2(el3, el4), 0)) {
      t0 = el4;
      el4 = el3;
      el3 = t0;
    }
    if (J.$gt$n(t1.call$2(el2, el5), 0)) {
      t0 = el5;
      el5 = el2;
      el2 = t0;
    }
    if (J.$gt$n(t1.call$2(el2, el3), 0)) {
      t0 = el3;
      el3 = el2;
      el2 = t0;
    }
    if (J.$gt$n(t1.call$2(el4, el5), 0)) {
      t0 = el5;
      el5 = el4;
      el4 = t0;
    }
    t2.$indexSet(a, index1, el1);
    t2.$indexSet(a, index3, el3);
    t2.$indexSet(a, index5, el5);
    t2.$indexSet(a, index2, t2.$index(a, left));
    t2.$indexSet(a, index4, t2.$index(a, right));
    less = left + 1;
    great = right - 1;
    if (J.$eq(t1.call$2(el2, el4), 0)) {
      for (k = less; k <= great; ++k) {
        ak = t2.$index(a, k);
        comp = H.intTypeCheck(t1.call$2(ak, el2));
        if (comp === 0)
          continue;
        if (typeof comp !== "number")
          return comp.$lt();
        if (comp < 0) {
          if (k !== less) {
            t2.$indexSet(a, k, t2.$index(a, less));
            t2.$indexSet(a, less, ak);
          }
          ++less;
        } else
          for (; true;) {
            comp = H.intTypeCheck(t1.call$2(t2.$index(a, great), el2));
            if (typeof comp !== "number")
              return comp.$gt();
            if (comp > 0) {
              --great;
              continue;
            } else {
              great0 = great - 1;
              if (comp < 0) {
                t2.$indexSet(a, k, t2.$index(a, less));
                less0 = less + 1;
                t2.$indexSet(a, less, t2.$index(a, great));
                t2.$indexSet(a, great, ak);
                great = great0;
                less = less0;
                break;
              } else {
                t2.$indexSet(a, k, t2.$index(a, great));
                t2.$indexSet(a, great, ak);
                great = great0;
                break;
              }
            }
          }
      }
      pivots_are_equal = true;
    } else {
      for (k = less; k <= great; ++k) {
        ak = t2.$index(a, k);
        comp_pivot1 = H.intTypeCheck(t1.call$2(ak, el2));
        if (typeof comp_pivot1 !== "number")
          return comp_pivot1.$lt();
        if (comp_pivot1 < 0) {
          if (k !== less) {
            t2.$indexSet(a, k, t2.$index(a, less));
            t2.$indexSet(a, less, ak);
          }
          ++less;
        } else {
          comp_pivot2 = H.intTypeCheck(t1.call$2(ak, el4));
          if (typeof comp_pivot2 !== "number")
            return comp_pivot2.$gt();
          if (comp_pivot2 > 0)
            for (; true;) {
              comp = H.intTypeCheck(t1.call$2(t2.$index(a, great), el4));
              if (typeof comp !== "number")
                return comp.$gt();
              if (comp > 0) {
                --great;
                if (great < k)
                  break;
                continue;
              } else {
                comp = H.intTypeCheck(t1.call$2(t2.$index(a, great), el2));
                if (typeof comp !== "number")
                  return comp.$lt();
                great0 = great - 1;
                if (comp < 0) {
                  t2.$indexSet(a, k, t2.$index(a, less));
                  less0 = less + 1;
                  t2.$indexSet(a, less, t2.$index(a, great));
                  t2.$indexSet(a, great, ak);
                  great = great0;
                  less = less0;
                } else {
                  t2.$indexSet(a, k, t2.$index(a, great));
                  t2.$indexSet(a, great, ak);
                  great = great0;
                }
                break;
              }
            }
        }
      }
      pivots_are_equal = false;
    }
    t3 = less - 1;
    t2.$indexSet(a, left, t2.$index(a, t3));
    t2.$indexSet(a, t3, el2);
    t3 = great + 1;
    t2.$indexSet(a, right, t2.$index(a, t3));
    t2.$indexSet(a, t3, el4);
    H.Sort__doSort(a, left, less - 2, t1);
    H.Sort__doSort(a, great + 2, right, t1);
    if (pivots_are_equal)
      return;
    if (less < index1 && great > index5) {
      for (; J.$eq(t1.call$2(t2.$index(a, less), el2), 0);)
        ++less;
      for (; J.$eq(t1.call$2(t2.$index(a, great), el4), 0);)
        --great;
      for (k = less; k <= great; ++k) {
        ak = t2.$index(a, k);
        if (H.intTypeCheck(t1.call$2(ak, el2)) === 0) {
          if (k !== less) {
            t2.$indexSet(a, k, t2.$index(a, less));
            t2.$indexSet(a, less, ak);
          }
          ++less;
        } else if (H.intTypeCheck(t1.call$2(ak, el4)) === 0)
          for (; true;)
            if (H.intTypeCheck(t1.call$2(t2.$index(a, great), el4)) === 0) {
              --great;
              if (great < k)
                break;
              continue;
            } else {
              comp = H.intTypeCheck(t1.call$2(t2.$index(a, great), el2));
              if (typeof comp !== "number")
                return comp.$lt();
              great0 = great - 1;
              if (comp < 0) {
                t2.$indexSet(a, k, t2.$index(a, less));
                less0 = less + 1;
                t2.$indexSet(a, less, t2.$index(a, great));
                t2.$indexSet(a, great, ak);
                great = great0;
                less = less0;
              } else {
                t2.$indexSet(a, k, t2.$index(a, great));
                t2.$indexSet(a, great, ak);
                great = great0;
              }
              break;
            }
      }
      H.Sort__doSort(a, less, great, t1);
    } else
      H.Sort__doSort(a, less, great, t1);
  },
  Symbol_getName: function(symbol) {
    return symbol.get$_name();
  },
  ListIterable: {
    "^": "IterableBase;",
    get$iterator: function(_) {
      var t1, t2;
      t1 = H.getRuntimeTypeArgument(this, "ListIterable", 0);
      H.listSuperNativeTypeCheck(this, "$isIterable");
      t2 = this.get$length(this);
      return H.assertSubtype(H.setRuntimeTypeInfo(new H.ListIterator(H.listSuperNativeTypeCheck(this, "$isIterable"), t2, 0, H.assertSubtypeOfRuntimeType(null, t1)), [t1]), "$isIterator", [H.getRuntimeTypeArgument(this, "ListIterable", 0)], "$asIterator");
    },
    forEach$1: function(_, action) {
      var t1, $length, i;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [this.E5()])._assertCheck$1(action);
      $length = this.get$length(this);
      for (i = 0; i < $length; ++i) {
        t1.call$1(this.elementAt$1(0, i));
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    toList$1$growable: function(_, growable) {
      var result, t1, i;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
        C.JSArray_methods.set$length(result, this.get$length(this));
        H.assertSubtype(result, "$isList", [H.getRuntimeTypeArgument(this, "ListIterable", 0)], "$asList");
      } else {
        t1 = Array(this.get$length(this));
        t1.fixed$length = Array;
        result = H.assertSubtype(H.setRuntimeTypeInfo(t1, [H.getRuntimeTypeArgument(this, "ListIterable", 0)]), "$isList", [H.getRuntimeTypeArgument(this, "ListIterable", 0)], "$asList");
      }
      for (i = 0; i < this.get$length(this); ++i) {
        t1 = this.elementAt$1(0, i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
      }
      return H.assertSubtype(result, "$isList", [H.getRuntimeTypeArgument(this, "ListIterable", 0)], "$asList");
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    E5: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    E: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isEfficientLength: 1
  },
  ListIterator: {
    "^": "Object;__internal$_iterable,__internal$_length,__internal$_index,__internal$_current",
    set$__internal$_current: function(_current) {
      this.__internal$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    get$current: function() {
      return H.assertSubtypeOfRuntimeType(this.__internal$_current, H.getTypeArgumentByIndex(this, 0));
    },
    moveNext$0: function() {
      var t1, $length, t2;
      t1 = this.__internal$_iterable;
      $length = t1.get$length(t1);
      if (this.__internal$_length !== $length)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t2 = this.__internal$_index;
      if (t2 >= $length) {
        this.set$__internal$_current(null);
        return false;
      }
      this.set$__internal$_current(t1.elementAt$1(0, t2));
      ++this.__internal$_index;
      return true;
    },
    $isIterator: 1
  },
  MappedIterable: {
    "^": "IterableBase;__internal$_iterable,_f",
    get$iterator: function(_) {
      var t1, t2, t3, t4, t5;
      t1 = J.get$iterator$a(this.__internal$_iterable);
      t2 = this._f;
      t3 = H.getTypeArgumentByIndex(this, 0);
      t4 = H.getTypeArgumentByIndex(this, 1);
      H.assertSubtype(t1, "$isIterator", [t3], "$asIterator");
      t5 = H.buildFunctionType(H.convertRtiToRuntimeType(t4), [H.convertRtiToRuntimeType(t3)]);
      t5._assertCheck$1(t2);
      t2 = new H.MappedIterator(H.assertSubtypeOfRuntimeType(null, t4), H.assertSubtype(t1, "$isIterator", [t3], "$asIterator"), t5._assertCheck$1(t2));
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      return H.assertSubtype(t2, "$isIterator", [H.getTypeArgumentByIndex(this, 1)], "$asIterator");
    },
    get$length: function(_) {
      return J.get$length$as(this.__internal$_iterable);
    },
    get$isEmpty: function(_) {
      return J.get$isEmpty$as(this.__internal$_iterable);
    },
    S1: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T10: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[1]);
    },
    E: function() {
      return H.convertRtiToRuntimeType(function($S, $T) {
        return $T;
      }.apply(null, this.$builtinTypeInfo));
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    $asIterable: function($S, $T) {
      return [$T];
    },
    static: {MappedIterable_MappedIterable: function(iterable, $function, $S, $T) {
        var t1, t2;
        t1 = H.buildFunctionType(H.convertRtiToRuntimeType($T), [H.convertRtiToRuntimeType($S)]);
        t2 = t1._assertCheck$1($function);
        if (!!J.getInterceptor(iterable).$isEfficientLength) {
          t1 = H.buildFunctionType(H.convertRtiToRuntimeType($T), [H.convertRtiToRuntimeType($S)]);
          t1._assertCheck$1(t2);
          return H.assertSubtype(H.setRuntimeTypeInfo(new H.EfficientLengthMappedIterable(H.listSuperNativeTypeCheck(iterable, "$isIterable"), t1._assertCheck$1(t2)), [$S, $T]), "$isMappedIterable", [$S, $T], "$asMappedIterable");
        }
        H.listSuperNativeTypeCheck(iterable, "$isIterable");
        t1._assertCheck$1(t2);
        return H.assertSubtype(H.setRuntimeTypeInfo(new H.MappedIterable(H.listSuperNativeTypeCheck(iterable, "$isIterable"), t1._assertCheck$1(t2)), [$S, $T]), "$isMappedIterable", [$S, $T], "$asMappedIterable");
      }}
  },
  EfficientLengthMappedIterable: {
    "^": "MappedIterable;__internal$_iterable,_f",
    S1: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T10: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[1]);
    },
    E: function() {
      return H.convertRtiToRuntimeType(function($S, $T) {
        return $T;
      }.apply(null, this.$builtinTypeInfo));
    },
    $isEfficientLength: 1
  },
  MappedIterator: {
    "^": "Iterator;__internal$_current,_iterator,_f",
    set$__internal$_current: function(_current) {
      this.__internal$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 1));
    },
    moveNext$0: function() {
      var t1 = this._iterator;
      if (t1.moveNext$0()) {
        this.set$__internal$_current(this._f$1(t1.get$current()));
        return true;
      }
      this.set$__internal$_current(null);
      return false;
    },
    get$current: function() {
      return H.assertSubtypeOfRuntimeType(this.__internal$_current, H.getTypeArgumentByIndex(this, 1));
    },
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    S0: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T9: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[1]);
    },
    $asIterator: function($S, $T) {
      return [$T];
    }
  },
  MappedListIterable: {
    "^": "ListIterable;__internal$_source,_f",
    get$length: function(_) {
      return J.get$length$as(this.__internal$_source);
    },
    elementAt$1: function(_, index) {
      return H.assertSubtypeOfRuntimeType(this._f$1(J.elementAt$1$a(this.__internal$_source, index)), H.getTypeArgumentByIndex(this, 1));
    },
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    S: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T8: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[1]);
    },
    E5: function() {
      return H.convertRtiToRuntimeType(function($S, $T) {
        return $T;
      }.apply(null, this.$builtinTypeInfo));
    },
    E: function() {
      return H.convertRtiToRuntimeType(function($S, $T) {
        return $T;
      }.apply(null, this.$builtinTypeInfo));
    },
    $asListIterable: function($S, $T) {
      return [$T];
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    $asIterable: function($S, $T) {
      return [$T];
    },
    $isEfficientLength: 1
  },
  WhereIterable: {
    "^": "IterableBase;__internal$_iterable,_f",
    get$iterator: function(_) {
      var t1, t2, t3, t4;
      t1 = J.get$iterator$a(this.__internal$_iterable);
      t2 = this._f;
      t3 = H.getTypeArgumentByIndex(this, 0);
      H.assertSubtype(t1, "$isIterator", [t3], "$asIterator");
      t4 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t4, [H.convertRtiToRuntimeType(t3)])._assertCheck$1(t2);
      t2 = new H.WhereIterator(H.assertSubtype(t1, "$isIterator", [t3], "$asIterator"), H.buildFunctionType(t4, [H.getDynamicRuntimeType()])._assertCheck$1(t2));
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      return H.assertSubtype(t2, "$isIterator", [H.getTypeArgumentByIndex(this, 0)], "$asIterator");
    },
    E: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  WhereIterator: {
    "^": "Iterator;_iterator,_f",
    moveNext$0: function() {
      for (var t1 = this._iterator; t1.moveNext$0();)
        if (H.boolConversionCheck(this._f$1(t1.get$current())))
          return true;
      return false;
    },
    get$current: function() {
      return H.assertSubtypeOfRuntimeType(this._iterator.get$current(), H.getTypeArgumentByIndex(this, 0));
    },
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    }
  },
  ExpandIterable: {
    "^": "IterableBase;__internal$_iterable,_f",
    get$iterator: function(_) {
      var t1, t2, t3, t4, t5;
      t1 = J.get$iterator$a(this.__internal$_iterable);
      t2 = this._f;
      t3 = H.getTypeArgumentByIndex(this, 0);
      t4 = H.getTypeArgumentByIndex(this, 1);
      H.assertSubtype(t1, "$isIterator", [t3], "$asIterator");
      H.buildFunctionType(H.buildInterfaceType(P.Iterable, [H.convertRtiToRuntimeType(t4)]), [H.convertRtiToRuntimeType(t3)])._assertCheck$1(t2);
      t5 = H.getDynamicRuntimeType();
      t4 = new H.ExpandIterator(H.assertSubtype(t1, "$isIterator", [t3], "$asIterator"), H.buildFunctionType(H.buildInterfaceType(P.Iterable, [t5]), [t5])._assertCheck$1(t2), H.assertSubtype(C.C_EmptyIterator, "$isIterator", [t4], "$asIterator"), H.assertSubtypeOfRuntimeType(null, t4));
      t4.$builtinTypeInfo = this.$builtinTypeInfo;
      return H.assertSubtype(t4, "$isIterator", [H.getTypeArgumentByIndex(this, 1)], "$asIterator");
    },
    E: function() {
      return H.convertRtiToRuntimeType(function($S, $T) {
        return $T;
      }.apply(null, this.$builtinTypeInfo));
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    $asIterable: function($S, $T) {
      return [$T];
    }
  },
  ExpandIterator: {
    "^": "Object;_iterator,_f,_currentExpansion,__internal$_current",
    set$_currentExpansion: function(_currentExpansion) {
      this._currentExpansion = H.assertSubtype(_currentExpansion, "$isIterator", [H.getTypeArgumentByIndex(this, 1)], "$asIterator");
    },
    set$__internal$_current: function(_current) {
      this.__internal$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 1));
    },
    get$current: function() {
      return H.assertSubtypeOfRuntimeType(this.__internal$_current, H.getTypeArgumentByIndex(this, 1));
    },
    moveNext$0: function() {
      if (this._currentExpansion == null)
        return false;
      for (var t1 = this._iterator; !this._currentExpansion.moveNext$0();) {
        this.set$__internal$_current(null);
        if (t1.moveNext$0()) {
          this.set$_currentExpansion(null);
          this.set$_currentExpansion(J.get$iterator$a(this._f$1(t1.get$current())));
        } else
          return false;
      }
      this.set$__internal$_current(this._currentExpansion.get$current());
      return true;
    },
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    $isIterator: 1,
    $asIterator: function($S, $T) {
      return [$T];
    }
  },
  EmptyIterator: {
    "^": "Object;",
    moveNext$0: function() {
      return false;
    },
    get$current: function() {
      return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  }
}],
["dart._js_names", "dart:_js_names", , H, {
  "^": "",
  extractKeys: function(victim) {
    var t1 = H.setRuntimeTypeInfo(H.assertSubtype(victim ? Object.keys(victim) : [], "$isJSArray", [null], "$asJSArray"), [null]);
    t1.fixed$length = Array;
    return H.assertSubtype(t1, "$isJSArray", [null], "$asJSArray");
  }
}],
["dart.async", "dart:async", , P, {
  "^": "",
  _AsyncRun__initializeScheduleImmediate: function() {
    var t1, div, span;
    t1 = {};
    if (self.scheduleImmediate != null)
      return H.interceptedTypeCheck(P._AsyncRun__scheduleImmediateJsOverride$closure(), "$isFunction");
    if (self.MutationObserver != null && self.document != null) {
      div = self.document.createElement("div");
      span = self.document.createElement("span");
      t1._captured_storedCallback_0 = null;
      new self.MutationObserver(H.convertDartClosureToJS(new P._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
      return new P._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
    } else if (self.setImmediate != null)
      return H.interceptedTypeCheck(P._AsyncRun__scheduleImmediateWithSetImmediate$closure(), "$isFunction");
    return H.interceptedTypeCheck(P._AsyncRun__scheduleImmediateWithTimer$closure(), "$isFunction");
  },
  _AsyncRun__scheduleImmediateJsOverride: [function(callback) {
    var t1 = H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(callback);
    ++init.globalState.topEventLoop._activeJsAsyncCount;
    self.scheduleImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateJsOverride_internalCallback(t1), 0));
  }, "call$1", "_AsyncRun__scheduleImmediateJsOverride$closure", 2, 0, 62],
  _AsyncRun__scheduleImmediateWithSetImmediate: [function(callback) {
    var t1 = H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(callback);
    ++init.globalState.topEventLoop._activeJsAsyncCount;
    self.setImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(t1), 0));
  }, "call$1", "_AsyncRun__scheduleImmediateWithSetImmediate$closure", 2, 0, 62],
  _AsyncRun__scheduleImmediateWithTimer: [function(callback) {
    P.Timer__createTimer(C.Duration_0, H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(callback));
  }, "call$1", "_AsyncRun__scheduleImmediateWithTimer$closure", 2, 0, 62],
  _registerErrorHandler: function(errorHandler, zone) {
    var t1, t2, t3;
    t1 = H.getDynamicRuntimeType();
    t2 = H.buildFunctionType(t1, [t1, t1]);
    t3 = t2._isTest$1(errorHandler);
    if (t3) {
      zone.toString;
      t2._assertCheck$1(errorHandler);
      return t2._assertCheck$1(errorHandler);
    } else {
      zone.toString;
      t1 = H.buildFunctionType(t1, [t1]);
      t1._assertCheck$1(errorHandler);
      return t1._assertCheck$1(errorHandler);
    }
  },
  Future_Future$value: function(value, $T) {
    var t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [$T]);
    t1._asyncComplete$1(value);
    return H.assertSubtype(t1, "$isFuture", [$T], "$asFuture");
  },
  _asyncRunCallbackLoop: function() {
    var t1, t2;
    for (; t1 = $._nextCallback, t1 != null;) {
      $._lastPriorityCallback = null;
      t2 = t1.next;
      $._nextCallback = t2;
      if (t2 == null)
        $._lastCallback = null;
      t1.callback$0();
    }
  },
  _asyncRunCallback: [function() {
    $._isInCallbackLoop = true;
    try {
      P._asyncRunCallbackLoop();
    } finally {
      $._lastPriorityCallback = null;
      $._isInCallbackLoop = false;
      if ($._nextCallback != null) {
        H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(P._asyncRunCallback$closure());
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
      }
    }
  }, "call$0", "_asyncRunCallback$closure", 0, 0, 4],
  _scheduleAsyncCallback: function(callback) {
    var t1, t2, newEntry;
    t1 = H.getVoidRuntimeType();
    if ($._nextCallback == null) {
      t1 = H.buildFunctionType(t1);
      t1._assertCheck$1(callback);
      t2 = new P._AsyncCallbackEntry(t1._assertCheck$1(callback), null);
      $._lastCallback = t2;
      $._nextCallback = t2;
      if (!$._isInCallbackLoop) {
        t1._assertCheck$1(P._asyncRunCallback$closure());
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
      }
    } else {
      t1 = H.buildFunctionType(t1);
      t1._assertCheck$1(callback);
      newEntry = new P._AsyncCallbackEntry(t1._assertCheck$1(callback), null);
      $._lastCallback.next = newEntry;
      $._lastCallback = newEntry;
    }
  },
  scheduleMicrotask: function(callback) {
    var t1, t2, t3;
    t1 = H.buildFunctionType(H.getVoidRuntimeType());
    t2 = t1._assertCheck$1(callback);
    t3 = $.Zone__current;
    if (C.C__RootZone === t3) {
      P._rootScheduleMicrotask(null, null, C.C__RootZone, t2);
      return;
    }
    t2 = t3.bindCallback$2$runGuarded(t2, true);
    t1._assertCheck$1(t2);
    P._rootScheduleMicrotask(null, null, t3, t2);
  },
  StreamController_StreamController: function(onCancel, onListen, onPause, onResume, sync, $T) {
    var t1, t2, t3, t4, t5, t6;
    t1 = H.buildFunctionType(H.getDynamicRuntimeType());
    t2 = t1._assertCheck$1(onCancel);
    t3 = H.buildFunctionType(H.getVoidRuntimeType());
    t4 = t3._assertCheck$1(onListen);
    t5 = t3._assertCheck$1(onPause);
    t6 = t3._assertCheck$1(onResume);
    if (t2 == null) {
      t1 = sync ? new P._NoCallbackSyncStreamController(null, 0, null) : new P._NoCallbackAsyncStreamController(null, 0, null);
      return H.assertSubtype(t1, "$isStreamController", [$T], "$asStreamController");
    }
    if (sync) {
      t3._assertCheck$1(t4);
      t3._assertCheck$1(t5);
      t3._assertCheck$1(t6);
      t1._assertCheck$1(t2);
      t1 = H.setRuntimeTypeInfo(new P._SyncStreamController(t1._assertCheck$1(t4), t1._assertCheck$1(t5), t1._assertCheck$1(t6), t1._assertCheck$1(t2), null, 0, null), [$T]);
    } else {
      t3._assertCheck$1(t4);
      t3._assertCheck$1(t5);
      t3._assertCheck$1(t6);
      t1._assertCheck$1(t2);
      t1 = H.setRuntimeTypeInfo(new P._AsyncStreamController(t1._assertCheck$1(t4), t1._assertCheck$1(t5), t1._assertCheck$1(t6), t1._assertCheck$1(t2), null, 0, null), [$T]);
    }
    return H.assertSubtype(t1, "$isStreamController", [$T], "$asStreamController");
  },
  _runGuarded: function(notificationHandler) {
    var result, e, s, t1, exception;
    H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(notificationHandler);
    if (notificationHandler == null)
      return;
    try {
      result = notificationHandler.call$0();
      if (!!J.getInterceptor(result).$isFuture) {
        t1 = H.interceptedTypeCheck(result, "$isFuture");
        return t1;
      }
      return;
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      s = H.getTraceFromException(exception);
      t1 = $.Zone__current;
      t1.toString;
      P._rootHandleUncaughtError(null, null, t1, e, H.interceptedTypeCheck(s, "$isStackTrace"));
    }
  },
  _nullDataHandler: [function(value) {
  }, "call$1", "_nullDataHandler$closure", 2, 0, 63],
  _nullErrorHandler: [function(error, stackTrace) {
    var t1;
    H.interceptedTypeCheck(stackTrace, "$isStackTrace");
    t1 = $.Zone__current;
    t1.toString;
    P._rootHandleUncaughtError(null, null, t1, error, stackTrace);
  }, function(error) {
    return P._nullErrorHandler(error, null);
  }, null, "call$2", "call$1", "_nullErrorHandler$closure", 2, 2, 13, 0],
  _nullDoneHandler: [function() {
  }, "call$0", "_nullDoneHandler$closure", 0, 0, 4],
  _runUserCode: function(userCode, onSuccess, onError) {
    var e, s, replacement, error, stackTrace, t1, exception;
    t1 = H.getDynamicRuntimeType();
    H.buildFunctionType(t1)._assertCheck$1(userCode);
    H.buildFunctionType(t1, [t1])._assertCheck$1(onSuccess);
    H.buildFunctionType(t1, [t1, H.buildInterfaceType(P.StackTrace)])._assertCheck$1(onError);
    try {
      onSuccess.call$1(userCode.call$0());
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      s = H.getTraceFromException(exception);
      $.Zone__current.toString;
      H.interceptedTypeCheck(s, "$isStackTrace");
      replacement = null;
      if (replacement == null)
        onError.call$2(e, s);
      else {
        t1 = replacement.get$error();
        error = t1;
        stackTrace = replacement.get$stackTrace();
        onError.call$2(error, stackTrace);
      }
    }
  },
  _cancelAndError: function(subscription, future, error, stackTrace) {
    var cancelFuture = subscription.cancel$0();
    if (!!J.getInterceptor(cancelFuture).$isFuture)
      cancelFuture.whenComplete$1(new P._cancelAndError_closure(future, error, stackTrace));
    else
      future._completeError$2(error, stackTrace);
  },
  _cancelAndErrorClosure: function(subscription, future) {
    return new P._cancelAndErrorClosure_closure(subscription, future);
  },
  _addErrorWithReplacement: function(sink, error, stackTrace) {
    $.Zone__current.toString;
    sink._addError$2(error, stackTrace);
  },
  Timer_Timer: function(duration, callback) {
    var t1, t2, t3;
    t1 = H.buildFunctionType(H.getVoidRuntimeType());
    t2 = t1._assertCheck$1(callback);
    t3 = $.Zone__current;
    if (t3 === C.C__RootZone) {
      t3.toString;
      t1._assertCheck$1(t2);
      return P.Timer__createTimer(duration, t2);
    }
    t2 = t3.bindCallback$2$runGuarded(t2, true);
    t1._assertCheck$1(t2);
    return P.Timer__createTimer(duration, t2);
  },
  Timer__createTimer: function(duration, callback) {
    var t1, milliseconds;
    t1 = H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(callback);
    milliseconds = C.JSInt_methods._tdivFast$1(duration._duration, 1000);
    return H.TimerImpl$(milliseconds < 0 ? 0 : milliseconds, t1);
  },
  Zone__enter: function(zone) {
    var t1, previous;
    H.assertHelper(zone != null);
    t1 = $.Zone__current;
    H.assertHelper(zone == null ? t1 != null : zone !== t1);
    previous = $.Zone__current;
    $.Zone__current = zone;
    return previous;
  },
  _rootHandleUncaughtError: function($self, $parent, zone, error, stackTrace) {
    var t1, t2, entry;
    t1 = new P._rootHandleUncaughtError_closure(error, stackTrace);
    t2 = H.buildFunctionType(H.getVoidRuntimeType());
    t2._assertCheck$1(t1);
    entry = new P._AsyncCallbackEntry(t2._assertCheck$1(t1), null);
    t2 = $._nextCallback;
    if (t2 == null) {
      P._scheduleAsyncCallback(t1);
      $._lastPriorityCallback = $._lastCallback;
    } else {
      t1 = $._lastPriorityCallback;
      if (t1 == null) {
        entry.next = t2;
        $._lastPriorityCallback = entry;
        $._nextCallback = entry;
      } else {
        entry.next = t1.next;
        t1.next = entry;
        $._lastPriorityCallback = entry;
        if (entry.next == null)
          $._lastCallback = entry;
      }
    }
  },
  _rootRun: function($self, $parent, zone, f) {
    var old, t1;
    H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(f);
    if ($.Zone__current === zone)
      return f.call$0();
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$0();
      return t1;
    } finally {
      t1 = H.interceptedTypeCheck(old, "$isZone");
      H.assertHelper(t1 != null);
      $.Zone__current = t1;
    }
  },
  _rootRunUnary: function($self, $parent, zone, f, arg) {
    var old, t1;
    t1 = H.getDynamicRuntimeType();
    H.buildFunctionType(t1, [t1])._assertCheck$1(f);
    if ($.Zone__current === zone)
      return f.call$1(arg);
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$1(arg);
      return t1;
    } finally {
      t1 = H.interceptedTypeCheck(old, "$isZone");
      H.assertHelper(t1 != null);
      $.Zone__current = t1;
    }
  },
  _rootRunBinary: function($self, $parent, zone, f, arg1, arg2) {
    var old, t1;
    t1 = H.getDynamicRuntimeType();
    H.buildFunctionType(t1, [t1, t1])._assertCheck$1(f);
    if ($.Zone__current === zone)
      return f.call$2(arg1, arg2);
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$2(arg1, arg2);
      return t1;
    } finally {
      t1 = H.interceptedTypeCheck(old, "$isZone");
      H.assertHelper(t1 != null);
      $.Zone__current = t1;
    }
  },
  _rootScheduleMicrotask: function($self, $parent, zone, f) {
    var t1, t2;
    t1 = H.buildFunctionType(H.getDynamicRuntimeType());
    f = t1._assertCheck$1(f);
    t2 = C.C__RootZone !== zone;
    if (t2)
      f = t1._assertCheck$1(zone.bindCallback$2$runGuarded(f, !(!t2 || C.C__RootZone.get$errorZone() === zone)));
    P._scheduleAsyncCallback(f);
  },
  _AsyncRun__initializeScheduleImmediate_internalCallback: {
    "^": "Closure:2;_box_0",
    call$1: function(_) {
      var t1, f;
      H.leaveJsAsync();
      t1 = this._box_0;
      f = t1._captured_storedCallback_0;
      t1._captured_storedCallback_0 = null;
      f.call$0();
    }
  },
  _AsyncRun__initializeScheduleImmediate_closure: {
    "^": "Closure:10;_box_0,_captured_div_1,_captured_span_2",
    call$1: function(callback) {
      var storedCallback, t1, t2;
      storedCallback = H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(callback);
      t1 = this._box_0;
      H.assertHelper(t1._captured_storedCallback_0 == null);
      ++init.globalState.topEventLoop._activeJsAsyncCount;
      t1._captured_storedCallback_0 = storedCallback;
      t1 = this._captured_div_1;
      t2 = this._captured_span_2;
      t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
    }
  },
  _AsyncRun__scheduleImmediateJsOverride_internalCallback: {
    "^": "Closure:1;_captured_callback_0",
    call$0: function() {
      H.leaveJsAsync();
      this._captured_callback_0.call$0();
    }
  },
  _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback: {
    "^": "Closure:1;_captured_callback_0",
    call$0: function() {
      H.leaveJsAsync();
      this._captured_callback_0.call$0();
    }
  },
  _UncaughtAsyncError: {
    "^": "AsyncError;error,stackTrace",
    toString$0: function(_) {
      var result, t1;
      result = "Uncaught Error: " + H.S(this.error);
      t1 = this.stackTrace;
      return t1 != null ? result + ("\nStack Trace:\n" + J.toString$0(t1)) : result;
    },
    static: {_UncaughtAsyncError__getBestStackTrace: function(error, stackTrace) {
        if (stackTrace != null)
          return stackTrace;
        if (!!J.getInterceptor(error).$isError)
          return error.get$stackTrace();
        return;
      }}
  },
  _BroadcastSubscription: {
    "^": "_ControllerSubscription;_eventState,_async$_next<,_async$_previous,_async$_controller,_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending",
    set$_async$_next: function(_next) {
      this._async$_next = H.interceptedTypeCheck(_next, "$is_BroadcastSubscriptionLink");
    },
    set$_async$_previous: function(_previous) {
      this._async$_previous = H.interceptedTypeCheck(_previous, "$is_BroadcastSubscriptionLink");
    },
    get$_async$_controller: function() {
      return H.interceptedTypeCheck(this._async$_controller, "$is_BroadcastStreamController");
    },
    _onPause$0: [function() {
    }, "call$0", "get$_onPause", 0, 0, 4],
    _onResume$0: [function() {
    }, "call$0", "get$_onResume", 0, 0, 4],
    T3: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T4: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $is_EventSink: 1,
    $isStreamSubscription: 1,
    $is_BroadcastSubscriptionLink: 1
  },
  _BroadcastStreamController: {
    "^": "Object;_state<,_async$_next<,_async$_previous",
    set$_state: function(_state) {
      this._state = H.intTypeCheck(_state);
    },
    set$_async$_next: function(_next) {
      this._async$_next = H.interceptedTypeCheck(_next, "$is_BroadcastSubscriptionLink");
    },
    set$_async$_previous: function(_previous) {
      this._async$_previous = H.interceptedTypeCheck(_previous, "$is_BroadcastSubscriptionLink");
    },
    get$_mayAddEvent: function() {
      return this._state < 4;
    },
    _ensureDoneFuture$0: function() {
      var t1 = this._doneFuture;
      if (t1 != null)
        return t1;
      t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
      this._doneFuture = t1;
      return t1;
    },
    _removeListener$1: function(subscription) {
      var previous, next;
      H.assertSubtype(subscription, "$is_BroadcastSubscription", [H.getTypeArgumentByIndex(this, 0)], "$as_BroadcastSubscription");
      H.assertHelper(H.interceptedTypeCheck(subscription._async$_controller, "$is_BroadcastStreamController") === this);
      H.assertHelper(subscription._async$_next !== subscription);
      previous = subscription._async$_previous;
      next = subscription._async$_next;
      previous.set$_async$_next(next);
      next.set$_async$_previous(previous);
      subscription._async$_previous = subscription;
      subscription._async$_next = subscription;
    },
    _subscribe$4: function(onData, onError, onDone, cancelOnError) {
      var t1, t2, t3, t4, t5, t6, t7, subscription;
      t1 = H.getVoidRuntimeType();
      t2 = H.buildFunctionType(t1, [this.T2()])._assertCheck$1(onData);
      t3 = H.buildFunctionType(t1);
      onDone = t3._assertCheck$1(onDone);
      if ((this._state & 4) !== 0) {
        if (onDone == null)
          onDone = t3._assertCheck$1(P._nullDoneHandler$closure());
        t3._assertCheck$1(onDone);
        t1 = new P._DoneStreamSubscription($.Zone__current, 0, t3._assertCheck$1(onDone));
        t1.$builtinTypeInfo = this.$builtinTypeInfo;
        t3._assertCheck$1(onDone);
        t1._async$_schedule$0();
        return H.assertSubtype(t1, "$isStreamSubscription", [H.getTypeArgumentByIndex(this, 0)], "$asStreamSubscription");
      }
      t4 = H.getTypeArgumentByIndex(this, 0);
      t5 = H.buildFunctionType(t1, [H.convertRtiToRuntimeType(t4)]);
      t5._assertCheck$1(t2);
      t3._assertCheck$1(onDone);
      t6 = $.Zone__current;
      t7 = cancelOnError ? 1 : 0;
      subscription = new P._BroadcastSubscription(null, null, null, H.assertSubtype(this, "$is_StreamControllerLifecycle", [t4], "$as_StreamControllerLifecycle"), t5._assertCheck$1(null), null, t3._assertCheck$1(null), t6, t7, null, null);
      subscription.$builtinTypeInfo = this.$builtinTypeInfo;
      subscription._BufferingStreamSubscription$4(t2, onError, onDone, cancelOnError, t4);
      H.buildFunctionType(t1, [subscription.T3()])._assertCheck$1(t2);
      t3._assertCheck$1(onDone);
      subscription._async$_previous = subscription;
      subscription._async$_next = subscription;
      H.assertSubtype(subscription, "$is_BroadcastSubscription", [H.getTypeArgumentByIndex(this, 0)], "$as_BroadcastSubscription");
      H.assertHelper(subscription === subscription);
      t3 = this._async$_previous;
      subscription._async$_previous = t3;
      subscription._async$_next = this;
      t3.set$_async$_next(subscription);
      this._async$_previous = subscription;
      subscription._eventState = this._state & 1;
      if (this._async$_next === subscription)
        P._runGuarded(this._onListen);
      return H.assertSubtype(subscription, "$isStreamSubscription", [H.getTypeArgumentByIndex(this, 0)], "$asStreamSubscription");
    },
    _recordCancel$1: function(subscription) {
      var t1;
      H.assertSubtype(subscription, "$is_BroadcastSubscription", [H.getTypeArgumentByIndex(this, 0)], "$as_BroadcastSubscription");
      if (subscription._async$_next === subscription)
        return;
      H.assertHelper(true);
      t1 = subscription._eventState;
      if (typeof t1 !== "number")
        return t1.$and();
      t1 = (t1 & 2) !== 0;
      if (t1) {
        H.assertHelper(t1);
        t1 = subscription._eventState;
        if (typeof t1 !== "number")
          return t1.$or();
        subscription._eventState = t1 | 4;
      } else {
        H.assertHelper(subscription._async$_next !== subscription);
        this._removeListener$1(subscription);
        if ((this._state & 2) === 0 && this._async$_next === this)
          this._callOnCancel$0();
      }
      return;
    },
    _recordPause$1: function(subscription) {
      H.assertSubtype(subscription, "$isStreamSubscription", [H.getTypeArgumentByIndex(this, 0)], "$asStreamSubscription");
    },
    _recordResume$1: function(subscription) {
      H.assertSubtype(subscription, "$isStreamSubscription", [H.getTypeArgumentByIndex(this, 0)], "$asStreamSubscription");
    },
    _addEventError$0: ["super$_BroadcastStreamController$_addEventError$0", function() {
      var t1 = this._state;
      if ((t1 & 4) !== 0)
        return new P.StateError("Cannot add new events after calling close");
      H.assertHelper((t1 & 8) !== 0);
      return new P.StateError("Cannot add new events while doing an addStream");
    }],
    add$1: ["super$_BroadcastStreamController$add$1", function(_, data) {
      H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 0));
      if (!this.get$_mayAddEvent())
        throw H.wrapException(this._addEventError$0());
      this._sendData$1(data);
    }],
    close$0: ["super$_BroadcastStreamController$close$0", function() {
      if ((this._state & 4) !== 0) {
        H.assertHelper(this._doneFuture != null);
        return this._doneFuture;
      }
      if (!this.get$_mayAddEvent())
        throw H.wrapException(this._addEventError$0());
      this._state |= 4;
      var doneFuture = this._ensureDoneFuture$0();
      this._sendDone$0();
      return doneFuture;
    }],
    get$done: function() {
      return this._ensureDoneFuture$0();
    },
    _async$_add$1: function(data) {
      this._sendData$1(H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 0)));
    },
    _forEachListener$1: function(action) {
      var t1, t2, link, id, link0;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P._BufferingStreamSubscription, [this.T2()])])._assertCheck$1(action);
      t2 = this._state;
      if ((t2 & 2) !== 0)
        throw H.wrapException(P.StateError$("Cannot fire new event. Controller is already firing an event"));
      link = this._async$_next;
      if (link === this)
        return;
      id = t2 & 1;
      this._state = t2 ^ 3;
      for (; link !== this;) {
        H.assertSubtype(link, "$is_BroadcastSubscription", [H.getTypeArgumentByIndex(this, 0)], "$as_BroadcastSubscription");
        t2 = link._eventState;
        if (typeof t2 !== "number")
          return t2.$and();
        if ((t2 & 1) === id) {
          link._eventState = t2 | 2;
          t1.call$1(link);
          t2 = link._eventState;
          if (typeof t2 !== "number")
            return t2.$xor();
          t2 ^= 1;
          link._eventState = t2;
          link0 = link._async$_next;
          if ((t2 & 4) !== 0)
            this._removeListener$1(link);
          t2 = link._eventState;
          if (typeof t2 !== "number")
            return t2.$and();
          link._eventState = t2 & 4294967293;
          link = link0;
        } else
          link = link._async$_next;
      }
      this._state &= 4294967293;
      if (this._async$_next === this)
        this._callOnCancel$0();
    },
    _callOnCancel$0: ["super$_BroadcastStreamController$_callOnCancel$0", function() {
      H.assertHelper(this._async$_next === this);
      if ((this._state & 4) !== 0 && this._doneFuture._state === 0)
        this._doneFuture._asyncComplete$1(null);
      P._runGuarded(this._onCancel);
    }],
    T2: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $is_EventDispatch: 1,
    $is_EventSink: 1,
    $is_BroadcastSubscriptionLink: 1,
    $is_StreamControllerLifecycle: 1,
    $isStreamController: 1
  },
  _SyncBroadcastStreamController: {
    "^": "_BroadcastStreamController;",
    get$_mayAddEvent: function() {
      return P._BroadcastStreamController.prototype.get$_mayAddEvent.call(this) && (this._state & 2) === 0;
    },
    _addEventError$0: function() {
      if ((this._state & 2) !== 0)
        return new P.StateError("Cannot fire new event. Controller is already firing an event");
      return this.super$_BroadcastStreamController$_addEventError$0();
    },
    _sendData$1: function(data) {
      H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 0));
      if (this._async$_next === this)
        return;
      H.assertHelper(true);
      if (this._async$_next.get$_async$_next() === this) {
        this._state |= 2;
        H.interceptedTypeCheck(this._async$_next, "$is_BroadcastSubscription")._async$_add$1(data);
        this._state &= 4294967293;
        if (this._async$_next === this)
          this._callOnCancel$0();
        return;
      }
      this._forEachListener$1(new P._SyncBroadcastStreamController__sendData_closure(this, data));
    },
    _sendError$2: function(error, stackTrace) {
      if (this._async$_next === this)
        return;
      this._forEachListener$1(new P._SyncBroadcastStreamController__sendError_closure(this, error, stackTrace));
    },
    _sendDone$0: function() {
      if (this._async$_next !== this)
        this._forEachListener$1(new P._SyncBroadcastStreamController__sendDone_closure(this));
      else {
        H.assertHelper(this._doneFuture != null);
        H.assertHelper(this._doneFuture._state === 0);
        this._doneFuture._asyncComplete$1(null);
      }
    },
    T2: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isStreamController: 1
  },
  _SyncBroadcastStreamController__sendData_closure: {
    "^": "Closure;_async$_captured_this_0,_captured_data_1",
    call$1: function(subscription) {
      H.assertSubtype(subscription, "$is_BufferingStreamSubscription", [H.getTypeArgumentByIndex(this._async$_captured_this_0, 0)], "$as_BufferingStreamSubscription")._async$_add$1(this._captured_data_1);
    },
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "", args: [[P._BufferingStreamSubscription, T]]};
      }, this._async$_captured_this_0, "_SyncBroadcastStreamController");
    }
  },
  _SyncBroadcastStreamController__sendError_closure: {
    "^": "Closure;_async$_captured_this_0,_captured_error_1,_captured_stackTrace_2",
    call$1: function(subscription) {
      H.assertSubtype(subscription, "$is_BufferingStreamSubscription", [H.getTypeArgumentByIndex(this._async$_captured_this_0, 0)], "$as_BufferingStreamSubscription")._addError$2(this._captured_error_1, this._captured_stackTrace_2);
    },
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "", args: [[P._BufferingStreamSubscription, T]]};
      }, this._async$_captured_this_0, "_SyncBroadcastStreamController");
    }
  },
  _SyncBroadcastStreamController__sendDone_closure: {
    "^": "Closure;_async$_captured_this_0",
    call$1: function(subscription) {
      H.assertSubtype(subscription, "$is_BroadcastSubscription", [H.getTypeArgumentByIndex(this._async$_captured_this_0, 0)], "$as_BroadcastSubscription")._close$0();
    },
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "", args: [[P._BroadcastSubscription, T]]};
      }, this._async$_captured_this_0, "_SyncBroadcastStreamController");
    }
  },
  _AsBroadcastStreamController: {
    "^": "_SyncBroadcastStreamController;_pending,_onListen,_onCancel,_state,_async$_next,_async$_previous,_addStreamState,_doneFuture",
    _addPendingEvent$1: function($event) {
      var t1 = this._pending;
      if (t1 == null) {
        t1 = new P._StreamImplEvents(null, null, 0);
        this._pending = t1;
      }
      t1.add$1(0, $event);
    },
    add$1: [function(_, data) {
      var t1;
      H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 0));
      t1 = this._state;
      if ((t1 & 4) === 0 && (t1 & 2) !== 0) {
        t1 = new P._DelayedData(H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 0)), null);
        t1.$builtinTypeInfo = this.$builtinTypeInfo;
        this._addPendingEvent$1(t1);
        return;
      }
      this.super$_BroadcastStreamController$add$1(this, data);
      while (true) {
        t1 = this._pending;
        if (!(t1 != null && t1.lastPendingEvent != null))
          break;
        t1.handleNext$1(this);
      }
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "", void: true, args: [T]};
      }, this.$receiver, "_AsBroadcastStreamController");
    }],
    addError$2: [function(error, stackTrace) {
      var t1;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      t1 = this._state;
      if ((t1 & 4) === 0 && (t1 & 2) !== 0) {
        this._addPendingEvent$1(new P._DelayedError(error, stackTrace, null));
        return;
      }
      if (!(P._BroadcastStreamController.prototype.get$_mayAddEvent.call(this) && (this._state & 2) === 0))
        throw H.wrapException(this._addEventError$0());
      this._sendError$2(error, stackTrace);
      while (true) {
        t1 = this._pending;
        if (!(t1 != null && t1.lastPendingEvent != null))
          break;
        t1.handleNext$1(this);
      }
    }, function(error) {
      return this.addError$2(error, null);
    }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 11, 0],
    close$0: [function() {
      var t1, result;
      t1 = this._state;
      if ((t1 & 4) === 0 && (t1 & 2) !== 0) {
        this._addPendingEvent$1(C.C__DelayedDone);
        this._state |= 4;
        return P._BroadcastStreamController.prototype.get$done.call(this);
      }
      result = this.super$_BroadcastStreamController$close$0();
      t1 = this._pending;
      H.assertHelper(!(t1 != null && t1.lastPendingEvent != null));
      return result;
    }, "call$0", "get$close", 0, 0, 12],
    _callOnCancel$0: function() {
      var t1 = this._pending;
      if (t1 != null && t1.lastPendingEvent != null) {
        if (t1._state === 1)
          t1._state = 3;
        t1.lastPendingEvent = null;
        t1.firstPendingEvent = null;
        this._pending = null;
      }
      this.super$_BroadcastStreamController$_callOnCancel$0();
    },
    T2: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $is_EventDispatch: 1
  },
  Future: {
    "^": "Object;"
  },
  _Completer: {
    "^": "Object;",
    completeError$2: function(error, stackTrace) {
      error = error != null ? error : new P.NullThrownError();
      if (this.future._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      $.Zone__current.toString;
      this._completeError$2(error, stackTrace);
    },
    completeError$1: function(error) {
      return this.completeError$2(error, null);
    },
    $isCompleter: 1
  },
  _AsyncCompleter: {
    "^": "_Completer;future",
    complete$1: function(value) {
      var t1 = this.future;
      if (t1._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      t1._asyncComplete$1(value);
    },
    _completeError$2: function(error, stackTrace) {
      this.future._asyncCompleteError$2(error, stackTrace);
    }
  },
  _FutureListener: {
    "^": "Object;_nextListener,result,state,callback,errorCallback"
  },
  _Future: {
    "^": "Object;_state<,_zone,_resultOrListeners",
    set$_state: function(_state) {
      this._state = H.intTypeCheck(_state);
    },
    set$_isChained: function(value) {
      var t1 = this._state;
      if (value) {
        H.assertHelper(t1 < 4);
        this._state = 2;
      } else {
        H.assertHelper(t1 === 2);
        this._state = 0;
      }
    },
    then$2$onError: function(f, onError) {
      var t1, t2, result, t3, t4;
      t1 = H.getDynamicRuntimeType();
      t2 = H.buildFunctionType(t1, [this.T()]);
      f = t2._assertCheck$1(f);
      result = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
      t3 = result._zone;
      if (t3 !== C.C__RootZone) {
        t3.toString;
        t4 = H.buildFunctionType(t1, [t1]);
        t4._assertCheck$1(f);
        f = t2._assertCheck$1(t4._assertCheck$1(f));
        if (onError != null)
          onError = P._registerErrorHandler(onError, t3);
      }
      H.buildFunctionType(t1, [t1])._assertCheck$1(f);
      this._addListener$1(new P._FutureListener(null, result, onError == null ? 1 : 3, f, onError));
      return result;
    },
    then$1: function(f) {
      return this.then$2$onError(f, null);
    },
    whenComplete$1: function(action) {
      var t1, t2, result;
      t1 = H.buildFunctionType(H.getDynamicRuntimeType());
      action = t1._assertCheck$1(action);
      t2 = $.Zone__current;
      result = new P._Future(0, t2, null);
      result.$builtinTypeInfo = this.$builtinTypeInfo;
      if (t2 !== C.C__RootZone) {
        t2.toString;
        t1._assertCheck$1(action);
        action = t1._assertCheck$1(t1._assertCheck$1(action));
      }
      t1._assertCheck$1(action);
      this._addListener$1(new P._FutureListener(null, result, 8, action, null));
      return H.assertSubtype(result, "$isFuture", [H.getTypeArgumentByIndex(this, 0)], "$asFuture");
    },
    _markPendingCompletion$0: function() {
      if (this._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      this._state = 1;
    },
    _setValue$1: function(value) {
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0));
      H.assertHelper(this._state < 4);
      this._state = 4;
      this._resultOrListeners = value;
    },
    _setErrorObject$1: function(error) {
      H.assertHelper(this._state < 4);
      this._state = 8;
      this._resultOrListeners = error;
    },
    _setError$2: function(error, stackTrace) {
      this._setErrorObject$1(new P.AsyncError(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace")));
    },
    _addListener$1: function(listener) {
      var t1, t2;
      H.assertHelper(listener._nextListener == null);
      if (this._state >= 4) {
        t1 = this._zone;
        t2 = new P._Future__addListener_closure(this, listener);
        t1.toString;
        H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(t2);
        P._rootScheduleMicrotask(null, null, t1, t2);
      } else {
        listener._nextListener = H.interceptedTypeCheck(this._resultOrListeners, "$is_FutureListener");
        this._resultOrListeners = listener;
      }
    },
    _removeListeners$0: function() {
      var current, prev, next;
      H.assertHelper(this._state < 4);
      current = H.interceptedTypeCheck(this._resultOrListeners, "$is_FutureListener");
      this._resultOrListeners = null;
      for (prev = null; current != null; prev = current, current = next) {
        next = current._nextListener;
        current._nextListener = prev;
      }
      return prev;
    },
    _complete$1: function(value) {
      var t1, listeners;
      H.assertHelper(this._state < 4);
      t1 = J.getInterceptor(value);
      if (!!t1.$isFuture)
        if (!!t1.$is_Future)
          P._Future__chainCoreFuture(value, this);
        else
          P._Future__chainForeignFuture(value, this);
      else {
        listeners = this._removeListeners$0();
        this._setValue$1(value);
        P._Future__propagateToListeners(this, listeners);
      }
    },
    _completeWithValue$1: function(value) {
      var listeners;
      H.assertHelper(this._state < 4);
      H.assertHelper(!J.getInterceptor(value).$isFuture);
      listeners = this._removeListeners$0();
      this._setValue$1(value);
      P._Future__propagateToListeners(this, listeners);
    },
    _completeError$2: [function(error, stackTrace) {
      var listeners;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      H.assertHelper(this._state < 4);
      listeners = this._removeListeners$0();
      this._setErrorObject$1(new P.AsyncError(error, stackTrace));
      P._Future__propagateToListeners(this, listeners);
    }, function(error) {
      return this._completeError$2(error, null);
    }, "_completeError$1", "call$2", "call$1", "get$_completeError", 2, 2, 13, 0],
    _asyncComplete$1: function(value) {
      var t1, t2;
      H.assertHelper(this._state < 4);
      if (value == null)
        ;
      else {
        t1 = J.getInterceptor(value);
        if (!!t1.$isFuture) {
          H.assertSubtype(value, "$isFuture", [H.getTypeArgumentByIndex(this, 0)], "$asFuture");
          if (!!t1.$is_Future) {
            H.assertSubtype(value, "$is_Future", [H.getTypeArgumentByIndex(this, 0)], "$as_Future");
            t1 = value._state;
            if (t1 >= 4 && t1 === 8) {
              this._markPendingCompletion$0();
              t1 = this._zone;
              t2 = new P._Future__asyncComplete_closure(this, value);
              t1.toString;
              H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(t2);
              P._rootScheduleMicrotask(null, null, t1, t2);
            } else
              P._Future__chainCoreFuture(value, this);
          } else
            P._Future__chainForeignFuture(value, this);
          return;
        } else
          H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0));
      }
      this._markPendingCompletion$0();
      t1 = this._zone;
      t2 = new P._Future__asyncComplete_closure0(this, value);
      t1.toString;
      H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(t2);
      P._rootScheduleMicrotask(null, null, t1, t2);
    },
    _asyncCompleteError$2: function(error, stackTrace) {
      var t1, t2;
      H.assertHelper(this._state < 4);
      this._markPendingCompletion$0();
      t1 = this._zone;
      t2 = new P._Future__asyncCompleteError_closure(this, error, stackTrace);
      t1.toString;
      H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(t2);
      P._rootScheduleMicrotask(null, null, t1, t2);
    },
    T: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isFuture: 1,
    static: {_Future__chainForeignFuture: function(source, target) {
        var e, s, t1, exception;
        H.assertHelper(target.get$_state() < 4);
        H.assertHelper(!(source instanceof P._Future));
        t1 = target;
        H.assertHelper(t1.get$_state() < 4);
        t1.set$_state(2);
        try {
          source.then$2$onError(new P._Future__chainForeignFuture_closure(target), new P._Future__chainForeignFuture_closure0(target));
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          P.scheduleMicrotask(new P._Future__chainForeignFuture_closure1(target, e, s));
        }
      }, _Future__chainCoreFuture: function(source, target) {
        var listener;
        H.assertHelper(target._state < 4);
        H.assertHelper(true);
        H.assertHelper(target._state < 4);
        target._state = 2;
        listener = new P._FutureListener(null, target, 0, null, null);
        if (source._state >= 4)
          P._Future__propagateToListeners(source, listener);
        else
          source._addListener$1(listener);
      }, _Future__propagateToListeners: function(source, listeners) {
        var t1, t2, t3, t4, hasError, asyncError, t5, listeners0, sourceValue, zone, previous, oldZone, chainSource, result;
        t1 = {};
        t1._captured_source_4 = source;
        H.interceptedTypeCheck(source, "$is_Future");
        for (t2 = source; true;) {
          t3 = {};
          H.assertHelper(t2._state >= 4);
          t2 = t1._captured_source_4;
          t4 = t2._state;
          hasError = t4 === 8;
          if (listeners == null) {
            if (hasError) {
              H.assertHelper(t4 >= 4 && true);
              asyncError = H.interceptedTypeCheck(t2._resultOrListeners, "$isAsyncError");
              t2 = t1._captured_source_4._zone;
              t3 = asyncError.error;
              t5 = asyncError.stackTrace;
              t2.toString;
              P._rootHandleUncaughtError(null, null, t2, t3, t5);
            }
            return;
          }
          for (; listeners0 = listeners._nextListener, listeners0 != null; listeners = listeners0) {
            listeners._nextListener = null;
            P._Future__propagateToListeners(t1._captured_source_4, listeners);
          }
          t3._captured_listenerHasValue_1 = true;
          if (hasError)
            sourceValue = null;
          else {
            t2 = t1._captured_source_4;
            t4 = t2._state;
            H.assertHelper(t4 >= 4 && t4 === 4);
            sourceValue = H.assertSubtypeOfRuntimeType(t2._resultOrListeners, H.getTypeArgumentByIndex(t2, 0));
          }
          t3._captured_listenerValueOrError_2 = sourceValue;
          t3._captured_isPropagationAborted_3 = false;
          t2 = !hasError;
          if (t2) {
            t4 = listeners.state;
            t4 = (t4 & 1) !== 0 || t4 === 8;
          } else
            t4 = true;
          if (t4) {
            t4 = listeners.result;
            zone = t4._zone;
            if (hasError) {
              t5 = t1._captured_source_4._zone;
              t5.toString;
              if (t5 == null ? zone != null : t5 !== zone) {
                t5 = t5.get$errorZone();
                zone.toString;
                t5 = t5 === zone;
              } else
                t5 = true;
              t5 = !t5;
            } else
              t5 = false;
            if (t5) {
              t2 = t1._captured_source_4;
              t3 = t2._state;
              H.assertHelper(t3 >= 4 && t3 === 8);
              asyncError = H.interceptedTypeCheck(t2._resultOrListeners, "$isAsyncError");
              t2 = t1._captured_source_4._zone;
              t3 = asyncError.error;
              t4 = asyncError.stackTrace;
              t2.toString;
              P._rootHandleUncaughtError(null, null, t2, t3, t4);
              return;
            }
            t5 = $.Zone__current;
            if (t5 == null ? zone != null : t5 !== zone) {
              H.assertHelper(zone != null);
              t5 = $.Zone__current;
              H.assertHelper(zone == null ? t5 != null : zone !== t5);
              previous = $.Zone__current;
              $.Zone__current = zone;
              oldZone = previous;
            } else
              oldZone = null;
            if (t2) {
              if ((listeners.state & 1) !== 0)
                t3._captured_listenerHasValue_1 = H.boolTypeCheck(new P._Future__propagateToListeners_handleValueCallback(t3, listeners, sourceValue, zone).call$0());
            } else
              new P._Future__propagateToListeners_handleError(t1, t3, listeners, zone).call$0();
            if (listeners.state === 8)
              new P._Future__propagateToListeners_handleWhenCompleteCallback(t1, t3, hasError, listeners, zone).call$0();
            if (oldZone != null) {
              H.assertHelper(true);
              $.Zone__current = oldZone;
            }
            if (t3._captured_isPropagationAborted_3)
              return;
            if (H.boolConversionCheck(t3._captured_listenerHasValue_1)) {
              t2 = t3._captured_listenerValueOrError_2;
              t2 = (sourceValue == null ? t2 != null : sourceValue !== t2) && !!J.getInterceptor(t2).$isFuture;
            } else
              t2 = false;
            if (t2) {
              chainSource = H.interceptedTypeCheck(t3._captured_listenerValueOrError_2, "$isFuture");
              if (chainSource instanceof P._Future)
                if (chainSource._state >= 4) {
                  H.assertHelper(t4._state < 4);
                  t4._state = 2;
                  t1._captured_source_4 = chainSource;
                  listeners = new P._FutureListener(null, t4, 0, null, null);
                  t2 = chainSource;
                  continue;
                } else
                  P._Future__chainCoreFuture(chainSource, t4);
              else
                P._Future__chainForeignFuture(chainSource, t4);
              return;
            }
          }
          result = listeners.result;
          listeners = result._removeListeners$0();
          t2 = H.boolConversionCheck(t3._captured_listenerHasValue_1);
          t3 = t3._captured_listenerValueOrError_2;
          t4 = result._state;
          if (t2) {
            H.assertSubtypeOfRuntimeType(t3, H.getTypeArgumentByIndex(result, 0));
            H.assertHelper(t4 < 4);
            result._state = 4;
            result._resultOrListeners = t3;
          } else {
            H.interceptedTypeCheck(t3, "$isAsyncError");
            H.assertHelper(t4 < 4);
            result._state = 8;
            result._resultOrListeners = t3;
          }
          t1._captured_source_4 = result;
          t2 = result;
        }
      }}
  },
  _Future__addListener_closure: {
    "^": "Closure:1;_async$_captured_this_0,_captured_listener_1",
    call$0: function() {
      P._Future__propagateToListeners(this._async$_captured_this_0, this._captured_listener_1);
    }
  },
  _Future__chainForeignFuture_closure: {
    "^": "Closure:2;_captured_target_0",
    call$1: function(value) {
      var t1 = this._captured_target_0;
      H.assertHelper(t1._state === 2);
      t1._completeWithValue$1(value);
    }
  },
  _Future__chainForeignFuture_closure0: {
    "^": "Closure:14;_captured_target_1",
    call$2: function(error, stackTrace) {
      var t1 = this._captured_target_1;
      H.assertHelper(t1._state === 2);
      t1._completeError$2(error, stackTrace);
    },
    call$1: function(error) {
      return this.call$2(error, null);
    }
  },
  _Future__chainForeignFuture_closure1: {
    "^": "Closure:1;_captured_target_2,_captured_e_3,_captured_s_4",
    call$0: function() {
      this._captured_target_2._completeError$2(this._captured_e_3, this._captured_s_4);
    }
  },
  _Future__asyncComplete_closure: {
    "^": "Closure:1;_async$_captured_this_0,_captured_coreFuture_1",
    call$0: function() {
      P._Future__chainCoreFuture(this._captured_coreFuture_1, this._async$_captured_this_0);
    }
  },
  _Future__asyncComplete_closure0: {
    "^": "Closure:1;_async$_captured_this_2,_captured_value_3",
    call$0: function() {
      this._async$_captured_this_2._completeWithValue$1(this._captured_value_3);
    }
  },
  _Future__asyncCompleteError_closure: {
    "^": "Closure:1;_async$_captured_this_0,_captured_error_1,_captured_stackTrace_2",
    call$0: function() {
      this._async$_captured_this_0._completeError$2(this._captured_error_1, this._captured_stackTrace_2);
    }
  },
  _Future__propagateToListeners_handleValueCallback: {
    "^": "Closure:15;_box_1,_captured_listener_3,_captured_sourceValue_4,_captured_zone_5",
    call$0: function() {
      var e, s, t1, t2, exception;
      try {
        t1 = this._captured_listener_3;
        H.assertHelper((t1.state & 1) !== 0);
        t2 = H.getDynamicRuntimeType();
        this._box_1._captured_listenerValueOrError_2 = this._captured_zone_5.runUnary$2(H.buildFunctionType(t2, [t2])._assertCheck$1(t1.callback), this._captured_sourceValue_4);
        return true;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        this._box_1._captured_listenerValueOrError_2 = new P.AsyncError(e, H.interceptedTypeCheck(s, "$isStackTrace"));
        return false;
      }
    }
  },
  _Future__propagateToListeners_handleError: {
    "^": "Closure:4;_box_2,_box_1,_captured_listener_6,_captured_zone_7",
    call$0: function() {
      var asyncError, matchesTest, test, e, s, errorCallback, e0, s0, t1, t2, exception, listenerValueOrError, t3, t4;
      t1 = this._box_2._captured_source_4;
      t2 = t1._state;
      H.assertHelper(t2 >= 4 && t2 === 8);
      asyncError = H.interceptedTypeCheck(t1._resultOrListeners, "$isAsyncError");
      matchesTest = true;
      t1 = this._captured_listener_6;
      if (t1.state === 6) {
        H.assertHelper(true);
        t2 = H.buildFunctionType(H.buildInterfaceType(P.bool), [H.getDynamicRuntimeType()]);
        test = t2._assertCheck$1(t2._assertCheck$1(t1.callback));
        try {
          matchesTest = H.boolTypeCheck(this._captured_zone_7.runUnary$2(test, asyncError.get$error()));
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          t1 = asyncError.get$error();
          t2 = e;
          listenerValueOrError = (t1 == null ? t2 == null : t1 === t2) ? asyncError : new P.AsyncError(e, H.interceptedTypeCheck(s, "$isStackTrace"));
          t1 = this._box_1;
          t1._captured_listenerValueOrError_2 = listenerValueOrError;
          t1._captured_listenerHasValue_1 = false;
          return;
        }
      }
      errorCallback = t1.errorCallback;
      if (H.boolConversionCheck(matchesTest) && errorCallback != null) {
        try {
          t1 = errorCallback;
          t2 = H.getDynamicRuntimeType();
          t2 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
          t3 = this._captured_zone_7;
          t4 = this._box_1;
          if (t2)
            t4._captured_listenerValueOrError_2 = t3.runBinary$3(errorCallback, asyncError.get$error(), asyncError.get$stackTrace());
          else
            t4._captured_listenerValueOrError_2 = t3.runUnary$2(errorCallback, asyncError.get$error());
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e0 = t1;
          s0 = H.getTraceFromException(exception);
          t1 = asyncError.get$error();
          t2 = e0;
          listenerValueOrError = (t1 == null ? t2 == null : t1 === t2) ? asyncError : new P.AsyncError(e0, H.interceptedTypeCheck(s0, "$isStackTrace"));
          t1 = this._box_1;
          t1._captured_listenerValueOrError_2 = listenerValueOrError;
          t1._captured_listenerHasValue_1 = false;
          return;
        }
        this._box_1._captured_listenerHasValue_1 = true;
      } else {
        t1 = this._box_1;
        t1._captured_listenerValueOrError_2 = asyncError;
        t1._captured_listenerHasValue_1 = false;
      }
    }
  },
  _Future__propagateToListeners_handleWhenCompleteCallback: {
    "^": "Closure:4;_box_2,_box_1,_captured_hasError_8,_captured_listener_9,_captured_zone_10",
    call$0: function() {
      var t1, e, s, t2, completeResult, exception, result;
      t1 = {};
      t1._captured_completeResult_0 = null;
      try {
        t2 = this._captured_listener_9;
        H.assertHelper(t2.state === 8);
        completeResult = this._captured_zone_10.run$1(H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(t2.callback));
        t1._captured_completeResult_0 = completeResult;
        t2 = completeResult;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        if (this._captured_hasError_8) {
          t1 = this._box_2._captured_source_4;
          t2 = t1._state;
          H.assertHelper(t2 >= 4 && t2 === 8);
          t1 = H.interceptedTypeCheck(t1._resultOrListeners, "$isAsyncError").error;
          t2 = e;
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = false;
        if (t1) {
          t1 = this._box_2._captured_source_4;
          t2 = t1._state;
          H.assertHelper(t2 >= 4 && t2 === 8);
          t2 = this._box_1;
          t2._captured_listenerValueOrError_2 = H.interceptedTypeCheck(t1._resultOrListeners, "$isAsyncError");
          t1 = t2;
        } else {
          t1 = this._box_1;
          t1._captured_listenerValueOrError_2 = new P.AsyncError(e, H.interceptedTypeCheck(s, "$isStackTrace"));
        }
        t1._captured_listenerHasValue_1 = false;
        return;
      }
      if (!!J.getInterceptor(t2).$isFuture) {
        result = this._captured_listener_9.result;
        result.set$_isChained(true);
        this._box_1._captured_isPropagationAborted_3 = true;
        t1._captured_completeResult_0.then$2$onError(new P._Future__propagateToListeners_handleWhenCompleteCallback_closure(this._box_2, result), new P._Future__propagateToListeners_handleWhenCompleteCallback_closure0(t1, result));
      }
    }
  },
  _Future__propagateToListeners_handleWhenCompleteCallback_closure: {
    "^": "Closure:2;_box_2,_captured_result_11",
    call$1: function(ignored) {
      P._Future__propagateToListeners(this._box_2._captured_source_4, new P._FutureListener(null, this._captured_result_11, 0, null, null));
    }
  },
  _Future__propagateToListeners_handleWhenCompleteCallback_closure0: {
    "^": "Closure:14;_box_0,_captured_result_12",
    call$2: function(error, stackTrace) {
      var t1, completeResult;
      t1 = this._box_0;
      if (!(t1._captured_completeResult_0 instanceof P._Future)) {
        completeResult = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
        t1._captured_completeResult_0 = completeResult;
        completeResult._setError$2(error, stackTrace);
      }
      P._Future__propagateToListeners(t1._captured_completeResult_0, new P._FutureListener(null, this._captured_result_12, 0, null, null));
    },
    call$1: function(error) {
      return this.call$2(error, null);
    }
  },
  _AsyncCallbackEntry: {
    "^": "Object;callback,next",
    callback$0: function() {
      return this.callback.call$0();
    }
  },
  Stream: {
    "^": "Object;",
    forEach$1: function(_, action) {
      var t1, t2, future;
      t1 = {};
      t2 = H.buildFunctionType(H.getVoidRuntimeType(), [this.T0()])._assertCheck$1(action);
      future = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
      t1._captured_subscription_0 = null;
      t1._captured_subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_forEach_closure(t1, this, t2, future), true, new P.Stream_forEach_closure0(future), future.get$_completeError());
      return future;
    },
    get$length: function(_) {
      var t1, future;
      t1 = {};
      future = H.assertSubtype(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [P.$int]), "$is_Future", [P.$int], "$as_Future");
      t1._captured_count_0 = 0;
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_length_closure(t1), true, new P.Stream_length_closure0(t1, future), future.get$_completeError());
      return H.assertSubtype(future, "$isFuture", [P.$int], "$asFuture");
    },
    T0: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  Stream_forEach_closure: {
    "^": "Closure;_box_0,_captured_this_1,_captured_action_2,_captured_future_3",
    call$1: function(element) {
      P._runUserCode(new P.Stream_forEach__closure(this._captured_action_2, H.assertSubtypeOfRuntimeType(element, H.getRuntimeTypeArgument(this._captured_this_1, "Stream", 0))), new P.Stream_forEach__closure0(), P._cancelAndErrorClosure(this._box_0._captured_subscription_0, this._captured_future_3));
    },
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "", args: [T]};
      }, this._captured_this_1, "Stream");
    }
  },
  Stream_forEach__closure: {
    "^": "Closure:1;_captured_action_4,_captured_element_5",
    call$0: function() {
      return this._captured_action_4.call$1(this._captured_element_5);
    }
  },
  Stream_forEach__closure0: {
    "^": "Closure:2;",
    call$1: function(_) {
    }
  },
  Stream_forEach_closure0: {
    "^": "Closure:1;_captured_future_6",
    call$0: function() {
      this._captured_future_6._complete$1(null);
    }
  },
  Stream_length_closure: {
    "^": "Closure:2;_box_0",
    call$1: function(_) {
      ++this._box_0._captured_count_0;
    }
  },
  Stream_length_closure0: {
    "^": "Closure:1;_box_0,_captured_future_1",
    call$0: function() {
      this._captured_future_1._complete$1(this._box_0._captured_count_0);
    }
  },
  StreamSubscription: {
    "^": "Object;"
  },
  _StreamController: {
    "^": "Object;_state<",
    set$_state: function(_state) {
      this._state = H.intTypeCheck(_state);
    },
    get$_pendingEvents: function() {
      H.assertHelper((this._state & 3) === 0);
      if ((this._state & 8) === 0)
        return H.interceptedTypeCheck(this._varData, "$is_PendingEvents");
      return H.interceptedTypeCheck(this._varData, "$is_StreamControllerAddStreamState").get$varData();
    },
    _ensurePendingEvents$0: function() {
      var t1, state;
      H.assertHelper((this._state & 3) === 0);
      if ((this._state & 8) === 0) {
        t1 = this._varData;
        if (t1 == null) {
          t1 = new P._StreamImplEvents(null, null, 0);
          this._varData = t1;
        }
        return H.interceptedTypeCheck(t1, "$is_StreamImplEvents");
      }
      state = H.interceptedTypeCheck(this._varData, "$is_StreamControllerAddStreamState");
      state.get$varData();
      return state.get$varData();
    },
    get$_subscription: function() {
      H.assertHelper((this._state & 1) !== 0);
      if ((this._state & 8) !== 0)
        return H.interceptedTypeCheck(this._varData, "$is_StreamControllerAddStreamState").get$varData();
      return H.interceptedTypeCheck(this._varData, "$is_ControllerSubscription");
    },
    _badEventState$0: function() {
      var t1 = this._state;
      if ((t1 & 4) !== 0)
        return new P.StateError("Cannot add event after closing");
      H.assertHelper((t1 & 8) !== 0);
      return new P.StateError("Cannot add event while adding a stream");
    },
    _ensureDoneFuture$0: function() {
      var t1 = this._doneFuture;
      if (t1 == null) {
        t1 = (this._state & 2) !== 0 ? $.get$Future__nullFuture() : H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
        this._doneFuture = t1;
      }
      return t1;
    },
    add$1: [function(_, value) {
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(this, "_StreamController", 0));
      if (this._state >= 4)
        throw H.wrapException(this._badEventState$0());
      this._async$_add$1(value);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "", void: true, args: [T]};
      }, this.$receiver, "_StreamController");
    }],
    close$0: function() {
      var t1 = this._state;
      if ((t1 & 4) !== 0)
        return this._ensureDoneFuture$0();
      if (t1 >= 4)
        throw H.wrapException(this._badEventState$0());
      t1 |= 4;
      this._state = t1;
      if ((t1 & 1) !== 0)
        this._sendDone$0();
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, C.C__DelayedDone);
      return this._ensureDoneFuture$0();
    },
    _async$_add$1: function(value) {
      var t1;
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(this, "_StreamController", 0));
      t1 = this._state;
      if ((t1 & 1) !== 0)
        this._sendData$1(value);
      else if ((t1 & 3) === 0) {
        t1 = H.getRuntimeTypeArgument(this, "_StreamController", 0);
        this._ensurePendingEvents$0().add$1(0, H.setRuntimeTypeInfo(new P._DelayedData(H.assertSubtypeOfRuntimeType(value, t1), null), [t1]));
      }
    },
    _subscribe$4: function(onData, onError, onDone, cancelOnError) {
      var t1, t2, t3, t4, t5, t6, subscription, pendingEvents, addState;
      t1 = H.getVoidRuntimeType();
      t2 = H.buildFunctionType(t1, [this.T13()])._assertCheck$1(onData);
      t3 = H.buildFunctionType(t1);
      t4 = t3._assertCheck$1(onDone);
      if ((this._state & 3) !== 0)
        throw H.wrapException(P.StateError$("Stream has already been listened to."));
      H.assertSubtype(this, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle");
      t1 = H.buildFunctionType(t1, [H.convertRtiToRuntimeType(null)]);
      t1._assertCheck$1(t2);
      t3._assertCheck$1(t4);
      t5 = $.Zone__current;
      t6 = cancelOnError ? 1 : 0;
      subscription = H.setRuntimeTypeInfo(new P._ControllerSubscription(H.assertSubtype(this, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle"), t1._assertCheck$1(null), null, t3._assertCheck$1(null), t5, t6, null, null), [null]);
      subscription._BufferingStreamSubscription$4(t2, onError, t4, cancelOnError, null);
      pendingEvents = this.get$_pendingEvents();
      t4 = this._state |= 1;
      if ((t4 & 8) !== 0) {
        addState = H.interceptedTypeCheck(this._varData, "$is_StreamControllerAddStreamState");
        addState.set$varData(subscription);
        addState.resume$0();
      } else
        this._varData = subscription;
      subscription._setPendingEvents$1(pendingEvents);
      subscription._guardCallback$1(new P._StreamController__subscribe_closure(this));
      return H.assertSubtype(subscription, "$isStreamSubscription", [H.getRuntimeTypeArgument(this, "_StreamController", 0)], "$asStreamSubscription");
    },
    _recordCancel$1: function(subscription) {
      var result, e, s, exception, t1, result0;
      H.assertSubtype(subscription, "$isStreamSubscription", [H.getRuntimeTypeArgument(this, "_StreamController", 0)], "$asStreamSubscription");
      result = null;
      if ((this._state & 8) !== 0)
        result = H.interceptedTypeCheck(this._varData, "$is_StreamControllerAddStreamState").cancel$0();
      this._varData = null;
      this._state = this._state & 4294967286 | 2;
      if (this.get$_onCancel() != null)
        if (result == null)
          try {
            result = H.interceptedTypeCheck(this._onCancel$0(), "$isFuture");
          } catch (exception) {
            t1 = H.unwrapException(exception);
            e = t1;
            s = H.getTraceFromException(exception);
            result0 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
            result0._asyncCompleteError$2(e, s);
            result = result0;
          }
        else
          result = result.whenComplete$1(this.get$_onCancel());
      t1 = new P._StreamController__recordCancel_complete(this);
      if (result != null)
        result = result.whenComplete$1(t1);
      else
        t1.call$0();
      return H.interceptedTypeCheck(result, "$isFuture");
    },
    _recordPause$1: function(subscription) {
      H.assertSubtype(subscription, "$isStreamSubscription", [H.getRuntimeTypeArgument(this, "_StreamController", 0)], "$asStreamSubscription");
      if ((this._state & 8) !== 0)
        H.interceptedTypeCheck(this._varData, "$is_StreamControllerAddStreamState").pause$0();
      P._runGuarded(this.get$_onPause());
    },
    _recordResume$1: function(subscription) {
      H.assertSubtype(subscription, "$isStreamSubscription", [H.getRuntimeTypeArgument(this, "_StreamController", 0)], "$asStreamSubscription");
      if ((this._state & 8) !== 0)
        H.interceptedTypeCheck(this._varData, "$is_StreamControllerAddStreamState").resume$0();
      P._runGuarded(this.get$_onResume());
    },
    T13: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $is_EventDispatch: 1,
    $is_EventSink: 1,
    $is_StreamControllerLifecycle: 1,
    $isStreamController: 1
  },
  _StreamController__subscribe_closure: {
    "^": "Closure:1;_async$_captured_this_0",
    call$0: function() {
      P._runGuarded(this._async$_captured_this_0.get$_onListen());
    }
  },
  _StreamController__recordCancel_complete: {
    "^": "Closure:4;_async$_captured_this_0",
    call$0: function() {
      var t1 = this._async$_captured_this_0._doneFuture;
      if (t1 != null && t1._state === 0)
        t1._asyncComplete$1(null);
    }
  },
  _SyncStreamControllerDispatch: {
    "^": "Object;",
    _sendData$1: function(data) {
      H.assertSubtypeOfRuntimeType(data, H.getRuntimeTypeArgument(this, "_SyncStreamControllerDispatch", 0));
      this.get$_subscription()._async$_add$1(data);
    },
    _sendDone$0: function() {
      this.get$_subscription()._close$0();
    },
    $isStreamController: 1,
    $is_EventDispatch: 1,
    $is_EventSink: 1,
    $is_StreamControllerLifecycle: 1
  },
  _AsyncStreamControllerDispatch: {
    "^": "Object;",
    _sendData$1: function(data) {
      H.assertSubtypeOfRuntimeType(data, H.getRuntimeTypeArgument(this, "_AsyncStreamControllerDispatch", 0));
      this.get$_subscription()._addPending$1(H.setRuntimeTypeInfo(new P._DelayedData(H.assertSubtypeOfRuntimeType(data, null), null), [null]));
    },
    _sendDone$0: function() {
      this.get$_subscription()._addPending$1(C.C__DelayedDone);
    },
    $is_EventDispatch: 1,
    $is_EventSink: 1,
    $is_StreamControllerLifecycle: 1,
    $isStreamController: 1
  },
  _AsyncStreamController: {
    "^": "_StreamController__AsyncStreamControllerDispatch;_onListen<,_onPause<,_onResume<,_onCancel<,_varData,_state,_doneFuture",
    _onCancel$0: function() {
      return this._onCancel.call$0();
    },
    T13: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  _StreamController__AsyncStreamControllerDispatch: {
    "^": "_StreamController+_AsyncStreamControllerDispatch;",
    T13: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $is_EventDispatch: 1,
    $is_EventSink: 1,
    $is_StreamControllerLifecycle: 1,
    $isStreamController: 1
  },
  _SyncStreamController: {
    "^": "_StreamController__SyncStreamControllerDispatch;_onListen<,_onPause<,_onResume<,_onCancel<,_varData,_state,_doneFuture",
    _onCancel$0: function() {
      return this._onCancel.call$0();
    },
    T13: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  _StreamController__SyncStreamControllerDispatch: {
    "^": "_StreamController+_SyncStreamControllerDispatch;",
    T13: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isStreamController: 1,
    $is_EventDispatch: 1,
    $is_EventSink: 1,
    $is_StreamControllerLifecycle: 1
  },
  _NoCallbacks: {
    "^": "Object;",
    get$_onListen: function() {
      return H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(null);
    },
    get$_onPause: function() {
      return H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(null);
    },
    get$_onResume: function() {
      return H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(null);
    },
    get$_onCancel: function() {
      return H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(null);
    },
    _onCancel$0: function() {
      return this.get$_onCancel().call$0();
    }
  },
  _NoCallbackAsyncStreamController: {
    "^": "_StreamController__AsyncStreamControllerDispatch0+_NoCallbacks;_varData,_state,_doneFuture",
    T13: function() {
      return H.convertRtiToRuntimeType($.functionThatReturnsNull.apply(null, this.$builtinTypeInfo));
    }
  },
  _StreamController__AsyncStreamControllerDispatch0: {
    "^": "_StreamController+_AsyncStreamControllerDispatch;",
    T13: function() {
      return H.convertRtiToRuntimeType($.functionThatReturnsNull.apply(null, this.$builtinTypeInfo));
    },
    $as_StreamController: $.functionThatReturnsNull,
    $as_AsyncStreamControllerDispatch: $.functionThatReturnsNull,
    $as_EventDispatch: $.functionThatReturnsNull,
    $as_EventSink: $.functionThatReturnsNull,
    $as_StreamControllerLifecycle: $.functionThatReturnsNull,
    $asStreamController: $.functionThatReturnsNull,
    $is_EventDispatch: 1,
    $is_EventSink: 1,
    $is_StreamControllerLifecycle: 1,
    $isStreamController: 1
  },
  _NoCallbackSyncStreamController: {
    "^": "_StreamController__SyncStreamControllerDispatch0+_NoCallbacks;_varData,_state,_doneFuture",
    T13: function() {
      return H.convertRtiToRuntimeType($.functionThatReturnsNull.apply(null, this.$builtinTypeInfo));
    }
  },
  _StreamController__SyncStreamControllerDispatch0: {
    "^": "_StreamController+_SyncStreamControllerDispatch;",
    T13: function() {
      return H.convertRtiToRuntimeType($.functionThatReturnsNull.apply(null, this.$builtinTypeInfo));
    },
    $as_StreamController: $.functionThatReturnsNull,
    $as_SyncStreamControllerDispatch: $.functionThatReturnsNull,
    $as_EventDispatch: $.functionThatReturnsNull,
    $as_EventSink: $.functionThatReturnsNull,
    $as_StreamControllerLifecycle: $.functionThatReturnsNull,
    $asStreamController: $.functionThatReturnsNull,
    $isStreamController: 1,
    $is_EventDispatch: 1,
    $is_EventSink: 1,
    $is_StreamControllerLifecycle: 1
  },
  _ControllerStream: {
    "^": "_StreamImpl;_async$_controller",
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      var t1, t2;
      t1 = H.getVoidRuntimeType();
      t2 = H.buildFunctionType(t1, [this.T12()])._assertCheck$1(onData);
      t1 = H.buildFunctionType(t1)._assertCheck$1(onDone);
      return H.assertSubtype(this._async$_controller._subscribe$4(t2, onError, t1, cancelOnError), "$isStreamSubscription", [H.getTypeArgumentByIndex(this, 0)], "$asStreamSubscription");
    },
    get$hashCode: function(_) {
      return (H.Primitives_objectHashCode(this._async$_controller) ^ 892482866) >>> 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!(other instanceof P._ControllerStream))
        return false;
      return other._async$_controller === this._async$_controller;
    },
    T12: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T11: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T0: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  _ControllerSubscription: {
    "^": "_BufferingStreamSubscription;_async$_controller<,_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending",
    _onCancel$0: function() {
      return this.get$_async$_controller()._recordCancel$1(this);
    },
    _onPause$0: [function() {
      this.get$_async$_controller()._recordPause$1(this);
    }, "call$0", "get$_onPause", 0, 0, 4],
    _onResume$0: [function() {
      this.get$_async$_controller()._recordResume$1(this);
    }, "call$0", "get$_onResume", 0, 0, 4],
    T4: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  _EventSink: {
    "^": "Object;"
  },
  _BufferingStreamSubscription: {
    "^": "Object;_onData,_onError,_onDone,_zone,_state<,_cancelFuture,_pending",
    set$_onData: function(_onData) {
      this._onData = H.buildFunctionType(H.getVoidRuntimeType(), [this.T4()])._assertCheck$1(_onData);
    },
    set$_state: function(_state) {
      this._state = H.intTypeCheck(_state);
    },
    _setPendingEvents$1: function(pendingEvents) {
      H.assertHelper(this._pending == null);
      if (pendingEvents == null)
        return;
      this._pending = pendingEvents;
      if (pendingEvents.lastPendingEvent != null) {
        this._state = (this._state | 64) >>> 0;
        pendingEvents.schedule$1(this);
      }
    },
    pause$1: function(resumeSignal) {
      var t1, t2, t3;
      t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      t2 = (t1 + 128 | 4) >>> 0;
      this._state = t2;
      if (t1 < 128 && this._pending != null) {
        t3 = this._pending;
        if (t3._state === 1)
          t3._state = 3;
      }
      if ((t1 & 4) === 0 && (t2 & 32) === 0)
        this._guardCallback$1(this.get$_onPause());
    },
    pause$0: function() {
      return this.pause$1(null);
    },
    resume$0: function() {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 >= 128) {
        H.assertHelper(true);
        t1 = this._state -= 128;
        if (t1 < 128)
          if ((t1 & 64) !== 0 && this._pending.lastPendingEvent != null)
            this._pending.schedule$1(this);
          else {
            H.assertHelper(this.get$_mayResumeInput());
            t1 = (this._state & 4294967291) >>> 0;
            this._state = t1;
            if ((t1 & 32) === 0)
              this._guardCallback$1(this.get$_onResume());
          }
      }
    },
    cancel$0: function() {
      var t1 = (this._state & 4294967279) >>> 0;
      this._state = t1;
      if ((t1 & 8) !== 0)
        return this._cancelFuture;
      this._cancel$0();
      return this._cancelFuture;
    },
    get$_mayResumeInput: function() {
      if (this._state < 128) {
        var t1 = this._pending;
        t1 = t1 == null || t1.lastPendingEvent == null;
      } else
        t1 = false;
      return t1;
    },
    _cancel$0: function() {
      var t1, t2;
      t1 = (this._state | 8) >>> 0;
      this._state = t1;
      if ((t1 & 64) !== 0) {
        t2 = this._pending;
        if (t2._state === 1)
          t2._state = 3;
      }
      if ((t1 & 32) === 0)
        this._pending = null;
      this._cancelFuture = this._onCancel$0();
    },
    _async$_add$1: ["super$_BufferingStreamSubscription$_async$_add$1", function(data) {
      var t1;
      H.assertSubtypeOfRuntimeType(data, H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0));
      H.assertHelper((this._state & 2) === 0);
      t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 32)
        this._sendData$1(data);
      else
        this._addPending$1(H.setRuntimeTypeInfo(new P._DelayedData(H.assertSubtypeOfRuntimeType(data, null), null), [null]));
    }],
    _addError$2: ["super$_BufferingStreamSubscription$_addError$2", function(error, stackTrace) {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 32)
        this._sendError$2(error, stackTrace);
      else
        this._addPending$1(new P._DelayedError(error, stackTrace, null));
    }],
    _close$0: function() {
      H.assertHelper((this._state & 2) === 0);
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      t1 = (t1 | 2) >>> 0;
      this._state = t1;
      if (t1 < 32)
        this._sendDone$0();
      else
        this._addPending$1(C.C__DelayedDone);
    },
    _onPause$0: [function() {
      H.assertHelper((this._state & 4) !== 0);
    }, "call$0", "get$_onPause", 0, 0, 4],
    _onResume$0: [function() {
      H.assertHelper((this._state & 4) === 0);
    }, "call$0", "get$_onResume", 0, 0, 4],
    _onCancel$0: function() {
      H.assertHelper((this._state & 8) !== 0);
      return;
    },
    _addPending$1: function($event) {
      var pending, t1;
      pending = this._pending;
      if (pending == null) {
        pending = new P._StreamImplEvents(null, null, 0);
        this._pending = pending;
      }
      pending.add$1(0, $event);
      t1 = this._state;
      if ((t1 & 64) === 0) {
        t1 = (t1 | 64) >>> 0;
        this._state = t1;
        if (t1 < 128)
          this._pending.schedule$1(this);
      }
    },
    _sendData$1: function(data) {
      var t1;
      H.assertSubtypeOfRuntimeType(data, H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0));
      H.assertHelper((this._state & 8) === 0);
      H.assertHelper(this._state < 128);
      H.assertHelper((this._state & 32) === 0);
      t1 = this._state;
      this._state = (t1 | 32) >>> 0;
      this._zone.runUnaryGuarded$2(this._onData, data);
      this._state = (this._state & 4294967263) >>> 0;
      this._checkState$1((t1 & 4) !== 0);
    },
    _sendError$2: function(error, stackTrace) {
      var t1, t2;
      H.assertHelper((this._state & 8) === 0);
      H.assertHelper(this._state < 128);
      H.assertHelper((this._state & 32) === 0);
      t1 = this._state;
      t2 = new P._BufferingStreamSubscription__sendError_sendError(this, error, stackTrace);
      if ((t1 & 1) !== 0) {
        this._state = (t1 | 16) >>> 0;
        this._cancel$0();
        t1 = this._cancelFuture;
        if (!!J.getInterceptor(t1).$isFuture)
          t1.whenComplete$1(t2);
        else
          t2.call$0();
      } else {
        t2.call$0();
        this._checkState$1((t1 & 4) !== 0);
      }
    },
    _sendDone$0: function() {
      var t1, t2;
      H.assertHelper((this._state & 8) === 0);
      H.assertHelper(this._state < 128);
      H.assertHelper((this._state & 32) === 0);
      t1 = new P._BufferingStreamSubscription__sendDone_sendDone(this);
      this._cancel$0();
      this._state = (this._state | 16) >>> 0;
      t2 = this._cancelFuture;
      if (!!J.getInterceptor(t2).$isFuture)
        t2.whenComplete$1(t1);
      else
        t1.call$0();
    },
    _guardCallback$1: function(callback) {
      var t1;
      H.assertHelper((this._state & 32) === 0);
      t1 = this._state;
      this._state = (t1 | 32) >>> 0;
      callback.call$0();
      this._state = (this._state & 4294967263) >>> 0;
      this._checkState$1((t1 & 4) !== 0);
    },
    _checkState$1: function(wasInputPaused) {
      var t1, isInputPaused;
      H.assertHelper((this._state & 32) === 0);
      t1 = this._state;
      if ((t1 & 64) !== 0 && this._pending.lastPendingEvent == null) {
        t1 = (t1 & 4294967231) >>> 0;
        this._state = t1;
        if ((t1 & 4) !== 0 && this.get$_mayResumeInput())
          this._state = (this._state & 4294967291) >>> 0;
      }
      for (; true; wasInputPaused = isInputPaused) {
        t1 = this._state;
        if ((t1 & 8) !== 0) {
          this._pending = null;
          return;
        }
        isInputPaused = (t1 & 4) !== 0;
        if (wasInputPaused === isInputPaused)
          break;
        this._state = (t1 ^ 32) >>> 0;
        if (isInputPaused)
          this._onPause$0();
        else
          this._onResume$0();
        this._state = (this._state & 4294967263) >>> 0;
      }
      t1 = this._state;
      if ((t1 & 64) !== 0 && t1 < 128)
        this._pending.schedule$1(this);
    },
    _BufferingStreamSubscription$4: function(onData, onError, onDone, cancelOnError, $T) {
      var t1, t2, t3, handleDone, t4, t5;
      t1 = H.getVoidRuntimeType();
      t2 = H.buildFunctionType(t1, [this.T4()]);
      t3 = t2._assertCheck$1(onData);
      t1 = H.buildFunctionType(t1);
      handleDone = t1._assertCheck$1(onDone);
      t2._assertCheck$1(t3);
      t2 = this._zone;
      t2.toString;
      t4 = H.getDynamicRuntimeType();
      t5 = H.buildFunctionType(t4, [t4]);
      t5._assertCheck$1(t3);
      this.set$_onData(t5._assertCheck$1(t3));
      this._onError = P._registerErrorHandler(onError == null ? H.interceptedTypeCheck(P._nullErrorHandler$closure(), "$isFunction") : onError, t2);
      t1._assertCheck$1(handleDone);
      if (handleDone == null)
        handleDone = t1._assertCheck$1(P._nullDoneHandler$closure());
      t1 = H.buildFunctionType(t4);
      t1._assertCheck$1(handleDone);
      this._onDone = t1._assertCheck$1(handleDone);
    },
    T4: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $is_EventSink: 1,
    $isStreamSubscription: 1,
    $is_EventDispatch: 1,
    static: {_BufferingStreamSubscription$: function(onData, onError, onDone, cancelOnError, $T) {
        var t1, t2, t3, t4, t5, t6;
        t1 = H.getVoidRuntimeType();
        t2 = H.buildFunctionType(t1, [H.convertRtiToRuntimeType($T)]);
        t3 = t2._assertCheck$1(onData);
        t1 = H.buildFunctionType(t1);
        t4 = t1._assertCheck$1(onDone);
        t5 = $.Zone__current;
        t6 = cancelOnError ? 1 : 0;
        t6 = H.setRuntimeTypeInfo(new P._BufferingStreamSubscription(t2._assertCheck$1(null), null, t1._assertCheck$1(null), t5, t6, null, null), [$T]);
        t6._BufferingStreamSubscription$4(t3, onError, t4, cancelOnError, $T);
        return t6;
      }}
  },
  _BufferingStreamSubscription__sendError_sendError: {
    "^": "Closure:4;_async$_captured_this_0,_captured_error_1,_captured_stackTrace_2",
    call$0: function() {
      var t1, t2, t3, t4, t5, t6;
      t1 = this._async$_captured_this_0;
      t2 = t1._state;
      if ((t2 & 8) !== 0 && (t2 & 16) === 0)
        return;
      t1._state = (t2 | 32) >>> 0;
      t2 = t1._onError;
      t3 = H.getDynamicRuntimeType();
      t3 = H.buildFunctionType(t3, [t3, t3])._isTest$1(t2);
      t4 = t1._zone;
      t5 = this._captured_error_1;
      t6 = t1._onError;
      if (t3)
        t4.runBinaryGuarded$3(t6, t5, this._captured_stackTrace_2);
      else
        t4.runUnaryGuarded$2(t6, t5);
      t1._state = (t1._state & 4294967263) >>> 0;
    }
  },
  _BufferingStreamSubscription__sendDone_sendDone: {
    "^": "Closure:4;_async$_captured_this_0",
    call$0: function() {
      var t1, t2;
      t1 = this._async$_captured_this_0;
      t2 = t1._state;
      if ((t2 & 16) === 0)
        return;
      t1._state = (t2 | 42) >>> 0;
      t1._zone.runGuarded$1(t1._onDone);
      t1._state = (t1._state & 4294967263) >>> 0;
    }
  },
  _StreamImpl: {
    "^": "Stream;",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1 = H.getVoidRuntimeType();
      return H.assertSubtype(this._createSubscription$4(H.buildFunctionType(t1, [this.T11()])._assertCheck$1(onData), onError, H.buildFunctionType(t1)._assertCheck$1(onDone), true === cancelOnError), "$isStreamSubscription", [H.getTypeArgumentByIndex(this, 0)], "$asStreamSubscription");
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      var t1 = H.getVoidRuntimeType();
      return H.assertSubtype(P._BufferingStreamSubscription$(H.buildFunctionType(t1, [this.T11()])._assertCheck$1(onData), onError, H.buildFunctionType(t1)._assertCheck$1(onDone), cancelOnError, H.getTypeArgumentByIndex(this, 0)), "$is_BufferingStreamSubscription", [H.getTypeArgumentByIndex(this, 0)], "$as_BufferingStreamSubscription");
    },
    T11: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T0: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  _DelayedEvent: {
    "^": "Object;next<",
    set$next: function(next) {
      this.next = H.interceptedTypeCheck(next, "$is_DelayedEvent");
    }
  },
  _DelayedData: {
    "^": "_DelayedEvent;value,next",
    perform$1: function(dispatch) {
      H.assertSubtype(dispatch, "$is_EventDispatch", [H.getTypeArgumentByIndex(this, 0)], "$as_EventDispatch")._sendData$1(this.value);
    }
  },
  _DelayedError: {
    "^": "_DelayedEvent;error<,stackTrace<,next",
    perform$1: function(dispatch) {
      dispatch._sendError$2(this.error, this.stackTrace);
    }
  },
  _DelayedDone: {
    "^": "Object;",
    perform$1: function(dispatch) {
      dispatch._sendDone$0();
    },
    get$next: function() {
      return;
    },
    set$next: function(_) {
      throw H.wrapException(P.StateError$("No events after a done."));
    },
    $is_DelayedEvent: 1
  },
  _PendingEvents: {
    "^": "Object;_state<",
    set$_state: function(_state) {
      this._state = H.intTypeCheck(_state);
    },
    schedule$1: function(dispatch) {
      var t1;
      if (this._state === 1)
        return;
      H.assertHelper(!this.get$isEmpty(this));
      t1 = this._state;
      if (t1 >= 1) {
        H.assertHelper(t1 === 3);
        this._state = 1;
        return;
      }
      P.scheduleMicrotask(new P._PendingEvents_schedule_closure(this, dispatch));
      this._state = 1;
    }
  },
  _PendingEvents_schedule_closure: {
    "^": "Closure:1;_async$_captured_this_0,_captured_dispatch_1",
    call$0: function() {
      var t1, oldState;
      t1 = this._async$_captured_this_0;
      oldState = t1._state;
      t1._state = 0;
      if (oldState === 3)
        return;
      t1.handleNext$1(this._captured_dispatch_1);
    }
  },
  _StreamImplEvents: {
    "^": "_PendingEvents;firstPendingEvent,lastPendingEvent,_state",
    get$isEmpty: function(_) {
      return this.lastPendingEvent == null;
    },
    add$1: function(_, $event) {
      var t1 = this.lastPendingEvent;
      if (t1 == null) {
        this.lastPendingEvent = $event;
        this.firstPendingEvent = $event;
      } else {
        t1.set$next($event);
        this.lastPendingEvent = $event;
      }
    },
    handleNext$1: function(dispatch) {
      var $event, t1;
      H.assertHelper(this._state !== 1);
      $event = this.firstPendingEvent;
      t1 = $event.get$next();
      this.firstPendingEvent = t1;
      if (t1 == null)
        this.lastPendingEvent = null;
      $event.perform$1(dispatch);
    }
  },
  _DoneStreamSubscription: {
    "^": "Object;_zone,_state<,_onDone",
    set$_state: function(_state) {
      this._state = H.intTypeCheck(_state);
    },
    _async$_schedule$0: function() {
      var t1, t2;
      if ((this._state & 2) !== 0)
        return;
      t1 = this._zone;
      t2 = this.get$_sendDone();
      t1.toString;
      H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(t2);
      P._rootScheduleMicrotask(null, null, t1, t2);
      this._state = (this._state | 2) >>> 0;
    },
    pause$1: function(resumeSignal) {
      this._state += 4;
    },
    pause$0: function() {
      return this.pause$1(null);
    },
    resume$0: function() {
      var t1 = this._state;
      if (t1 >= 4) {
        t1 -= 4;
        this._state = t1;
        if (t1 < 4 && (t1 & 1) === 0)
          this._async$_schedule$0();
      }
    },
    cancel$0: function() {
      return;
    },
    _sendDone$0: [function() {
      var t1 = (this._state & 4294967293) >>> 0;
      this._state = t1;
      if (t1 >= 4)
        return;
      this._state = (t1 | 1) >>> 0;
      this._zone.runGuarded$1(this._onDone);
    }, "call$0", "get$_sendDone", 0, 0, 4],
    $isStreamSubscription: 1
  },
  _AsBroadcastStream: {
    "^": "Stream;_source,_onListenHandler,_onCancelHandler,_zone,_async$_controller,_subscription",
    set$_async$_controller: function(_controller) {
      this._async$_controller = H.assertSubtype(_controller, "$is_AsBroadcastStreamController", [H.getTypeArgumentByIndex(this, 0)], "$as_AsBroadcastStreamController");
    },
    set$_subscription: function(_subscription) {
      this._subscription = H.assertSubtype(_subscription, "$isStreamSubscription", [H.getTypeArgumentByIndex(this, 0)], "$asStreamSubscription");
    },
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1, t2, t3, t4;
      t1 = H.getVoidRuntimeType();
      t2 = H.buildFunctionType(t1, [this.T1()])._assertCheck$1(onData);
      t1 = H.buildFunctionType(t1);
      t3 = t1._assertCheck$1(onDone);
      t4 = this._async$_controller;
      if (t4 == null || (t4._state & 4) !== 0) {
        t1._assertCheck$1(t3);
        t2 = new P._DoneStreamSubscription($.Zone__current, 0, t1._assertCheck$1(t3));
        t2.$builtinTypeInfo = this.$builtinTypeInfo;
        t1._assertCheck$1(t3);
        t2._async$_schedule$0();
        return H.assertSubtype(t2, "$isStreamSubscription", [H.getTypeArgumentByIndex(this, 0)], "$asStreamSubscription");
      }
      if (this._subscription == null) {
        t1 = t4.get$add(t4);
        t4 = this._async$_controller.get$addError();
        this.set$_subscription(this._source.listen$3$onDone$onError(t1, this._async$_controller.get$close(), t4));
      }
      return H.assertSubtype(this._async$_controller._subscribe$4(t2, onError, t3, true === cancelOnError), "$isStreamSubscription", [H.getTypeArgumentByIndex(this, 0)], "$asStreamSubscription");
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    _onCancel$0: [function() {
      var t1, shutdown;
      t1 = this._async$_controller;
      shutdown = t1 == null || (t1._state & 4) !== 0;
      t1 = this._onCancelHandler;
      if (t1 != null)
        this._zone.runUnary$2(t1, H.setRuntimeTypeInfo(new P._BroadcastSubscriptionWrapper(this), [null]));
      if (shutdown) {
        t1 = this._subscription;
        if (t1 != null) {
          t1.cancel$0();
          this.set$_subscription(null);
        }
      }
    }, "call$0", "get$_onCancel", 0, 0, 4],
    _onListen$0: [function() {
      var t1 = this._onListenHandler;
      if (t1 != null)
        this._zone.runUnary$2(t1, H.setRuntimeTypeInfo(new P._BroadcastSubscriptionWrapper(this), [null]));
    }, "call$0", "get$_onListen", 0, 0, 4],
    T1: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T0: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  _BroadcastSubscriptionWrapper: {
    "^": "Object;_async$_stream",
    $isStreamSubscription: 1
  },
  _cancelAndError_closure: {
    "^": "Closure:1;_captured_future_0,_captured_error_1,_captured_stackTrace_2",
    call$0: function() {
      return this._captured_future_0._completeError$2(this._captured_error_1, this._captured_stackTrace_2);
    }
  },
  _cancelAndErrorClosure_closure: {
    "^": "Closure:16;_captured_subscription_0,_captured_future_1",
    call$2: function(error, stackTrace) {
      return P._cancelAndError(this._captured_subscription_0, this._captured_future_1, error, stackTrace);
    }
  },
  _ForwardingStream: {
    "^": "Stream;",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1 = H.getVoidRuntimeType();
      return H.assertSubtype(this._createSubscription$4(H.buildFunctionType(t1, [this.T5()])._assertCheck$1(onData), onError, H.buildFunctionType(t1)._assertCheck$1(onDone), true === cancelOnError), "$isStreamSubscription", [H.getRuntimeTypeArgument(this, "_ForwardingStream", 1)], "$asStreamSubscription");
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      var t1 = H.getVoidRuntimeType();
      return H.assertSubtype(P._ForwardingStreamSubscription$(this, H.buildFunctionType(t1, [this.T5()])._assertCheck$1(onData), onError, H.buildFunctionType(t1)._assertCheck$1(onDone), cancelOnError, H.getRuntimeTypeArgument(this, "_ForwardingStream", 0), H.getRuntimeTypeArgument(this, "_ForwardingStream", 1)), "$isStreamSubscription", [H.getRuntimeTypeArgument(this, "_ForwardingStream", 1)], "$asStreamSubscription");
    },
    _handleData$2: function(data, sink) {
      H.assertSubtypeOfRuntimeType(data, H.getRuntimeTypeArgument(this, "_ForwardingStream", 0));
      H.assertSubtype(sink, "$is_EventSink", [H.getRuntimeTypeArgument(this, "_ForwardingStream", 1)], "$as_EventSink")._async$_add$1(data);
    },
    T5: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[1]);
    },
    T0: function() {
      return H.convertRtiToRuntimeType(function($S, $T) {
        return $T;
      }.apply(null, this.$builtinTypeInfo));
    },
    $asStream: function($S, $T) {
      return [$T];
    }
  },
  _ForwardingStreamSubscription: {
    "^": "_BufferingStreamSubscription;_async$_stream,_subscription,_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending",
    set$_subscription: function(_subscription) {
      this._subscription = H.assertSubtype(_subscription, "$isStreamSubscription", [H.getRuntimeTypeArgument(this, "_ForwardingStreamSubscription", 0)], "$asStreamSubscription");
    },
    _async$_add$1: function(data) {
      H.assertSubtypeOfRuntimeType(data, H.getRuntimeTypeArgument(this, "_ForwardingStreamSubscription", 1));
      if ((this._state & 2) !== 0)
        return;
      this.super$_BufferingStreamSubscription$_async$_add$1(data);
    },
    _addError$2: function(error, stackTrace) {
      if ((this._state & 2) !== 0)
        return;
      this.super$_BufferingStreamSubscription$_addError$2(error, stackTrace);
    },
    _onPause$0: [function() {
      var t1 = this._subscription;
      if (t1 == null)
        return;
      t1.pause$0();
    }, "call$0", "get$_onPause", 0, 0, 4],
    _onResume$0: [function() {
      var t1 = this._subscription;
      if (t1 == null)
        return;
      t1.resume$0();
    }, "call$0", "get$_onResume", 0, 0, 4],
    _onCancel$0: function() {
      var t1 = this._subscription;
      if (t1 != null) {
        this.set$_subscription(null);
        t1.cancel$0();
      }
      return;
    },
    _handleData$1: [function(data) {
      this._async$_stream._handleData$2(H.assertSubtypeOfRuntimeType(data, H.getRuntimeTypeArgument(this, "_ForwardingStreamSubscription", 0)), this);
    }, "call$1", "get$_handleData", 2, 0, function() {
      return H.computeSignature(function(S, T) {
        return {func: "", void: true, args: [S]};
      }, this.$receiver, "_ForwardingStreamSubscription");
    }],
    _handleError$2: [function(error, stackTrace) {
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      H.assertSubtype(this, "$is_EventSink", [H.getRuntimeTypeArgument(this._async$_stream, "_ForwardingStream", 1)], "$as_EventSink");
      this._addError$2(error, stackTrace);
    }, "call$2", "get$_handleError", 4, 0, 17],
    _handleDone$0: [function() {
      H.assertSubtype(this, "$is_EventSink", [H.getRuntimeTypeArgument(this._async$_stream, "_ForwardingStream", 1)], "$as_EventSink");
      this._close$0();
    }, "call$0", "get$_handleDone", 0, 0, 4],
    _ForwardingStreamSubscription$5: function(_stream, onData, onError, onDone, cancelOnError, $S, $T) {
      var t1, t2;
      H.assertSubtype(_stream, "$is_ForwardingStream", [$S, $T], "$as_ForwardingStream");
      t1 = H.getVoidRuntimeType();
      H.buildFunctionType(t1, [this.T6()])._assertCheck$1(onData);
      H.buildFunctionType(t1)._assertCheck$1(onDone);
      t1 = this.get$_handleData();
      t2 = this.get$_handleError();
      this.set$_subscription(this._async$_stream._source.listen$3$onDone$onError(t1, this.get$_handleDone(), t2));
    },
    T6: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[1]);
    },
    T4: function() {
      return H.convertRtiToRuntimeType(function($S, $T) {
        return $T;
      }.apply(null, this.$builtinTypeInfo));
    },
    $as_BufferingStreamSubscription: function($S, $T) {
      return [$T];
    },
    $as_EventDispatch: function($S, $T) {
      return [$T];
    },
    $as_EventSink: function($S, $T) {
      return [$T];
    },
    $asStreamSubscription: function($S, $T) {
      return [$T];
    },
    static: {_ForwardingStreamSubscription$: function(_stream, onData, onError, onDone, cancelOnError, $S, $T) {
        var t1, t2, t3, t4, t5, t6;
        H.assertSubtype(_stream, "$is_ForwardingStream", [$S, $T], "$as_ForwardingStream");
        t1 = H.getVoidRuntimeType();
        t2 = H.buildFunctionType(t1, [H.convertRtiToRuntimeType($T)]);
        t3 = t2._assertCheck$1(onData);
        t1 = H.buildFunctionType(t1);
        t4 = t1._assertCheck$1(onDone);
        t5 = $.Zone__current;
        t6 = cancelOnError ? 1 : 0;
        t6 = H.setRuntimeTypeInfo(new P._ForwardingStreamSubscription(H.assertSubtype(_stream, "$is_ForwardingStream", [$S, $T], "$as_ForwardingStream"), H.assertSubtype(null, "$isStreamSubscription", [$S], "$asStreamSubscription"), t2._assertCheck$1(null), null, t1._assertCheck$1(null), t5, t6, null, null), [$S, $T]);
        t6._BufferingStreamSubscription$4(t3, onError, t4, cancelOnError, $T);
        t6._ForwardingStreamSubscription$5(_stream, t3, onError, t4, cancelOnError, $S, $T);
        return t6;
      }}
  },
  _WhereStream: {
    "^": "_ForwardingStream;_test,_source",
    _handleData$2: function(inputEvent, sink) {
      var satisfies, e, s, exception, t1;
      H.assertSubtypeOfRuntimeType(inputEvent, H.getTypeArgumentByIndex(this, 0));
      H.assertSubtype(sink, "$is_EventSink", [H.getTypeArgumentByIndex(this, 0)], "$as_EventSink");
      satisfies = null;
      try {
        satisfies = H.boolTypeCheck(this._test$1(inputEvent));
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        P._addErrorWithReplacement(sink, e, s);
        return;
      }
      if (H.boolConversionCheck(satisfies))
        sink._async$_add$1(inputEvent);
    },
    _test$1: function(arg0) {
      return this._test.call$1(arg0);
    },
    T7: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T5: function() {
      return H.convertRtiToRuntimeType(function($T) {
        return $T;
      }.apply(null, this.$builtinTypeInfo));
    },
    T0: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $as_ForwardingStream: function($T) {
      return [$T, $T];
    },
    $asStream: null
  },
  _MapStream: {
    "^": "_ForwardingStream;_transform,_source",
    _handleData$2: function(inputEvent, sink) {
      var outputEvent, e, s, exception, t1;
      H.assertSubtypeOfRuntimeType(inputEvent, H.getTypeArgumentByIndex(this, 0));
      H.assertSubtype(sink, "$is_EventSink", [H.getTypeArgumentByIndex(this, 1)], "$as_EventSink");
      outputEvent = null;
      try {
        outputEvent = H.assertSubtypeOfRuntimeType(this._transform$1(inputEvent), H.getTypeArgumentByIndex(this, 1));
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        P._addErrorWithReplacement(sink, e, s);
        return;
      }
      sink._async$_add$1(outputEvent);
    },
    _transform$1: function(arg0) {
      return this._transform.call$1(arg0);
    },
    T5: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[1]);
    },
    T0: function() {
      return H.convertRtiToRuntimeType(function($S, $T) {
        return $T;
      }.apply(null, this.$builtinTypeInfo));
    }
  },
  AsyncError: {
    "^": "Object;error<,stackTrace<",
    toString$0: function(_) {
      return H.S(this.error);
    },
    $isError: 1
  },
  _Zone: {
    "^": "Object;",
    $isZone: 1
  },
  _rootHandleUncaughtError_closure: {
    "^": "Closure:1;_captured_error_0,_captured_stackTrace_1",
    call$0: function() {
      var t1 = this._captured_error_0;
      throw H.wrapException(new P._UncaughtAsyncError(t1, P._UncaughtAsyncError__getBestStackTrace(t1, this._captured_stackTrace_1)));
    }
  },
  _RootZone: {
    "^": "_Zone;",
    get$errorZone: function() {
      return this;
    },
    runGuarded$1: function(f) {
      var e, s, t1, exception;
      H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(f);
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$0();
          return t1;
        }
        t1 = P._rootRun(null, null, this, f);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        return P._rootHandleUncaughtError(null, null, this, e, H.interceptedTypeCheck(s, "$isStackTrace"));
      }
    },
    runUnaryGuarded$2: function(f, arg) {
      var e, s, t1, exception;
      t1 = H.getDynamicRuntimeType();
      H.buildFunctionType(t1, [t1])._assertCheck$1(f);
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$1(arg);
          return t1;
        }
        t1 = P._rootRunUnary(null, null, this, f, arg);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        return P._rootHandleUncaughtError(null, null, this, e, H.interceptedTypeCheck(s, "$isStackTrace"));
      }
    },
    runBinaryGuarded$3: function(f, arg1, arg2) {
      var e, s, t1, exception;
      t1 = H.getDynamicRuntimeType();
      H.buildFunctionType(t1, [t1, t1])._assertCheck$1(f);
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$2(arg1, arg2);
          return t1;
        }
        t1 = P._rootRunBinary(null, null, this, f, arg1, arg2);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        return P._rootHandleUncaughtError(null, null, this, e, H.interceptedTypeCheck(s, "$isStackTrace"));
      }
    },
    bindCallback$2$runGuarded: function(f, runGuarded) {
      var t1, t2;
      t1 = H.buildFunctionType(H.getDynamicRuntimeType());
      t2 = t1._assertCheck$1(f);
      if (runGuarded)
        return t1._assertCheck$1(new P._RootZone_bindCallback_closure(this, t2));
      else
        return t1._assertCheck$1(new P._RootZone_bindCallback_closure0(this, t2));
    },
    $index: function(_, key) {
      return;
    },
    run$1: function(f) {
      var t1 = H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(f);
      if ($.Zone__current === C.C__RootZone)
        return t1.call$0();
      return P._rootRun(null, null, this, t1);
    },
    runUnary$2: function(f, arg) {
      var t1 = H.getDynamicRuntimeType();
      t1 = H.buildFunctionType(t1, [t1])._assertCheck$1(f);
      if ($.Zone__current === C.C__RootZone)
        return t1.call$1(arg);
      return P._rootRunUnary(null, null, this, t1, arg);
    },
    runBinary$3: function(f, arg1, arg2) {
      var t1 = H.getDynamicRuntimeType();
      t1 = H.buildFunctionType(t1, [t1, t1])._assertCheck$1(f);
      if ($.Zone__current === C.C__RootZone)
        return t1.call$2(arg1, arg2);
      return P._rootRunBinary(null, null, this, t1, arg1, arg2);
    }
  },
  _RootZone_bindCallback_closure: {
    "^": "Closure:1;_async$_captured_this_0,_captured_f_1",
    call$0: function() {
      return this._async$_captured_this_0.runGuarded$1(this._captured_f_1);
    }
  },
  _RootZone_bindCallback_closure0: {
    "^": "Closure:1;_async$_captured_this_2,_captured_f_3",
    call$0: function() {
      return this._async$_captured_this_2.run$1(this._captured_f_3);
    }
  }
}],
["dart.collection", "dart:collection", , P, {
  "^": "",
  LinkedHashMap_LinkedHashMap$_literal: function(keyValuePairs, $K, $V) {
    return H.assertSubtype(H.fillLiteralMap(H.listTypeCheck(keyValuePairs), H.setRuntimeTypeInfo(new H.JsLinkedHashMap(0, null, null, null, null, null, 0), [$K, $V])), "$isLinkedHashMap", [$K, $V], "$asLinkedHashMap");
  },
  LinkedHashMap_LinkedHashMap$_empty: function($K, $V) {
    return H.assertSubtype(H.setRuntimeTypeInfo(new H.JsLinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]), "$isLinkedHashMap", [$K, $V], "$asLinkedHashMap");
  },
  _defaultEquals: [function(a, b) {
    return J.$eq(a, b);
  }, "call$2", "_defaultEquals$closure", 4, 0, 64],
  _defaultHashCode: [function(a) {
    return J.get$hashCode$(a);
  }, "call$1", "_defaultHashCode$closure", 2, 0, 65],
  IterableBase_iterableToShortString: function(iterable, leftDelimiter, rightDelimiter) {
    var parts, t1, t2, t3;
    if (P.IterableBase__isToStringVisiting(iterable)) {
      if (leftDelimiter === "(" && rightDelimiter === ")")
        return "(...)";
      return leftDelimiter + "..." + rightDelimiter;
    }
    parts = [];
    t1 = $.get$IterableBase__toStringVisiting();
    C.JSArray_methods.add$1(t1, iterable);
    try {
      P.IterableBase__iterablePartsToStrings(iterable, parts);
    } finally {
      t2 = C.JSArray_methods.get$last(t1);
      t3 = iterable;
      H.assertHelper(t2 == null ? t3 == null : t2 === t3);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    t1 = new P.StringBuffer(leftDelimiter);
    t1.writeAll$2(parts, ", ");
    t1 = t1._contents += rightDelimiter;
    return t1.charCodeAt(0) == 0 ? t1 : t1;
  },
  IterableBase_iterableToFullString: function(iterable, leftDelimiter, rightDelimiter) {
    var buffer, t1, t2, t3;
    if (P.IterableBase__isToStringVisiting(iterable))
      return leftDelimiter + "..." + rightDelimiter;
    buffer = new P.StringBuffer(leftDelimiter);
    t1 = $.get$IterableBase__toStringVisiting();
    C.JSArray_methods.add$1(t1, iterable);
    try {
      buffer.writeAll$2(iterable, ", ");
    } finally {
      t2 = C.JSArray_methods.get$last(t1);
      t3 = iterable;
      H.assertHelper(t2 == null ? t3 == null : t2 === t3);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    t1 = buffer;
    t1._contents = t1.get$_contents() + rightDelimiter;
    t1 = buffer.get$_contents();
    return t1.charCodeAt(0) == 0 ? t1 : t1;
  },
  IterableBase__isToStringVisiting: function(o) {
    var i, t1;
    for (i = 0; t1 = $.get$IterableBase__toStringVisiting(), i < t1.length; ++i) {
      t1 = t1[i];
      if (o == null ? t1 == null : o === t1)
        return true;
    }
    return false;
  },
  IterableBase__iterablePartsToStrings: function(iterable, parts) {
    var it, $length, count, next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, elision;
    it = iterable.get$iterator(iterable);
    $length = 0;
    count = 0;
    while (true) {
      if (!($length < 80 || count < 3))
        break;
      if (!it.moveNext$0())
        return;
      next = H.S(it.get$current());
      C.JSArray_methods.add$1(parts, next);
      $length += next.length + 2;
      ++count;
    }
    if (!it.moveNext$0()) {
      if (count <= 5)
        return;
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      ultimateString = parts.pop();
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      penultimateString = parts.pop();
    } else {
      penultimate = it.get$current();
      ++count;
      if (!it.moveNext$0()) {
        if (count <= 4) {
          C.JSArray_methods.add$1(parts, H.S(penultimate));
          return;
        }
        ultimateString = H.S(penultimate);
        if (0 >= parts.length)
          return H.ioore(parts, 0);
        penultimateString = parts.pop();
        $length += ultimateString.length + 2;
      } else {
        ultimate = it.get$current();
        ++count;
        H.assertHelper(count < 100);
        for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
          ultimate0 = it.get$current();
          ++count;
          if (count > 100) {
            while (true) {
              if (!($length > 75 && count > 3))
                break;
              if (0 >= parts.length)
                return H.ioore(parts, 0);
              $length -= parts.pop().length + 2;
              --count;
            }
            C.JSArray_methods.add$1(parts, "...");
            return;
          }
        }
        penultimateString = H.S(penultimate);
        ultimateString = H.S(ultimate);
        $length += ultimateString.length + penultimateString.length + 4;
      }
    }
    if (count > parts.length + 2) {
      $length += 5;
      elision = "...";
    } else
      elision = null;
    while (true) {
      if (!($length > 80 && parts.length > 3))
        break;
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      $length -= parts.pop().length + 2;
      if (elision == null) {
        $length += 5;
        elision = "...";
      }
    }
    if (elision != null)
      C.JSArray_methods.add$1(parts, elision);
    C.JSArray_methods.add$1(parts, penultimateString);
    C.JSArray_methods.add$1(parts, ultimateString);
  },
  LinkedHashMap_LinkedHashMap: function(equals, hashCode, isValidKey, $K, $V) {
    var t1, t2;
    t1 = H.buildInterfaceType(P.bool);
    t2 = H.convertRtiToRuntimeType($K);
    H.buildFunctionType(t1, [t2, t2])._assertCheck$1(equals);
    H.buildFunctionType(H.buildInterfaceType(P.$int), [t2])._assertCheck$1(hashCode);
    H.buildFunctionType(t1, [H.getDynamicRuntimeType()])._assertCheck$1(isValidKey);
    return H.assertSubtype(H.setRuntimeTypeInfo(new H.JsLinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]), "$isLinkedHashMap", [$K, $V], "$asLinkedHashMap");
  },
  LinkedHashMap_LinkedHashMap$identity: function($K, $V) {
    return H.setRuntimeTypeInfo(new P._LinkedIdentityHashMap(0, null, null, null, null, null, 0), [$K, $V]);
  },
  LinkedHashMap_LinkedHashMap$from: function(other, $K, $V) {
    var result = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, $K, $V), "$isLinkedHashMap", [$K, $V], "$asLinkedHashMap");
    other.forEach$1(0, new P.LinkedHashMap_LinkedHashMap$from_closure(result));
    return H.assertSubtype(result, "$isLinkedHashMap", [$K, $V], "$asLinkedHashMap");
  },
  LinkedHashSet_LinkedHashSet: function(equals, hashCode, isValidKey, $E) {
    var t1, t2;
    t1 = H.buildInterfaceType(P.bool);
    t2 = H.convertRtiToRuntimeType($E);
    H.buildFunctionType(t1, [t2, t2])._assertCheck$1(equals);
    H.buildFunctionType(H.buildInterfaceType(P.$int), [t2])._assertCheck$1(hashCode);
    H.buildFunctionType(t1, [H.getDynamicRuntimeType()])._assertCheck$1(isValidKey);
    return H.assertSubtype(H.setRuntimeTypeInfo(new P._LinkedHashSet(0, null, null, null, null, null, 0), [$E]), "$isLinkedHashSet", [$E], "$asLinkedHashSet");
  },
  LinkedHashSet_LinkedHashSet$from: function(elements, $E) {
    var result, t1;
    H.listSuperNativeTypeCheck(elements, "$isIterable");
    result = H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, $E), "$isLinkedHashSet", [$E], "$asLinkedHashSet");
    for (t1 = J.get$iterator$a(elements); t1.moveNext$0();)
      result.add$1(0, H.assertSubtypeOfRuntimeType(t1.get$current(), $E));
    return H.assertSubtype(result, "$isLinkedHashSet", [$E], "$asLinkedHashSet");
  },
  ListMixin__filter: function(source, test, retainMatching) {
    var t1, retained, $length, i, element;
    t1 = H.buildFunctionType(H.buildInterfaceType(P.bool), [H.getDynamicRuntimeType()])._assertCheck$1(test);
    retained = [];
    $length = source.get$length(source);
    for (i = 0; i < $length; ++i) {
      element = source.$index(0, i);
      if (J.$eq(t1.call$1(element), retainMatching))
        C.JSArray_methods.add$1(retained, element);
      if ($length !== source.get$length(source))
        throw H.wrapException(P.ConcurrentModificationError$(source));
    }
    if (retained.length !== source.get$length(source)) {
      source.setRange$3(0, 0, retained.length, retained);
      source.set$length(0, retained.length);
    }
  },
  Maps_mapToString: function(m) {
    var t1, result, t2, t3;
    t1 = {};
    if (P.IterableBase__isToStringVisiting(m))
      return "{...}";
    result = new P.StringBuffer("");
    try {
      C.JSArray_methods.add$1($.get$IterableBase__toStringVisiting(), m);
      t2 = result;
      t2._contents = t2.get$_contents() + "{";
      t1._captured_first_0 = true;
      J.forEach$1$a(m, new P.Maps_mapToString_closure(t1, result));
      t1 = result;
      t1._contents = t1.get$_contents() + "}";
    } finally {
      t1 = $.get$IterableBase__toStringVisiting();
      t2 = C.JSArray_methods.get$last(t1);
      t3 = m;
      H.assertHelper(t2 == null ? t3 == null : t2 === t3);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    t1 = result.get$_contents();
    return t1.charCodeAt(0) == 0 ? t1 : t1;
  },
  _LinkedIdentityHashMap: {
    "^": "JsLinkedHashMap;__js_helper$_length,_strings,_nums,_rest,_first,_last,_modifications",
    internalComputeHashCode$1: function(key) {
      return H.objectHashCode(key) & 0x3ffffff;
    },
    internalFindBucketIndex$2: function(bucket, key) {
      var $length, i, t1;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i) {
        t1 = H.interceptedTypeCheck(bucket[i], "$isLinkedHashMapCell").hashMapCellKey;
        if (t1 == null ? key == null : t1 === key)
          return i;
      }
      return -1;
    },
    K: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    V: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[1]);
    }
  },
  _LinkedHashSet: {
    "^": "_HashSetBase;_collection$_length,_collection$_strings,_collection$_nums,_collection$_rest,_collection$_first,_collection$_last,_collection$_modifications",
    _newSet$0: function() {
      var t1 = new P._LinkedHashSet(0, null, null, null, null, null, 0);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return H.assertSubtype(t1, "$isSet", [H.getTypeArgumentByIndex(this, 0)], "$asSet");
    },
    get$iterator: function(_) {
      var t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(this, this._collection$_modifications, null, H.assertSubtypeOfRuntimeType(null, null)), [null]);
      t1._collection$_cell = t1._set._collection$_first;
      return H.assertSubtype(t1, "$isIterator", [H.getTypeArgumentByIndex(this, 0)], "$asIterator");
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    contains$1: function(_, object) {
      var strings, nums;
      if (typeof object === "string" && object !== "__proto__") {
        strings = this._collection$_strings;
        if (strings == null)
          return false;
        return H.interceptedTypeCheck(strings[object], "$isLinkedHashSetCell") != null;
      } else if (typeof object === "number" && (object & 0x3ffffff) === object) {
        nums = this._collection$_nums;
        if (nums == null)
          return false;
        return H.interceptedTypeCheck(nums[object], "$isLinkedHashSetCell") != null;
      } else
        return this._contains$1(object);
    },
    _contains$1: function(object) {
      var rest = this._collection$_rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(H.listTypeCheck(rest[this._computeHashCode$1(object)]), object) >= 0;
    },
    lookup$1: function(object) {
      var t1 = typeof object === "number" && (object & 0x3ffffff) === object;
      if (t1) {
        t1 = this.contains$1(0, object) ? object : null;
        return H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(this, 0));
      } else
        return H.assertSubtypeOfRuntimeType(this._lookup$1(object), H.getTypeArgumentByIndex(this, 0));
    },
    _lookup$1: function(object) {
      var rest, bucket, index;
      rest = this._collection$_rest;
      if (rest == null)
        return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 0));
      bucket = H.listTypeCheck(rest[this._computeHashCode$1(object)]);
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 0));
      return H.assertSubtypeOfRuntimeType(J.$index$as(bucket, index).get$_element(), H.getTypeArgumentByIndex(this, 0));
    },
    forEach$1: function(_, action) {
      var t1, cell, modifications;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [this.E4()])._assertCheck$1(action);
      cell = this._collection$_first;
      modifications = this._collection$_modifications;
      for (; cell != null;) {
        t1.call$1(cell._element);
        if (modifications !== this._collection$_modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        cell = cell._collection$_next;
      }
    },
    add$1: function(_, element) {
      var strings, table, nums;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
      if (typeof element === "string" && element !== "__proto__") {
        strings = this._collection$_strings;
        if (strings == null) {
          table = Object.create(null);
          H.assertHelper(table != null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._collection$_strings = table;
          strings = table;
        }
        return this._collection$_addHashTableEntry$2(strings, element);
      } else if (typeof element === "number" && (element & 0x3ffffff) === element) {
        nums = this._collection$_nums;
        if (nums == null) {
          table = Object.create(null);
          H.assertHelper(table != null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._collection$_nums = table;
          nums = table;
        }
        return this._collection$_addHashTableEntry$2(nums, element);
      } else
        return this._add$1(element);
    },
    _add$1: function(element) {
      var rest, hash, bucket, t1;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
      rest = this._collection$_rest;
      if (rest == null) {
        rest = P._LinkedHashSet__newHashTable();
        this._collection$_rest = rest;
      }
      hash = this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null) {
        t1 = [this._collection$_newLinkedCell$1(element)];
        H.assertHelper(t1 != null);
        rest[hash] = t1;
      } else {
        if (this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(this._collection$_newLinkedCell$1(element));
      }
      return true;
    },
    remove$1: function(_, object) {
      if (typeof object === "string" && object !== "__proto__")
        return this._removeHashTableEntry$2(this._collection$_strings, object);
      else if (typeof object === "number" && (object & 0x3ffffff) === object)
        return this._removeHashTableEntry$2(this._collection$_nums, object);
      else
        return this._remove$1(object);
    },
    _remove$1: function(object) {
      var rest, bucket, index;
      rest = this._collection$_rest;
      if (rest == null)
        return false;
      bucket = H.listTypeCheck(rest[this._computeHashCode$1(object)]);
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      this._unlinkCell$1(H.interceptedTypeCheck(bucket.splice(index, 1)[0], "$isLinkedHashSetCell"));
      return true;
    },
    clear$0: function(_) {
      if (this._collection$_length > 0) {
        this._collection$_last = null;
        this._collection$_first = null;
        this._collection$_rest = null;
        this._collection$_nums = null;
        this._collection$_strings = null;
        this._collection$_length = 0;
        this._collection$_modifications = this._collection$_modifications + 1 & 67108863;
      }
    },
    _collection$_addHashTableEntry$2: function(table, element) {
      var t1;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
      if (H.interceptedTypeCheck(table[element], "$isLinkedHashSetCell") != null)
        return false;
      t1 = this._collection$_newLinkedCell$1(element);
      H.assertHelper(true);
      table[element] = t1;
      return true;
    },
    _removeHashTableEntry$2: function(table, element) {
      var cell;
      if (table == null)
        return false;
      cell = H.interceptedTypeCheck(table[element], "$isLinkedHashSetCell");
      if (cell == null)
        return false;
      this._unlinkCell$1(cell);
      delete table[element];
      return true;
    },
    _collection$_newLinkedCell$1: function(element) {
      var cell, last;
      cell = new P.LinkedHashSetCell(H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0)), null, null);
      if (this._collection$_first == null) {
        this._collection$_last = cell;
        this._collection$_first = cell;
      } else {
        last = this._collection$_last;
        cell._collection$_previous = last;
        last._collection$_next = cell;
        this._collection$_last = cell;
      }
      ++this._collection$_length;
      this._collection$_modifications = this._collection$_modifications + 1 & 67108863;
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var previous, next, t1;
      previous = cell._collection$_previous;
      next = cell._collection$_next;
      if (previous == null) {
        t1 = this._collection$_first;
        H.assertHelper(cell == null ? t1 == null : cell === t1);
        this._collection$_first = next;
      } else
        previous._collection$_next = next;
      if (next == null) {
        t1 = this._collection$_last;
        H.assertHelper(cell == null ? t1 == null : cell === t1);
        this._collection$_last = previous;
      } else
        next._collection$_previous = previous;
      --this._collection$_length;
      this._collection$_modifications = this._collection$_modifications + 1 & 67108863;
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(H.interceptedTypeCheck(bucket[i], "$isLinkedHashSetCell")._element, element))
          return i;
      return -1;
    },
    E4: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    E3: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isLinkedHashSet: 1,
    $isSet: 1,
    $isEfficientLength: 1,
    $isIterable: 1,
    static: {_LinkedHashSet__newHashTable: function() {
        var table = Object.create(null);
        H.assertHelper(table != null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  LinkedHashSetCell: {
    "^": "Object;_element<,_collection$_next,_collection$_previous"
  },
  LinkedHashSetIterator: {
    "^": "Object;_set,_collection$_modifications,_collection$_cell,_collection$_current",
    set$_collection$_current: function(_current) {
      this._collection$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    get$current: function() {
      return H.assertSubtypeOfRuntimeType(this._collection$_current, H.getTypeArgumentByIndex(this, 0));
    },
    moveNext$0: function() {
      var t1 = this._set;
      if (this._collection$_modifications !== t1._collection$_modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = this._collection$_cell;
        if (t1 == null) {
          this.set$_collection$_current(null);
          return false;
        } else {
          this.set$_collection$_current(t1._element);
          this._collection$_cell = this._collection$_cell._collection$_next;
          return true;
        }
      }
    },
    $isIterator: 1
  },
  _HashSetBase: {
    "^": "SetBase;",
    difference$1: function(other) {
      var result, t1, element;
      H.assertSubtype(other, "$isSet", [P.Object], "$asSet");
      result = H.assertSubtype(this._newSet$0(), "$isSet", [H.getTypeArgumentByIndex(this, 0)], "$asSet");
      for (t1 = this.get$iterator(this); t1.moveNext$0();) {
        element = H.assertSubtypeOfRuntimeType(t1._collection$_current, H.getTypeArgumentByIndex(t1, 0));
        if (!other.contains$1(0, element))
          result.add$1(0, element);
      }
      return H.assertSubtype(result, "$isSet", [H.getTypeArgumentByIndex(this, 0)], "$asSet");
    },
    E3: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  IterableBase: {
    "^": "Object;",
    map$1: function(_, f) {
      return H.MappedIterable_MappedIterable(this, H.buildFunctionType(H.getDynamicRuntimeType(), [this.E()])._assertCheck$1(f), H.getRuntimeTypeArgument(this, "IterableBase", 0), null);
    },
    contains$1: function(_, element) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (J.$eq(H.assertSubtypeOfRuntimeType(t1.get$current(), H.getRuntimeTypeArgument(this, "IterableBase", 0)), element))
          return true;
      return false;
    },
    forEach$1: function(_, f) {
      var t1, t2;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [this.E()])._assertCheck$1(f);
      for (t2 = this.get$iterator(this); t2.moveNext$0();)
        t1.call$1(H.assertSubtypeOfRuntimeType(t2.get$current(), H.getRuntimeTypeArgument(this, "IterableBase", 0)));
    },
    fold$2: function(_, initialValue, combine) {
      var t1, t2, value;
      t1 = H.getDynamicRuntimeType();
      t1 = H.buildFunctionType(t1, [t1, this.E()])._assertCheck$1(combine);
      for (t2 = this.get$iterator(this), value = initialValue; t2.moveNext$0();)
        value = t1.call$2(value, H.assertSubtypeOfRuntimeType(t2.get$current(), H.getRuntimeTypeArgument(this, "IterableBase", 0)));
      return value;
    },
    any$1: function(_, f) {
      var t1, t2;
      t1 = H.buildFunctionType(H.buildInterfaceType(P.bool), [this.E()])._assertCheck$1(f);
      for (t2 = this.get$iterator(this); t2.moveNext$0();)
        if (H.boolConversionCheck(t1.call$1(H.assertSubtypeOfRuntimeType(t2.get$current(), H.getRuntimeTypeArgument(this, "IterableBase", 0)))))
          return true;
      return false;
    },
    toList$1$growable: function(_, growable) {
      return H.assertSubtype(P.List_List$from(this, growable, H.getRuntimeTypeArgument(this, "IterableBase", 0)), "$isList", [H.getRuntimeTypeArgument(this, "IterableBase", 0)], "$asList");
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    get$length: function(_) {
      var it, count;
      H.assertHelper(!this.$isEfficientLength);
      it = this.get$iterator(this);
      for (count = 0; it.moveNext$0();)
        ++count;
      return count;
    },
    get$isEmpty: function(_) {
      return !this.get$iterator(this).moveNext$0();
    },
    get$isNotEmpty: function(_) {
      return !this.get$isEmpty(this);
    },
    get$last: function(_) {
      var it, result;
      it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      do
        result = H.assertSubtypeOfRuntimeType(it.get$current(), H.getRuntimeTypeArgument(this, "IterableBase", 0));
      while (it.moveNext$0());
      return H.assertSubtypeOfRuntimeType(result, H.getRuntimeTypeArgument(this, "IterableBase", 0));
    },
    get$single: function(_) {
      var it, result;
      it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      result = H.assertSubtypeOfRuntimeType(it.get$current(), H.getRuntimeTypeArgument(this, "IterableBase", 0));
      if (it.moveNext$0())
        throw H.wrapException(H.IterableElementError_tooMany());
      return H.assertSubtypeOfRuntimeType(result, H.getRuntimeTypeArgument(this, "IterableBase", 0));
    },
    elementAt$1: function(_, index) {
      var t1, elementIndex, element;
      if (index < 0)
        H.throwExpression(P.RangeError$range(index, 0, null, "index", null));
      for (t1 = this.get$iterator(this), elementIndex = 0; t1.moveNext$0();) {
        element = H.assertSubtypeOfRuntimeType(t1.get$current(), H.getRuntimeTypeArgument(this, "IterableBase", 0));
        if (index === elementIndex)
          return H.assertSubtypeOfRuntimeType(element, H.getRuntimeTypeArgument(this, "IterableBase", 0));
        ++elementIndex;
      }
      throw H.wrapException(P.IndexError$(index, this, "index", null, elementIndex));
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToShortString(this, "(", ")");
    },
    E: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isIterable: 1
  },
  LinkedHashMap: {
    "^": "Object;",
    $isMap: 1
  },
  LinkedHashMap_LinkedHashMap$from_closure: {
    "^": "Closure:6;_captured_result_0",
    call$2: function(k, v) {
      this._captured_result_0.$indexSet(0, k, v);
    }
  },
  LinkedHashSet: {
    "^": "Object;",
    $isSet: 1,
    $isEfficientLength: 1,
    $isIterable: 1
  },
  ListBase: {
    "^": "Object_ListMixin;"
  },
  Object_ListMixin: {
    "^": "Object+ListMixin;",
    $isList: 1,
    $isEfficientLength: 1,
    $isIterable: 1
  },
  ListMixin: {
    "^": "Object;",
    get$iterator: function(_) {
      var t1, t2;
      t1 = H.getRuntimeTypeArgument(this, "ListMixin", 0);
      H.listSuperNativeTypeCheck(this, "$isIterable");
      t2 = this.get$length(this);
      return H.assertSubtype(H.setRuntimeTypeInfo(new H.ListIterator(H.listSuperNativeTypeCheck(this, "$isIterable"), t2, 0, H.assertSubtypeOfRuntimeType(null, t1)), [t1]), "$isIterator", [H.getRuntimeTypeArgument(this, "ListMixin", 0)], "$asIterator");
    },
    elementAt$1: function(_, index) {
      return H.assertSubtypeOfRuntimeType(this.$index(0, index), H.getRuntimeTypeArgument(this, "ListMixin", 0));
    },
    forEach$1: function(_, action) {
      var t1, $length, i;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [this.E1()])._assertCheck$1(action);
      $length = this.get$length(this);
      for (i = 0; i < $length; ++i) {
        t1.call$1(this.$index(0, i));
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    get$isNotEmpty: function(_) {
      return !this.get$isEmpty(this);
    },
    get$last: function(_) {
      if (this.get$length(this) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      return H.assertSubtypeOfRuntimeType(this.$index(0, this.get$length(this) - 1), H.getRuntimeTypeArgument(this, "ListMixin", 0));
    },
    contains$1: function(_, element) {
      var $length, i;
      $length = this.get$length(this);
      for (i = 0; i < this.get$length(this); ++i) {
        if (J.$eq(this.$index(0, i), element))
          return true;
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return false;
    },
    any$1: function(_, test) {
      var t1, $length, i;
      t1 = H.buildFunctionType(H.buildInterfaceType(P.bool), [this.E1()])._assertCheck$1(test);
      $length = this.get$length(this);
      for (i = 0; i < $length; ++i) {
        if (H.boolConversionCheck(t1.call$1(this.$index(0, i))))
          return true;
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return false;
    },
    firstWhere$2$orElse: function(_, test, orElse) {
      var t1, t2, $length, i, element;
      t1 = this.E1();
      t2 = H.buildFunctionType(H.buildInterfaceType(P.bool), [t1])._assertCheck$1(test);
      t1 = H.buildFunctionType(t1)._assertCheck$1(orElse);
      $length = this.get$length(this);
      for (i = 0; i < $length; ++i) {
        element = H.assertSubtypeOfRuntimeType(this.$index(0, i), H.getRuntimeTypeArgument(this, "ListMixin", 0));
        if (H.boolConversionCheck(t2.call$1(element)))
          return H.assertSubtypeOfRuntimeType(element, H.getRuntimeTypeArgument(this, "ListMixin", 0));
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return H.assertSubtypeOfRuntimeType(t1.call$0(), H.getRuntimeTypeArgument(this, "ListMixin", 0));
    },
    where$1: function(_, test) {
      var t1, t2, t3;
      t1 = H.buildInterfaceType(P.bool);
      t2 = H.buildFunctionType(t1, [this.E1()])._assertCheck$1(test);
      t3 = H.getRuntimeTypeArgument(this, "ListMixin", 0);
      H.listSuperNativeTypeCheck(this, "$isIterable");
      H.buildFunctionType(t1, [H.convertRtiToRuntimeType(t3)])._assertCheck$1(t2);
      return H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(this, "$isIterable"), H.buildFunctionType(t1, [H.getDynamicRuntimeType()])._assertCheck$1(t2)), [t3]), "$isIterable");
    },
    map$1: function(_, f) {
      var t1, t2;
      t1 = H.buildFunctionType(H.getDynamicRuntimeType(), [this.E1()])._assertCheck$1(f);
      H.listSuperNativeTypeCheck(this, "$isIterable");
      t2 = H.buildFunctionType(H.convertRtiToRuntimeType(null), [H.convertRtiToRuntimeType(null)]);
      t2._assertCheck$1(t1);
      return H.setRuntimeTypeInfo(new H.MappedListIterable(H.listSuperNativeTypeCheck(this, "$isIterable"), t2._assertCheck$1(t1)), [null, null]);
    },
    add$1: function(_, element) {
      var t1;
      H.assertSubtypeOfRuntimeType(element, H.getRuntimeTypeArgument(this, "ListMixin", 0));
      t1 = this.get$length(this);
      this.set$length(0, t1 + 1);
      this.$indexSet(0, t1, element);
    },
    remove$1: function(_, element) {
      var i;
      for (i = 0; i < this.get$length(this); ++i)
        if (J.$eq(this.$index(0, i), element)) {
          this.setRange$4(0, i, this.get$length(this) - 1, this, i + 1);
          this.set$length(0, this.get$length(this) - 1);
          return true;
        }
      return false;
    },
    removeWhere$1: function(_, test) {
      P.ListMixin__filter(this, H.buildFunctionType(H.buildInterfaceType(P.bool), [this.E1()])._assertCheck$1(test), false);
    },
    clear$0: function(_) {
      this.set$length(0, 0);
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      var $length, t1, i;
      H.listSuperNativeTypeCheck(iterable, "$isIterable");
      P.RangeError_checkValidRange(start, end, this.get$length(this), null, null, null);
      $length = end - start;
      if ($length === 0)
        return;
      t1 = J.getInterceptor$as(iterable);
      if (skipCount + $length > t1.get$length(iterable))
        throw H.wrapException(H.IterableElementError_tooFew());
      if (skipCount < start)
        for (i = $length - 1; i >= 0; --i)
          this.$indexSet(0, start + i, t1.$index(iterable, skipCount + i));
      else
        for (i = 0; i < $length; ++i)
          this.$indexSet(0, start + i, t1.$index(iterable, skipCount + i));
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    insert$2: function(_, index, element) {
      H.assertSubtypeOfRuntimeType(element, H.getRuntimeTypeArgument(this, "ListMixin", 0));
      P.RangeError_checkValueInInterval(index, 0, this.get$length(this), "index", null);
      if (index === this.get$length(this)) {
        this.add$1(0, element);
        return;
      }
      this.set$length(0, this.get$length(this) + 1);
      this.setRange$4(0, index + 1, this.get$length(this), this, index);
      this.$indexSet(0, index, element);
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "[", "]");
    },
    E1: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isList: 1,
    $isEfficientLength: 1,
    $isIterable: 1
  },
  Maps_mapToString_closure: {
    "^": "Closure:6;_collection$_box_0,_captured_result_1",
    call$2: function(k, v) {
      var t1, t2;
      t1 = this._collection$_box_0;
      if (!t1._captured_first_0)
        this._captured_result_1._contents += ", ";
      t1._captured_first_0 = false;
      t1 = this._captured_result_1;
      t2 = t1._contents += H.S(k);
      t1._contents = t2 + ": ";
      t1._contents += H.S(v);
    }
  },
  ListQueue: {
    "^": "IterableBase;_table,_head,_tail,_modificationCount",
    set$_table: function(_table) {
      this._table = H.assertSubtype(_table, "$isList", [H.getTypeArgumentByIndex(this, 0)], "$asList");
    },
    get$iterator: function(_) {
      var t1 = new P._ListQueueIterator(this, this._tail, this._modificationCount, this._head, H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 0)));
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return H.assertSubtype(t1, "$isIterator", [H.getTypeArgumentByIndex(this, 0)], "$asIterator");
    },
    forEach$1: function(_, action) {
      var t1, modificationCount, i, t2;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [this.E0()])._assertCheck$1(action);
      modificationCount = this._modificationCount;
      for (i = this._head; i !== this._tail; i = (i + 1 & this._table.length - 1) >>> 0) {
        t2 = this._table;
        if (i < 0 || i >= t2.length)
          return H.ioore(t2, i);
        t1.call$1(t2[i]);
        if (modificationCount !== this._modificationCount)
          H.throwExpression(P.ConcurrentModificationError$(this));
      }
    },
    get$isEmpty: function(_) {
      return this._head === this._tail;
    },
    get$length: function(_) {
      return (this._tail - this._head & this._table.length - 1) >>> 0;
    },
    clear$0: function(_) {
      var i, t1, t2, t3, t4;
      i = this._head;
      t1 = this._tail;
      if (i !== t1) {
        for (t2 = this._table, t3 = t2.length, t4 = t3 - 1; i !== t1; i = (i + 1 & t4) >>> 0) {
          if (i < 0 || i >= t3)
            return H.ioore(t2, i);
          t2[i] = null;
        }
        this._tail = 0;
        this._head = 0;
        ++this._modificationCount;
      }
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    removeFirst$0: function() {
      var t1, t2, t3, result;
      t1 = this._head;
      if (t1 === this._tail)
        throw H.wrapException(H.IterableElementError_noElement());
      ++this._modificationCount;
      t2 = this._table;
      t3 = t2.length;
      if (t1 >= t3)
        return H.ioore(t2, t1);
      result = H.assertSubtypeOfRuntimeType(t2[t1], H.getTypeArgumentByIndex(this, 0));
      t2[t1] = null;
      this._head = (t1 + 1 & t3 - 1) >>> 0;
      return H.assertSubtypeOfRuntimeType(result, H.getTypeArgumentByIndex(this, 0));
    },
    _add$1: function(element) {
      var t1, t2, t3;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
      t1 = this._table;
      t2 = this._tail;
      t3 = t1.length;
      if (t2 < 0 || t2 >= t3)
        return H.ioore(t1, t2);
      t1[t2] = element;
      t3 = (t2 + 1 & t3 - 1) >>> 0;
      this._tail = t3;
      if (this._head === t3)
        this._grow$0();
      ++this._modificationCount;
    },
    _grow$0: function() {
      var t1, newTable, t2, split;
      t1 = Array(this._table.length * 2);
      t1.fixed$length = Array;
      newTable = H.assertSubtype(H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]), "$isList", [H.getTypeArgumentByIndex(this, 0)], "$asList");
      t1 = this._table;
      t2 = this._head;
      split = t1.length - t2;
      C.JSArray_methods.setRange$4(newTable, 0, split, t1, t2);
      C.JSArray_methods.setRange$4(newTable, split, split + this._head, this._table, 0);
      this._head = 0;
      this._tail = this._table.length;
      this.set$_table(newTable);
    },
    ListQueue$1: function(initialCapacity, $E) {
      var t1;
      H.assertHelper(true);
      t1 = Array(8);
      t1.fixed$length = Array;
      this.set$_table(H.setRuntimeTypeInfo(t1, [$E]));
    },
    E0: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    E: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isQueue: 1,
    $isEfficientLength: 1,
    $isIterable: 1,
    static: {ListQueue$: function(initialCapacity, $E) {
        var t1 = H.setRuntimeTypeInfo(new P.ListQueue(H.assertSubtype(null, "$isList", [$E], "$asList"), 0, 0, 0), [$E]);
        t1.ListQueue$1(initialCapacity, $E);
        return t1;
      }}
  },
  _ListQueueIterator: {
    "^": "Object;_queue,_end,_modificationCount,_position,_collection$_current",
    set$_collection$_current: function(_current) {
      this._collection$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    get$current: function() {
      return H.assertSubtypeOfRuntimeType(this._collection$_current, H.getTypeArgumentByIndex(this, 0));
    },
    moveNext$0: function() {
      var t1, t2, t3;
      t1 = this._queue;
      if (this._modificationCount !== t1._modificationCount)
        H.throwExpression(P.ConcurrentModificationError$(t1));
      t2 = this._position;
      if (t2 === this._end) {
        this.set$_collection$_current(null);
        return false;
      }
      t3 = t1._table;
      if (t2 >= t3.length)
        return H.ioore(t3, t2);
      this.set$_collection$_current(t3[t2]);
      this._position = (this._position + 1 & t1._table.length - 1) >>> 0;
      return true;
    },
    $isIterator: 1
  },
  SetMixin: {
    "^": "Object;",
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    addAll$1: function(_, elements) {
      var t1;
      for (t1 = J.get$iterator$a(H.listSuperNativeTypeCheck(elements, "$isIterable")); t1.moveNext$0();)
        this.add$1(0, H.assertSubtypeOfRuntimeType(t1.get$current(), H.getTypeArgumentByIndex(this, 0)));
    },
    toList$1$growable: function(_, growable) {
      var result, t1, i, element, i0;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(this, 0)]);
        C.JSArray_methods.set$length(result, this.get$length(this));
      } else {
        t1 = Array(this.get$length(this));
        t1.fixed$length = Array;
        result = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      }
      H.assertSubtype(result, "$isList", [H.getTypeArgumentByIndex(this, 0)], "$asList");
      for (t1 = this.get$iterator(this), i = 0; t1.moveNext$0(); i = i0) {
        element = H.assertSubtypeOfRuntimeType(H.assertSubtypeOfRuntimeType(t1._collection$_current, H.getTypeArgumentByIndex(t1, 0)), H.getTypeArgumentByIndex(this, 0));
        i0 = i + 1;
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = element;
      }
      return H.assertSubtype(result, "$isList", [H.getTypeArgumentByIndex(this, 0)], "$asList");
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    forEach$1: function(_, f) {
      var t1, t2;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [this.E3()])._assertCheck$1(f);
      for (t2 = this.get$iterator(this); t2.moveNext$0();)
        t1.call$1(H.assertSubtypeOfRuntimeType(H.assertSubtypeOfRuntimeType(t2._collection$_current, H.getTypeArgumentByIndex(t2, 0)), H.getTypeArgumentByIndex(this, 0)));
    },
    singleWhere$1: function(_, test) {
      var t1, t2, result, foundMatching, element;
      t1 = H.buildFunctionType(H.buildInterfaceType(P.bool), [this.E3()])._assertCheck$1(test);
      H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 0));
      for (t2 = this.get$iterator(this), result = null, foundMatching = false; t2.moveNext$0();) {
        element = H.assertSubtypeOfRuntimeType(H.assertSubtypeOfRuntimeType(t2._collection$_current, H.getTypeArgumentByIndex(t2, 0)), H.getTypeArgumentByIndex(this, 0));
        if (H.boolConversionCheck(t1.call$1(element))) {
          if (foundMatching)
            throw H.wrapException(H.IterableElementError_tooMany());
          H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
          result = element;
          foundMatching = true;
        }
      }
      if (foundMatching)
        return H.assertSubtypeOfRuntimeType(result, H.getTypeArgumentByIndex(this, 0));
      throw H.wrapException(H.IterableElementError_noElement());
    },
    E3: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isSet: 1,
    $isEfficientLength: 1,
    $isIterable: 1
  },
  SetBase: {
    "^": "SetMixin;",
    E3: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  }
}],
["dart.convert", "dart:convert", , P, {
  "^": "",
  _convertJsonToDartLazy: function(object) {
    var i;
    if (object == null)
      return;
    if (typeof object != "object")
      return object;
    if (Object.getPrototypeOf(object) !== Array.prototype)
      return new P._JsonMap(object, Object.create(null), null);
    for (i = 0; i < object.length; ++i)
      object[i] = P._convertJsonToDartLazy(object[i]);
    return object;
  },
  _parseJson: function(source, reviver) {
    var parsed, e, t1, exception;
    t1 = H.getDynamicRuntimeType();
    H.buildFunctionType(t1, [t1, t1])._assertCheck$1(reviver);
    t1 = source;
    if (typeof t1 !== "string")
      throw H.wrapException(P.ArgumentError$(source));
    parsed = null;
    try {
      parsed = JSON.parse(source);
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      throw H.wrapException(P.FormatException$(String(e), null, null));
    }
    return P._convertJsonToDartLazy(parsed);
  },
  _defaultToEncodable: [function(object) {
    return object.toJson$0();
  }, "call$1", "_defaultToEncodable$closure", 2, 0, 66],
  _JsonMap: {
    "^": "Object;_original,_processed,_data",
    $index: function(_, key) {
      var t1, result;
      t1 = this._processed;
      if (t1 == null) {
        H.assertHelper(true);
        return this._data.$index(0, key);
      } else if (typeof key !== "string")
        return;
      else {
        result = t1[key];
        return typeof result == "undefined" ? this._process$1(key) : result;
      }
    },
    get$length: function(_) {
      var t1;
      if (this._processed == null) {
        H.assertHelper(true);
        t1 = this._data;
        t1 = t1.get$length(t1);
      } else
        t1 = this._computeKeys$0().length;
      return t1;
    },
    $indexSet: function(_, key, value) {
      var processed, original;
      if (this._processed == null) {
        H.assertHelper(true);
        this._data.$indexSet(0, key, value);
      } else if (this.containsKey$1(key)) {
        processed = this._processed;
        H.stringTypeCheck(key);
        processed[key] = value;
        original = this._original;
        if (original == null ? processed != null : original !== processed)
          original[key] = null;
      } else
        this._upgrade$0().$indexSet(0, key, value);
    },
    addAll$1: function(_, other) {
      H.interceptedTypeCheck(other, "$isMap").forEach$1(0, new P._JsonMap_addAll_closure(this));
    },
    containsKey$1: function(key) {
      if (this._processed == null) {
        H.assertHelper(true);
        return this._data.containsKey$1(key);
      }
      if (typeof key !== "string")
        return false;
      return Object.prototype.hasOwnProperty.call(this._original, key);
    },
    forEach$1: function(_, f) {
      var t1, keys, i, key, value;
      t1 = H.getDynamicRuntimeType();
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [t1, t1])._assertCheck$1(f);
      if (this._processed == null) {
        H.assertHelper(true);
        return H.voidTypeCheck(this._data.forEach$1(0, t1));
      }
      keys = H.assertSubtype(this._computeKeys$0(), "$isList", [P.String], "$asList");
      for (i = 0; i < keys.length; ++i) {
        key = H.stringTypeCheck(keys[i]);
        value = this._processed[key];
        if (typeof value == "undefined") {
          value = P._convertJsonToDartLazy(this._original[key]);
          this._processed[key] = value;
        }
        t1.call$2(key, value);
        if (keys !== this._data)
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    _computeKeys$0: function() {
      H.assertHelper(this._processed != null);
      var keys = H.listTypeCheck(this._data);
      if (keys == null) {
        keys = Object.keys(this._original);
        this._data = keys;
      }
      return H.assertSubtype(keys, "$isList", [P.String], "$asList");
    },
    _upgrade$0: function() {
      var result, keys, i, t1, key;
      if (this._processed == null) {
        H.assertHelper(true);
        return this._data;
      }
      result = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      keys = H.assertSubtype(this._computeKeys$0(), "$isList", [P.String], "$asList");
      for (i = 0; t1 = keys.length, i < t1; ++i) {
        key = H.stringTypeCheck(keys[i]);
        result.$indexSet(0, key, this.$index(0, key));
      }
      if (t1 === 0)
        C.JSArray_methods.add$1(keys, null);
      else
        C.JSArray_methods.set$length(keys, 0);
      this._processed = null;
      this._original = null;
      this._data = result;
      H.assertHelper(true);
      return result;
    },
    _process$1: function(key) {
      var result;
      if (!Object.prototype.hasOwnProperty.call(this._original, key))
        return;
      result = P._convertJsonToDartLazy(this._original[key]);
      return this._processed[key] = result;
    },
    $isLinkedHashMap: 1,
    $asLinkedHashMap: $.functionThatReturnsNull,
    $isMap: 1,
    $asMap: $.functionThatReturnsNull
  },
  _JsonMap_addAll_closure: {
    "^": "Closure:6;_convert$_captured_this_0",
    call$2: function(key, value) {
      this._convert$_captured_this_0.$indexSet(0, key, value);
    }
  },
  Codec: {
    "^": "Object;"
  },
  Converter: {
    "^": "Object;"
  },
  JsonUnsupportedObjectError: {
    "^": "Error;unsupportedObject,cause",
    toString$0: function(_) {
      if (this.cause != null)
        return "Converting object to an encodable object failed.";
      else
        return "Converting object did not return an encodable object.";
    },
    static: {JsonUnsupportedObjectError$: function(unsupportedObject, cause) {
        return new P.JsonUnsupportedObjectError(unsupportedObject, cause);
      }}
  },
  JsonCyclicError: {
    "^": "JsonUnsupportedObjectError;unsupportedObject,cause",
    toString$0: function(_) {
      return "Cyclic error in JSON stringify";
    }
  },
  JsonCodec: {
    "^": "Codec;_reviver,_toEncodable",
    decode$2$reviver: function(source, reviver) {
      var t1 = H.getDynamicRuntimeType();
      t1 = H.buildFunctionType(t1, [t1, t1]);
      t1._assertCheck$1(reviver);
      t1._assertCheck$1(this._reviver);
      return P._parseJson(source, this.get$decoder()._reviver);
    },
    decode$1: function(source) {
      return this.decode$2$reviver(source, null);
    },
    encode$2$toEncodable: function(value, toEncodable) {
      var t1 = H.getDynamicRuntimeType();
      t1 = H.buildFunctionType(t1, [t1]);
      t1._assertCheck$1(toEncodable);
      t1._assertCheck$1(this._toEncodable);
      t1 = this.get$encoder();
      return P._JsonStringStringifier_stringify(value, t1._toEncodable, t1.indent);
    },
    encode$1: function(value) {
      return this.encode$2$toEncodable(value, null);
    },
    get$encoder: function() {
      return C.JsonEncoder_null_null;
    },
    get$decoder: function() {
      return C.JsonDecoder_null;
    },
    $asCodec: function() {
      return [P.Object, P.String];
    }
  },
  JsonEncoder: {
    "^": "Converter;indent,_toEncodable",
    $asConverter: function() {
      return [P.Object, P.String];
    }
  },
  JsonDecoder: {
    "^": "Converter;_reviver",
    $asConverter: function() {
      return [P.String, P.Object];
    }
  },
  _JsonStringifier: {
    "^": "Object;",
    writeStringContent$1: function(s) {
      var $length, t1, offset, i, charCode, t2;
      $length = s.length;
      for (t1 = J.getInterceptor$s(s), offset = 0, i = 0; i < $length; ++i) {
        charCode = t1.codeUnitAt$1(s, i);
        if (charCode > 92)
          continue;
        if (charCode < 32) {
          if (i > offset)
            this.writeStringSlice$3(s, offset, i);
          offset = i + 1;
          this.writeCharCode$1(92);
          switch (charCode) {
            case 8:
              this.writeCharCode$1(98);
              break;
            case 9:
              this.writeCharCode$1(116);
              break;
            case 10:
              this.writeCharCode$1(110);
              break;
            case 12:
              this.writeCharCode$1(102);
              break;
            case 13:
              this.writeCharCode$1(114);
              break;
            default:
              this.writeCharCode$1(117);
              this.writeCharCode$1(48);
              this.writeCharCode$1(48);
              t2 = charCode >>> 4 & 15;
              this.writeCharCode$1(t2 < 10 ? 48 + t2 : 87 + t2);
              t2 = charCode & 15;
              this.writeCharCode$1(t2 < 10 ? 48 + t2 : 87 + t2);
              break;
          }
        } else if (charCode === 34 || charCode === 92) {
          if (i > offset)
            this.writeStringSlice$3(s, offset, i);
          offset = i + 1;
          this.writeCharCode$1(92);
          this.writeCharCode$1(charCode);
        }
      }
      if (offset === 0)
        this.writeString$1(s);
      else if (offset < $length)
        this.writeStringSlice$3(s, offset, $length);
    },
    _checkCycle$1: function(object) {
      var t1, t2, i, t3;
      for (t1 = this._seen, t2 = t1.length, i = 0; i < t2; ++i) {
        t3 = t1[i];
        if (object == null ? t3 == null : object === t3)
          throw H.wrapException(new P.JsonCyclicError(object, null));
      }
      C.JSArray_methods.add$1(t1, object);
    },
    _removeSeen$1: function(object) {
      var t1, t2;
      t1 = this._seen;
      H.assertHelper(t1.length !== 0);
      t2 = C.JSArray_methods.get$last(t1);
      H.assertHelper(t2 == null ? object == null : t2 === object);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    },
    writeObject$1: function(object) {
      var customJson, e, t1, t2, t3, exception;
      if (this.writeJsonValue$1(object))
        return;
      this._checkCycle$1(object);
      try {
        customJson = this._toEncodable$1(object);
        if (!this.writeJsonValue$1(customJson)) {
          t1 = P.JsonUnsupportedObjectError$(object, null);
          throw H.wrapException(t1);
        }
        t1 = object;
        t2 = this._seen;
        H.assertHelper(t2.length !== 0);
        t3 = C.JSArray_methods.get$last(t2);
        H.assertHelper(t3 == null ? t1 == null : t3 === t1);
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2.pop();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        throw H.wrapException(P.JsonUnsupportedObjectError$(object, e));
      }
    },
    writeJsonValue$1: function(object) {
      var t1;
      if (typeof object === "number") {
        if (!C.JSNumber_methods.get$isFinite(object))
          return false;
        this.writeNumber$1(object);
        return true;
      } else if (object === true) {
        this.writeString$1("true");
        return true;
      } else if (object === false) {
        this.writeString$1("false");
        return true;
      } else if (object == null) {
        this.writeString$1("null");
        return true;
      } else if (typeof object === "string") {
        this.writeString$1("\"");
        this.writeStringContent$1(object);
        this.writeString$1("\"");
        return true;
      } else {
        t1 = J.getInterceptor(object);
        if (!!t1.$isList) {
          this._checkCycle$1(object);
          this.writeList$1(object);
          this._removeSeen$1(object);
          return true;
        } else if (!!t1.$isMap) {
          this._checkCycle$1(object);
          this.writeMap$1(object);
          this._removeSeen$1(object);
          return true;
        } else
          return false;
      }
    },
    writeList$1: function(list) {
      var t1, i;
      this.writeString$1("[");
      t1 = J.getInterceptor$as(list);
      if (t1.get$length(list) > 0) {
        this.writeObject$1(t1.$index(list, 0));
        for (i = 1; i < t1.get$length(list); ++i) {
          this.writeString$1(",");
          this.writeObject$1(t1.$index(list, i));
        }
      }
      this.writeString$1("]");
    },
    writeMap$1: function(map) {
      var t1 = {};
      H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
      this.writeString$1("{");
      t1._captured_separator_0 = "\"";
      map.forEach$1(0, new P._JsonStringifier_writeMap_closure(t1, this));
      this.writeString$1("}");
    },
    _toEncodable$1: function(arg0) {
      return this._toEncodable.call$1(arg0);
    }
  },
  _JsonStringifier_writeMap_closure: {
    "^": "Closure:18;_convert$_box_0,_convert$_captured_this_1",
    call$2: function(key, value) {
      var t1, t2;
      H.stringTypeCheck(key);
      t1 = this._convert$_captured_this_1;
      t2 = this._convert$_box_0;
      t1.writeString$1(t2._captured_separator_0);
      t2._captured_separator_0 = ",\"";
      t1.writeStringContent$1(key);
      t1.writeString$1("\":");
      t1.writeObject$1(value);
    }
  },
  _JsonStringStringifier: {
    "^": "_JsonStringifier;_sink,_seen,_toEncodable",
    writeNumber$1: function(number) {
      this._sink._contents += C.JSNumber_methods.toString$0(number);
    },
    writeString$1: function(string) {
      this._sink._contents += string;
    },
    writeStringSlice$3: function(string, start, end) {
      this._sink._contents += C.JSString_methods.substring$2(string, start, end);
    },
    writeCharCode$1: function(charCode) {
      this._sink._contents += H.Primitives_stringFromCharCode(charCode);
    },
    static: {_JsonStringStringifier_stringify: function(object, toEncodable, indent) {
        var t1, output, stringifier;
        t1 = H.getDynamicRuntimeType();
        t1 = H.buildFunctionType(t1, [t1]);
        output = new P.StringBuffer("");
        t1._assertCheck$1(t1._assertCheck$1(toEncodable));
        stringifier = new P._JsonStringStringifier(output, [], H.interceptedTypeCheck(P._defaultToEncodable$closure(), "$isFunction"));
        stringifier.writeObject$1(object);
        t1 = output._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }}
  }
}],
["dart.core", "dart:core", , P, {
  "^": "",
  _symbolToString: function(symbol) {
    return H.Symbol_getName(symbol);
  },
  Comparable_compare: [function(a, b) {
    return J.compareTo$1$ns(H.numberOrStringSuperNativeTypeCheck(a, "$isComparable"), H.numberOrStringSuperNativeTypeCheck(b, "$isComparable"));
  }, "call$2", "Comparable_compare$closure", 4, 0, 67],
  Error_safeToString: function(object) {
    if (typeof object === "number" || typeof object === "boolean" || null == object)
      return J.toString$0(object);
    if (typeof object === "string")
      return JSON.stringify(object);
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Exception_Exception: function(message) {
    return new P._ExceptionImplementation(message);
  },
  identical: [function(a, b) {
    return a == null ? b == null : a === b;
  }, "call$2", "identical$closure", 4, 0, 68],
  identityHashCode: [function(object) {
    return H.objectHashCode(object);
  }, "call$1", "identityHashCode$closure", 2, 0, 69],
  List_List$from: function(elements, growable, $E) {
    var list, t1;
    list = H.assertSubtype(H.setRuntimeTypeInfo([], [$E]), "$isList", [$E], "$asList");
    for (t1 = J.get$iterator$a(elements); t1.moveNext$0();)
      C.JSArray_methods.add$1(list, H.assertSubtypeOfRuntimeType(t1.get$current(), $E));
    if (growable)
      return H.assertSubtype(list, "$isList", [$E], "$asList");
    list.fixed$length = Array;
    return H.assertSubtype(list, "$isList", [$E], "$asList");
  },
  print: function(object) {
    var line = H.S(object);
    H.printString(line);
  },
  RegExp_RegExp: function(source, caseSensitive, multiLine) {
    return new H.JSSyntaxRegExp(source, H.JSSyntaxRegExp_makeNative(source, multiLine, caseSensitive, false), null, null);
  },
  NoSuchMethodError_toString_closure: {
    "^": "Closure:19;_core$_box_0",
    call$2: function(key, value) {
      var t1 = this._core$_box_0;
      if (t1._captured_i_1 > 0)
        t1._captured_sb_0._contents += ", ";
      P._symbolToString(key);
    }
  },
  bool: {
    "^": "Object;"
  },
  "+bool": 0,
  Comparable: {
    "^": "Object;"
  },
  DateTime: {
    "^": "Object;",
    $isComparable: 1,
    $asComparable: $.functionThatReturnsNull
  },
  $double: {
    "^": "num;"
  },
  "+double": 0,
  Duration: {
    "^": "Object;_duration",
    $add: function(_, other) {
      return new P.Duration(H.intTypeCheck(C.JSInt_methods.$add(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration)));
    },
    $sub: function(_, other) {
      return new P.Duration(H.intTypeCheck(C.JSInt_methods.$sub(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration)));
    },
    $lt: function(_, other) {
      return C.JSInt_methods.$lt(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration);
    },
    $gt: function(_, other) {
      return C.JSInt_methods.$gt(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration);
    },
    $le: function(_, other) {
      return C.JSInt_methods.$le(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration);
    },
    $ge: function(_, other) {
      return C.JSInt_methods.$ge(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof P.Duration))
        return false;
      return this._duration === other._duration;
    },
    get$hashCode: function(_) {
      return this._duration & 0x1FFFFFFF;
    },
    compareTo$1: function(_, other) {
      return C.JSInt_methods.compareTo$1(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration);
    },
    toString$0: function(_) {
      var t1, t2, twoDigitMinutes, twoDigitSeconds, sixDigitUs;
      t1 = new P.Duration_toString_twoDigits();
      t2 = this._duration;
      if (t2 < 0)
        return "-" + new P.Duration(-t2).toString$0(0);
      twoDigitMinutes = H.stringTypeCheck(t1.call$1(C.JSInt_methods.remainder$1(C.JSInt_methods._tdivFast$1(t2, 60000000), 60)));
      twoDigitSeconds = H.stringTypeCheck(t1.call$1(C.JSInt_methods.remainder$1(C.JSInt_methods._tdivFast$1(t2, 1000000), 60)));
      sixDigitUs = H.stringTypeCheck(new P.Duration_toString_sixDigits().call$1(C.JSInt_methods.remainder$1(t2, 1000000)));
      return "" + C.JSInt_methods._tdivFast$1(t2, 3600000000) + ":" + H.S(twoDigitMinutes) + ":" + H.S(twoDigitSeconds) + "." + H.S(sixDigitUs);
    },
    $isComparable: 1,
    $asComparable: function() {
      return [P.Duration];
    }
  },
  Duration_toString_sixDigits: {
    "^": "Closure:20;",
    call$1: function(n) {
      if (n >= 100000)
        return "" + n;
      if (n >= 10000)
        return "0" + n;
      if (n >= 1000)
        return "00" + n;
      if (n >= 100)
        return "000" + n;
      if (n >= 10)
        return "0000" + n;
      return "00000" + n;
    }
  },
  Duration_toString_twoDigits: {
    "^": "Closure:20;",
    call$1: function(n) {
      if (n >= 10)
        return "" + n;
      return "0" + n;
    }
  },
  Error: {
    "^": "Object;",
    get$stackTrace: function() {
      return H.getTraceFromException(this.$thrownJsError);
    }
  },
  AssertionError: {
    "^": "Error;"
  },
  NullThrownError: {
    "^": "Error;",
    toString$0: function(_) {
      return "Throw of null.";
    }
  },
  ArgumentError: {
    "^": "Error;_hasValue,invalidValue,name<,message",
    get$_errorName: function() {
      return "Invalid argument" + (!this._hasValue ? "(s)" : "");
    },
    get$_errorExplanation: function() {
      return "";
    },
    toString$0: function(_) {
      var t1, nameString, message, prefix, explanation, errorValue;
      t1 = this.name;
      nameString = t1 != null ? " (" + H.S(t1) + ")" : "";
      t1 = this.message;
      message = t1 == null ? "" : ": " + H.S(t1);
      prefix = this.get$_errorName() + nameString + message;
      if (!this._hasValue)
        return prefix;
      explanation = this.get$_errorExplanation();
      errorValue = P.Error_safeToString(this.invalidValue);
      return prefix + explanation + ": " + H.S(errorValue);
    },
    static: {ArgumentError$: function(message) {
        return new P.ArgumentError(false, null, null, message);
      }}
  },
  RangeError: {
    "^": "ArgumentError;start,end,_hasValue,invalidValue,name,message",
    get$_errorName: function() {
      return "RangeError";
    },
    get$_errorExplanation: function() {
      var t1, explanation, t2;
      H.assertHelper(this._hasValue);
      t1 = this.start;
      if (t1 == null) {
        t1 = this.end;
        explanation = t1 != null ? ": Not less than or equal to " + H.S(t1) : "";
      } else {
        t2 = this.end;
        if (t2 == null)
          explanation = ": Not greater than or equal to " + H.S(t1);
        else {
          if (typeof t2 !== "number")
            return t2.$gt();
          if (C.JSInt_methods.$gt(t2, t1))
            explanation = ": Not in range " + H.S(t1) + ".." + t2 + ", inclusive";
          else
            explanation = C.JSInt_methods.$lt(t2, t1) ? ": Valid value range is empty" : ": Only valid value is " + H.S(t1);
        }
      }
      return explanation;
    },
    static: {RangeError$: function(message) {
        return new P.RangeError(null, null, false, null, null, message);
      }, RangeError$value: function(value, $name, message) {
        H.numTypeCheck(value);
        return new P.RangeError(null, null, true, value, $name, "Value not in range");
      }, RangeError$range: function(invalidValue, minValue, maxValue, $name, message) {
        return new P.RangeError(minValue, maxValue, true, invalidValue, $name, "Invalid value");
      }, RangeError_checkValueInInterval: function(value, minValue, maxValue, $name, message) {
        if (value < minValue || value > maxValue)
          throw H.wrapException(P.RangeError$range(value, minValue, maxValue, $name, message));
      }, RangeError_checkValidRange: function(start, end, $length, startName, endName, message) {
        if (0 > start || start > $length)
          throw H.wrapException(P.RangeError$range(start, 0, $length, "start", message));
        if (start > end || end > $length)
          throw H.wrapException(P.RangeError$range(end, start, $length, "end", message));
        return end;
      }}
  },
  IndexError: {
    "^": "ArgumentError;indexable,length>,_hasValue,invalidValue,name,message",
    get$_errorName: function() {
      return "RangeError";
    },
    get$_errorExplanation: function() {
      var explanation, t1;
      H.assertHelper(this._hasValue);
      P.Error_safeToString(this.indexable);
      explanation = ": index should be less than " + this.length;
      t1 = this.invalidValue;
      if (typeof t1 !== "number")
        return t1.$lt();
      return t1 < 0 ? ": index must not be negative" : explanation;
    },
    $isRangeError: 1,
    static: {IndexError$: function(invalidValue, indexable, $name, message, $length) {
        var t1 = $length != null ? $length : indexable.get$length(indexable);
        return new P.IndexError(indexable, H.intTypeCheck(t1), true, invalidValue, $name, "Index out of range");
      }}
  },
  UnsupportedError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Unsupported operation: " + this.message;
    },
    static: {UnsupportedError$: function(message) {
        return new P.UnsupportedError(message);
      }}
  },
  UnimplementedError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "UnimplementedError";
    },
    static: {UnimplementedError$: function(message) {
        return new P.UnimplementedError(message);
      }}
  },
  StateError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Bad state: " + this.message;
    },
    static: {StateError$: function(message) {
        return new P.StateError(message);
      }}
  },
  ConcurrentModificationError: {
    "^": "Error;modifiedObject",
    toString$0: function(_) {
      return "Concurrent modification during iteration: " + H.S(P.Error_safeToString(this.modifiedObject)) + ".";
    },
    static: {ConcurrentModificationError$: function(modifiedObject) {
        return new P.ConcurrentModificationError(modifiedObject);
      }}
  },
  OutOfMemoryError: {
    "^": "Object;",
    toString$0: function(_) {
      return "Out of Memory";
    },
    get$stackTrace: function() {
      return;
    },
    $isError: 1
  },
  StackOverflowError: {
    "^": "Object;",
    toString$0: function(_) {
      return "Stack Overflow";
    },
    get$stackTrace: function() {
      return;
    },
    $isError: 1
  },
  CyclicInitializationError: {
    "^": "Error;variableName",
    toString$0: function(_) {
      return "Reading static variable '" + this.variableName + "' during its initialization";
    }
  },
  _ExceptionImplementation: {
    "^": "Object;message",
    toString$0: function(_) {
      var t1 = this.message;
      if (t1 == null)
        return "Exception";
      return "Exception: " + H.S(t1);
    },
    $isException: 1
  },
  FormatException: {
    "^": "Object;message,source,offset",
    toString$0: function(_) {
      var t1, report, source;
      t1 = this.message;
      report = t1 != null && "" !== t1 ? "FormatException: " + H.S(t1) : "FormatException";
      source = this.source;
      if (typeof source !== "string")
        return report;
      if (source.length > 78)
        source = J.substring$2$s(source, 0, 75) + "...";
      return report + "\n" + H.S(source);
    },
    $isException: 1,
    static: {FormatException$: function(message, source, offset) {
        return new P.FormatException(message, source, offset);
      }}
  },
  Expando: {
    "^": "Object;name<",
    toString$0: function(_) {
      return "Expando:" + H.S(this.name);
    },
    $index: function(_, object) {
      var values, t1;
      values = H.Primitives_getProperty(object, "expando$values");
      t1 = values == null ? null : H.Primitives_getProperty(values, this._getKey$0());
      return H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(this, 0));
    },
    _getKey$0: function() {
      var key, t1;
      key = H.stringTypeCheck(H.Primitives_getProperty(this, "expando$key"));
      if (key == null) {
        t1 = $.Expando__keyCount;
        $.Expando__keyCount = t1 + 1;
        key = "expando$key$" + t1;
        H.Primitives_setProperty(this, "expando$key", key);
      }
      return key;
    }
  },
  Function: {
    "^": "Object;"
  },
  $int: {
    "^": "num;",
    $isComparable: 1,
    $asComparable: function() {
      return [P.num];
    }
  },
  "+int": 0,
  Iterable: {
    "^": "Object;"
  },
  Iterator: {
    "^": "Object;"
  },
  List: {
    "^": "Object;",
    $isIterable: 1,
    $isEfficientLength: 1
  },
  "+List": 0,
  Map: {
    "^": "Object;"
  },
  Null: {
    "^": "Object;",
    toString$0: function(_) {
      return "null";
    }
  },
  "+Null": 0,
  num: {
    "^": "Object;",
    $isComparable: 1,
    $asComparable: function() {
      return [P.num];
    }
  },
  "+num": 0,
  Object: {
    "^": ";",
    $eq: function(_, other) {
      return this === other;
    },
    get$hashCode: function(_) {
      return H.Primitives_objectHashCode(this);
    },
    toString$0: function(_) {
      return H.Primitives_objectToString(this);
    }
  },
  Match: {
    "^": "Object;"
  },
  StackTrace: {
    "^": "Object;"
  },
  String: {
    "^": "Object;",
    $isComparable: 1,
    $asComparable: function() {
      return [P.String];
    },
    $isPattern: 1
  },
  "+String": 0,
  StringBuffer: {
    "^": "Object;_contents<",
    get$length: function(_) {
      return this._contents.length;
    },
    writeAll$2: function(objects, separator) {
      var iterator = J.get$iterator$a(objects);
      if (!iterator.moveNext$0())
        return;
      if (separator.length === 0) {
        do
          this._contents += H.S(iterator.get$current());
        while (iterator.moveNext$0());
      } else {
        this._contents += H.S(iterator.get$current());
        for (; iterator.moveNext$0();) {
          this._contents += separator;
          this._contents += H.S(iterator.get$current());
        }
      }
    },
    toString$0: function(_) {
      var t1 = this._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $isStringSink: 1,
    static: {StringBuffer$: function($content) {
        return new P.StringBuffer($content);
      }}
  },
  Symbol: {
    "^": "Object;"
  }
}],
["dart.isolate", "dart:isolate", , P, {
  "^": "",
  Capability: {
    "^": "Object;"
  },
  SendPort: {
    "^": "Object;",
    $isCapability: 1
  }
}],
["dart.math", "dart:math", , P, {
  "^": "",
  Random_Random: function(seed) {
    return C.C__JSRandom;
  },
  _JSRandom: {
    "^": "Object;",
    nextInt$1: function(max) {
      if (max <= 0 || max > 4294967296)
        throw H.wrapException(P.RangeError$("max must be in range 0 < max \u2264 2^32, was " + max));
      return Math.random() * max >>> 0;
    },
    nextDouble$0: function() {
      return Math.random();
    },
    $isRandom: 1
  }
}],
["dart2js._js_primitives", "dart:_js_primitives", , H, {
  "^": "",
  printString: function(string) {
    if (typeof dartPrint == "function") {
      dartPrint(string);
      return;
    }
    if (typeof console == "object" && typeof console.log != "undefined") {
      console.log(string);
      return;
    }
    if (typeof window == "object")
      return;
    if (typeof print == "function") {
      print(string);
      return;
    }
    throw "Unable to print message: " + String(string);
  }
}],
["dom", "package:html5lib/dom.dart", , B, {
  "^": "",
  Node0: {
    "^": "Object;parent,_elements",
    set$parent: function($parent) {
      this.parent = H.interceptedTypeCheck($parent, "$isNode0");
    },
    set$_elements: function(_elements) {
      this._elements = H.assertSubtype(_elements, "$isList", [B.Element], "$asList");
    },
    get$children: function() {
      if (this._elements == null)
        this.set$_elements(new B.FilteredElementList(this, H.assertSubtype(this.nodes, "$isList", [B.Node0], "$asList")));
      return H.assertSubtype(this._elements, "$isList", [B.Element], "$asList");
    },
    remove$0: function(_) {
      var t1 = this.parent;
      if (t1 != null)
        t1.nodes.remove$1(0, this);
      return this;
    }
  },
  Element: {
    "^": "Node0;namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    toString$0: function(_) {
      return "<" + H.S(this._tagName) + ">";
    },
    get$id: function() {
      var result = this.attributes.$index(0, "id");
      return H.stringTypeCheck(result != null ? result : "");
    },
    set$id: function(value) {
      this.attributes.$indexSet(0, "id", value);
    }
  },
  NodeList: {
    "^": "ListProxy;_parent,_list",
    add$1: function(_, value) {
      H.interceptedTypeCheck(value, "$isNode0");
      value.remove$0(0);
      value.parent = this._parent;
      this.super$ListProxy$add$1(this, value);
    },
    insert$2: function(_, index, value) {
      H.interceptedTypeCheck(value, "$isNode0");
      value.remove$0(0);
      value.parent = this._parent;
      this.super$ListProxy$insert$2(this, index, value);
    },
    removeAt$1: function(_, i) {
      var t1 = this.super$ListProxy$removeAt$1(this, i);
      t1.set$parent(null);
      return t1;
    },
    $indexSet: function(_, index, value) {
      var t1;
      H.interceptedTypeCheck(value, "$isNode0");
      t1 = this._list;
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      H.assertSubtypeOfRuntimeType(t1[index], H.getRuntimeTypeArgument(this, "ListProxy", 0)).set$parent(null);
      t1 = value.parent;
      if (t1 != null)
        t1.nodes.remove$1(0, value);
      value.parent = this._parent;
      this.super$ListProxy$$indexSet(this, index, value);
    },
    E: function() {
      return H.convertRtiToRuntimeType(function() {
        return B.Node0;
      }.apply(null, this.$builtinTypeInfo));
    },
    $asListProxy: function() {
      return [B.Node0];
    },
    $asIterableBase: function() {
      return [B.Node0];
    },
    $asList: function() {
      return [B.Node0];
    },
    $asIterable: function() {
      return [B.Node0];
    }
  },
  FilteredElementList: {
    "^": "IterableBase_ListMixin;_node,_childNodes",
    get$_filtered: function() {
      var t1, t2, t3, t4;
      t1 = this._childNodes;
      t2 = new B.FilteredElementList__filtered_closure();
      t3 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t3, [t1.E()])._assertCheck$1(t2);
      t4 = H.getRuntimeTypeArgument(t1, "IterableBase", 0);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
      return H.assertSubtype(P.List_List$from(H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), H.buildFunctionType(t3, [H.getDynamicRuntimeType()])._assertCheck$1(t2)), [t4]), "$isIterable"), true, B.Element), "$isList", [B.Element], "$asList");
    },
    forEach$1: function(_, f) {
      var t1 = H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(B.Element)])._assertCheck$1(f);
      C.JSArray_methods.forEach$1(this.get$_filtered(), t1);
    },
    $indexSet: function(_, index, value) {
      var t1, t2;
      H.interceptedTypeCheck(value, "$isElement");
      t1 = this.get$_filtered();
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      t1 = H.interceptedTypeCheck(t1[index], "$isElement");
      t2 = t1.parent;
      if (t2 == null)
        H.throwExpression(P.UnsupportedError$("Node must have a parent to replace it."));
      t2 = t2.nodes;
      H.assertSubtypeOfRuntimeType(t1, H.getRuntimeTypeArgument(t2, "ListProxy", 0));
      t2.$indexSet(0, C.JSArray_methods.indexOf$2(t2._list, t1, 0), value);
    },
    set$length: function(_, newLength) {
      var len = this.get$_filtered().length;
      if (newLength >= len)
        return;
      else if (newLength < 0)
        throw H.wrapException(P.ArgumentError$("Invalid list length"));
      this.removeRange$2(0, newLength, len);
    },
    add$1: function(_, value) {
      var t1, t2;
      H.interceptedTypeCheck(value, "$isElement");
      t1 = this._childNodes;
      t2 = value.parent;
      if (t2 != null)
        t2.nodes.remove$1(0, value);
      value.parent = t1._parent;
      t1.super$ListProxy$add$1(t1, value);
    },
    addAll$1: function(_, iterable) {
      var t1, t2, element, t3;
      H.listSuperNativeTypeCheck(iterable, "$isIterable");
      for (t1 = H.getTypeArgumentByIndex(iterable, 0), H.assertSubtype(iterable, "$isJSArray", [t1], "$asJSArray"), t2 = iterable.length, t1 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(iterable, "$isJSArray", [t1], "$asJSArray"), t2, 0, H.assertSubtypeOfRuntimeType(null, t1)), [t1]), "$isIterator", [H.getTypeArgumentByIndex(iterable, 0)], "$asIterator"), t2 = this._childNodes; t1.moveNext$0();) {
        element = H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0)), "$isElement");
        t3 = element.parent;
        if (t3 != null)
          t3.nodes.remove$1(0, element);
        element.parent = t2._parent;
        t2.super$ListProxy$add$1(t2, element);
      }
    },
    contains$1: function(_, element) {
      H.interceptedTypeCheck(element, "$isElement");
      return false;
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      H.listSuperNativeTypeCheck(iterable, "$isIterable");
      throw H.wrapException(P.UnimplementedError$(null));
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    removeRange$2: function(_, start, end) {
      C.JSArray_methods.forEach$1(C.JSArray_methods.sublist$2(this.get$_filtered(), start, end), new B.FilteredElementList_removeRange_closure());
    },
    map$1: function(_, f) {
      var t1, t2, t3;
      t1 = H.getDynamicRuntimeType();
      t2 = H.buildFunctionType(t1, [H.buildInterfaceType(B.Element)])._assertCheck$1(f);
      t3 = this.get$_filtered();
      H.buildFunctionType(t1, [H.convertRtiToRuntimeType(t3.$builtinTypeInfo && t3.$builtinTypeInfo[0])])._assertCheck$1(t2);
      H.listSuperNativeTypeCheck(t3, "$isIterable");
      t1 = H.buildFunctionType(H.convertRtiToRuntimeType(null), [H.convertRtiToRuntimeType(null)]);
      t1._assertCheck$1(t2);
      return H.setRuntimeTypeInfo(new H.MappedListIterable(H.listSuperNativeTypeCheck(t3, "$isIterable"), t1._assertCheck$1(t2)), [null, null]);
    },
    insert$2: function(_, index, value) {
      this._childNodes.insert$2(0, index, H.interceptedTypeCheck(value, "$isElement"));
    },
    remove$1: function(_, element) {
      return false;
    },
    elementAt$1: function(_, index) {
      var t1 = this.get$_filtered();
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      return H.interceptedTypeCheck(t1[index], "$isElement");
    },
    get$isEmpty: function(_) {
      return this.get$_filtered().length === 0;
    },
    get$length: function(_) {
      return this.get$_filtered().length;
    },
    $index: function(_, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = this.get$_filtered();
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      return H.interceptedTypeCheck(t1[index], "$isElement");
    },
    get$iterator: function(_) {
      var t1, t2, t3;
      t1 = this.get$_filtered();
      t2 = H.getTypeArgumentByIndex(t1, 0);
      H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray");
      t3 = t1.length;
      return H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"), "$isIterator", [B.Element], "$asIterator");
    },
    get$last: function(_) {
      return H.interceptedTypeCheck(C.JSArray_methods.get$last(this.get$_filtered()), "$isElement");
    },
    E: function() {
      return H.convertRtiToRuntimeType(function() {
        return B.Element;
      }.apply(null, this.$builtinTypeInfo));
    },
    $isList: 1,
    $asList: function() {
      return [B.Element];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [B.Element];
    }
  },
  IterableBase_ListMixin: {
    "^": "IterableBase+ListMixin;",
    E: function() {
      return H.convertRtiToRuntimeType(function() {
        return B.Element;
      }.apply(null, this.$builtinTypeInfo));
    },
    $asIterableBase: function() {
      return [B.Element];
    },
    $asListMixin: function() {
      return [B.Element];
    },
    $asIterable: function() {
      return [B.Element];
    },
    $asList: function() {
      return [B.Element];
    },
    $isList: 1,
    $isEfficientLength: 1,
    $isIterable: 1
  },
  FilteredElementList__filtered_closure: {
    "^": "Closure:2;",
    call$1: function(n) {
      return n instanceof B.Element;
    }
  },
  FilteredElementList_removeRange_closure: {
    "^": "Closure:2;",
    call$1: function(el) {
      return J.remove$0$a(el);
    }
  }
}],
["egb_form", "package:egamebook/src/shared/form.dart", , G, {
  "^": "",
  FormElement: {
    "^": "Element;namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    set$hidden: function(value) {
      var t1 = H.boolTypeCheck(value) ? "true" : "false";
      this.attributes.$indexSet(0, "hidden", t1);
      return t1;
    },
    toMap$0: ["super$FormElement$toMap$0", function() {
      var t1 = this.attributes;
      return H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_literal(["hidden", J.$eq(t1.$index(0, "hidden"), "true"), "disabled", J.$eq(t1.$index(0, "disabled"), "true")], null, null), "$isMap", [P.String, P.Object], "$asMap");
    }],
    updateFromMap$1: ["super$FormElement$updateFromMap$1", function(map) {
      var t1;
      H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
      t1 = this.attributes;
      t1.$indexSet(0, "hidden", H.boolConversionCheck(H.boolTypeCheck(map.$index(0, "hidden"))) ? "true" : "false");
      t1.$indexSet(0, "disabled", H.boolConversionCheck(H.boolTypeCheck(map.$index(0, "disabled"))) ? "true" : "false");
    }],
    _addFormChildrenToSet$2: function(element, set) {
      var t1, t2, t3, child;
      H.assertSubtype(set, "$isSet", [G.FormElement], "$asSet");
      t1 = element.get$formElementChildren();
      t2 = H.getTypeArgumentByIndex(t1, 0);
      H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray");
      t3 = t1.length;
      t3 = new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2));
      H.assertHelper(true);
      t3.$builtinTypeInfo = [t2];
      H.assertSubtype(t3, "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator");
      for (; t3.moveNext$0();) {
        child = H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t3._current, H.getTypeArgumentByIndex(t3, 0)), "$isFormElement");
        set.add$1(0, child);
        this._addFormChildrenToSet$2(child, set);
      }
    },
    get$formElementChildren: function() {
      var result, t1, t2, t3, t4, t5, t6;
      result = H.assertSubtype(H.setRuntimeTypeInfo([], [G.FormElement]), "$isList", [G.FormElement], "$asList");
      for (t1 = this.get$children(), t2 = new G.FormElement_formElementChildren_closure(), t1.toString, t3 = H.buildInterfaceType(P.bool), H.buildFunctionType(t3, [H.buildInterfaceType(B.Element)])._assertCheck$1(t2), t1 = t1.get$_filtered(), H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t1.$builtinTypeInfo && t1.$builtinTypeInfo[0])])._assertCheck$1(t2), t4 = H.getTypeArgumentByIndex(t1, 0), H.listSuperNativeTypeCheck(t1, "$isIterable"), H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2), t5 = H.buildFunctionType(t3, [H.getDynamicRuntimeType()]), t1 = H.listSuperNativeTypeCheck(H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), t5._assertCheck$1(t2)), [t4]), "$isIterable"), "$isIterable"), t4 = J.get$iterator$a(t1.__internal$_iterable), t2 = t1._f, t6 = H.getTypeArgumentByIndex(t1, 0), H.assertSubtype(t4, "$isIterator", [t6], "$asIterator"), H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t6)])._assertCheck$1(t2), t1 = H.assertSubtype(H.setRuntimeTypeInfo(new H.WhereIterator(H.assertSubtype(t4, "$isIterator", [t6], "$asIterator"), t5._assertCheck$1(t2)), [t6]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"), t6 = t1._iterator; t1.moveNext$0();)
        C.JSArray_methods.add$1(result, H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t6.get$current(), H.getTypeArgumentByIndex(t1, 0)), "$isFormElement"));
      return H.listSuperNativeTypeCheck(result, "$isIterable");
    },
    get$allFormElementsBelowThisOne: function() {
      var set = H.assertSubtype(H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, G.FormElement), "$isSet", [G.FormElement], "$asSet"), "$isSet", [G.FormElement], "$asSet");
      this._addFormChildrenToSet$2(this, set);
      return H.assertSubtype(set, "$isSet", [G.FormElement], "$asSet");
    },
    $isUpdatableByMap: 1
  },
  FormElement_formElementChildren_closure: {
    "^": "Closure:21;",
    call$1: function(child) {
      return H.interceptedTypeCheck(child, "$isElement") instanceof G.FormElement;
    }
  },
  FormBase: {
    "^": "FormElement;"
  },
  Form: {
    "^": "FormBase;onSubmit,onInput<,_uniqueIdsGiven,namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    receiveUserInput$1: function(newValues) {
      var parentsOfUpdatedElements, t1, t2, t3, t4, t5, t6, element, result, newCurrent, $parent, callback;
      parentsOfUpdatedElements = H.assertSubtype(H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, G._NewValueCallback), "$isSet", [G._NewValueCallback], "$asSet"), "$isSet", [G._NewValueCallback], "$asSet");
      for (t1 = this.get$allFormElementsBelowThisOne(), t2 = new G.Form_receiveUserInput_closure(), t3 = H.buildInterfaceType(P.bool), H.buildFunctionType(t3, [t1.E3()])._assertCheck$1(t2), t4 = H.getTypeArgumentByIndex(t1, 0), H.listSuperNativeTypeCheck(t1, "$isIterable"), H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2), t5 = H.buildFunctionType(t3, [H.getDynamicRuntimeType()]), t1 = H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), t5._assertCheck$1(t2)), [t4]), "$isIterable"), t4 = J.get$iterator$a(t1.__internal$_iterable), t2 = t1._f, t6 = H.getTypeArgumentByIndex(t1, 0), H.assertSubtype(t4, "$isIterator", [t6], "$asIterator"), H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t6)])._assertCheck$1(t2), t1 = H.assertSubtype(H.setRuntimeTypeInfo(new H.WhereIterator(H.assertSubtype(t4, "$isIterator", [t6], "$asIterator"), t5._assertCheck$1(t2)), [t6]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"), t6 = t1._iterator; t1.moveNext$0();) {
        element = H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t6.get$current(), H.getTypeArgumentByIndex(t1, 0)), "$isFormElement");
        result = element.attributes.$index(0, "id");
        t2 = H.stringTypeCheck(result != null ? result : "");
        newCurrent = newValues._valuesMap.$index(0, t2);
        if (newCurrent != null && !J.$eq(newCurrent, H.interceptedTypeCast(element, "$isInput").get$current())) {
          H.interceptedTypeCast(element, "$isInput");
          element.set$current(newCurrent);
          if (element.get$onInput() != null)
            element.onInput$1(newCurrent);
          $parent = element;
          do {
            $parent = H.interceptedTypeCheck($parent.parent, "$isFormElement");
            if (!!J.getInterceptor($parent).$is_NewValueCallback && $parent.get$onInput() != null)
              parentsOfUpdatedElements.add$1(0, H.interceptedTypeCast($parent, "$is_NewValueCallback"));
          } while ($parent.parent != null);
        }
      }
      parentsOfUpdatedElements.forEach$1(0, new G.Form_receiveUserInput_closure0());
      t1 = this.get$allFormElementsBelowThisOne();
      t2 = new G.Form_receiveUserInput_closure1();
      H.buildFunctionType(t3, [t1.E3()])._assertCheck$1(t2);
      t4 = H.getTypeArgumentByIndex(t1, 0);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
      H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), t5._assertCheck$1(t2)), [t4]), "$isIterable").forEach$1(0, new G.Form_receiveUserInput_closure2());
      t1 = newValues._valuesMap;
      if (H.boolTypeCheck(t1.$index(0, "__submitted__"))) {
        H.assertHelper(H.stringTypeCheck(t1.$index(0, "__submitterId__")) != null);
        t1 = H.stringTypeCheck(t1.$index(0, "__submitterId__"));
        t2 = this.get$id();
        t3 = H.getVoidRuntimeType();
        callback = (t1 == null ? t2 == null : t1 === t2) ? H.buildFunctionType(t3)._assertCheck$1(this.onSubmit) : H.buildFunctionType(t3)._assertCheck$1(H.interceptedTypeCast(this.get$allFormElementsBelowThisOne().singleWhere$1(0, new G.Form_receiveUserInput_closure3(newValues)), "$isSubmitButton").onSubmit);
        if (callback != null)
          callback.call$0();
        return;
      } else
        return this._createConfiguration$0();
    },
    _giveChildrenUniqueIds$0: function() {
      var t1 = {};
      t1._captured_id_0 = 0;
      this.get$allFormElementsBelowThisOne().forEach$1(0, new G.Form__giveChildrenUniqueIds_closure(t1, this));
      this._uniqueIdsGiven = true;
    },
    toMap$0: function() {
      if (!this._uniqueIdsGiven)
        this._giveChildrenUniqueIds$0();
      var map = H.assertSubtype(this.super$FormElement$toMap$0(), "$isMap", [P.String, P.Object], "$asMap");
      map.$indexSet(0, "jsonml", R.encodeToJsonML(this));
      map.$indexSet(0, "values", H.assertSubtype(P.LinkedHashMap_LinkedHashMap$from(this._createConfiguration$0()._valuesMap, null, null), "$isMap", [P.String, [P.Map, P.String, P.Object]], "$asMap"));
      return H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
    },
    _createConfiguration$0: function() {
      var t1, t2, t3, t4, t5, t6, t7, element, map, elementCurrent, result;
      t1 = H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [P.Map, P.String, P.Object]), "$isMap", [P.String, [P.Map, P.String, P.Object]], "$asMap"), "$isMap", [P.String, [P.Map, P.String, P.Object]], "$asMap");
      for (t2 = this.get$allFormElementsBelowThisOne(), t3 = new G.Form__createConfiguration_closure(), t4 = H.buildInterfaceType(P.bool), H.buildFunctionType(t4, [t2.E3()])._assertCheck$1(t3), t5 = H.getTypeArgumentByIndex(t2, 0), H.listSuperNativeTypeCheck(t2, "$isIterable"), H.buildFunctionType(t4, [H.convertRtiToRuntimeType(t5)])._assertCheck$1(t3), t6 = H.buildFunctionType(t4, [H.getDynamicRuntimeType()]), t2 = H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t2, "$isIterable"), t6._assertCheck$1(t3)), [t5]), "$isIterable"), t5 = J.get$iterator$a(t2.__internal$_iterable), t3 = t2._f, t7 = H.getTypeArgumentByIndex(t2, 0), H.assertSubtype(t5, "$isIterator", [t7], "$asIterator"), H.buildFunctionType(t4, [H.convertRtiToRuntimeType(t7)])._assertCheck$1(t3), t2 = H.assertSubtype(H.setRuntimeTypeInfo(new H.WhereIterator(H.assertSubtype(t5, "$isIterator", [t7], "$asIterator"), t6._assertCheck$1(t3)), [t7]), "$isIterator", [H.getTypeArgumentByIndex(t2, 0)], "$asIterator"), t7 = t2._iterator; t2.moveNext$0();) {
        element = H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t7.get$current(), H.getTypeArgumentByIndex(t2, 0)), "$isUpdatableByMap");
        map = H.assertSubtype(element.toMap$0(), "$isMap", [P.String, P.Object], "$asMap");
        if (!!element.$isStringRepresentationCreator) {
          elementCurrent = element.current;
          map.$indexSet(0, "__string__", element.stringifyFunction$1(elementCurrent));
        }
        result = element.attributes.$index(0, "id");
        t3 = H.stringTypeCheck(result != null ? result : "");
        H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
        t1.$indexSet(0, t3, map);
      }
      return new G.FormConfiguration(t1);
    },
    Form$1$submitText: function(submitText) {
      this.attributes.$indexSet(0, "submitText", submitText);
      this.set$id("" + $.get$Form__random().nextInt$1(65536));
    },
    onInput$1: function(arg0) {
      return this.onInput.call$1(arg0);
    },
    $is_NewValueCallback: 1,
    $as_NewValueCallback: $.functionThatReturnsNull,
    static: {Form$: function(submitText) {
        var t1, t2, t3;
        t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
        t2 = H.setRuntimeTypeInfo([], [B.Node0]);
        t2 = new B.NodeList(null, H.assertSubtype(t2, "$isList", [B.Node0], "$asList"));
        t3 = H.getVoidRuntimeType();
        t1 = new G.Form(H.buildFunctionType(t3)._assertCheck$1(null), H.buildFunctionType(t3, [H.buildInterfaceType(P.Object)])._assertCheck$1(null), false, null, "Form", null, H.assertSubtype(t1, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap"), t2, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
        t2._parent = t1;
        t1.Form$1$submitText(submitText);
        return t1;
      }}
  },
  Form_receiveUserInput_closure: {
    "^": "Closure:2;",
    call$1: function(element) {
      var t1 = J.getInterceptor(element);
      return !!t1.$isUpdatableByMap && !!t1.$isInput;
    }
  },
  Form_receiveUserInput_closure0: {
    "^": "Closure:22;",
    call$1: function($parent) {
      H.interceptedTypeCheck($parent, "$is_NewValueCallback");
      $parent.onInput$1(!!J.getInterceptor($parent).$isInput ? $parent.get$current() : null);
    }
  },
  Form_receiveUserInput_closure1: {
    "^": "Closure:2;",
    call$1: function(element) {
      return !!J.getInterceptor(element).$isInput;
    }
  },
  Form_receiveUserInput_closure2: {
    "^": "Closure:23;",
    call$1: function(element) {
      H.interceptedTypeCast(H.interceptedTypeCheck(element, "$isFormElement"), "$isInput").sanitizeCurrent$0();
    }
  },
  Form_receiveUserInput_closure3: {
    "^": "Closure:2;_captured_newValues_0",
    call$1: function(element) {
      var t1, t2;
      if (element instanceof G.SubmitButton) {
        t1 = element.get$id();
        t2 = H.stringTypeCheck(this._captured_newValues_0._valuesMap.$index(0, "__submitterId__"));
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    }
  },
  Form__giveChildrenUniqueIds_closure: {
    "^": "Closure:23;_egb_form$_box_0,_egb_form$_captured_this_1",
    call$1: function(element) {
      H.interceptedTypeCheck(element, "$isFormElement").set$id("form" + H.S(this._egb_form$_captured_this_1.get$id()) + "-element" + this._egb_form$_box_0._captured_id_0++);
    }
  },
  Form__createConfiguration_closure: {
    "^": "Closure:2;",
    call$1: function(element) {
      return !!J.getInterceptor(element).$isUpdatableByMap;
    }
  },
  FormConfiguration: {
    "^": "Object;_valuesMap<",
    toMap$0: function() {
      return H.assertSubtype(P.LinkedHashMap_LinkedHashMap$from(this._valuesMap, null, null), "$isMap", [P.String, [P.Map, P.String, P.Object]], "$asMap");
    }
  },
  CurrentState: {
    "^": "Object;_valuesMap<",
    toMap$0: function() {
      return H.assertSubtype(P.LinkedHashMap_LinkedHashMap$from(this._valuesMap, null, null), "$isMap", [P.String, P.Object], "$asMap");
    },
    toString$0: function(_) {
      return "<CurrentState submitted=" + H.S(H.boolTypeCheck(this._valuesMap.$index(0, "__submitted__"))) + ">";
    }
  },
  FormSection: {
    "^": "FormElement;namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    get$name: function() {
      return H.stringTypeCheck(this.attributes.$index(0, "name"));
    },
    set$name: function(value) {
      this.attributes.$indexSet(0, "name", value);
      return value;
    }
  },
  _NewValueCallback: {
    "^": "Object;onInput:_NewValueCallback_onInput<",
    set$onInput: function(onInput) {
      this._NewValueCallback_onInput = H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P.Object)])._assertCheck$1(onInput);
    },
    onInput$1: function(arg0) {
      return this._NewValueCallback_onInput.call$1(arg0);
    }
  },
  StringRepresentationCreator: {
    "^": "Object;",
    stringifyFunction$1: function(arg0) {
      return this.StringRepresentationCreator_stringifyFunction.call$1(arg0);
    }
  },
  closure4: {
    "^": "Closure:24;",
    call$1: function(value) {
      return H.S(value);
    }
  },
  Output: {
    "^": "Object;"
  },
  SubmitButtonBase: {
    "^": "FormElement;",
    get$name: function() {
      return H.stringTypeCheck(this.attributes.$index(0, "name"));
    },
    set$name: function(value) {
      H.stringTypeCheck(value);
      this.attributes.$indexSet(0, "name", value);
      return value;
    },
    toMap$0: function() {
      var map = H.assertSubtype(this.super$FormElement$toMap$0(), "$isMap", [P.String, P.Object], "$asMap");
      map.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["name", H.stringTypeCheck(this.attributes.$index(0, "name"))], null, null));
      return H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
    },
    updateFromMap$1: function(map) {
      H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
      this.super$FormElement$updateFromMap$1(map);
      this.attributes.$indexSet(0, "name", H.stringTypeCheck(map.$index(0, "name")));
    }
  },
  SubmitButton: {
    "^": "SubmitButtonBase;onSubmit,namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    onSubmit$0: function() {
      return this.onSubmit.call$0();
    }
  },
  CheckboxBase: {
    "^": "FormElement;current<",
    set$current: function(current) {
      this.current = H.boolTypeCheck(current);
    },
    get$name: function() {
      return H.stringTypeCheck(this.attributes.$index(0, "name"));
    },
    set$name: function(value) {
      this.attributes.$indexSet(0, "name", value);
      return value;
    },
    toMap$0: function() {
      var map = H.assertSubtype(this.super$FormElement$toMap$0(), "$isMap", [P.String, P.Object], "$asMap");
      map.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["current", this.current], null, null));
      return H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
    },
    updateFromMap$1: function(map) {
      H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
      this.super$FormElement$updateFromMap$1(map);
      this.current = H.boolTypeCheck(map.$index(0, "current"));
    }
  },
  CheckboxInputBase: {
    "^": "CheckboxBase;",
    sanitizeCurrent$0: function() {
      if (this.current == null)
        throw H.wrapException(P.StateError$("CheckboxInput state must be either true or false."));
    },
    $isInput: 1,
    $asInput: function() {
      return [P.bool];
    }
  },
  CheckboxInput: {
    "^": "CheckboxInputBase__NewValueCallback;_NewValueCallback_onInput,current,namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    $is_NewValueCallback: 1,
    $as_NewValueCallback: function() {
      return [P.bool];
    }
  },
  CheckboxInputBase__NewValueCallback: {
    "^": "CheckboxInputBase+_NewValueCallback;onInput:_NewValueCallback_onInput<",
    set$onInput: function(onInput) {
      this._NewValueCallback_onInput = H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P.Object)])._assertCheck$1(onInput);
    },
    $is_NewValueCallback: 1,
    $as_NewValueCallback: function() {
      return [P.bool];
    }
  },
  RangeBase: {
    "^": "FormElement;",
    get$name: function() {
      return H.stringTypeCheck(this.attributes.$index(0, "name"));
    },
    set$name: function(value) {
      this.attributes.$indexSet(0, "name", value);
      return value;
    },
    toMap$0: function() {
      var map = H.assertSubtype(this.super$FormElement$toMap$0(), "$isMap", [P.String, P.Object], "$asMap");
      map.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["min", this.min, "max", this.max, "step", this.step, "minEnabled", this.minEnabled, "maxEnabled", this.maxEnabled, "current", this.current], null, null));
      return H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
    },
    updateFromMap$1: function(map) {
      H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
      this.super$FormElement$updateFromMap$1(map);
      this.min = H.intTypeCheck(map.$index(0, "min"));
      this.max = H.intTypeCheck(map.$index(0, "max"));
      this.step = H.intTypeCheck(map.$index(0, "step"));
      this.minEnabled = H.intTypeCheck(map.$index(0, "minEnabled"));
      this.maxEnabled = H.intTypeCheck(map.$index(0, "maxEnabled"));
      this.current = H.intTypeCheck(map.$index(0, "current"));
    },
    RangeBase$withConstraints$8: function(elementClass, $name, current, min, max, step, minEnabled, maxEnabled) {
      var t1, t2;
      this.attributes.$indexSet(0, "name", $name);
      t1 = this.max;
      t2 = this.min;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (C.JSInt_methods.$mod(C.JSInt_methods.$sub(t1, t2), this.step) !== 0)
        throw H.wrapException(P.ArgumentError$("The value of max (" + H.S(this.max) + ") is not valid, given the step (" + H.S(this.step) + ") and min(" + H.S(this.min) + ")."));
    }
  },
  RangeOutputBase: {
    "^": "RangeBase;"
  },
  RangeOutput: {
    "^": "RangeOutputBase_StringRepresentationCreator;StringRepresentationCreator_stringifyFunction,current,min,max,step,minEnabled,maxEnabled,namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans"
  },
  RangeOutputBase_StringRepresentationCreator: {
    "^": "RangeOutputBase+StringRepresentationCreator;",
    $isStringRepresentationCreator: 1
  },
  TextBase: {
    "^": "FormElement;",
    toMap$0: function() {
      var map = H.assertSubtype(this.super$FormElement$toMap$0(), "$isMap", [P.String, P.Object], "$asMap");
      map.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["html", this.html], null, null));
      return H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
    },
    updateFromMap$1: function(map) {
      H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
      this.super$FormElement$updateFromMap$1(map);
      this.html = H.stringTypeCheck(map.$index(0, "html"));
    }
  },
  TextOutputBase: {
    "^": "TextBase_Output;"
  },
  TextBase_Output: {
    "^": "TextBase+Output;"
  },
  TextOutput: {
    "^": "TextOutputBase;Output_current,html,namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans"
  },
  MultipleChoiceInputBase: {
    "^": "FormElement;",
    get$name: function() {
      return H.stringTypeCheck(this.attributes.$index(0, "name"));
    },
    set$name: function(value) {
      this.attributes.$indexSet(0, "name", value);
      return value;
    }
  },
  MultipleChoiceInput: {
    "^": "MultipleChoiceInputBase__NewValueCallback;_NewValueCallback_onInput,namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    $is_NewValueCallback: 1,
    $as_NewValueCallback: function() {
      return [P.$int];
    }
  },
  MultipleChoiceInputBase__NewValueCallback: {
    "^": "MultipleChoiceInputBase+_NewValueCallback;onInput:_NewValueCallback_onInput<",
    set$onInput: function(onInput) {
      this._NewValueCallback_onInput = H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P.Object)])._assertCheck$1(onInput);
    },
    $is_NewValueCallback: 1,
    $as_NewValueCallback: function() {
      return [P.$int];
    }
  },
  OptionBase: {
    "^": "FormElement;current<",
    set$current: function(current) {
      this.current = H.boolTypeCheck(current);
    },
    toMap$0: function() {
      var map = H.assertSubtype(this.super$FormElement$toMap$0(), "$isMap", [P.String, P.Object], "$asMap");
      map.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["text", H.stringTypeCheck(this.attributes.$index(0, "text")), "current", this.current], null, null));
      return H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
    },
    updateFromMap$1: function(map) {
      H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
      this.super$FormElement$updateFromMap$1(map);
      this.attributes.$indexSet(0, "text", H.stringTypeCheck(map.$index(0, "text")));
      this.current = H.boolTypeCheck(map.$index(0, "current"));
    },
    sanitizeCurrent$0: function() {
    },
    OptionBase$3$helpMessage$selected: function(text, helpMessage, selected) {
      var t1 = this.attributes;
      t1.$indexSet(0, "text", text);
      this.current = selected;
      t1.$indexSet(0, "helpMessage", helpMessage);
    },
    $isInput: 1,
    $asInput: function() {
      return [P.bool];
    }
  },
  Option: {
    "^": "OptionBase__NewValueCallback;_NewValueCallback_onInput,current,namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    Option$4$helpMessage$selected: function(text, onSelect, helpMessage, selected) {
      this.set$onInput(new G.Option_closure(H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P.Object)])._assertCheck$1(onSelect)));
    },
    static: {Option$: function(text, onSelect, helpMessage, selected) {
        var t1, t2, t3, t4;
        t1 = H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P.Object)]);
        t2 = t1._assertCheck$1(onSelect);
        t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
        t4 = H.setRuntimeTypeInfo([], [B.Node0]);
        t4 = new B.NodeList(null, H.assertSubtype(t4, "$isList", [B.Node0], "$asList"));
        t3 = new G.Option(t1._assertCheck$1(null), false, null, "Option", null, H.assertSubtype(t3, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap"), t4, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
        t4._parent = t3;
        t3.OptionBase$3$helpMessage$selected(text, helpMessage, selected);
        t3.Option$4$helpMessage$selected(text, t2, helpMessage, selected);
        return t3;
      }}
  },
  OptionBase__NewValueCallback: {
    "^": "OptionBase+_NewValueCallback;onInput:_NewValueCallback_onInput<",
    set$onInput: function(onInput) {
      this._NewValueCallback_onInput = H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P.Object)])._assertCheck$1(onInput);
    },
    $is_NewValueCallback: 1,
    $as_NewValueCallback: function() {
      return [P.bool];
    }
  },
  Option_closure: {
    "^": "Closure:9;_captured_onSelect_0",
    call$1: function(selected) {
      if (H.boolTypeCheck(selected))
        this._captured_onSelect_0.call$1(true);
    }
  }
}],
["egb_message", "package:egamebook/src/shared/message.dart", , A, {
  "^": "",
  EgbMessage: {
    "^": "Object;type<,listContent<,strContent,intContent<,mapContent<",
    set$mapContent: function(mapContent) {
      this.mapContent = H.assertSubtype(mapContent, "$isMap", [P.String, P.Object], "$asMap");
    },
    get$typeString: function() {
      var t1 = this.type;
      switch (t1) {
        case 10:
          return "SEND_BOOK_UID";
        case 20:
          return "NO_RESULT";
        case 30:
          return "TEXT_RESULT";
        case 40:
          return "SHOW_CHOICES";
        case 50:
          return "SAVE_GAME";
        case 60:
          return "SAVE_PLAYER_CHRONOLOGY";
        case 70:
          return "POINTS_AWARD";
        case 80:
          return "END_OF_BOOK";
        case 90:
          return "SET_STATS";
        case 100:
          return "UPDATE_STATS";
        case 110:
          return "SHOW_FORM";
        case 120:
          return "UPDATE_FORM";
        case 666:
          return "SCRIPTER_ERROR";
        case 667:
          return "SCRIPTER_LOG";
        case 1000:
          return "REQUEST_BOOK_UID";
        case 1010:
          return "START";
        case 1020:
          return "LOAD_GAME";
        case 1040:
          return "PROCEED";
        case 1050:
          return "CHOICE_SELECTED";
        case 1060:
          return "FORM_INPUT";
        case 1070:
          return "QUIT";
        default:
          return "Unknown type=" + H.S(t1);
      }
    },
    toString$0: function(_) {
      var t1, t2;
      t1 = "EgbMessage " + this.get$typeString();
      t2 = this.type;
      return t1 + (t2 === 50 || t2 === 60 || t2 === 90 || t2 === 100 || t2 === 666 || t2 === 667 ? " (async)" : "");
    },
    toJson$0: function() {
      return C.JsonCodec_null_null.encode$1(this.toMap$0());
    },
    toMap$0: function() {
      var map, t1;
      map = H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.Object), "$isMap", [P.String, P.Object], "$asMap"), "$isMap", [P.String, P.Object], "$asMap");
      map.$indexSet(0, "type", this.type);
      t1 = this.strContent;
      if (t1 != null)
        map.$indexSet(0, "strContent", t1);
      t1 = this.listContent;
      if (t1 != null)
        map.$indexSet(0, "listContent", t1);
      t1 = this.intContent;
      if (t1 != null)
        map.$indexSet(0, "intContent", t1);
      t1 = this.mapContent;
      if (t1 != null)
        map.$indexSet(0, "mapContent", t1);
      return H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
    }
  }
}],
["egb_page", "package:egamebook/src/shared/page.dart", , E, {
  "^": "",
  EgbPage: {
    "^": "Object;name<",
    set$name: function($name) {
      this.name = H.stringTypeCheck($name);
    },
    toString$0: function(_) {
      return this.name;
    },
    get$groupName: function() {
      var t1, index;
      t1 = this.name;
      if (t1 == null)
        throw H.wrapException("Accessed groupName EgbPage has name = null.");
      index = J.indexOf$1$as(t1, ": ");
      if (index > 0)
        return J.substring$2$s(this.name, 0, index);
      else
        return;
    }
  }
}],
["egb_presenter_proxy", "package:egamebook/src/presenter/presenter_proxy.dart", , D, {
  "^": "",
  EgbPresenterViewedFromScripter: {
    "^": "Object;"
  },
  EgbPresenterProxy: {
    "^": "EgbPresenterViewedFromScripter;"
  },
  EgbIsolatePresenterProxy: {
    "^": "EgbPresenterProxy;mainIsolatePort,port,_textMessageCache,_messageBacklog,_choiceSelectedCompleter,_formInputStreamController,scripter",
    set$_choiceSelectedCompleter: function(_choiceSelectedCompleter) {
      this._choiceSelectedCompleter = H.assertSubtype(_choiceSelectedCompleter, "$isCompleter", [P.$int], "$asCompleter");
    },
    set$_formInputStreamController: function(_formInputStreamController) {
      this._formInputStreamController = H.assertSubtype(_formInputStreamController, "$isStreamController", [G.CurrentState], "$asStreamController");
    },
    _onMessageFromMainIsolate$1: [function(_message) {
      var message, e, stacktrace, savegame, playerChronology, e0, stacktrace0, e1, stacktrace1, e2, stacktrace2, t1, message0, t2, choiceHash, state, exception, t3, savegame0, saveMap;
      t1 = J.getInterceptor(_message);
      H.assertHelper(!!t1.$isMap);
      _message = H.assertSubtype(H.subtypeCast(_message, "$isMap", [P.String, P.Object], "$asMap"), "$isMap", [P.String, P.Object], "$asMap");
      H.assertSubtype(_message, "$isMap", [P.String, P.Object], "$asMap");
      message0 = new A.EgbMessage(H.intTypeCheck(t1.$index(_message, "type")), null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
      H.assertSubtype(_message, "$isMap", [P.String, P.Object], "$asMap");
      if (_message.containsKey$1("strContent"))
        message0.strContent = H.stringTypeCheck(t1.$index(_message, "strContent"));
      if (_message.containsKey$1("listContent"))
        message0.listContent = H.listTypeCheck(t1.$index(_message, "listContent"));
      if (_message.containsKey$1("intContent"))
        message0.intContent = H.intTypeCheck(t1.$index(_message, "intContent"));
      if (_message.containsKey$1("mapContent"))
        message0.set$mapContent(t1.$index(_message, "mapContent"));
      message = message0;
      switch (message.get$type()) {
        case 1070:
          t1 = this._choiceSelectedCompleter;
          if (t1 != null) {
            t1.completeError$1(new D.EgbAsyncOperationOverridenException("Book Quit before choice was selected."));
            this.set$_choiceSelectedCompleter(null);
          }
          t1 = this.port;
          t1._rawPort.close$0();
          t1._controller.close$0();
          return;
        case 1000:
          t1 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
          t1.strContent = "GET_BOOK_UID received.";
          t2 = this.mainIsolatePort;
          t2.send$1(t1.toMap$0());
          t2.send$1(new A.EgbMessage(10, null, "DEFAULT_BOOK_UID", null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap")).toMap$0());
          return;
        case 1050:
          choiceHash = message.get$intContent();
          H.assertHelper(this._choiceSelectedCompleter != null);
          this._choiceSelectedCompleter.complete$1(choiceHash);
          this.set$_choiceSelectedCompleter(null);
          return;
        case 1060:
          t1 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
          t1.strContent = "New form state from player received.";
          this.mainIsolatePort.send$1(t1.toMap$0());
          t1 = message.get$mapContent();
          H.assertSubtype(t1, "$isMap", [P.String, P.Object], "$asMap");
          H.assertSubtype(t1, "$isMap", [P.String, P.Object], "$asMap");
          state = new G.CurrentState(t1);
          H.assertSubtype(t1, "$isMap", [P.String, P.Object], "$asMap");
          if (!t1.containsKey$1("__submitted__"))
            t1.$indexSet(0, "__submitted__", false);
          t1 = this._formInputStreamController;
          t1.toString;
          H.assertSubtypeOfRuntimeType(state, H.getRuntimeTypeArgument(t1, "_StreamController", 0));
          if (t1._state >= 4)
            H.throwExpression(t1._badEventState$0());
          t1._async$_add$1(state);
          return;
        case 1010:
          t1 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
          t1.strContent = "Starting book from scratch.";
          t2 = this.mainIsolatePort;
          t2.send$1(t1.toMap$0());
          t1 = this._choiceSelectedCompleter;
          if (t1 != null) {
            t1.completeError$1(new D.EgbAsyncOperationOverridenException("Book Restart before choice was selected."));
            this.set$_choiceSelectedCompleter(null);
          }
          try {
            this.scripter.restart$0();
          } catch (exception) {
            t1 = H.unwrapException(exception);
            e = t1;
            stacktrace = H.getTraceFromException(exception);
            t1 = "An error occured when initializing: " + H.S(e) + ".\n" + H.S(stacktrace);
            t3 = new A.EgbMessage(666, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
            t3.strContent = t1;
            t2.send$1(t3.toMap$0());
            throw H.wrapException(e);
          }
          t1 = Z.Stat_createStatList();
          H.assertSubtype(t1, "$isList", [[P.Map, P.String, P.Object]], "$asList");
          t3 = new A.EgbMessage(90, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
          H.assertSubtype(t1, "$isList", [[P.Map, P.String, P.Object]], "$asList");
          t3.listContent = t1;
          t2.send$1(t3.toMap$0());
          t2.send$1(new A.PointsAward(0, 0, null).toMessage$0().toMap$0());
          return;
        case 1020:
          t1 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
          t1.strContent = "Loading a saved game.";
          t2 = this.mainIsolatePort;
          t2.send$1(t1.toMap$0());
          t1 = this._choiceSelectedCompleter;
          if (t1 != null) {
            t1.completeError$1(new D.EgbAsyncOperationOverridenException("Book Load before choice was selected."));
            this.set$_choiceSelectedCompleter(null);
          }
          try {
            t1 = H.interceptedTypeCheck(message, "$isEgbMessage").strContent;
            savegame0 = new Z.EgbSavegame(null, H.assertSubtype(null, "$isMap", [P.String, null], "$asMap"), H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"), null, null, null);
            saveMap = H.assertSubtype(C.JsonCodec_null_null.decode$1(t1), "$isMap", [P.String, null], "$asMap");
            if (!saveMap.containsKey$1("currentPageName") || !saveMap.containsKey$1("vars"))
              H.throwExpression(Z.InvalidSavegameException$("Invalid JSON for EgbSavegame. Doesn't contain required fields 'currentPageName' or 'vars'. JSON='" + H.S(t1) + "'."));
            savegame0.uid = H.stringTypeCheck(saveMap.$index(0, "uid"));
            savegame0.currentPageName = H.stringTypeCheck(saveMap.$index(0, "currentPageName"));
            savegame0.timestamp = H.intTypeCheck(saveMap.$index(0, "timestamp"));
            savegame0.set$pageMapState(saveMap.$index(0, "pageMapState"));
            savegame0.set$vars(saveMap.$index(0, "vars"));
            if (saveMap.containsKey$1("previousText"))
              savegame0.textHistory = H.stringTypeCheck(saveMap.$index(0, "previousText"));
            savegame = savegame0;
            playerChronology = message.get$listContent();
            t1 = this.scripter;
            if (playerChronology != null)
              t1.loadFromSaveGame$2(savegame, playerChronology);
            else
              t1.loadFromSaveGame$1(savegame);
          } catch (exception) {
            t1 = H.unwrapException(exception);
            if (t1 instanceof Z.IncompatibleSavegameException) {
              e0 = t1;
              stacktrace0 = H.getTraceFromException(exception);
              t1 = "Load failed due to incompatibility: " + H.S(e0) + ".\n" + H.S(stacktrace0);
              t3 = new A.EgbMessage(666, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
              t3.strContent = t1;
              t2.send$1(t3.toMap$0());
              this.scripter.restart$0();
            } else {
              e1 = t1;
              stacktrace1 = H.getTraceFromException(exception);
              t1 = "Load failed for unknown reason: " + H.S(e1) + ".\n" + H.S(stacktrace1);
              t3 = new A.EgbMessage(666, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
              t3.strContent = t1;
              t2.send$1(t3.toMap$0());
              this.scripter.restart$0();
            }
          }
          try {
            t1 = Z.Stat_createStatList();
            H.assertSubtype(t1, "$isList", [[P.Map, P.String, P.Object]], "$asList");
            t3 = new A.EgbMessage(90, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
            H.assertSubtype(t1, "$isList", [[P.Map, P.String, P.Object]], "$asList");
            t3.listContent = t1;
            t2.send$1(t3.toMap$0());
          } catch (exception) {
            t1 = H.unwrapException(exception);
            e2 = t1;
            stacktrace2 = H.getTraceFromException(exception);
            t1 = "Sending Stats failed for unknown reason: " + H.S(e2) + ".\n" + H.S(stacktrace2);
            t3 = new A.EgbMessage(666, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
            t3.strContent = t1;
            t2.send$1(t3.toMap$0());
            throw H.wrapException(e2);
          }
          this.scripter.toString;
          t2.send$1(new A.PointsAward(0, $.get$_points()._points, null).toMessage$0().toMap$0());
          return;
        case 1040:
          this.scripter.walk$0();
          return;
        default:
          t1 = "Wrong message type received by Scripter - " + H.S(message.get$type()) + ".";
          t2 = new A.EgbMessage(666, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
          t2.strContent = t1;
          this.mainIsolatePort.send$1(t2.toMap$0());
      }
    }, "call$1", "get$_onMessageFromMainIsolate", 2, 0, 25]
  },
  EgbAsyncOperationOverridenException: {
    "^": "Object;message",
    toString$0: function(_) {
      return "EgbAsyncOperationOverridenException: " + this.message + ".";
    },
    $isException: 1
  }
}],
["egb_savegame", "package:egamebook/src/persistence/savegame.dart", , Z, {
  "^": "",
  EgbSavegame: {
    "^": "Object;currentPageName,pageMapState,vars,textHistory,uid,timestamp",
    set$pageMapState: function(pageMapState) {
      this.pageMapState = H.assertSubtype(pageMapState, "$isMap", [P.String, null], "$asMap");
    },
    set$vars: function(vars) {
      this.vars = H.assertSubtype(vars, "$isMap", [P.String, P.Object], "$asMap");
    },
    toMessage$1: function(type) {
      var message;
      if (type !== 50 && type !== 1020)
        throw H.wrapException("Cannot create EgbMessage of type " + type + ". Can only be MSG_SAVE_GAME (50) or MSG_LOAD_GAME (1020).");
      message = new A.EgbMessage(type, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
      message.strContent = this.toJson$0();
      return message;
    },
    toJson$0: function() {
      var saveMap, t1;
      saveMap = H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, null), "$isMap", [P.String, null], "$asMap"), "$isMap", [P.String, null], "$asMap");
      saveMap.$indexSet(0, "uid", this.uid);
      saveMap.$indexSet(0, "currentPageName", this.currentPageName);
      saveMap.$indexSet(0, "pageMapState", this.pageMapState);
      saveMap.$indexSet(0, "vars", this.vars);
      saveMap.$indexSet(0, "timestamp", this.timestamp);
      t1 = this.textHistory;
      if (t1 != null)
        saveMap.$indexSet(0, "previousText", t1);
      return C.JsonCodec_null_null.encode$1(saveMap);
    },
    toString$0: function(_) {
      return this.toJson$0();
    },
    static: {EgbSavegame__isSaveable: function(variable) {
        var t1, primitivelySaveable;
        if (variable != null)
          if (typeof variable !== "string") {
            if (typeof variable !== "number" || Math.floor(variable) !== variable)
              if (typeof variable !== "number")
                if (typeof variable !== "boolean") {
                  t1 = J.getInterceptor(variable);
                  t1 = !!t1.$isList || !!t1.$isMap;
                } else
                  t1 = true;
              else
                t1 = true;
            else
              t1 = true;
            primitivelySaveable = t1;
          } else
            primitivelySaveable = true;
        else
          primitivelySaveable = true;
        if (primitivelySaveable)
          return true;
        return !!J.getInterceptor(variable).$isSaveable;
      }, EgbSavegame__dissolveToPrimitives: function(input) {
        var t1, outputList, i, outputMap, saveableMap;
        if (input == null || typeof input === "string" || typeof input === "number" && Math.floor(input) === input || typeof input === "number" || typeof input === "boolean")
          return input;
        else {
          t1 = J.getInterceptor(input);
          if (!!t1.$isList) {
            outputList = [];
            for (i = 0; i < t1.get$length(input); ++i)
              if (Z.EgbSavegame__isSaveable(t1.$index(input, i)))
                C.JSArray_methods.add$1(outputList, Z.EgbSavegame__dissolveToPrimitives(t1.$index(input, i)));
            return outputList;
          } else if (!!t1.$isMap) {
            outputMap = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
            t1.forEach$1(input, new Z.EgbSavegame__dissolveToPrimitives_closure(input, outputMap));
            return outputMap;
          } else if (!!t1.$isSaveable) {
            saveableMap = H.assertSubtype(input.toMap$0(), "$isMap", [P.String, null], "$asMap");
            saveableMap.$indexSet(0, "_class", input.get$className());
            return Z.EgbSavegame__dissolveToPrimitives(saveableMap);
          } else
            throw H.wrapException("Function _dissolveToPrimitivess called with a non-saveable argument type.");
        }
      }, EgbSavegame__assembleFromPrimitives: function(input, constructors, updateExisting) {
        var t1, outputList, i, t2, outputMap, className;
        H.assertSubtype(constructors, "$isMap", [P.String, P.Function], "$asMap");
        if (input == null || typeof input === "string" || typeof input === "number" && Math.floor(input) === input || typeof input === "number" || typeof input === "boolean")
          return input;
        else {
          t1 = J.getInterceptor(input);
          if (!!t1.$isList) {
            outputList = [];
            for (i = 0; i < t1.get$length(input); ++i)
              C.JSArray_methods.add$1(outputList, Z.EgbSavegame__assembleFromPrimitives(t1.$index(input, i), constructors, null));
            return outputList;
          } else {
            t2 = !!t1.$isMap;
            if (t2 && !input.containsKey$1("_class")) {
              outputMap = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
              t1.forEach$1(H.interceptedTypeCast(input, "$isMap"), new Z.EgbSavegame__assembleFromPrimitives_closure(constructors, outputMap));
              return outputMap;
            } else if (t2 && input.containsKey$1("_class"))
              if (updateExisting != null) {
                updateExisting.updateFromMap$1(input);
                return updateExisting;
              } else {
                className = H.stringTypeCheck(t1.$index(input, "_class"));
                if (!constructors.containsKey$1(className))
                  throw H.wrapException(Z.IncompatibleSavegameException$("Constructor for " + H.S(className) + " not set. Cannot assemble a new instance."));
                else
                  return constructors.$index(0, className).call$1(input);
              }
            else
              throw H.wrapException("Function _assembleFromPrimitives called with a non-primitive argument type.");
          }
        }
      }, EgbSavegame_importSavegameToVars: function(savegame, vars, constructors) {
        H.assertSubtype(vars, "$isMap", [P.String, null], "$asMap");
        H.assertSubtype(constructors, "$isMap", [P.String, P.Function], "$asMap");
        savegame.vars.forEach$1(0, new Z.EgbSavegame_importSavegameToVars_closure(vars, constructors));
      }}
  },
  EgbSavegame__dissolveToPrimitives_closure: {
    "^": "Closure:6;_captured_inputMap_0,_captured_outputMap_1",
    call$2: function(key, value) {
      if (Z.EgbSavegame__isSaveable(this._captured_inputMap_0.$index(0, key)))
        this._captured_outputMap_1.$indexSet(0, key, Z.EgbSavegame__dissolveToPrimitives(value));
    }
  },
  EgbSavegame__assembleFromPrimitives_closure: {
    "^": "Closure:6;_captured_constructors_0,_captured_outputMap_1",
    call$2: function(key, value) {
      this._captured_outputMap_1.$indexSet(0, key, Z.EgbSavegame__assembleFromPrimitives(value, this._captured_constructors_0, null));
    }
  },
  EgbSavegame_importSavegameToVars_closure: {
    "^": "Closure:18;_captured_vars_0,_captured_constructors_1",
    call$2: function(key, value) {
      var t1, existingValue, t2;
      H.stringTypeCheck(key);
      t1 = this._captured_vars_0;
      existingValue = t1.$index(0, key);
      t2 = this._captured_constructors_1;
      if (existingValue == null)
        t1.$indexSet(0, key, Z.EgbSavegame__assembleFromPrimitives(value, t2, null));
      else
        t1.$indexSet(0, key, Z.EgbSavegame__assembleFromPrimitives(value, t2, existingValue));
    }
  },
  IncompatibleSavegameException: {
    "^": "Object;message",
    toString$0: function(_) {
      return "IncompatibleSavegameException: " + this.message;
    },
    $isException: 1,
    static: {IncompatibleSavegameException$: function(message) {
        return new Z.IncompatibleSavegameException(message);
      }}
  },
  InvalidSavegameException: {
    "^": "Object;message",
    toString$0: function(_) {
      return "InvalidSavegameException: " + this.message;
    },
    $isException: 1,
    static: {InvalidSavegameException$: function(message) {
        return new Z.InvalidSavegameException(message);
      }}
  }
}],
["egb_scripter", "package:egamebook/scripter.dart", , O, {
  "^": "",
  echo: [function(str) {
    var t1, t2;
    H.stringTypeCheck(str);
    t1 = $.get$textBuffer();
    t2 = t1._contents;
    if (t2.length > 0)
      t1._contents = t2 + " ";
    t1.toString;
    t1._contents += H.S(str);
  }, "call$1", "echo$closure", 2, 0, 70],
  $goto: [function(pageName) {
    $.gotoPageName = H.stringTypeCheck(pageName);
  }, "call$1", "$goto$closure", 2, 0, 70],
  choice: [function(string, deferToChoiceList, deferToEndOfPage, $goto, script, submenu) {
    var choice = L.EgbChoice$(H.stringTypeCheck(string), H.boolTypeCheck(deferToChoiceList), H.boolTypeCheck(deferToEndOfPage), H.stringTypeCheck($goto), H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(script), H.stringTypeCheck(submenu));
    $.get$choices().add$1(0, choice);
    return choice;
  }, function(string) {
    return O.choice(string, false, false, null, null, null);
  }, null, function(string, script) {
    return O.choice(string, false, false, null, script, null);
  }, null, "call$6$deferToChoiceList$deferToEndOfPage$goto$script$submenu", "call$1", "call$2$script", "choice$closure", 2, 11, 71, 0, 0, 0, 1, 1],
  showForm: [function(form) {
    $._currentForm = form;
  }, "call$1", "showForm$closure", 2, 0, 72],
  throwIfNotInInitOrDeclareBlock: function(customMessage) {
    if (!$.isInInitOrDeclareBlock)
      throw H.wrapException(P.StateError$("An initialization code meant for the initBlock (inside the <variables> tag) was called outside of it (probably in a <script> tag). " + customMessage));
  },
  EgbScripter: {
    "^": "Object;",
    walk$0: function() {
      var loop, e, stacktrace, e0, stacktrace0, t1, t2, t3, exception;
      if ($.Stat_someChanged) {
        t1 = this.presenter;
        t1.toString;
        t2 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t2.strContent = "Sending updated stats.";
        t1.mainIsolatePort.send$1(t2.toMap$0());
        t2 = this.presenter;
        t1 = Z.Stat_createUpdates();
        t2.toString;
        t3 = new A.EgbMessage(100, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t3.set$mapContent(t1.toMap$0());
        t2.mainIsolatePort.send$1(t3.toMap$0());
        t3 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
        t3._asyncComplete$1(true);
        H.assertSubtype(H.assertSubtype(t3, "$isFuture", [null], "$asFuture"), "$isFuture", [P.bool], "$asFuture");
      }
      if (this._playerChronologyChanged) {
        t1 = this.presenter;
        t1.toString;
        t2 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t2.strContent = "Saving player chronology.";
        t1.mainIsolatePort.send$1(t2.toMap$0());
        this._playerChronologyChanged = false;
        t2 = this.presenter;
        t1 = this._playerChronology;
        t2.toString;
        H.assertSubtype(t1, "$isSet", [P.String], "$asSet");
        H.assertSubtype(t1, "$isSet", [P.String], "$asSet");
        t3 = new A.EgbMessage(60, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        H.assertSubtype(t1, "$isSet", [P.String], "$asSet");
        t3.listContent = t1.toList$0(0);
        t2.mainIsolatePort.send$1(t3.toMap$0());
      }
      loop = null;
      do {
        t1 = this.presenter;
        t1.toString;
        t2 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t2.strContent = "Calling _goOneStep().";
        t1.mainIsolatePort.send$1(t2.toMap$0());
        try {
          loop = this._goOneStep$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (t1 instanceof M.AuthorScriptException) {
            e = t1;
            stacktrace = H.getTraceFromException(exception);
            t1 = this.presenter;
            t2 = H.S(e) + "\nStacktrace: " + H.S(stacktrace);
            t1.toString;
            t2 = "AuthorScriptException: " + t2;
            t3 = new A.EgbMessage(666, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
            t3.strContent = t2;
            t1.mainIsolatePort.send$1(t3.toMap$0());
            return;
          } else {
            e0 = t1;
            stacktrace0 = H.getTraceFromException(exception);
            t1 = this.presenter;
            t2 = H.S(e0) + "\nStacktrace: " + H.S(stacktrace0);
            t1.toString;
            t2 = "Unknown Error (probably in egamebook itself): " + t2;
            t3 = new A.EgbMessage(666, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
            t3.strContent = t2;
            t1.mainIsolatePort.send$1(t3.toMap$0());
            return;
          }
        }
        H.assertHelper(loop != null);
      } while (J.$eq(loop, false));
      t1 = this.presenter;
      t1.toString;
      t2 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
      t2.strContent = "Ending _goOneStep() loop.";
      t1.mainIsolatePort.send$1(t2.toMap$0());
    },
    restart$0: function() {
      this._initScriptEnvironment$0();
      this._playerChronology.clear$0(0);
      this._playerChronologyChanged = true;
      this.currentPage = this.firstPage;
    },
    _handleChoiceSelected$1: [function(choiceHash) {
      var t1 = {};
      H.intTypeCheck(choiceHash);
      t1._captured_pickedChoice_0 = null;
      $.get$choices().forEach$1(0, new O.EgbScripter__handleChoiceSelected_closure(t1, this, choiceHash));
      t1 = t1._captured_pickedChoice_0;
      if (t1 == null)
        throw H.wrapException(P.ArgumentError$("The sent choice hash (" + H.S(choiceHash) + ") is not one of those offered."));
      this._pickChoice$1(t1);
      this.walk$0();
    }, "call$1", "get$_handleChoiceSelected", 2, 0, 26],
    _pickChoice$1: function(choice) {
      var t1, t2;
      t1 = choice.f;
      if (t1 != null) {
        H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(t1);
        t2 = $.get$_nextScriptStack();
        t2.toString;
        H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(t2, 0));
        t2._add$1(t1);
      }
      t1 = choice.$goto;
      if (t1 != null)
        this._performGoto$1(t1);
      choice.shown = true;
    },
    _goOneStep$0: function() {
      var t1, e, stacktrace, t2, t3, award, t4, message, t5, atStaticChoiceList, actionableChoices, onError, test, result, autoChoice, t6, exception, savegame, canContinue;
      t1 = {};
      t2 = $.get$_points();
      t3 = t2.pointsAwards;
      if (t3._head !== t3._tail) {
        t1 = this.presenter;
        t1.toString;
        t3 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t3.strContent = "Awarding points.";
        t1.mainIsolatePort.send$1(t3.toMap$0());
        award = t2.pointsAwards.removeFirst$0();
        t2 = this.presenter;
        t3 = award.get$addition();
        t1 = award.result;
        t4 = award.justification;
        t2.toString;
        message = new A.EgbMessage(70, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        message.listContent = [t3, t1];
        message.strContent = t4;
        t2.mainIsolatePort.send$1(message.toMap$0());
        return true;
      }
      t2 = this.currentBlockIndex;
      t3 = this.currentPage.blocks;
      t4 = t3.length;
      t1._captured_atEndOfPage_0 = t2 === t4 - 1 || t2 === this.LAST_BLOCK_ON_PAGE;
      t5 = this.LAST_BLOCK_ON_PAGE;
      if (t2 !== t5)
        if (t2 != null) {
          if (typeof t2 !== "number")
            return t2.$lt();
          if (t2 < t4) {
            if (t2 < 0 || t2 >= t3.length)
              return H.ioore(t3, t2);
            t2 = !!J.getInterceptor(t3[t2]).$isList;
          } else
            t2 = false;
          atStaticChoiceList = t2;
        } else
          atStaticChoiceList = false;
      else
        atStaticChoiceList = false;
      t2 = "atEndOfPage = " + t1._captured_atEndOfPage_0 + ", atStaticChoiceList = " + atStaticChoiceList;
      t3 = this.presenter;
      t3.toString;
      t4 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
      t4.strContent = t2;
      t3.mainIsolatePort.send$1(t4.toMap$0());
      t4 = $.get$choices();
      t4.removeWhere$1(0, new O.EgbScripter__goOneStep_closure(this));
      if (!t4.get$isEmpty(t4)) {
        t2 = this.presenter;
        t2.toString;
        t3 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t3.strContent = "We have choices.";
        t2.mainIsolatePort.send$1(t3.toMap$0());
        t3 = t4.where$1(0, new O.EgbScripter__goOneStep_closure0(t1, atStaticChoiceList));
        t3 = H.assertSubtype(P.List_List$from(t3, true, H.getRuntimeTypeArgument(t3, "IterableBase", 0)), "$isList", [H.getRuntimeTypeArgument(t3, "IterableBase", 0)], "$asList");
        t2 = t4.question;
        H.assertSubtype(t3, "$isList", [L.EgbChoice], "$asList");
        H.assertHelper(true);
        [].$builtinTypeInfo = [L.EgbChoice];
        actionableChoices = new L.EgbChoiceList(t2, H.assertSubtype(t3, "$isList", [L.EgbChoice], "$asList"));
        if (actionableChoices.get$isNotEmpty(actionableChoices)) {
          t1 = this.presenter;
          t2 = t1._choiceSelectedCompleter;
          if (t2 != null) {
            t2.completeError$1(new D.EgbAsyncOperationOverridenException("Showing new choice before previous one was selected."));
            t1.set$_choiceSelectedCompleter(null);
          }
          t2 = P.$int;
          t3 = new P._Future(0, $.Zone__current, null);
          H.assertHelper(true);
          t3.$builtinTypeInfo = [t2];
          t3 = new P._AsyncCompleter(H.assertSubtype(t3, "$is_Future", [t2], "$as_Future"));
          H.assertHelper(true);
          t3.$builtinTypeInfo = [t2];
          t1.set$_choiceSelectedCompleter(H.assertSubtype(t3, "$isCompleter", [t2], "$asCompleter"));
          t2 = actionableChoices.toMessage$0();
          t1.mainIsolatePort.send$1(t2.toMap$0());
          t1 = H.assertSubtype(t1._choiceSelectedCompleter.future, "$isFuture", [P.$int], "$asFuture").then$1(this.get$_handleChoiceSelected());
          onError = new O.EgbScripter__goOneStep_closure1(this);
          test = new O.EgbScripter__goOneStep_closure2();
          t2 = H.getDynamicRuntimeType();
          t3 = H.buildFunctionType(H.buildInterfaceType(P.bool), [t2]);
          t3._assertCheck$1(test);
          t4 = $.Zone__current;
          result = new P._Future(0, t4, null);
          H.assertHelper(true);
          result.$builtinTypeInfo = [null];
          if (t4 !== C.C__RootZone) {
            onError = P._registerErrorHandler(onError, t4);
            t4.toString;
            t2 = H.buildFunctionType(t2, [t2]);
            t2._assertCheck$1(test);
            test = t3._assertCheck$1(t2._assertCheck$1(test));
          }
          t3._assertCheck$1(test);
          t1._addListener$1(new P._FutureListener(null, result, 6, test, onError));
          return true;
        } else {
          autoChoice = H.interceptedTypeCheck(t4.firstWhere$2$orElse(0, new O.EgbScripter__goOneStep_closure3(), new O.EgbScripter__goOneStep_closure4()), "$isEgbChoice");
          if (autoChoice != null) {
            this._pickChoice$1(autoChoice);
            t4.remove$1(0, autoChoice);
          }
        }
      }
      if ($._currentForm != null) {
        t2 = this.presenter;
        t2.toString;
        t3 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t3.strContent = "We have a form.";
        t2.mainIsolatePort.send$1(t3.toMap$0());
        t3 = this.presenter;
        t2 = $._currentForm;
        t3.toString;
        t4 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t4.strContent = "Scripter asks to show form.";
        t5 = t3.mainIsolatePort;
        t5.send$1(t4.toMap$0());
        t3.set$_formInputStreamController(P.StreamController_StreamController(null, null, null, null, false, G.CurrentState));
        t4 = new A.EgbMessage(110, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t4.set$mapContent(t2.toMap$0());
        t5.send$1(t4.toMap$0());
        t3 = t3._formInputStreamController;
        t3.toString;
        H.assertSubtype(t3, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle");
        t4 = new P._ControllerStream(H.assertSubtype(t3, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle"));
        H.assertHelper(true);
        t4.$builtinTypeInfo = [null];
        t4 = H.assertSubtype(H.assertSubtype(H.assertSubtype(t4, "$isStream", [H.getRuntimeTypeArgument(t3, "_StreamController", 0)], "$asStream"), "$isStream", [G.CurrentState], "$asStream"), "$isStream", [G.CurrentState], "$asStream");
        t1._captured_subscription_1 = null;
        t2 = new O.EgbScripter__goOneStep_closure5(t1, this);
        t3 = H.getVoidRuntimeType();
        H.buildFunctionType(t3, [t4.T11()])._assertCheck$1(t2);
        H.buildFunctionType(t3)._assertCheck$1(null);
        t1._captured_subscription_1 = H.assertSubtype(t4._createSubscription$4(t2, null, null, false), "$isStreamSubscription", [H.getTypeArgumentByIndex(t4, 0)], "$asStreamSubscription");
        return true;
      }
      t2 = $.get$_nextScriptStack();
      t3 = t2._head;
      t6 = t2._tail;
      if (t3 !== t6) {
        if (t3 === t6)
          H.throwExpression(H.IterableElementError_noElement());
        ++t2._modificationCount;
        t1 = t2._table;
        t3 = t1.length;
        t6 = (t6 - 1 & t3 - 1) >>> 0;
        t2._tail = t6;
        if (t6 < 0 || t6 >= t3)
          return H.ioore(t1, t6);
        result = H.assertSubtypeOfRuntimeType(t1[t6], H.getTypeArgumentByIndex(t2, 0));
        t1[t6] = null;
        return this._runScriptBlock$1(H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(H.assertSubtypeOfRuntimeType(result, H.getTypeArgumentByIndex(t2, 0))));
      }
      t2 = $.gotoPageName;
      if (t2 != null) {
        this._performGoto$1(t2);
        $.gotoPageName = null;
        return false;
      }
      t2 = this.currentBlockIndex;
      if (t2 == null) {
        this.currentBlockIndex = 0;
        t2 = 0;
      } else if (t2 === t5) {
        t2 = this.currentPage.blocks.length - 1;
        this.currentBlockIndex = t2;
      } else if ($._repeatBlockBit)
        $._repeatBlockBit = false;
      else {
        if (typeof t2 !== "number")
          return t2.$add();
        ++t2;
        this.currentBlockIndex = t2;
      }
      t3 = this.currentPage;
      t1._captured_atEndOfPage_0 = t2 === t3.blocks.length - 1;
      t3 = "Resolving block: '" + H.S(t3.name) + "' block " + H.S(this.currentBlockIndex) + ".";
      t2 = this.presenter;
      t2.toString;
      t5 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
      t5.strContent = t3;
      t2.mainIsolatePort.send$1(t5.toMap$0());
      t2 = this.currentBlockIndex;
      t3 = this.currentPage.blocks;
      if (t2 === t3.length) {
        H.assertHelper(!t4.any$1(0, new O.EgbScripter__goOneStep_closure6()));
        t1 = this.presenter;
        t1.toString;
        t2 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t2.strContent = "End of book.";
        t1.mainIsolatePort.send$1(t2.toMap$0());
        t2 = this.presenter;
        t1 = this._createSaveGame$0();
        t2.toString;
        t1 = t1.toMessage$1(50);
        t2.mainIsolatePort.send$1(t1.toMap$0());
        t1 = this.presenter;
        t1.toString;
        H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap");
        t1.mainIsolatePort.send$1(new A.EgbMessage(80, null, null, null, null).toMap$0());
        return true;
      }
      t2 = C.JSArray_methods.$index(t3, t2);
      if (typeof t2 === "string") {
        t1 = this.presenter;
        t2 = C.JSArray_methods.$index(this.currentPage.blocks, this.currentBlockIndex);
        t1.toString;
        H.stringTypeCheck(t2);
        t3 = new A.EgbMessage(30, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t3.strContent = t2;
        t1.mainIsolatePort.send$1(t3.toMap$0());
        t3 = new P._Future(0, $.Zone__current, null);
        H.assertHelper(true);
        t3.$builtinTypeInfo = [null];
        t3._asyncComplete$1(null);
        H.assertSubtype(H.assertSubtype(t3, "$isFuture", [null], "$asFuture"), "$isFuture", [P.bool], "$asFuture");
        return true;
      } else if (!!J.getInterceptor(C.JSArray_methods.$index(this.currentPage.blocks, this.currentBlockIndex)).$isList) {
        t2 = this.presenter;
        t2.toString;
        t3 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t3.strContent = "A ChoiceList encountered.";
        t2.mainIsolatePort.send$1(t3.toMap$0());
        try {
          t4.addFromScripterList$1(C.JSArray_methods.$index(this.currentPage.blocks, this.currentBlockIndex));
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (t1 instanceof M.AuthorScriptException) {
            e = t1;
            stacktrace = H.getTraceFromException(exception);
            t1 = this.presenter;
            t2 = H.S(e) + "\nStacktrace: " + H.S(stacktrace);
            t1.toString;
            t2 = "AuthorScriptException: " + t2;
            t3 = new A.EgbMessage(666, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
            t3.strContent = t2;
            t1.mainIsolatePort.send$1(t3.toMap$0());
            return true;
          } else
            throw exception;
        }
        t2 = this.presenter;
        t2.toString;
        t3 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t3.strContent = "- choices added";
        t2.mainIsolatePort.send$1(t3.toMap$0());
        if (t4.any$1(0, new O.EgbScripter__goOneStep_closure7(t1, this)) && this.currentBlockIndex === this.currentPage.blocks.length - 1) {
          t1 = this.presenter;
          t1.toString;
          t2 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
          t2.strContent = "Creating & sending savegame";
          t1.mainIsolatePort.send$1(t2.toMap$0());
          t2 = this.presenter;
          t1 = this._createSaveGame$0();
          t2.toString;
          t1 = t1.toMessage$1(50);
          t2.mainIsolatePort.send$1(t1.toMap$0());
          return false;
        }
        return false;
      } else {
        t2 = C.JSArray_methods.$index(this.currentPage.blocks, this.currentBlockIndex);
        t3 = H.buildFunctionType(H.getVoidRuntimeType())._isTest$1(t2);
        if (t3) {
          savegame = this.currentBlockIndex === this.currentPage.blocks.length - 1 ? this._createSaveGame$0() : null;
          canContinue = this._runScriptBlock$1(C.JSArray_methods.$index(this.currentPage.blocks, this.currentBlockIndex));
          if (t4.any$1(0, new O.EgbScripter__goOneStep_closure8(t1, this)) && this.currentBlockIndex === this.currentPage.blocks.length - 1) {
            H.assertHelper(savegame != null);
            t1 = this.presenter;
            t1.toString;
            t2 = savegame.toMessage$1(50);
            t1.mainIsolatePort.send$1(t2.toMap$0());
          }
          return canContinue;
        } else
          throw H.wrapException(P.StateError$("Invalid block: " + H.S(C.JSArray_methods.$index(this.currentPage.blocks, this.currentBlockIndex))));
      }
    },
    _performGoto$1: function(dest) {
      var t1, t2, _gotoPage, _gotoBlockIndex, t3;
      t1 = $.get$EgbChoice_GO_BACK();
      if (t1._nativeRegExp.test(H.checkString(dest))) {
        t2 = this._preGotoPosition;
        if (t2 == null)
          throw H.wrapException(P.StateError$("Cannot use [" + J.toString$0(t1) + "] when there is no _preGotoPosition."));
        _gotoPage = t2.page;
        t1 = t2.blockIndex;
        if (typeof t1 !== "number")
          return t1.$sub();
        _gotoBlockIndex = t1 - 1;
      } else {
        _gotoPage = this.pageMap.getPage$2$currentGroupName(dest, this.currentPage.get$groupName());
        if (_gotoPage == null)
          throw H.wrapException("Function goto() called with an invalid argument '" + H.S(dest) + "'. No such page.");
        _gotoBlockIndex = null;
      }
      t1 = this._preGotoPosition;
      t2 = t1 == null;
      if ((t2 ? null : t1.page) != null) {
        t1 = t2 ? null : t1.page;
        t2 = this.currentPage;
        this._playerChronology.add$1(0, H.S(t1.name) + ">>" + H.S(t2.name));
        this._playerChronologyChanged = true;
      }
      if (!this._playerChronology.contains$1(0, H.S(this.currentPage.name) + ">>" + H.S(_gotoPage.name))) {
        t1 = _gotoPage.visitCount;
        if (typeof t1 !== "number")
          return t1.$gt();
        t1 = t1 > 0;
      } else
        t1 = true;
      if (t1) {
        t1 = this._preGotoPosition;
        t2 = t1 == null;
        if ((t2 ? null : t1.page) != null) {
          t1 = (t2 ? null : t1.page).visitCount;
          if (typeof t1 !== "number")
            return t1.$gt();
          t1 = t1 <= 0;
        } else
          t1 = false;
      } else
        t1 = false;
      $._pointsEmbargo = t1;
      t1 = "Points embargo = " + t1;
      t2 = this.presenter;
      t2.toString;
      t3 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
      t3.strContent = t1;
      t2.mainIsolatePort.send$1(t3.toMap$0());
      t3 = this.currentPage;
      this._preGotoPosition = new O.EgbScripterBlockPointer(t3, this.currentBlockIndex);
      this.currentPage = _gotoPage;
      this.currentBlockIndex = _gotoBlockIndex;
      t1 = t3.visitCount;
      if (typeof t1 !== "number")
        return t1.$add();
      t3.visitCount = t1 + 1;
    },
    _initScriptEnvironment$0: function() {
      var e, stacktrace, t1, t2, exception, t3;
      this.currentBlockIndex = null;
      $.get$_nextScriptStack().clear$0(0);
      $.get$choices().clear$0(0);
      $._currentForm = null;
      t1 = $.get$vars();
      t1.clear$0(0);
      t2 = $.get$_points();
      t1.$indexSet(0, "points", t2);
      t2._points = 0;
      t2.pointsAwards.clear$0(0);
      this.pageMap.clearState$0();
      $.isInInitOrDeclareBlock = true;
      try {
        this.initBlock$0();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        stacktrace = H.getTraceFromException(exception);
        t1 = this.presenter;
        t2 = H.S(e) + "\n" + H.S(stacktrace);
        t1.toString;
        t2 = "Author Exception in initBlock() (<variables>): " + t2;
        t3 = new A.EgbMessage(666, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t3.strContent = t2;
        t1.mainIsolatePort.send$1(t3.toMap$0());
        throw H.wrapException(e);
      }
      this.populateVarsFromState$0();
      $.isInInitOrDeclareBlock = false;
    },
    _runScriptBlock$1: function(script) {
      var e, stacktrace, t1, exception, t2, t3;
      H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(script);
      t1 = $.get$textBuffer();
      t1._contents = "";
      try {
        script.call$0();
      } catch (exception) {
        t2 = H.unwrapException(exception);
        e = t2;
        stacktrace = H.getTraceFromException(exception);
        t1._contents += "<code><pre>ERROR: " + H.S(e) + "\n\n" + H.S(stacktrace) + "</pre></code>";
        throw H.wrapException(new M.AuthorScriptException(J.toString$0(e), this.currentPage.name, this.currentBlockIndex));
      }
      if (t1._contents.length !== 0) {
        t2 = this.presenter;
        t1 = J.toString$0(t1);
        t2.toString;
        t3 = new A.EgbMessage(30, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t3.strContent = t1;
        t2.mainIsolatePort.send$1(t3.toMap$0());
        t3 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
        t3._asyncComplete$1(null);
        H.assertSubtype(H.assertSubtype(t3, "$isFuture", [null], "$asFuture"), "$isFuture", [P.bool], "$asFuture");
        return true;
      } else
        return false;
    },
    _leadsToIllegalPage$1: [function(choice) {
      var t1, targetPage, t2, t3, revisitingVisitOncePage;
      t1 = H.interceptedTypeCheck(choice, "$isEgbChoice").$goto;
      if (t1 == null)
        return false;
      if ($.get$EgbChoice_GO_BACK()._nativeRegExp.test(H.checkString(t1)))
        return false;
      targetPage = this.pageMap.getPage$2$currentGroupName(t1, this.currentPage.get$groupName());
      if (targetPage == null) {
        t1 = "Target page '" + H.S(t1) + "' was not found.";
        t2 = this.presenter;
        t2.toString;
        t3 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t3.strContent = t1;
        t2.mainIsolatePort.send$1(t3.toMap$0());
        return true;
      }
      if (targetPage.visitOnce) {
        t1 = targetPage.visitCount;
        if (typeof t1 !== "number")
          return t1.$gt();
        revisitingVisitOncePage = t1 > 0;
      } else
        revisitingVisitOncePage = false;
      if (revisitingVisitOncePage) {
        t1 = this.presenter;
        t1.toString;
        t2 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t2.strContent = "Trying to revisit a visitOnce page.";
        t1.mainIsolatePort.send$1(t2.toMap$0());
        return true;
      } else
        return false;
    }, "call$1", "get$_leadsToIllegalPage", 2, 0, 27],
    _createSaveGame$0: function() {
      var e, stacktrace, t1, t2, t3, exception;
      this.populateVarsFromState$0();
      try {
        t1 = this.currentPage.name;
        t2 = $.get$vars();
        t3 = this.pageMap.exportState$0();
        H.assertSubtype(t3, "$isMap", [P.String, null], "$asMap");
        t1 = new Z.EgbSavegame(t1, H.assertSubtype(t3, "$isMap", [P.String, null], "$asMap"), H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"), null, null, null);
        H.assertSubtype(t3, "$isMap", [P.String, null], "$asMap");
        t1.set$vars(Z.EgbSavegame__dissolveToPrimitives(t2));
        t1.timestamp = Date.now();
        t1.uid = C.JSInt_methods.toRadixString$1(H.Primitives_objectHashCode(t1), 16);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        stacktrace = H.getTraceFromException(exception);
        t1 = this.presenter;
        t2 = H.S(e) + "\n" + H.S(stacktrace);
        t1.toString;
        t2 = "Error when creating savegame: " + t2;
        t3 = new A.EgbMessage(666, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t3.strContent = t2;
        t1.mainIsolatePort.send$1(t3.toMap$0());
        throw H.wrapException(e);
      }
    },
    loadFromSaveGame$2: function(savegame, playerChronology) {
      var t1, t2, t3;
      H.assertSubtype(playerChronology, "$isList", [P.String], "$asList");
      this._initScriptEnvironment$0();
      t1 = this.pageMap;
      t2 = t1.pages;
      if (H.interceptedTypeCheck(t2.$index(0, savegame.currentPageName), "$isEgbScripterPage") == null)
        throw H.wrapException(Z.IncompatibleSavegameException$("Trying to load page '" + H.S(savegame.currentPageName) + "' which doesn't exist in current egamebook."));
      this.currentPage = H.interceptedTypeCheck(t2.$index(0, savegame.currentPageName), "$isEgbScripterPage");
      this.currentBlockIndex = this.LAST_BLOCK_ON_PAGE;
      t2 = this.presenter;
      t2.toString;
      t3 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
      t3.strContent = "Importing state from savegame.";
      t2.mainIsolatePort.send$1(t3.toMap$0());
      t1.importState$1(savegame.pageMapState);
      if (playerChronology != null) {
        t1 = this.presenter;
        t1.toString;
        t2 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t2.strContent = "Importing player chronology.";
        t1.mainIsolatePort.send$1(t2.toMap$0());
        this._playerChronology.addAll$1(0, playerChronology);
      }
      t1 = this.presenter;
      t1.toString;
      t2 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
      t2.strContent = "Copying save variables into vars.";
      t1.mainIsolatePort.send$1(t2.toMap$0());
      Z.EgbSavegame_importSavegameToVars(savegame, $.get$vars(), P.LinkedHashMap_LinkedHashMap$_empty(null, null));
      this.extractStateFromVars$0();
      t2 = this.presenter;
      t2.toString;
      t1 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
      t1.strContent = "loadFromSaveGame() done.";
      t2.mainIsolatePort.send$1(t1.toMap$0());
    },
    loadFromSaveGame$1: function(savegame) {
      return this.loadFromSaveGame$2(savegame, null);
    }
  },
  EgbScripter__handleChoiceSelected_closure: {
    "^": "Closure:2;_egb_scripter$_box_0,_egb_scripter$_captured_this_1,_captured_choiceHash_2",
    call$1: function(choice) {
      var t1, t2, t3, toPage;
      t1 = choice.get$hash();
      t2 = this._captured_choiceHash_2;
      if (t1 == null ? t2 == null : t1 === t2) {
        t1 = "Found choice that was selected: " + choice.get$string();
        t2 = this._egb_scripter$_captured_this_1.presenter;
        t2.toString;
        t3 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t3.strContent = t1;
        t2.mainIsolatePort.send$1(t3.toMap$0());
        this._egb_scripter$_box_0._captured_pickedChoice_0 = choice;
      } else if (choice.get$$goto() != null) {
        t1 = $.get$EgbChoice_GO_BACK();
        t2 = choice.$goto;
        t3 = this._egb_scripter$_captured_this_1;
        toPage = t1._nativeRegExp.test(H.checkString(t2)) ? t3._preGotoPosition.page : t3.pageMap.getPage$2$currentGroupName(t2, t3.currentPage.get$groupName());
        if (toPage != null) {
          t3._playerChronology.add$1(0, H.S(t3.currentPage.name) + ">>" + H.S(toPage.name));
          t3._playerChronologyChanged = true;
        }
      }
    }
  },
  EgbScripter__goOneStep_closure: {
    "^": "Closure:2;_egb_scripter$_captured_this_1",
    call$1: function(choice) {
      return choice.get$shown() || this._egb_scripter$_captured_this_1._leadsToIllegalPage$1(choice);
    }
  },
  EgbScripter__goOneStep_closure0: {
    "^": "Closure:28;_egb_scripter$_box_0,_captured_atStaticChoiceList_2",
    call$1: function(choice) {
      return H.interceptedTypeCheck(choice, "$isEgbChoice").isActionable$2$atChoiceList$atEndOfPage(this._captured_atStaticChoiceList_2, this._egb_scripter$_box_0._captured_atEndOfPage_0);
    }
  },
  EgbScripter__goOneStep_closure1: {
    "^": "Closure:2;_egb_scripter$_captured_this_3",
    call$1: function(e) {
      var t1, t2, t3;
      t1 = H.S(e);
      t2 = this._egb_scripter$_captured_this_3.presenter;
      t2.toString;
      t3 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
      t3.strContent = t1;
      t2.mainIsolatePort.send$1(t3.toMap$0());
      return;
    }
  },
  EgbScripter__goOneStep_closure2: {
    "^": "Closure:2;",
    call$1: function(e) {
      return e instanceof D.EgbAsyncOperationOverridenException;
    }
  },
  EgbScripter__goOneStep_closure3: {
    "^": "Closure:2;",
    call$1: function(choice) {
      return choice.get$isAutomatic();
    }
  },
  EgbScripter__goOneStep_closure4: {
    "^": "Closure:1;",
    call$0: function() {
      return;
    }
  },
  EgbScripter__goOneStep_closure5: {
    "^": "Closure:29;_egb_scripter$_box_0,_egb_scripter$_captured_this_4",
    call$1: function(values) {
      var changedConfig, e, stacktrace, t1, t2, t3, t4, exception;
      H.interceptedTypeCheck(values, "$isCurrentState");
      t1 = this._egb_scripter$_captured_this_4;
      t2 = "New values = " + H.S(values) + ".";
      t3 = t1.presenter;
      t3.toString;
      t4 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
      t4.strContent = t2;
      t3.mainIsolatePort.send$1(t4.toMap$0());
      changedConfig = null;
      try {
        changedConfig = $._currentForm.receiveUserInput$1(values);
      } catch (exception) {
        t2 = H.unwrapException(exception);
        e = t2;
        stacktrace = H.getTraceFromException(exception);
        t1 = t1.presenter;
        t2 = H.S(e) + "\n" + H.S(stacktrace);
        t1.toString;
        t2 = "Error while handling user input in Form: " + t2;
        t3 = new A.EgbMessage(666, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t3.strContent = t2;
        t1.mainIsolatePort.send$1(t3.toMap$0());
        throw H.wrapException(e);
      }
      t2 = H.boolTypeCheck(values.get$_valuesMap().$index(0, "__submitted__"));
      t3 = t1.presenter;
      if (!t2) {
        t3.toString;
        t1 = H.interceptedTypeCheck(changedConfig, "$isFormConfiguration");
        t2 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t2.strContent = "Scripter sends newly updated values.";
        t3 = t3.mainIsolatePort;
        t3.send$1(t2.toMap$0());
        t2 = new A.EgbMessage(120, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t2.set$mapContent(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$from(t1._valuesMap, null, null), "$isMap", [P.String, [P.Map, P.String, P.Object]], "$asMap"));
        t3.send$1(t2.toMap$0());
      } else {
        t3.toString;
        t2 = new A.EgbMessage(667, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t2.strContent = "The form has been submitted.";
        t3.mainIsolatePort.send$1(t2.toMap$0());
        this._egb_scripter$_box_0._captured_subscription_1.cancel$0();
        $._currentForm = null;
        t1.walk$0();
      }
    }
  },
  EgbScripter__goOneStep_closure6: {
    "^": "Closure:2;",
    call$1: function(choice) {
      return !choice.get$shown();
    }
  },
  EgbScripter__goOneStep_closure7: {
    "^": "Closure:2;_egb_scripter$_box_0,_egb_scripter$_captured_this_5",
    call$1: function(choice) {
      return choice.isActionable$3$atChoiceList$atEndOfPage$filterOut(true, this._egb_scripter$_box_0._captured_atEndOfPage_0, this._egb_scripter$_captured_this_5.get$_leadsToIllegalPage());
    }
  },
  EgbScripter__goOneStep_closure8: {
    "^": "Closure:2;_egb_scripter$_box_0,_egb_scripter$_captured_this_6",
    call$1: function(choice) {
      return choice.isActionable$3$atChoiceList$atEndOfPage$filterOut(true, this._egb_scripter$_box_0._captured_atEndOfPage_0, this._egb_scripter$_captured_this_6.get$_leadsToIllegalPage());
    }
  },
  PointsCounter: {
    "^": "Object;_points,pointsAwards,_embargoedPoints,className<",
    set$pointsAwards: function(pointsAwards) {
      this.pointsAwards = H.assertSubtype(pointsAwards, "$isQueue", [A.PointsAward], "$asQueue");
    },
    add$2: function(_, value, justification) {
      var t1, t2;
      if (!$._pointsEmbargo) {
        t1 = this._points;
        if (typeof t1 !== "number")
          return t1.$add();
        t1 += value;
        this._points = t1;
        t2 = this.pointsAwards;
        t1 = new A.PointsAward(value, t1, justification);
        H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(t2, 0));
        t2._add$1(t1);
      }
    },
    add$1: function($receiver, value) {
      return this.add$2($receiver, value, null);
    },
    $add: function(_, value) {
      this.add$1(0, value);
      return this;
    },
    toMap$0: function() {
      return P.LinkedHashMap_LinkedHashMap$_literal(["points", this._points], null, null);
    },
    updateFromMap$1: function(map) {
      this._points = H.intTypeCheck(H.interceptedTypeCheck(map, "$isMap").$index(0, "points"));
      this.pointsAwards.clear$0(0);
    },
    PointsCounter$0: function() {
      this.set$pointsAwards(H.assertSubtype(P.ListQueue$(null, A.PointsAward), "$isQueue", [A.PointsAward], "$asQueue"));
    },
    $isSaveable: 1
  },
  EgbScripterPage: {
    "^": "EgbPage;blocks,visitCount<,name,visitOnce,showOnce",
    set$visitCount: function(visitCount) {
      this.visitCount = H.intTypeCheck(visitCount);
    }
  },
  EgbScripterBlockPointer: {
    "^": "Object;page,blockIndex"
  },
  EgbScripterPageMap: {
    "^": "Object;pages",
    $index: function(_, key) {
      return H.interceptedTypeCheck(this.pages.$index(0, H.stringTypeCheck(key)), "$isEgbScripterPage");
    },
    getPage$2$currentGroupName: function($name, currentGroupName) {
      var t1;
      if (currentGroupName != null && this.pages.containsKey$1(currentGroupName + ": " + H.S($name)))
        return H.interceptedTypeCheck(this.pages.$index(0, H.S(currentGroupName) + ": " + H.S($name)), "$isEgbScripterPage");
      else {
        t1 = this.pages;
        if (t1.containsKey$1($name))
          return H.interceptedTypeCheck(t1.$index(0, $name), "$isEgbScripterPage");
        else
          return;
      }
    },
    exportState$0: function() {
      var pageMapState = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, null), "$isMap", [P.String, null], "$asMap");
      this.pages.forEach$1(0, new O.EgbScripterPageMap_exportState_closure(pageMapState));
      return H.assertSubtype(pageMapState, "$isMap", [P.String, null], "$asMap");
    },
    importState$1: function(pageMapState) {
      H.assertSubtype(pageMapState, "$isMap", [P.String, null], "$asMap").forEach$1(0, new O.EgbScripterPageMap_importState_closure(this));
    },
    clearState$0: function() {
      this.pages.forEach$1(0, new O.EgbScripterPageMap_clearState_closure());
    }
  },
  EgbScripterPageMap_exportState_closure: {
    "^": "Closure:6;_captured_pageMapState_0",
    call$2: function($name, page) {
      this._captured_pageMapState_0.$indexSet(0, $name, P.LinkedHashMap_LinkedHashMap$_literal(["visitCount", page.get$visitCount()], null, null));
    }
  },
  EgbScripterPageMap_importState_closure: {
    "^": "Closure:6;_egb_scripter$_captured_this_0",
    call$2: function($name, map) {
      var t1 = this._egb_scripter$_captured_this_0.pages;
      if (t1.containsKey$1($name))
        t1.$index(0, $name).set$visitCount(J.$index$as(map, "visitCount"));
    }
  },
  EgbScripterPageMap_clearState_closure: {
    "^": "Closure:6;",
    call$2: function($name, page) {
      page.set$visitCount(0);
    }
  }
}],
["egb_user_interaction", "package:egamebook/src/shared/user_interaction.dart", , L, {
  "^": "",
  EgbUserInteraction: {
    "^": "Object;shown<,hash<"
  },
  EgbChoice: {
    "^": "EgbUserInteraction;string<,f,$goto<,submenu,shown,deferToEndOfPage,deferToChoiceList,hash",
    get$isAutomatic: function() {
      return this.string.length === 0;
    },
    isActionable$3$atChoiceList$atEndOfPage$filterOut: function(atChoiceList, atEndOfPage, filterOut) {
      var t1 = H.buildFunctionType(H.buildInterfaceType(P.bool), [H.buildInterfaceType(L.EgbChoice)])._assertCheck$1(filterOut);
      if (this.shown)
        return false;
      if (this.string.length === 0)
        return false;
      if (atEndOfPage != null && !atEndOfPage && H.boolConversionCheck(this.deferToEndOfPage))
        return false;
      if (atChoiceList != null && !atChoiceList && H.boolConversionCheck(this.deferToChoiceList))
        return false;
      if (t1 != null && H.boolConversionCheck(t1.call$1(this)))
        return false;
      return true;
    },
    isActionable$2$atChoiceList$atEndOfPage: function(atChoiceList, atEndOfPage) {
      return this.isActionable$3$atChoiceList$atEndOfPage$filterOut(atChoiceList, atEndOfPage, null);
    },
    toMapForPresenter$0: function() {
      return H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_literal(["string", this.string, "hash", this.hash, "submenu", this.submenu], null, null), "$isMap", [P.String, P.Object], "$asMap");
    },
    compareTo$1: function(_, other) {
      H.interceptedTypeCheck(other, "$isEgbChoice");
      return C.JSString_methods.compareTo$1(this.string, other.string);
    },
    toString$0: function(_) {
      return "Choice: " + this.string + " [" + H.S(this.$goto) + "]";
    },
    EgbChoice$6$deferToChoiceList$deferToEndOfPage$goto$script$submenu: function(string, deferToChoiceList, deferToEndOfPage, $goto, script, submenu) {
      H.stringTypeCheck($goto);
      H.interceptedTypeCheck(script, "$isFunction");
      H.stringTypeCheck(submenu);
      if (string == null)
        throw H.wrapException(P.ArgumentError$("String given to choice cannot be null."));
      this.string = C.JSString_methods.trim$0(string);
      this.hash = C.JSString_methods.get$hashCode(string);
      this.f = script;
      this.deferToEndOfPage = deferToEndOfPage;
      this.deferToChoiceList = deferToChoiceList;
    },
    $isComparable: 1,
    $asComparable: $.functionThatReturnsNull,
    static: {EgbChoice$: function(string, deferToChoiceList, deferToEndOfPage, $goto, script, submenu) {
        var t1;
        H.stringTypeCheck($goto);
        H.interceptedTypeCheck(script, "$isFunction");
        H.stringTypeCheck(submenu);
        t1 = new L.EgbChoice(null, null, $goto, submenu, false, null, null, null);
        t1.EgbChoice$6$deferToChoiceList$deferToEndOfPage$goto$script$submenu(string, deferToChoiceList, deferToEndOfPage, $goto, script, submenu);
        return t1;
      }}
  },
  EgbChoiceList: {
    "^": "ListBase;question,_choices",
    get$length: function(_) {
      return this._choices.length;
    },
    set$length: function(_, value) {
      C.JSArray_methods.set$length(this._choices, value);
      return value;
    },
    $index: function(_, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = this._choices;
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $indexSet: function(_, index, value) {
      var t1;
      H.interceptedTypeCheck(value, "$isEgbChoice");
      t1 = this._choices;
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      t1[index] = value;
      return value;
    },
    addFromScripterList$1: function(list) {
      var e, map, string, e0, exception, t1, i, t2, t3, t4, t5, choice;
      H.listTypeCheck(list);
      if (J.$index$as(list, 0) != null && !!J.getInterceptor(J.$index$as(list, 0)).$isFunction)
        try {
          this.question = H.stringTypeCheck(J.$index$as(list, 0).call$0());
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          throw H.wrapException(M.AuthorScriptException$(J.toString$0(e)));
        }
      else
        this.question = null;
      for (t1 = this._choices, i = 1; C.JSInt_methods.$lt(i, J.get$length$as(list)); ++i) {
        map = H.interceptedTypeCheck(J.$index$as(list, i), "$isMap");
        string = null;
        if (J.$index$as(map, "string") != null && !!J.getInterceptor(J.$index$as(map, "string")).$isFunction)
          try {
            string = H.stringTypeCheck(J.$index$as(map, "string").call$0());
          } catch (exception) {
            t1 = H.unwrapException(exception);
            e0 = t1;
            throw H.wrapException(M.AuthorScriptException$(J.toString$0(e0)));
          }
        else
          string = "";
        t2 = J.$index$as(map, "goto");
        t3 = J.$index$as(map, "script");
        t4 = J.$index$as(map, "submenu");
        t5 = H.stringTypeCheck(string);
        H.stringTypeCheck(t2);
        H.interceptedTypeCheck(t3, "$isFunction");
        choice = new L.EgbChoice(null, null, t2, H.stringTypeCheck(t4), false, null, null, null);
        if (t5 == null)
          H.throwExpression(P.ArgumentError$("String given to choice cannot be null."));
        choice.string = J.getInterceptor$s(t5).trim$0(t5);
        choice.hash = C.JSString_methods.get$hashCode(t5);
        choice.f = t3;
        choice.deferToEndOfPage = false;
        choice.deferToChoiceList = false;
        C.JSArray_methods.add$1(t1, choice);
      }
    },
    add$6$deferToChoiceList$deferToEndOfPage$goto$script$submenu: function(_, element, deferToChoiceList, deferToEndOfPage, $goto, script, submenu) {
      if (element instanceof L.EgbChoice)
        C.JSArray_methods.add$1(this._choices, element);
      else if (typeof element === "string")
        C.JSArray_methods.add$1(this._choices, L.EgbChoice$(element, deferToChoiceList, deferToEndOfPage, $goto, script, submenu));
      else
        throw H.wrapException(P.ArgumentError$("To add a choice to choices, one must provide either a new EgbChoice element or a String."));
    },
    add$1: function($receiver, element) {
      return this.add$6$deferToChoiceList$deferToEndOfPage$goto$script$submenu($receiver, element, false, false, null, null, null);
    },
    toMessage$4$atChoiceList$atEndOfPage$filterOut$prependText: function(atChoiceList, atEndOfPage, filterOut, prependText) {
      var t1, t2, t3, t4, choicesToSend, m;
      t1 = H.buildInterfaceType(P.bool);
      t2 = this._choices;
      t3 = new L.EgbChoiceList_toMessage_closure(atEndOfPage, atChoiceList, H.buildFunctionType(t1, [H.buildInterfaceType(L.EgbChoice)])._assertCheck$1(filterOut));
      H.buildFunctionType(t1, [H.convertRtiToRuntimeType(t2.$builtinTypeInfo && t2.$builtinTypeInfo[0])])._assertCheck$1(t3);
      t4 = H.getTypeArgumentByIndex(t2, 0);
      H.listSuperNativeTypeCheck(t2, "$isIterable");
      H.buildFunctionType(t1, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t3);
      t2 = H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t2, "$isIterable"), H.buildFunctionType(t1, [H.getDynamicRuntimeType()])._assertCheck$1(t3)), [t4]), "$isIterable");
      choicesToSend = H.assertSubtype(H.assertSubtype(P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "IterableBase", 0)), "$isList", [H.getRuntimeTypeArgument(t2, "IterableBase", 0)], "$asList"), "$isList", [L.EgbChoice], "$asList");
      if (choicesToSend.length === 0)
        throw H.wrapException("Choices is empty, but still choices.toMessage was called.");
      m = new A.EgbMessage(40, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
      t1 = [];
      m.listContent = t1;
      C.JSArray_methods.add$1(t1, prependText);
      C.JSArray_methods.add$1(t1, this.question);
      C.JSArray_methods.forEach$1(choicesToSend, new L.EgbChoiceList_toMessage_closure0(m));
      return m;
    },
    toMessage$0: function() {
      return this.toMessage$4$atChoiceList$atEndOfPage$filterOut$prependText(null, null, null, null);
    },
    $asListBase: function() {
      return [L.EgbChoice];
    },
    $asObject_ListMixin: function() {
      return [L.EgbChoice];
    },
    $asListMixin: function() {
      return [L.EgbChoice];
    },
    $asList: function() {
      return [L.EgbChoice];
    },
    $asIterable: function() {
      return [L.EgbChoice];
    }
  },
  EgbChoiceList_toMessage_closure: {
    "^": "Closure:2;_captured_atEndOfPage_0,_captured_atChoiceList_1,_captured_filterOut_2",
    call$1: function(choice) {
      return choice.isActionable$3$atChoiceList$atEndOfPage$filterOut(this._captured_atChoiceList_1, this._captured_atEndOfPage_0, this._captured_filterOut_2);
    }
  },
  EgbChoiceList_toMessage_closure0: {
    "^": "Closure:2;_captured_m_3",
    call$1: function(choice) {
      H.S(choice);
      J.add$1$a(this._captured_m_3.listContent, choice.toMapForPresenter$0());
      choice.shown = true;
    }
  }
}],
["footnotes", "../libraries/footnotes.dart", , E, {
  "^": "",
  fn: function($name) {
    if (!$.get$_footnotes().containsKey$1($name))
      throw H.wrapException(P.ArgumentError$("Footnote with name '" + $name + "' has not been defined."));
    return "<sup class=\"footnote\" title=\"" + H.S(J.replaceAll$2$s($.get$_footnotes().$index(0, $name), "\"", "&quot;")) + "\">?</sup>";
  }
}],
["html5lib2jsonml", "package:jsonml/html5lib2jsonml.dart", , R, {
  "^": "",
  encodeToJsonML: function(node) {
    var t1, t2, t3, t4, t5, output, attr, i, nodeIndex;
    H.interceptedTypeCheck(node, "$isNode0");
    t1 = J.getInterceptor(node);
    if (!!t1.$isText)
      return node.data;
    else if (!!t1.$isElement) {
      t1 = node.attributes;
      t2 = t1.__js_helper$_length !== 0;
      t3 = t2 ? 1 : 0;
      t4 = node.nodes;
      t5 = t4._list;
      t3 = 1 + t3 + t5.length;
      output = Array(t3);
      output.fixed$length = Array;
      output[0] = node._tagName;
      if (t2) {
        attr = H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.String), "$isMap", [P.String, P.String], "$asMap"), "$isMap", [P.String, P.String], "$asMap");
        t1.forEach$1(0, new R.encodeToJsonML_closure(attr));
        output[1] = attr;
        i = 2;
      } else
        i = 1;
      for (nodeIndex = 0; nodeIndex < t5.length; ++i, ++nodeIndex) {
        t1 = R.encodeToJsonML(H.assertSubtypeOfRuntimeType(t5[nodeIndex], H.getRuntimeTypeArgument(t4, "ListProxy", 0)));
        if (i >= t3)
          return H.ioore(output, i);
        output[i] = t1;
      }
      return output;
    } else
      throw H.wrapException(P.Exception_Exception("Couldn't encode node: " + t1.toString$0(node)));
  },
  encodeToJsonML_closure: {
    "^": "Closure:6;_captured_attr_0",
    call$2: function(key, value) {
      this._captured_attr_0.$indexSet(0, H.S(key), value);
    }
  }
}],
["list_proxy", "package:html5lib/src/list_proxy.dart", , F, {
  "^": "",
  ListProxy: {
    "^": "IterableBase;",
    remove$1: function(_, item) {
      var i;
      H.assertSubtypeOfRuntimeType(item, H.getRuntimeTypeArgument(this, "ListProxy", 0));
      H.assertSubtypeOfRuntimeType(item, H.getRuntimeTypeArgument(this, "ListProxy", 0));
      i = C.JSArray_methods.indexOf$2(this._list, item, 0);
      if (i === -1)
        return false;
      this.removeAt$1(0, i);
      return true;
    },
    insert$2: ["super$ListProxy$insert$2", function(_, index, item) {
      return H.voidTypeCheck(C.JSArray_methods.insert$2(this._list, index, H.assertSubtypeOfRuntimeType(item, H.getRuntimeTypeArgument(this, "ListProxy", 0))));
    }],
    get$length: function(_) {
      return this._list.length;
    },
    get$last: function(_) {
      return H.assertSubtypeOfRuntimeType(C.JSArray_methods.get$last(this._list), H.getRuntimeTypeArgument(this, "ListProxy", 0));
    },
    get$iterator: function(_) {
      var t1, t2, t3;
      t1 = this._list;
      t2 = H.getTypeArgumentByIndex(t1, 0);
      H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray");
      t3 = t1.length;
      return H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"), "$isIterator", [H.getRuntimeTypeArgument(this, "ListProxy", 0)], "$asIterator");
    },
    $index: function(_, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = this._list;
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      return H.assertSubtypeOfRuntimeType(t1[index], H.getRuntimeTypeArgument(this, "ListProxy", 0));
    },
    $indexSet: ["super$ListProxy$$indexSet", function(_, index, value) {
      var t1;
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(this, "ListProxy", 0));
      t1 = this._list;
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      t1[index] = value;
    }],
    add$1: ["super$ListProxy$add$1", function(_, value) {
      C.JSArray_methods.add$1(this._list, H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(this, "ListProxy", 0)));
    }],
    removeAt$1: ["super$ListProxy$removeAt$1", function(_, index) {
      var t1 = this._list;
      if (index < 0 || index >= t1.length)
        H.throwExpression(P.RangeError$value(index, null, null));
      C.JSArray_methods.checkGrowable$1(t1, "removeAt");
      return H.assertSubtypeOfRuntimeType(H.assertSubtypeOfRuntimeType(t1.splice(index, 1)[0], H.getTypeArgumentByIndex(t1, 0)), H.getRuntimeTypeArgument(this, "ListProxy", 0));
    }],
    E: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isList: 1,
    $isEfficientLength: 1,
    $isIterable: 1
  }
}],
["looped_event", "../libraries/loopedevent.dart", , Q, {
  "^": "",
  LoopedEvent: {
    "^": "Object;timeline<",
    run$0: function() {
      if (this.onFinishedGoto == null)
        throw H.wrapException(P.StateError$("Cannot run a LoopedEvent before onFinishedGoto is defined."));
      if (this.finished) {
        $.get$choices().clear$0(0);
        $.gotoPageName = this.onFinishedGoto;
        return;
      }
      while (true) {
        if (!this.finished) {
          var t1 = $.get$choices();
          t1 = t1.get$isEmpty(t1) && $._currentForm == null;
        } else
          t1 = false;
        if (!t1)
          break;
        this.update$0();
      }
      t1 = $.get$storyline();
      O.echo(J.toString$0(t1));
      C.JSArray_methods.set$length(t1.reports, 0);
      t1.strBuf._contents = "";
    }
  }
}],
["numscale", "../libraries/numscale.dart", , R, {
  "^": "",
  NumScale: {
    "^": "Object;_lastValue,_numscale$_value,downwardsChangeCallbacks,upwardsChangeCallbacks,min,max,_streamController,_stream,className<",
    set$downwardsChangeCallbacks: function(downwardsChangeCallbacks) {
      this.downwardsChangeCallbacks = H.assertSubtype(downwardsChangeCallbacks, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap");
    },
    set$upwardsChangeCallbacks: function(upwardsChangeCallbacks) {
      this.upwardsChangeCallbacks = H.assertSubtype(upwardsChangeCallbacks, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap");
    },
    set$_stream: function(_stream) {
      this._stream = H.assertSubtype(_stream, "$isStream", [P.num], "$asStream");
    },
    get$value: function() {
      return this._numscale$_value;
    },
    set$value: ["super$NumScale$set$value", function(v) {
      var t1, t2, passedKeys;
      v = this._clamp$1(v);
      t1 = this._numscale$_value;
      if (v === t1)
        return;
      this._lastValue = t1;
      this._numscale$_value = v;
      t1 = this._streamController;
      H.assertSubtypeOfRuntimeType(v, H.getRuntimeTypeArgument(t1, "_StreamController", 0));
      if (t1._state >= 4)
        H.throwExpression(t1._badEventState$0());
      t1._async$_add$1(v);
      t1 = this._numscale$_value;
      t2 = this._lastValue;
      if (typeof t1 !== "number")
        return t1.$lt();
      if (C.JSNumber_methods.$lt(t1, t2)) {
        passedKeys = H.assertSubtype(this._getPassedChangeCallbackKeys$2(this.downwardsChangeCallbacks, new R.NumScale_value_closure(this)), "$isList", [P.num], "$asList");
        if (passedKeys.length !== 0)
          this.downwardsChangeCallbacks.$index(0, C.JSArray_methods.get$first(passedKeys)).call$1(this._numscale$_value);
      } else {
        passedKeys = H.assertSubtype(this._getPassedChangeCallbackKeys$2(this.upwardsChangeCallbacks, new R.NumScale_value_closure0(this)), "$isList", [P.num], "$asList");
        if (passedKeys.length !== 0)
          this.upwardsChangeCallbacks.$index(0, C.JSArray_methods.get$last(passedKeys)).call$1(this._numscale$_value);
      }
    }],
    _clamp$1: function(v) {
      var v0 = this.min;
      if (v <= v0)
        v = v0;
      else {
        v0 = this.max;
        if (v >= v0)
          v = v0;
      }
      return v;
    },
    _getPassedChangeCallbackKeys$2: function(callbackMap, rangeChecker) {
      var t1, t2, t3, passedKeys;
      H.assertSubtype(callbackMap, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap");
      callbackMap.toString;
      t1 = H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.LinkedHashMapKeyIterable(callbackMap), [H.getTypeArgumentByIndex(callbackMap, 0)]), "$isIterable");
      t2 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t2, [t1.E()])._assertCheck$1(rangeChecker);
      t3 = H.getRuntimeTypeArgument(t1, "IterableBase", 0);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      H.buildFunctionType(t2, [H.convertRtiToRuntimeType(t3)])._assertCheck$1(rangeChecker);
      t1 = H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), H.buildFunctionType(t2, [H.getDynamicRuntimeType()])._assertCheck$1(rangeChecker)), [t3]), "$isIterable");
      passedKeys = H.assertSubtype(H.assertSubtype(P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0)), "$isList", [H.getRuntimeTypeArgument(t1, "IterableBase", 0)], "$asList"), "$isList", [P.num], "$asList");
      C.JSArray_methods.sort$0(passedKeys);
      return H.assertSubtype(passedKeys, "$isList", [P.num], "$asList");
    },
    get$percentage: function() {
      var t1, t2, t3;
      t1 = this.min;
      t2 = this.max - t1;
      if (t2 === 0)
        return 1;
      t3 = this._numscale$_value;
      if (typeof t3 !== "number")
        return t3.$sub();
      return (t3 - t1) / t2;
    },
    onMin$0: function() {
      var t1, t2, t3, t4;
      t1 = this._stream;
      t2 = new R.NumScale_onMin_closure(this);
      t3 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t3, [t1.T0()])._assertCheck$1(t2);
      t4 = H.getRuntimeTypeArgument(t1, "Stream", 0);
      H.assertSubtype(t1, "$isStream", [t4], "$asStream");
      t3 = H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)]);
      t3._assertCheck$1(t2);
      return H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new P._WhereStream(t3._assertCheck$1(t2), H.assertSubtype(t1, "$isStream", [t4], "$asStream")), [t4]), "$isStream", [H.getRuntimeTypeArgument(t1, "Stream", 0)], "$asStream"), "$isStream", [P.num], "$asStream");
    },
    get$changesStream: function() {
      var t1, t2, t3, t4;
      t1 = this._stream;
      t2 = new R.NumScale_changesStream_closure(this);
      t3 = H.getDynamicRuntimeType();
      H.buildFunctionType(t3, [t1.T0()])._assertCheck$1(t2);
      t4 = H.getRuntimeTypeArgument(t1, "Stream", 0);
      H.assertSubtype(t1, "$isStream", [t4], "$asStream");
      H.buildFunctionType(H.convertRtiToRuntimeType(null), [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
      return H.assertSubtype(H.setRuntimeTypeInfo(new P._MapStream(H.buildFunctionType(t3, [t3])._assertCheck$1(t2), H.assertSubtype(t1, "$isStream", [t4], "$asStream")), [t4, null]), "$isStream", [P.num], "$asStream");
    },
    toMap$0: function() {
      return P.LinkedHashMap_LinkedHashMap$_literal(["min", this.min, "max", this.max, "value", this._numscale$_value], null, null);
    },
    updateFromMap$1: function(map) {
      this._numscale$_value = H.numTypeCheck(J.$index$as(map, "value"));
    },
    NumScale$5$downwardsChangeCallbacks$initialValue$max$min$upwardsChangeCallbacks: function(downwardsChangeCallbacks, initialValue, max, min, upwardsChangeCallbacks) {
      var t1, t2, t3, t4, t5, t6, t7, t8;
      H.assertSubtype(downwardsChangeCallbacks, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap");
      H.assertSubtype(upwardsChangeCallbacks, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap");
      this._numscale$_value = this.max;
      this._lastValue = this._numscale$_value;
      t1 = P.StreamController_StreamController(null, null, null, null, true, null);
      this._streamController = t1;
      H.assertSubtype(t1, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle");
      t1 = H.assertSubtype(H.setRuntimeTypeInfo(new P._ControllerStream(H.assertSubtype(t1, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle")), [null]), "$isStream", [H.getRuntimeTypeArgument(t1, "_StreamController", 0)], "$asStream");
      t2 = H.getVoidRuntimeType();
      t3 = H.buildFunctionType(t2, [H.buildInterfaceType(P.StreamSubscription, [t1.T0()])]);
      t3._assertCheck$1(null);
      t3._assertCheck$1(null);
      t3 = H.getRuntimeTypeArgument(t1, "Stream", 0);
      H.assertSubtype(t1, "$isStream", [t3], "$asStream");
      t4 = H.getDynamicRuntimeType();
      t5 = H.buildFunctionType(t2, [H.buildInterfaceType(P.StreamSubscription, [t4])]);
      t5._assertCheck$1(null);
      t5._assertCheck$1(null);
      $.Zone__current.toString;
      t6 = H.buildFunctionType(t4, [t4]);
      t6._assertCheck$1(null);
      t7 = t6._assertCheck$1(null);
      $.Zone__current.toString;
      t6._assertCheck$1(null);
      t6 = t6._assertCheck$1(null);
      t8 = $.Zone__current;
      t8 = H.setRuntimeTypeInfo(new P._AsBroadcastStream(H.assertSubtype(t1, "$isStream", [t3], "$asStream"), t5._assertCheck$1(t7), t5._assertCheck$1(t6), t8, H.assertSubtype(null, "$is_AsBroadcastStreamController", [t3], "$as_AsBroadcastStreamController"), H.assertSubtype(null, "$isStreamSubscription", [t3], "$asStreamSubscription")), [t3]);
      H.assertSubtype(t1, "$isStream", [t3], "$asStream");
      t5._assertCheck$1(null);
      t5._assertCheck$1(null);
      t5 = t8.get$_onListen();
      t6 = t8.get$_onCancel();
      t2 = H.buildFunctionType(t2);
      t2._assertCheck$1(t5);
      t2._assertCheck$1(t6);
      t4 = H.buildFunctionType(t4);
      t3 = H.setRuntimeTypeInfo(new P._AsBroadcastStreamController(null, t4._assertCheck$1(t5), t4._assertCheck$1(t6), 0, null, null, H.assertSubtype(null, "$is_AddStreamState", [t3], "$as_AddStreamState"), null), [t3]);
      t4._assertCheck$1(t5);
      t4._assertCheck$1(t6);
      t3._async$_previous = t3;
      t3._async$_next = t3;
      t8.set$_async$_controller(t3);
      this.set$_stream(H.assertSubtype(t8, "$isStream", [H.getRuntimeTypeArgument(t1, "Stream", 0)], "$asStream"));
      if (this.downwardsChangeCallbacks == null)
        this.set$downwardsChangeCallbacks(P.LinkedHashMap_LinkedHashMap(null, null, null, null, null));
      if (this.upwardsChangeCallbacks == null)
        this.set$upwardsChangeCallbacks(P.LinkedHashMap_LinkedHashMap(null, null, null, null, null));
    },
    $isSaveable: 1,
    static: {NumScale$: function(downwardsChangeCallbacks, initialValue, max, min, upwardsChangeCallbacks) {
        var t1;
        H.assertSubtype(downwardsChangeCallbacks, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap");
        H.assertSubtype(upwardsChangeCallbacks, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap");
        t1 = new R.NumScale(null, null, H.assertSubtype(downwardsChangeCallbacks, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), H.assertSubtype(upwardsChangeCallbacks, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), min, max, null, H.assertSubtype(null, "$isStream", [P.num], "$asStream"), "NumScale");
        t1.NumScale$5$downwardsChangeCallbacks$initialValue$max$min$upwardsChangeCallbacks(downwardsChangeCallbacks, initialValue, max, min, upwardsChangeCallbacks);
        return t1;
      }}
  },
  NumScale_value_closure: {
    "^": "Closure:2;_numscale$_captured_this_0",
    call$1: function(k) {
      var t1, t2, t3, t4, t5;
      t1 = this._numscale$_captured_this_0;
      t2 = t1._numscale$_value;
      t3 = t1.min;
      if (typeof t2 !== "number")
        return t2.$sub();
      t4 = t1.max - t3;
      t5 = J.getInterceptor$n(k);
      if (t5.$ge(k, (t2 - t3) / t4)) {
        t1 = t1._lastValue;
        if (typeof t1 !== "number")
          return t1.$sub();
        t4 = t5.$lt(k, (t1 - t3) / t4);
        t1 = t4;
      } else
        t1 = false;
      return t1;
    }
  },
  NumScale_value_closure0: {
    "^": "Closure:2;_numscale$_captured_this_1",
    call$1: function(k) {
      var t1, t2, t3, t4, t5;
      t1 = this._numscale$_captured_this_1;
      t2 = t1._lastValue;
      t3 = t1.min;
      if (typeof t2 !== "number")
        return t2.$sub();
      t4 = t1.max - t3;
      t5 = J.getInterceptor$n(k);
      if (t5.$gt(k, (t2 - t3) / t4)) {
        t1 = t1._numscale$_value;
        if (typeof t1 !== "number")
          return t1.$sub();
        t4 = t5.$le(k, (t1 - t3) / t4);
        t1 = t4;
      } else
        t1 = false;
      return t1;
    }
  },
  NumScale_onMin_closure: {
    "^": "Closure:2;_numscale$_captured_this_0",
    call$1: function(v) {
      return J.$eq(v, this._numscale$_captured_this_0.min);
    }
  },
  NumScale_changesStream_closure: {
    "^": "Closure:30;_numscale$_captured_this_0",
    call$1: function(v) {
      var t1;
      H.numTypeCheck(v);
      t1 = this._numscale$_captured_this_0._lastValue;
      if (typeof v !== "number")
        return v.$sub();
      return C.JSNumber_methods.$sub(v, t1);
    }
  },
  IntScale: {
    "^": "NumScale;className:IntScale_className<,_lastValue,_numscale$_value,downwardsChangeCallbacks,upwardsChangeCallbacks,min,max,_streamController,_stream,className"
  }
}],
["points_award", "package:egamebook/src/shared/points_award.dart", , A, {
  "^": "",
  PointsAward: {
    "^": "Object;addition<,result,justification",
    toString$0: function(_) {
      var t1, t2;
      t1 = this.justification;
      t2 = this.addition;
      if (t1 != null)
        return "Score +" + t2 + " for " + H.S(t1) + ".";
      else
        return "Score +" + t2 + ".";
    },
    toMessage$0: function() {
      var message = new A.EgbMessage(70, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
      message.listContent = [this.addition, this.result];
      message.strContent = this.justification;
      return message;
    }
  }
}],
["randomly", "../libraries/randomly.dart", , S, {
  "^": "",
  Randomly_saveAgainst: function(probability) {
    if (probability < 0 || probability > 1)
      throw H.wrapException(P.ArgumentError$("Probability needs to be within <0,1>."));
    if (probability === 0)
      return false;
    if (probability === 1)
      return true;
    return $.get$Randomly__random().nextDouble$0() < probability;
  },
  Randomly_choose: function(choices) {
    var number, t1;
    number = choices.length;
    if (number === 0)
      throw H.wrapException(P.ArgumentError$("Cannot randomly choose from an empty set."));
    t1 = $.get$Randomly__random().nextInt$1(number);
    if (t1 < 0 || t1 >= choices.length)
      return H.ioore(choices, t1);
    return choices[t1];
  },
  Randomly_parse: function(str) {
    var startTagIndex, indexes, endTagIndex, i, t1, lastIndex, depth, ch, i0, numOptions, choice, t2, t3, t4, t5;
    startTagIndex = J.getInterceptor$as(str).indexOf$1(str, "{");
    if (startTagIndex !== -1 && startTagIndex < str.length - 1) {
      indexes = H.assertSubtype(H.setRuntimeTypeInfo([], [P.$int]), "$isList", [P.$int], "$asList");
      C.JSArray_methods.add$1(indexes, startTagIndex);
      i = startTagIndex + 1;
      t1 = str.length;
      lastIndex = null;
      depth = 1;
      while (true) {
        if (!(i < t1)) {
          endTagIndex = null;
          break;
        }
        if (i < 0)
          return H.ioore(str, i);
        ch = str[i];
        if (ch === "{")
          ++depth;
        else if (ch === "|" && depth === 1)
          C.JSArray_methods.add$1(indexes, i);
        else if (ch === "}") {
          --depth;
          if (depth === 0) {
            C.JSArray_methods.add$1(indexes, i);
            endTagIndex = i;
            lastIndex = endTagIndex;
            break;
          }
        }
        i0 = i + 1;
        lastIndex = i;
        i = i0;
      }
      numOptions = indexes.length - 1;
      if (numOptions > 1) {
        choice = $.get$Randomly__random().nextInt$1(numOptions);
        t2 = C.JSString_methods.substring$2(str, 0, startTagIndex);
        t3 = indexes.length;
        if (choice < 0 || choice >= t3)
          return H.ioore(indexes, choice);
        t4 = indexes[choice];
        t5 = choice + 1;
        if (t5 >= t3)
          return H.ioore(indexes, t5);
        t5 = t2 + S.Randomly_parse(C.JSString_methods.substring$2(str, t4 + 1, indexes[t5]));
        if (typeof endTagIndex !== "number")
          return endTagIndex.$add();
        t5 += C.JSString_methods.substring$2(str, endTagIndex + 1, t1);
        if (lastIndex === t1 - 1)
          return t5.charCodeAt(0) == 0 ? t5 : t5;
        else
          return S.Randomly_parse(t5.charCodeAt(0) == 0 ? t5 : t5);
      } else if (lastIndex === t1 - 1)
        return str;
      else {
        if (typeof lastIndex !== "number")
          return lastIndex.$add();
        t1 = lastIndex + 1;
        return C.JSString_methods.substring$2(str, 0, t1) + S.Randomly_parse(C.JSString_methods.substring$1(str, t1));
      }
    } else
      return str;
  },
  Randomly_humanDescribeProbability: function(probability) {
    if (probability >= 1)
      return "sure";
    if (probability >= 0.8)
      return "almost sure";
    if (probability >= 0.7)
      return "very probable";
    if (probability >= 0.6)
      return "quite likely";
    if (probability >= 0.5)
      return "quite possible";
    if (probability >= 0.4)
      return "possible";
    if (probability >= 0.3)
      return "improbable";
    if (probability >= 0.2)
      return "quite unlikely";
    if (probability >= 0.1)
      return "very unlikely";
    if (probability > 0)
      return "almost impossible";
    return "impossible";
  }
}],
["shipfight", "../libraries/spaceshipcombat.dart", , T, {
  "^": "",
  SpaceshipCombat: {
    "^": "LoopedEvent;",
    get$spaceships: function() {
      var t1, t2, t3, t4;
      t1 = this.actors;
      t2 = new T.SpaceshipCombat_spaceships_closure();
      t3 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t1.$builtinTypeInfo && t1.$builtinTypeInfo[0])])._assertCheck$1(t2);
      t4 = H.getTypeArgumentByIndex(t1, 0);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
      return H.listSuperNativeTypeCheck(H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), H.buildFunctionType(t3, [H.getDynamicRuntimeType()])._assertCheck$1(t2)), [t4]), "$isIterable"), "$isIterable");
    },
    update$0: function() {
      var t1, t2, t3;
      this.timeline.elapse$1(1);
      t1 = this.actors;
      t2 = H.getTypeArgumentByIndex(t1, 0);
      H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray");
      t3 = t1.length;
      t3 = new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2));
      H.assertHelper(true);
      t3.$builtinTypeInfo = [t2];
      H.assertSubtype(t3, "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator");
      for (; t3.moveNext$0();)
        H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t3._current, H.getTypeArgumentByIndex(t3, 0)), "$isSpaceship").update$0();
      t1 = this.playerSpaceship;
      if (t1 != null) {
        t1 = t1.hull.hp._numscale$_value;
        if (typeof t1 !== "number")
          return t1.$gt();
        t1 = !(t1 > 0);
      } else
        t1 = false;
      if (t1) {
        this.finished = true;
        return;
      }
      if (!C.JSArray_methods.any$1(this.actors, new T.SpaceshipCombat_update_closure(this))) {
        this.finished = true;
        return;
      }
    },
    SpaceshipCombat$2$ships$timeline: function(ships, timeline) {
      C.JSArray_methods.forEach$1(H.assertSubtype(ships, "$isList", [M.Spaceship], "$asList"), new T.SpaceshipCombat_closure(this));
    }
  },
  SpaceshipCombat_closure: {
    "^": "Closure:2;_shipfight$_captured_this_0",
    call$1: function(ship) {
      if (ship.get$pilot().isPlayer)
        this._shipfight$_captured_this_0.playerSpaceship = ship;
      ship.currentCombat = this._shipfight$_captured_this_0;
    }
  },
  SpaceshipCombat_spaceships_closure: {
    "^": "Closure:31;",
    call$1: function(actor) {
      return H.interceptedTypeCheck(actor, "$isActor") instanceof M.Spaceship;
    }
  },
  SpaceshipCombat_update_closure: {
    "^": "Closure:2;_shipfight$_captured_this_0",
    call$1: function(a) {
      return a.get$isAliveAndActive() && C.JSArray_methods.any$1(this._shipfight$_captured_this_0.actors, new T.SpaceshipCombat_update__closure(a));
    }
  },
  SpaceshipCombat_update__closure: {
    "^": "Closure:2;_captured_a_1",
    call$1: function(b) {
      var t1, t2;
      if (b.get$isAliveAndActive()) {
        t1 = b.team;
        t2 = this._captured_a_1.team;
        t2 = t1 == null ? t2 != null : t1 !== t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    }
  }
}],
["source_maps.span", "package:source_maps/span.dart", , Y, {
  "^": "",
  Span: {
    "^": "Object;",
    $isComparable: 1,
    $asComparable: $.functionThatReturnsNull
  },
  FileSpan: {
    "^": "Span;"
  }
}],
["spaceship", "../libraries/spaceship.dart", , M, {
  "^": "",
  CombatMove_cloneFieldsToExisting: function(orig, clone) {
    clone.isActive = orig.isActive;
    clone.onlyActorGetsReports = orig.onlyActorGetsReports;
    clone.targetShip = orig.targetShip;
    clone.targetSystem = orig.targetSystem;
    clone.set$timeToSetup(orig.get$timeToSetup());
    clone.set$timeToFinish(orig.get$timeToFinish());
    clone.stringAutoRepeat = orig.stringAutoRepeat;
    clone.stringCannotContinue = orig.stringCannotContinue;
    clone.set$stringFailure(orig.get$stringFailure());
    clone.set$stringSuccess(orig.get$stringSuccess());
    clone.stringSuccessFromTarget = orig.stringSuccessFromTarget;
    clone.set$isAutoRepeating(orig.get$isAutoRepeating());
    clone.set$needsTargetShip(orig.get$needsTargetShip());
    clone.set$needsTargetSystem(orig.get$needsTargetSystem());
    clone.set$defaultSuccessChance(orig.get$defaultSuccessChance());
  },
  CombatMove_getTargetObject: function(targetShip, targetSystem) {
    var object = targetSystem instanceof M.Hull ? targetSystem.spaceship : targetSystem;
    if (object == null)
      object = targetShip;
    return object instanceof M.Spaceship && object.pilot.isPlayer ? H.interceptedTypeCast(object, "$isSpaceship").pilot : object;
  },
  getAimString: function(aim) {
    if (typeof aim !== "number")
      return aim.$le();
    if (aim <= 0)
      return "poor";
    else if (aim === 1)
      return "decent";
    else if (aim === 2)
      return "good";
    else if (aim === 3)
      return "great";
    else
      return "perfect";
  },
  CombatMove: {
    "^": "Object;targetShip,targetSystem,isActive<,stringStarting<,stringSuccess<,stringFailure<,needsTargetShip<,needsTargetSystem<,isAutoRepeating<,defaultSuccessChance<,timeToSetup<,timeToFinish<",
    set$targetShip: function(targetShip) {
      this.targetShip = H.interceptedTypeCheck(targetShip, "$isSpaceship");
    },
    set$targetSystem: function(targetSystem) {
      this.targetSystem = H.interceptedTypeCheck(targetSystem, "$isShipSystem");
    },
    set$stringFailure: function(stringFailure) {
      this.stringFailure = H.stringTypeCheck(stringFailure);
    },
    set$isAutoRepeating: function(isAutoRepeating) {
      this.isAutoRepeating = H.boolTypeCheck(isAutoRepeating);
    },
    reportSettingUp$0: function() {
      var pilot, t1, t2, t3;
      pilot = this.system.spaceship.pilot;
      if (pilot == null || !pilot.isPlayer)
        throw H.wrapException(P.StateError$("reportSettingUp should not have been called since this spaceship's pilot is null or is not player"));
      t1 = $.get$storyline();
      t2 = this.get$stringSettingUp();
      t3 = this.system;
      t1.add$4$object$subject$time(0, t2, t3, pilot, t3.spaceship.currentCombat.timeline.time);
    },
    get$stringSettingUp: function() {
      return "<subject> start<s> programming the " + this.system.ShipSystem_name + " to " + this.get$commandText();
    },
    reportStarting$0: function() {
      return H.voidTypeCheck(this._report$1(this.get$stringStarting()));
    },
    reportCannotContinue$0: function() {
      return H.voidTypeCheck(this._report$1(this.stringCannotContinue));
    },
    reportSuccess$0: function() {
      return H.voidTypeCheck(this._report$2$positive(this.get$stringSuccess(), true));
    },
    onSuccess$0: [function() {
    }, "call$0", "get$onSuccess", 0, 0, 4],
    reportFailure$0: function() {
      return H.voidTypeCheck(this._report$2$negative(this.get$stringFailure(), true));
    },
    onFailure$0: [function() {
    }, "call$0", "get$onFailure", 0, 0, 4],
    reportAutoRepeat$0: function() {
      return H.voidTypeCheck(this._report$1(this.stringAutoRepeat));
    },
    _report$11$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$preferShipAsObject$subject: function(str, but, endSentence, isSupportiveActionInThread, negative, object, objectOwner, owner, positive, preferShipAsObject, subject) {
      var t1, subject0, t2;
      if (str == null || str === "")
        return;
      if (subject == null) {
        t1 = this.get$isAutoRepeating();
        subject = this.system;
        if (t1)
          ;
        else {
          subject = subject.spaceship;
          subject0 = subject.pilot;
          if (subject0.isPlayer)
            subject = subject0;
        }
      }
      if (owner == null) {
        t1 = this.get$isAutoRepeating() && this.system.spaceship.pilot.isPlayer;
        t2 = this.system;
        if (t1)
          owner = t2.spaceship.pilot;
        else {
          t1 = t2.spaceship;
          owner = t1.pilot;
          if (owner.isPlayer)
            owner = null;
          else {
            t1 = t1.team;
            owner = t1 === 1 || t1 === 0 ? owner : null;
          }
        }
      }
      if (object == null) {
        object = M.CombatMove_getTargetObject(this.targetShip, this.targetSystem);
        if (preferShipAsObject && object instanceof M.ShipSystem)
          object = H.interceptedTypeCast(object, "$isShipSystem").spaceship;
      }
      if (objectOwner == null && object != null) {
        t1 = J.getInterceptor(object);
        if (!!t1.$isShipSystem && !t1.$isHull)
          objectOwner = object.get$spaceship();
      }
      t1 = $.get$Entity_NOTHING();
      if (subject == null ? t1 == null : subject === t1)
        subject = null;
      if (owner == null ? t1 == null : owner === t1)
        owner = null;
      if (objectOwner == null ? t1 == null : objectOwner === t1)
        objectOwner = null;
      if (object == null ? t1 == null : object === t1)
        object = null;
      $.get$storyline().add$12$actionThread$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$subject$time(0, str, H.Primitives_objectHashCode(this), but, endSentence, isSupportiveActionInThread, negative, object, objectOwner, owner, positive, subject, this.system.spaceship.currentCombat.timeline.time);
    },
    _report$5$endSentence$negative$object$subject: function(str, endSentence, negative, object, subject) {
      return this._report$11$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$preferShipAsObject$subject(str, false, endSentence, false, negative, object, null, null, false, false, subject);
    },
    _report$2$positive: function(str, positive) {
      return this._report$11$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$preferShipAsObject$subject(str, false, false, false, false, null, null, null, positive, false, null);
    },
    _report$5$object$objectOwner$positive$subject: function(str, object, objectOwner, positive, subject) {
      return this._report$11$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$preferShipAsObject$subject(str, false, false, false, false, object, objectOwner, null, positive, false, subject);
    },
    _report$4$object$positive$subject: function(str, object, positive, subject) {
      return this._report$11$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$preferShipAsObject$subject(str, false, false, false, false, object, null, null, positive, false, subject);
    },
    _report$4$negative$object$subject: function(str, negative, object, subject) {
      return this._report$11$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$preferShipAsObject$subject(str, false, false, false, negative, object, null, null, false, false, subject);
    },
    _report$1: function(str) {
      return this._report$11$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$preferShipAsObject$subject(str, false, false, false, false, null, null, null, false, false, null);
    },
    _report$3$negative$preferShipAsObject: function(str, negative, preferShipAsObject) {
      return this._report$11$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$preferShipAsObject$subject(str, false, false, false, negative, null, null, null, false, preferShipAsObject, null);
    },
    _report$3$owner$subject: function(str, owner, subject) {
      return this._report$11$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$preferShipAsObject$subject(str, false, false, false, false, null, null, owner, false, false, subject);
    },
    _report$5$but$negative$object$subject: function(str, but, negative, object, subject) {
      return this._report$11$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$preferShipAsObject$subject(str, but, false, false, negative, object, null, null, false, false, subject);
    },
    _report$2$object: function(str, object) {
      return this._report$11$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$preferShipAsObject$subject(str, false, false, false, false, object, null, null, false, false, null);
    },
    _report$2$negative: function(str, negative) {
      return this._report$11$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$preferShipAsObject$subject(str, false, false, false, negative, null, null, null, false, false, null);
    },
    _report$3$positive$preferShipAsObject: function(str, positive, preferShipAsObject) {
      return this._report$11$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$preferShipAsObject$subject(str, false, false, false, false, null, null, null, positive, preferShipAsObject, null);
    },
    _report$3$isSupportiveActionInThread$preferShipAsObject: function(str, isSupportiveActionInThread, preferShipAsObject) {
      return this._report$11$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$preferShipAsObject$subject(str, false, false, isSupportiveActionInThread, false, null, null, null, false, preferShipAsObject, null);
    },
    _report$2$preferShipAsObject: function(str, preferShipAsObject) {
      return this._report$11$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$preferShipAsObject$subject(str, false, false, false, false, null, null, null, false, preferShipAsObject, null);
    },
    isEligible$2$targetShip$targetSystem: ["super$CombatMove$isEligible$2$targetShip$targetSystem", function(targetShip, targetSystem) {
      var t1, t2;
      if (this.get$needsTargetShip()) {
        if (this.targetShip != null)
          targetShip = this.targetShip;
        if (targetShip != null)
          t1 = !(targetShip.get$isAlive() && H.boolConversionCheck(targetShip.isActive));
        else
          t1 = true;
        if (t1)
          return false;
      }
      if (!this.get$needsTargetShip() && this.get$needsTargetSystem()) {
        if (this.targetSystem != null)
          targetSystem = this.targetSystem;
        if (targetSystem != null)
          t1 = !(targetSystem.get$isAlive() && H.boolConversionCheck(targetSystem.isActive));
        else
          t1 = true;
        if (t1)
          return false;
      }
      if (!this.isActive)
        return false;
      t1 = this.system;
      t2 = t1.hp._numscale$_value;
      if (typeof t2 !== "number")
        return t2.$gt();
      if (!(t2 > 0))
        return false;
      t1 = t1.spaceship;
      if (!(t1.get$isAlive() && H.boolConversionCheck(t1.isActive)))
        return false;
      return true;
    }, function() {
      return this.isEligible$2$targetShip$targetSystem(null, null);
    }, "isEligible$0", null, null, "get$isEligible", 0, 5, null, 0, 0],
    calculateSuccessChance$3: function(originSystem, targetShip, targetSystem) {
      return this.get$defaultSuccessChance();
    },
    update$0: function() {
      var t1, t2;
      if (this.system == null)
        throw H.wrapException(P.StateError$("Cannot call update() on a prototype move. Create a clone instance first."));
      if ((this.currentTimeToSetup != null || this.currentTimeToFinish != null) && !this.isEligible$0()) {
        this.reportCannotContinue$0();
        this.currentTimeToSetup = null;
        this.currentTimeToFinish = null;
      }
      t1 = this.currentTimeToSetup;
      if (t1 != null) {
        t2 = this.get$timeToSetup();
        if (t1 == null ? t2 == null : t1 === t2) {
          t1 = this.system.spaceship.pilot;
          t1 = t1 != null && t1.isPlayer && !this.isAutoRepeatContinuation;
        } else
          t1 = false;
        if (t1)
          this.reportSettingUp$0();
        t1 = this.currentTimeToSetup;
        if (typeof t1 !== "number")
          return t1.$sub();
        --t1;
        this.currentTimeToSetup = t1;
        if (t1 <= 0) {
          this.currentTimeToSetup = null;
          this.currentTimeToFinish = this.get$timeToFinish();
        }
        return;
      }
      t1 = this.currentTimeToFinish;
      if (t1 == null)
        return;
      t2 = this.get$timeToFinish();
      if (t1 == null ? t2 == null : t1 === t2)
        this.reportStarting$0();
      if (S.Randomly_saveAgainst(this.system.powerInput.get$percentage())) {
        t1 = this.currentTimeToFinish;
        if (typeof t1 !== "number")
          return t1.$sub();
        this.currentTimeToFinish = t1 - 1;
      }
      if (this.currentTimeToFinish === 0) {
        if (S.Randomly_saveAgainst(this.calculateSuccessChance$3(this.system, this.targetShip, this.targetSystem))) {
          this.reportSuccess$0();
          this.onSuccess$0();
        } else {
          this.reportFailure$0();
          this.onFailure$0();
        }
        this._isFinished = true;
        this.currentTimeToFinish = null;
      }
    },
    static: {"^": "CombatMove_name<"}
  },
  FireGun: {
    "^": "CombatMove;needsTargetShip:FireGun_needsTargetShip<,needsTargetSystem:FireGun_needsTargetSystem<,isAutoRepeating:FireGun_isAutoRepeating<,timeToSetup:FireGun_timeToSetup<,timeToFinish:FireGun_timeToFinish<,stringSuccess:FireGun_stringSuccess<,chanceOfImproveAimOnSuccess<,chanceOfImproveAimOnFailure<,defaultSuccessChance:FireGun_defaultSuccessChance<,system,targetShip,targetSystem,isActive,onlyActorGetsReports,stringStarting,stringCannotContinue,stringSuccess,stringSuccessFromTarget,stringFailure,stringAutoRepeat,needsTargetShip,needsTargetSystem,isAutoRepeating,isAutoRepeatContinuation,defaultSuccessChance,timeToSetup,currentTimeToSetup,timeToFinish,currentTimeToFinish,_isFinished",
    set$needsTargetShip: function(needsTargetShip) {
      this.FireGun_needsTargetShip = H.boolTypeCheck(needsTargetShip);
    },
    set$needsTargetSystem: function(needsTargetSystem) {
      this.FireGun_needsTargetSystem = H.boolTypeCheck(needsTargetSystem);
    },
    set$isAutoRepeating: function(isAutoRepeating) {
      this.FireGun_isAutoRepeating = H.boolTypeCheck(isAutoRepeating);
    },
    set$timeToSetup: function(timeToSetup) {
      this.FireGun_timeToSetup = H.intTypeCheck(timeToSetup);
    },
    set$timeToFinish: function(timeToFinish) {
      this.FireGun_timeToFinish = H.intTypeCheck(timeToFinish);
    },
    set$stringSuccess: function(stringSuccess) {
      this.FireGun_stringSuccess = H.stringTypeCheck(stringSuccess);
    },
    set$defaultSuccessChance: function(defaultSuccessChance) {
      this.FireGun_defaultSuccessChance = H.numTypeCheck(defaultSuccessChance);
    },
    clone$1: function(system) {
      var clone;
      H.interceptedTypeCheck(system, "$isShipSystem");
      clone = new M.FireGun(true, true, false, 1, 4, null, 0.2, 0.2, 0.8, null, null, null, true, false, "<subject> {initiate|start}<s> the undefined move", "", "<subject> successfully finish<es> undefined move", "<subject> successfully finish<es> undefined move", "<subject> fail<s> to perform undefined move", "", true, true, false, false, 1, null, null, null, null, false);
      M.CombatMove_cloneFieldsToExisting(this, clone);
      clone.system = system;
      clone.chanceOfImproveAimOnFailure = this.get$chanceOfImproveAimOnFailure();
      clone.chanceOfImproveAimOnSuccess = this.get$chanceOfImproveAimOnSuccess();
      return clone;
    },
    get$commandText: function() {
      return "take a shot";
    },
    reportSettingUp$0: function() {
      var pilot, t1, t2;
      pilot = this.system.spaceship.pilot;
      if (pilot == null || !pilot.isPlayer)
        throw H.wrapException(P.StateError$("reportSettingUp should not have been called since this spaceship's pilot is null or is not player"));
      t1 = $.get$storyline();
      t2 = this.targetShip;
      t1.add$6$actionThread$isSupportiveActionInThread$object$subject$time(0, "<subject> {start<s> {aiming at|taking aim at|fixing on|zeroing in on}|begin<s> to {{take |}aim at|fix on|zero in on}} <object>", H.Primitives_objectHashCode(this), true, t2, pilot, this.system.spaceship.currentCombat.timeline.time);
    },
    get$stringStarting: function() {
      return;
    },
    reportSuccess$0: function() {
      var t1, owner, subject;
      t1 = this.system;
      owner = t1.spaceship;
      if (!owner.pilot.isPlayer) {
        H.interceptedTypeCast(t1, "$isWeapon");
        subject = t1;
      } else {
        owner = null;
        subject = null;
      }
      this._report$3$owner$subject("<owner's> <subject> {shoot<s>|fire<s>} at <object-owner's> <object>", owner, subject);
    },
    onSuccess$0: [function() {
      this._hit$1(this.targetSystem);
    }, "call$0", "get$onSuccess", 0, 0, 4],
    _hit$2$collateral: function(targetSystem, collateral) {
      var damage, object, shield, t1, t2, t3, relativePosition;
      damage = H.interceptedTypeCast(this.system, "$isWeapon").damage;
      object = M.CombatMove_getTargetObject(targetSystem.spaceship, targetSystem);
      if (damage === 0)
        return;
      shield = targetSystem.spaceship.shield;
      t1 = shield.get$isAlive() && H.boolConversionCheck(shield.isActive) && shield.sp._numscale$_value !== 0;
      if (t1)
        if (!S.Randomly_saveAgainst(H.interceptedTypeCast(this.system, "$isWeapon").shieldPenetration)) {
          this._report$2$positive("<owner's> <subject> {drill<s> into|hit<s>} <object's> shield", true);
          t1 = C.JSInt_methods.$gt(damage, shield.sp._numscale$_value);
          t2 = shield.sp;
          if (t1) {
            damage = C.JSInt_methods.$sub(damage, t2._numscale$_value);
            shield.sp.set$value(0);
          } else {
            t1 = t2._numscale$_value;
            t3 = H.interceptedTypeCast(this.system, "$isWeapon").damage;
            if (typeof t1 !== "number")
              return t1.$sub();
            t2.set$value(t1 - t3);
            damage = 0;
          }
        } else {
          t1 = $.get$storyline();
          t2 = H.interceptedTypeCast(this.system, "$isWeapon");
          t3 = t2.projectile;
          t1.add$5$object$positive$subject$time(0, "<subject> goes {right|} through <object's> shield", targetSystem.spaceship, true, t3, t2.spaceship.currentCombat.timeline.time);
        }
      if (damage > 0) {
        relativePosition = this.system.spaceship.getPositionTowards$1(targetSystem.spaceship);
        if (collateral) {
          H.assertHelper(targetSystem instanceof M.Hull);
          t1 = H.interceptedTypeCast(this.system, "$isWeapon").projectile;
          this._report$5$object$objectOwner$positive$subject("<subject> land<s> on <object-owner's> <object> instead", targetSystem, targetSystem.spaceship, true, t1);
        } else {
          if (typeof relativePosition !== "number")
            return relativePosition.$ge();
          if (relativePosition >= 2) {
            damage *= 1.5;
            this._report$4$object$positive$subject("<subject> hit<s> <object's> weakest spot", object, true, H.interceptedTypeCast(this.system, "$isWeapon").projectile);
          } else if (relativePosition >= 1) {
            damage *= 1.25;
            this._report$4$object$positive$subject("<subject> hit<s> one of <object's> weaker spots", object, true, H.interceptedTypeCast(this.system, "$isWeapon").projectile);
          } else if (relativePosition >= 0) {
            t1 = H.interceptedTypeCast(this.system, "$isWeapon").projectile;
            this._report$4$object$positive$subject("<subject> hit<s>", $.get$Entity_NOTHING(), true, t1);
          } else {
            t1 = this.system;
            if (relativePosition >= -1) {
              damage /= 1.25;
              this._report$4$negative$object$subject("<subject> hit<s> one of <object's> tougher spots", true, object, H.interceptedTypeCast(t1, "$isWeapon").projectile);
            } else {
              damage /= 1.5;
              this._report$4$negative$object$subject("<subject> hit<s> <object's> toughest spot", true, object, H.interceptedTypeCast(t1, "$isWeapon").projectile);
            }
          }
        }
        t1 = targetSystem.hp;
        t2 = t1._numscale$_value;
        if (typeof t2 !== "number")
          return t2.$sub();
        t1.set$value(t2 - damage);
      }
      if (S.Randomly_saveAgainst(this.get$chanceOfImproveAimOnSuccess()))
        this._improveAim$0();
    },
    _hit$1: function(targetSystem) {
      return this._hit$2$collateral(targetSystem, false);
    },
    reportFailure$0: function() {
      var t1, owner, subject, object, miss;
      t1 = this.system;
      owner = t1.spaceship;
      if (!owner.pilot.isPlayer) {
        H.interceptedTypeCast(t1, "$isWeapon");
        subject = t1;
      } else {
        owner = null;
        subject = null;
      }
      this._report$3$owner$subject("<owner's> <subject> {shoot<s>|fire<s>} at <object-owner's> <object>", owner, subject);
      object = this.targetSystem;
      if (object instanceof M.Hull) {
        object = $.get$Entity_NOTHING();
        miss = "<subject> {fail<s> to hit|miss<es>|go<es> wide}";
      } else
        miss = "<subject> {fail<s> to hit|miss<es>|go<es> wide of} <object>";
      this._report$5$but$negative$object$subject(miss, true, true, object, H.interceptedTypeCast(this.system, "$isWeapon").projectile);
    },
    onFailure$0: [function() {
      var t1, t2;
      if (!(this.targetSystem instanceof M.Hull)) {
        t1 = this.system;
        t2 = this.targetShip;
        t2 = S.Randomly_saveAgainst(this.calculateSuccessChance$3(t1, t2, t2.hull) / 2);
        t1 = this.targetShip;
        if (t2)
          this._hit$2$collateral(t1.hull, true);
        else
          this._report$5$endSentence$negative$object$subject("<subject> completely {miss<es>|go<es> wide of} <object>, too", true, true, t1, H.interceptedTypeCast(this.system, "$isWeapon").projectile);
      }
      if (S.Randomly_saveAgainst(this.get$chanceOfImproveAimOnFailure()))
        this._improveAim$0();
    }, "call$0", "get$onFailure", 0, 0, 4],
    _improveAim$0: function() {
      var t1, t2, t3, owner, owner0;
      t1 = this.targetShip;
      if (!(t1.get$isAlive() && H.boolConversionCheck(t1.isActive)))
        return;
      t1 = H.interceptedTypeCast(this.system, "$isWeapon");
      t2 = this.targetShip;
      t3 = t1.getAimAt$1(t2);
      if (typeof t3 !== "number")
        return t3.$add();
      t1._aimMap.$indexSet(0, t2, t3 + 1);
      t1 = H.interceptedTypeCast(this.system, "$isWeapon");
      owner = t1.spaceship;
      owner0 = owner.pilot;
      owner0 = owner0.isPlayer ? owner0 : owner;
      $.get$storyline().add$6$object$owner$positive$subject$time(0, "<owner's> <subject's> aim at <object> gets better", this.targetShip, owner0, true, t1, owner.currentCombat.timeline.time);
    },
    isEligible$2$targetShip$targetSystem: function(targetShip, targetSystem) {
      var t1;
      if (!this.super$CombatMove$isEligible$2$targetShip$targetSystem(targetShip, targetSystem))
        return false;
      t1 = this.system.powerInput;
      if (t1._numscale$_value !== t1.max)
        return false;
      return true;
    },
    isEligible$0: function() {
      return this.isEligible$2$targetShip$targetSystem(null, null);
    },
    calculateSuccessChance$3: function(originSystem, targetShip, targetSystem) {
      var chance;
      H.interceptedTypeCast(originSystem, "$isWeapon");
      if (targetSystem == null)
        targetSystem = this.targetSystem;
      if (targetSystem == null && targetShip != null)
        targetSystem = targetShip.hull;
      if (targetSystem == null)
        return 0;
      chance = this.get$defaultSuccessChance() * targetSystem.get$exposedFactor() * originSystem.accuracyModifier - targetSystem.spaceship.get$maneuverability() / 100 + C.JSDouble_methods.$mul(0.1, originSystem.getAimAt$1(targetShip));
      if (chance < 0)
        return 0;
      if (chance > 1)
        return 1;
      return chance;
    },
    static: {"^": "FireGun_name<"}
  },
  QuickFireGun: {
    "^": "FireGun;commandText<,timeToSetup:QuickFireGun_timeToSetup<,timeToFinish:QuickFireGun_timeToFinish<,chanceOfImproveAimOnSuccess:QuickFireGun_chanceOfImproveAimOnSuccess<,chanceOfImproveAimOnFailure:QuickFireGun_chanceOfImproveAimOnFailure<,defaultSuccessChance:QuickFireGun_defaultSuccessChance<,FireGun_needsTargetShip,FireGun_needsTargetSystem,FireGun_isAutoRepeating,FireGun_timeToSetup,FireGun_timeToFinish,FireGun_stringSuccess,chanceOfImproveAimOnSuccess,chanceOfImproveAimOnFailure,FireGun_defaultSuccessChance,system,targetShip,targetSystem,isActive,onlyActorGetsReports,stringStarting,stringCannotContinue,stringSuccess,stringSuccessFromTarget,stringFailure,stringAutoRepeat,needsTargetShip,needsTargetSystem,isAutoRepeating,isAutoRepeatContinuation,defaultSuccessChance,timeToSetup,currentTimeToSetup,timeToFinish,currentTimeToFinish,_isFinished",
    reportSettingUp$0: function() {
      var t1, pilot, t2, t3;
      t1 = this.system;
      pilot = t1.spaceship.pilot;
      if (pilot == null || !pilot.isPlayer)
        throw H.wrapException(P.StateError$("reportSettingUp should not have been called since this spaceship's pilot is null or is not player"));
      t2 = $.get$storyline();
      t3 = this.targetShip;
      t2.add$7$actionThread$isSupportiveActionInThread$object$owner$subject$time(0, "<subject> decide<s> to take a quick shot at <object>", H.Primitives_objectHashCode(this), true, t3, t1, pilot, this.system.spaceship.currentCombat.timeline.time);
    }
  },
  ImproveAim: {
    "^": "CombatMove;timeToSetup:ImproveAim_timeToSetup<,timeToFinish:ImproveAim_timeToFinish<,needsTargetShip:ImproveAim_needsTargetShip<,needsTargetSystem:ImproveAim_needsTargetSystem<,stringSettingUp<,stringStarting:ImproveAim_stringStarting<,defaultSuccessChance:ImproveAim_defaultSuccessChance<,stringSuccess:ImproveAim_stringSuccess<,stringFailure:ImproveAim_stringFailure<,improvementStep,system,targetShip,targetSystem,isActive,onlyActorGetsReports,stringStarting,stringCannotContinue,stringSuccess,stringSuccessFromTarget,stringFailure,stringAutoRepeat,needsTargetShip,needsTargetSystem,isAutoRepeating,isAutoRepeatContinuation,defaultSuccessChance,timeToSetup,currentTimeToSetup,timeToFinish,currentTimeToFinish,_isFinished",
    set$timeToSetup: function(timeToSetup) {
      this.ImproveAim_timeToSetup = H.intTypeCheck(timeToSetup);
    },
    set$timeToFinish: function(timeToFinish) {
      this.ImproveAim_timeToFinish = H.intTypeCheck(timeToFinish);
    },
    set$needsTargetShip: function(needsTargetShip) {
      this.ImproveAim_needsTargetShip = H.boolTypeCheck(needsTargetShip);
    },
    set$needsTargetSystem: function(needsTargetSystem) {
      this.ImproveAim_needsTargetSystem = H.boolTypeCheck(needsTargetSystem);
    },
    set$defaultSuccessChance: function(defaultSuccessChance) {
      this.ImproveAim_defaultSuccessChance = H.numTypeCheck(defaultSuccessChance);
    },
    set$stringSuccess: function(stringSuccess) {
      this.ImproveAim_stringSuccess = H.stringTypeCheck(stringSuccess);
    },
    set$stringFailure: function(stringFailure) {
      this.ImproveAim_stringFailure = H.stringTypeCheck(stringFailure);
    },
    clone$1: function(system) {
      var clone;
      H.interceptedTypeCheck(system, "$isShipSystem");
      clone = new M.ImproveAim(1, 3, true, true, null, "<subject> {start<s> {aiming at|taking aim at|fixing on|zeroing in on}|begin<s> to {{take |}aim at|fix on|zero in on}} <object>", 0.9, "<subject> successfully improve<s> <subject's> aim on <object>", "<subject's> aim on <object> doesn't improve", 1, null, null, null, true, false, "<subject> {initiate|start}<s> the undefined move", "", "<subject> successfully finish<es> undefined move", "<subject> successfully finish<es> undefined move", "<subject> fail<s> to perform undefined move", "", true, true, false, false, 1, null, null, null, null, false);
      M.CombatMove_cloneFieldsToExisting(this, clone);
      clone.system = system;
      clone.improvementStep = this.improvementStep;
      return clone;
    },
    get$commandText: function() {
      return "improve aim";
    },
    reportStarting$0: function() {
      return H.voidTypeCheck(this._report$3$isSupportiveActionInThread$preferShipAsObject(this.ImproveAim_stringStarting, true, true));
    },
    reportSuccess$0: function() {
      return H.voidTypeCheck(this._report$3$positive$preferShipAsObject(this.ImproveAim_stringSuccess, true, true));
    },
    onSuccess$0: [function() {
      var weapon, t1, t2, t3;
      weapon = H.interceptedTypeCast(this.system, "$isWeapon");
      t1 = this.targetShip;
      t2 = weapon.getAimAt$1(t1);
      t3 = this.improvementStep;
      if (typeof t2 !== "number")
        return t2.$add();
      weapon._aimMap.$indexSet(0, t1, t2 + t3);
    }, "call$0", "get$onSuccess", 0, 0, 4],
    reportFailure$0: function() {
      return H.voidTypeCheck(this._report$3$negative$preferShipAsObject(this.ImproveAim_stringFailure, true, true));
    }
  },
  AutoGunStart: {
    "^": "FireGun;isAutoRepeating:AutoGunStart_isAutoRepeating<,FireGun_needsTargetShip,FireGun_needsTargetSystem,FireGun_isAutoRepeating,FireGun_timeToSetup,FireGun_timeToFinish,FireGun_stringSuccess,chanceOfImproveAimOnSuccess,chanceOfImproveAimOnFailure,FireGun_defaultSuccessChance,system,targetShip,targetSystem,isActive,onlyActorGetsReports,stringStarting,stringCannotContinue,stringSuccess,stringSuccessFromTarget,stringFailure,stringAutoRepeat,needsTargetShip,needsTargetSystem,isAutoRepeating,isAutoRepeatContinuation,defaultSuccessChance,timeToSetup,currentTimeToSetup,timeToFinish,currentTimeToFinish,_isFinished"
  },
  SpaceshipCombatMove: {
    "^": "CombatMove;needsTargetSystem:SpaceshipCombatMove_needsTargetSystem<",
    set$needsTargetSystem: function(needsTargetSystem) {
      this.SpaceshipCombatMove_needsTargetSystem = H.boolTypeCheck(needsTargetSystem);
    },
    isEligible$2$targetShip$targetSystem: function(targetShip, targetSystem) {
      var t1;
      if (this.get$needsTargetShip()) {
        if (this.targetShip != null)
          targetShip = this.targetShip;
        if (targetShip != null)
          t1 = !(targetShip.get$isAlive() && H.boolConversionCheck(targetShip.isActive));
        else
          t1 = true;
        if (t1)
          return false;
      }
      t1 = this.system.spaceship;
      if (!(t1.get$isAlive() && H.boolConversionCheck(t1.isActive)))
        return false;
      return true;
    },
    isEligible$0: function() {
      return this.isEligible$2$targetShip$targetSystem(null, null);
    },
    reportStarting$0: function() {
      return H.voidTypeCheck(this._report$3$isSupportiveActionInThread$preferShipAsObject(this.get$stringStarting(), true, true));
    },
    reportSuccess$0: function() {
      return H.voidTypeCheck(this._report$3$positive$preferShipAsObject(this.get$stringSuccess(), true, true));
    },
    reportCannotContinue$0: function() {
      return H.voidTypeCheck(this._report$2$preferShipAsObject(this.stringCannotContinue, true));
    },
    reportFailure$0: function() {
      return H.voidTypeCheck(this._report$3$negative$preferShipAsObject(this.get$stringFailure(), true, true));
    },
    reportAutoRepeat$0: function() {
      return H.voidTypeCheck(this._report$2$preferShipAsObject(this.stringAutoRepeat, true));
    }
  },
  ImprovePosition: {
    "^": "SpaceshipCombatMove;commandText<,timeToSetup:ImprovePosition_timeToSetup<,timeToFinish:ImprovePosition_timeToFinish<,defaultSuccessChance:ImprovePosition_defaultSuccessChance<,improvementStep<,needsTargetShip:ImprovePosition_needsTargetShip<,stringSettingUp<,stringStarting:ImprovePosition_stringStarting<,stringSuccess:ImprovePosition_stringSuccess<,stringFailure:ImprovePosition_stringFailure<,SpaceshipCombatMove_needsTargetSystem,system,targetShip,targetSystem,isActive,onlyActorGetsReports,stringStarting,stringCannotContinue,stringSuccess,stringSuccessFromTarget,stringFailure,stringAutoRepeat,needsTargetShip,needsTargetSystem,isAutoRepeating,isAutoRepeatContinuation,defaultSuccessChance,timeToSetup,currentTimeToSetup,timeToFinish,currentTimeToFinish,_isFinished",
    set$timeToSetup: function(timeToSetup) {
      this.ImprovePosition_timeToSetup = H.intTypeCheck(timeToSetup);
    },
    set$timeToFinish: function(timeToFinish) {
      this.ImprovePosition_timeToFinish = H.intTypeCheck(timeToFinish);
    },
    set$defaultSuccessChance: function(defaultSuccessChance) {
      this.ImprovePosition_defaultSuccessChance = H.numTypeCheck(defaultSuccessChance);
    },
    set$needsTargetShip: function(needsTargetShip) {
      this.ImprovePosition_needsTargetShip = H.boolTypeCheck(needsTargetShip);
    },
    set$stringSuccess: function(stringSuccess) {
      this.ImprovePosition_stringSuccess = H.stringTypeCheck(stringSuccess);
    },
    set$stringFailure: function(stringFailure) {
      this.ImprovePosition_stringFailure = H.stringTypeCheck(stringFailure);
    },
    clone$1: function(system) {
      var clone;
      H.interceptedTypeCheck(system, "$isShipSystem");
      clone = new M.ImprovePosition("improve position", 1, 5, 0.9, 1, true, null, "<subject> {start<s>|begin<s>} {trying|an attempt} to {improve|better} <subject's> position on <object>", "<subject> successfully improve<s> <subject's> position on <object>", "<subject> fail<s> to improve <subject's> position on <object>", false, null, null, null, true, false, "<subject> {initiate|start}<s> the undefined move", "", "<subject> successfully finish<es> undefined move", "<subject> successfully finish<es> undefined move", "<subject> fail<s> to perform undefined move", "", true, true, false, false, 1, null, null, null, null, false);
      M.CombatMove_cloneFieldsToExisting(this, clone);
      clone.system = system;
      clone.improvementStep = this.get$improvementStep();
      return clone;
    },
    onSuccess$0: [function() {
      var t1, t2, t3, t4;
      t1 = this.system.spaceship;
      t2 = this.targetShip;
      t3 = this.get$improvementStep();
      t4 = t1.getPositionTowards$1(t2);
      if (typeof t4 !== "number")
        return t4.$add();
      t1.setPositionTowards$2(t2, t4 + t3);
      t4 = t2.getPositionTowards$1(t1);
      if (typeof t4 !== "number")
        return t4.$sub();
      t2.setPositionTowards$2(t1, t4 - t3);
    }, "call$0", "get$onSuccess", 0, 0, 4]
  },
  RiskyImprovePosition: {
    "^": "ImprovePosition;commandText:RiskyImprovePosition_commandText<,defaultSuccessChance:RiskyImprovePosition_defaultSuccessChance<,improvementStep:RiskyImprovePosition_improvementStep<,regressionChance,stringStarting:RiskyImprovePosition_stringStarting<,stringSuccess:RiskyImprovePosition_stringSuccess<,stringFailure:RiskyImprovePosition_stringFailure<,commandText,ImprovePosition_timeToSetup,ImprovePosition_timeToFinish,ImprovePosition_defaultSuccessChance,improvementStep,ImprovePosition_needsTargetShip,stringSettingUp,ImprovePosition_stringStarting,ImprovePosition_stringSuccess,ImprovePosition_stringFailure,SpaceshipCombatMove_needsTargetSystem,system,targetShip,targetSystem,isActive,onlyActorGetsReports,stringStarting,stringCannotContinue,stringSuccess,stringSuccessFromTarget,stringFailure,stringAutoRepeat,needsTargetShip,needsTargetSystem,isAutoRepeating,isAutoRepeatContinuation,defaultSuccessChance,timeToSetup,currentTimeToSetup,timeToFinish,currentTimeToFinish,_isFinished",
    set$defaultSuccessChance: function(defaultSuccessChance) {
      this.RiskyImprovePosition_defaultSuccessChance = H.numTypeCheck(defaultSuccessChance);
    },
    set$stringSuccess: function(stringSuccess) {
      this.RiskyImprovePosition_stringSuccess = H.stringTypeCheck(stringSuccess);
    },
    set$stringFailure: function(stringFailure) {
      this.RiskyImprovePosition_stringFailure = H.stringTypeCheck(stringFailure);
    },
    clone$1: function(system) {
      var clone;
      H.interceptedTypeCheck(system, "$isShipSystem");
      clone = new M.RiskyImprovePosition("reversal maneuvre", 0.3, 3, 0.2, "<subject> {start<s>|begin<s>} a {risky|daring} maneuvre to gain positional advantage on <object>", "<subject> successfully pull<s> off the maneuvre on <object>", "<subject's> maneuvre fails", "improve position", 1, 5, 0.9, 1, true, null, "<subject> {start<s>|begin<s>} {trying|an attempt} to {improve|better} <subject's> position on <object>", "<subject> successfully improve<s> <subject's> position on <object>", "<subject> fail<s> to improve <subject's> position on <object>", false, null, null, null, true, false, "<subject> {initiate|start}<s> the undefined move", "", "<subject> successfully finish<es> undefined move", "<subject> successfully finish<es> undefined move", "<subject> fail<s> to perform undefined move", "", true, true, false, false, 1, null, null, null, null, false);
      M.CombatMove_cloneFieldsToExisting(this, clone);
      clone.system = system;
      clone.RiskyImprovePosition_improvementStep = this.RiskyImprovePosition_improvementStep;
      clone.regressionChance = this.regressionChance;
      return clone;
    },
    reportFailure$0: function() {
      return H.voidTypeCheck(this._report$2$object(this.RiskyImprovePosition_stringFailure, $.get$Entity_NOTHING()));
    },
    onFailure$0: [function() {
      if (S.Randomly_saveAgainst(this.regressionChance))
        this._report$1("in fact, <subject's> position on <object> worsens");
    }, "call$0", "get$onFailure", 0, 0, 4]
  },
  Pilot: {
    "^": "Actor;spaceship<,timeToNextInteraction,nameIsProperNoun,name,categories,alreadyMentioned,team,isActive,isPlayer,pronoun",
    set$spaceship: function(spaceship) {
      this.spaceship = H.interceptedTypeCheck(spaceship, "$isSpaceship");
    },
    update$0: function() {
      var t1, t2, form, t3, t4;
      if (!(this.get$isAlive() && H.boolConversionCheck(this.isActive)))
        return;
      t1 = this.spaceship;
      if (t1 != null && this.timeToNextInteraction <= 0)
        if (this.isPlayer) {
          t1 = t1.getManeuvreSetupSection$0();
          t2 = this.spaceship.getSystemSetupSections$0();
          H.assertSubtype(t2, "$isList", [G.FormSection], "$asList");
          form = G.Form$(null);
          t3 = form.get$children();
          t4 = this._createCurrentStatusText$0();
          t3._childNodes.add$1(0, t4);
          form.get$children()._childNodes.add$1(0, t1);
          form.get$children().addAll$1(0, t2);
          $._currentForm = form;
        } else
          this._aiChooseMove$2(t1.getManeuvreSetupSection$0(), this.spaceship.getSystemSetupSections$0());
      --this.timeToNextInteraction;
    },
    _createCurrentStatusText$0: function() {
      var t1, t2, section, text, buf, t3, t4;
      t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t2 = H.setRuntimeTypeInfo([], [B.Node0]);
      t2 = new B.NodeList(null, H.assertSubtype(t2, "$isList", [B.Node0], "$asList"));
      H.assertSubtype(t1, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      section = new G.FormSection(null, "FormSection", null, t1, t2, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t2._parent = section;
      t1.$indexSet(0, "name", "Info");
      t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t2 = H.setRuntimeTypeInfo([], [B.Node0]);
      t2 = new B.NodeList(null, H.assertSubtype(t2, "$isList", [B.Node0], "$asList"));
      text = new G.TextOutput(null, null, null, "TextOutput", null, H.assertSubtype(t1, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap"), t2, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t2._parent = text;
      buf = new P.StringBuffer("");
      buf._contents = "<table class='form-table'>";
      t2 = "<table class='form-table'>" + ("<tr><th></th><th>Hull</th><th>Weapons</th><th>Speed</th><th>Position to " + H.S(this.spaceship.name) + "</th></tr>");
      buf._contents = t2;
      buf._contents = t2 + this._createTableRowForShip$2(this.spaceship, null);
      t2 = this.spaceship.currentCombat.get$spaceships();
      t1 = new M.Pilot__createCurrentStatusText_closure(this);
      t3 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t3, [t2.E()])._assertCheck$1(t1);
      t4 = H.getRuntimeTypeArgument(t2, "IterableBase", 0);
      H.listSuperNativeTypeCheck(t2, "$isIterable");
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t1);
      H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t2, "$isIterable"), H.buildFunctionType(t3, [H.getDynamicRuntimeType()])._assertCheck$1(t1)), [t4]), "$isIterable").forEach$1(0, new M.Pilot__createCurrentStatusText_closure0(this, buf));
      t2 = buf._contents += "</table>";
      text.html = t2.charCodeAt(0) == 0 ? t2 : t2;
      section.get$children()._childNodes.add$1(0, text);
      return section;
    },
    _createTableRowForShip$2: function(ship, reference) {
      var t1;
      H.interceptedTypeCheck(ship, "$isSpaceship");
      t1 = "<tr>" + ("<td>" + H.S(ship.name) + "</td>") + ("<td>" + ("" + C.JSNumber_methods.round$0(ship.hull.hp.get$percentage() * 100) + "%") + "</td>");
      t1 + "<td>50%</td>";
      t1 += "<td>50%</td><td>slow</td>";
      t1 = (reference != null ? t1 + ("<td>" + ship.getPositionStringTowards$2$wrapInColor(reference, true) + "</td>") : t1 + "<td>&mdash;</td>") + "</tr>";
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _aiChooseMove$2: function(maneuvres, sections) {
      var t1, t2, t3, t4, t5, t6;
      t1 = [[maneuvres], H.assertSubtype(sections, "$isList", [G.FormSection], "$asList")];
      t2 = new M.Pilot__aiChooseMove_closure();
      t3 = H.getDynamicRuntimeType();
      t4 = H.buildInterfaceType(P.Iterable, [t3]);
      H.buildFunctionType(t4, [H.convertRtiToRuntimeType(t1.$builtinTypeInfo && t1.$builtinTypeInfo[0])])._assertCheck$1(t2);
      t5 = H.getTypeArgumentByIndex(t1, 0);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      t6 = H.buildInterfaceType(P.Iterable, [H.convertRtiToRuntimeType(null)]);
      H.buildFunctionType(t6, [H.convertRtiToRuntimeType(t5)])._assertCheck$1(t2);
      t3 = H.buildFunctionType(t4, [t3]);
      t5 = H.setRuntimeTypeInfo(new H.ExpandIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), t3._assertCheck$1(t2)), [t5, null]);
      t2 = new M.Pilot__aiChooseMove_closure0();
      H.buildFunctionType(t4, [t5.E()])._assertCheck$1(t2);
      t4 = H.getRuntimeTypeArgument(t5, "IterableBase", 0);
      H.listSuperNativeTypeCheck(t5, "$isIterable");
      H.buildFunctionType(t6, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
      t4 = H.setRuntimeTypeInfo(new H.ExpandIterable(H.listSuperNativeTypeCheck(t5, "$isIterable"), t3._assertCheck$1(t2)), [t4, null]);
      H.interceptedTypeCheck(S.Randomly_choose(H.assertSubtype(H.assertSubtype(P.List_List$from(t4, false, H.getRuntimeTypeArgument(t4, "IterableBase", 0)), "$isList", [H.getRuntimeTypeArgument(t4, "IterableBase", 0)], "$asList"), "$isList", [G.SubmitButton], "$asList")), "$isSubmitButton").onSubmit$0();
    }
  },
  Pilot__createCurrentStatusText_closure: {
    "^": "Closure:2;_spaceship$_captured_this_0",
    call$1: function(ship) {
      return !J.$eq(ship, this._spaceship$_captured_this_0.spaceship);
    }
  },
  Pilot__createCurrentStatusText_closure0: {
    "^": "Closure:2;_spaceship$_captured_this_1,_captured_buf_2",
    call$1: function(otherShip) {
      var t1 = this._spaceship$_captured_this_1;
      this._captured_buf_2._contents += t1._createTableRowForShip$2(otherShip, t1.spaceship);
    }
  },
  Pilot__aiChooseMove_closure: {
    "^": "Closure:2;",
    call$1: function(e) {
      return e;
    }
  },
  Pilot__aiChooseMove_closure0: {
    "^": "Closure:32;",
    call$1: function(s) {
      var t1, t2, t3, t4;
      t1 = H.interceptedTypeCheck(s, "$isFormSection").get$children();
      t2 = new M.Pilot__aiChooseMove__closure();
      t1.toString;
      t3 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t3, [H.buildInterfaceType(B.Element)])._assertCheck$1(t2);
      t1 = t1.get$_filtered();
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t1.$builtinTypeInfo && t1.$builtinTypeInfo[0])])._assertCheck$1(t2);
      t4 = H.getTypeArgumentByIndex(t1, 0);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
      return H.listSuperNativeTypeCheck(H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), H.buildFunctionType(t3, [H.getDynamicRuntimeType()])._assertCheck$1(t2)), [t4]), "$isIterable"), "$isIterable");
    }
  },
  Pilot__aiChooseMove__closure: {
    "^": "Closure:2;",
    call$1: function(el) {
      return el instanceof G.SubmitButton;
    }
  },
  ShipSystem: {
    "^": "Actor;name:ShipSystem_name<,spaceship<,hp,powerInput,isOutsideHull<,availableMoves,currentMove,stringFullRepair,stringDestroy<,nameIsProperNoun,name,categories,alreadyMentioned,team,isActive,isPlayer,pronoun",
    set$name: function($name) {
      this.ShipSystem_name = H.stringTypeCheck($name);
    },
    set$spaceship: function(spaceship) {
      this.spaceship = H.interceptedTypeCheck(spaceship, "$isSpaceship");
    },
    set$availableMoves: function(availableMoves) {
      this.availableMoves = H.assertSubtype(availableMoves, "$isList", [M.CombatMove], "$asList");
    },
    get$isAlive: function() {
      var t1 = this.hp._numscale$_value;
      if (typeof t1 !== "number")
        return t1.$gt();
      return t1 > 0;
    },
    get$exposedFactor: function() {
      if (!!this.$isHull)
        return 1;
      if (!this.get$isOutsideHull())
        return 0;
      else
        return this.hp.max / this.spaceship.hull.hp.max;
    },
    _report$3$negative$positive: function(str, negative, positive) {
      var t1, t2;
      t1 = $.get$storyline();
      t2 = this.spaceship;
      t1.add$6$negative$owner$positive$subject$time(0, str, negative, t2, positive, this, t2.currentCombat.timeline.time);
    },
    _report$2$negative: function(str, negative) {
      return this._report$3$negative$positive(str, negative, false);
    },
    _report$2$positive: function(str, positive) {
      return this._report$3$negative$positive(str, false, positive);
    },
    update$0: function() {
      var t1 = this.currentMove;
      if (t1 != null) {
        t1.update$0();
        t1 = this.currentMove;
        if (t1._isFinished)
          if (t1.get$isAutoRepeating()) {
            P.print("autorepeat");
            this.currentMove.reportAutoRepeat$0();
            t1 = this.currentMove.clone$1(this);
            this.currentMove = t1;
            t1.isAutoRepeatContinuation = true;
            t1.currentTimeToSetup = t1.get$timeToSetup();
            t1._isFinished = false;
          } else
            this.currentMove = null;
      }
    },
    createSetupSection$0: function() {
      var t1, t2, t3, t4, section, text, allMoveSubmitButtons, t5, t6, t7, t8, targetShipInput, allTargetSystemInputs;
      t1 = {};
      t2 = Y.Storyline_capitalize(this.ShipSystem_name);
      t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t4 = H.setRuntimeTypeInfo([], [B.Node0]);
      t4 = new B.NodeList(null, H.assertSubtype(t4, "$isList", [B.Node0], "$asList"));
      H.assertSubtype(t3, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      section = new G.FormSection(null, "FormSection", null, t3, t4, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t4._parent = section;
      t3.$indexSet(0, "name", t2);
      t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t3 = H.setRuntimeTypeInfo([], [B.Node0]);
      t3 = new B.NodeList(null, H.assertSubtype(t3, "$isList", [B.Node0], "$asList"));
      text = new G.TextOutput(null, null, null, "TextOutput", null, H.assertSubtype(t2, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap"), t3, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t3._parent = text;
      if (!(this.hp.get$percentage() > 0.2)) {
        text.html = Y.Storyline_capitalize(this.ShipSystem_name) + " is not operational.";
        H.voidTypeCheck(t4.add$1(0, text));
        return section;
      }
      text.html = "This is " + this.ShipSystem_name + " section.";
      H.voidTypeCheck(t4.add$1(0, text));
      allMoveSubmitButtons = H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(M.CombatMove, G.SubmitButton), "$isMap", [M.CombatMove, G.SubmitButton], "$asMap");
      t1._captured_targetShip_0 = null;
      t1._captured_targetSystem_1 = null;
      t2 = new M.ShipSystem_createSetupSection_recalculateProbabilities(t1, this, text, allMoveSubmitButtons);
      if (!!this.$isCanHaveTarget) {
        t1._captured_targetShip_0 = this.get$targetShip();
        t1._captured_targetSystem_1 = this.get$targetSystem();
        t3 = new M.ShipSystem_createSetupSection_closure();
        t5 = H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P.Object)]);
        t5._assertCheck$1(t3);
        t6 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
        t7 = H.setRuntimeTypeInfo([], [B.Node0]);
        t7 = new B.NodeList(null, H.assertSubtype(t7, "$isList", [B.Node0], "$asList"));
        t8 = t5._assertCheck$1(null);
        H.assertSubtype(t6, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
        targetShipInput = new G.MultipleChoiceInput(t8, null, "MultipleChoiceInput", null, t6, t7, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
        t7._parent = targetShipInput;
        t6.$indexSet(0, "name", "Target ship:");
        t5._assertCheck$1(t3);
        targetShipInput.set$onInput(t3);
        allTargetSystemInputs = H.assertSubtype(H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, G.MultipleChoiceInput), "$isSet", [G.MultipleChoiceInput], "$asSet"), "$isSet", [G.MultipleChoiceInput], "$asSet");
        H.voidTypeCheck(t7.add$1(0, G.Option$("None (off)", new M.ShipSystem_createSetupSection_closure0(t1, allMoveSubmitButtons, t2, allTargetSystemInputs), null, t1._captured_targetShip_0 == null)));
        t7 = this.spaceship.currentCombat.get$spaceships();
        t3 = new M.ShipSystem_createSetupSection_closure1(this);
        t5 = H.buildInterfaceType(P.bool);
        H.buildFunctionType(t5, [t7.E()])._assertCheck$1(t3);
        t6 = H.getRuntimeTypeArgument(t7, "IterableBase", 0);
        H.listSuperNativeTypeCheck(t7, "$isIterable");
        H.buildFunctionType(t5, [H.convertRtiToRuntimeType(t6)])._assertCheck$1(t3);
        H.listSuperNativeTypeCheck(H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t7, "$isIterable"), H.buildFunctionType(t5, [H.getDynamicRuntimeType()])._assertCheck$1(t3)), [t6]), "$isIterable"), "$isIterable").forEach$1(0, new M.ShipSystem_createSetupSection_closure2(t1, allMoveSubmitButtons, t2, targetShipInput, allTargetSystemInputs));
        H.voidTypeCheck(t4.add$1(0, targetShipInput));
        allTargetSystemInputs.forEach$1(0, new M.ShipSystem_createSetupSection_closure3(section));
      }
      t3 = this.availableMoves;
      t4 = new M.ShipSystem_createSetupSection_closure4();
      t5 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t5, [H.convertRtiToRuntimeType(t3.$builtinTypeInfo && t3.$builtinTypeInfo[0])])._assertCheck$1(t4);
      t6 = H.getTypeArgumentByIndex(t3, 0);
      H.listSuperNativeTypeCheck(t3, "$isIterable");
      H.buildFunctionType(t5, [H.convertRtiToRuntimeType(t6)])._assertCheck$1(t4);
      H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t3, "$isIterable"), H.buildFunctionType(t5, [H.getDynamicRuntimeType()])._assertCheck$1(t4)), [t6]), "$isIterable").forEach$1(0, new M.ShipSystem_createSetupSection_closure5(t1, this, section, allMoveSubmitButtons));
      t2.call$0();
      return section;
    },
    ShipSystem$5$hp$maxHp$maxPowerInput$pronoun: function($name, maxHp, maxPowerInput, pronoun, _box_0) {
      var t1, hp, t2, t3;
      t1 = _box_0._captured_hp_0;
      if (t1 == null) {
        hp = R.NumScale$(null, null, maxHp, 0, null);
        _box_0._captured_hp_0 = hp;
        t1 = hp;
      }
      this.hp = t1;
      t1.upwardsChangeCallbacks.$indexSet(0, 1, new M.ShipSystem_closure(this));
      _box_0._captured_hp_0.downwardsChangeCallbacks.$indexSet(0, 0, new M.ShipSystem_closure0(this));
      t1 = _box_0._captured_hp_0.get$changesStream();
      t2 = new M.ShipSystem_closure1(_box_0, this);
      t3 = H.getVoidRuntimeType();
      H.buildFunctionType(t3, [t1.T5()])._assertCheck$1(t2);
      H.buildFunctionType(t3)._assertCheck$1(null);
      H.assertSubtype(t1._createSubscription$4(t2, null, null, false), "$isStreamSubscription", [H.getRuntimeTypeArgument(t1, "_ForwardingStream", 1)], "$asStreamSubscription");
      this.powerInput = R.NumScale$(null, null, maxPowerInput, 0, null);
    }
  },
  ShipSystem_closure: {
    "^": "Closure:2;_spaceship$_captured_this_1",
    call$1: function(_) {
      var t1 = this._spaceship$_captured_this_1;
      H.voidTypeCheck(t1._report$2$positive(t1.stringFullRepair, true));
    }
  },
  ShipSystem_closure0: {
    "^": "Closure:2;_spaceship$_captured_this_2",
    call$1: function(_) {
      var t1 = this._spaceship$_captured_this_2;
      H.voidTypeCheck(t1._report$2$negative(t1.get$stringDestroy(), true));
    }
  },
  ShipSystem_closure1: {
    "^": "Closure:30;_spaceship$_box_0,_spaceship$_captured_this_3",
    call$1: function(change) {
      var t1, t2, t3, percentage;
      H.numTypeCheck(change);
      if (typeof change !== "number")
        return change.$lt();
      if (change < 0 && this._spaceship$_box_0._captured_hp_0._numscale$_value !== 0) {
        t1 = this._spaceship$_captured_this_3;
        t2 = Math.abs(change);
        t3 = t1.hp;
        percentage = t2 / Math.abs(t3.max - t3.min);
        if (percentage >= 0.5)
          t1._report$2$negative("<owner's> <subject> {take<s>|receive<s>|sustain<s>} {heavy|substantial|devastating} damage", true);
        else if (percentage >= 0.3)
          t1._report$2$negative("<owner's> <subject> {take<s>|receive<s>|sustain<s>} {quite a|hefty|quite heavy} damage", true);
        else if (percentage >= 0.05)
          t1._report$2$negative("<owner's> <subject> {take<s>|receive<s>|sustain<s>} {some|minor|slight} damage", true);
        else
          t1._report$2$negative("<owner's> <subject> {take<s>|receive<s>|sustain<s>} {{only|merely} {a dent|negligible damage}|{almost|nearly|practically|close to} no damage}", false);
      }
    }
  },
  ShipSystem_createSetupSection_recalculateProbabilities: {
    "^": "Closure:4;_spaceship$_box_0,_spaceship$_captured_this_1,_captured_text_2,_captured_allMoveSubmitButtons_3",
    call$0: function() {
      var t1, t2, t3, t4;
      t1 = this._spaceship$_captured_this_1;
      if (!!t1.$isCanHaveTarget) {
        t2 = this._spaceship$_box_0;
        this._captured_allMoveSubmitButtons_3.forEach$1(0, new M.ShipSystem_createSetupSection_recalculateProbabilities_closure(t2, t1));
        t3 = t2._captured_targetShip_0;
        t4 = this._captured_text_2;
        if (t3 != null)
          t4.html = "Aim at " + H.S(t3.name) + " is " + M.getAimString(H.interceptedTypeCast(t1, "$isCanHaveTarget").getAimAt$1(t2._captured_targetShip_0)) + ".";
        else
          t4.html = "No target.";
      }
    }
  },
  ShipSystem_createSetupSection_recalculateProbabilities_closure: {
    "^": "Closure:6;_spaceship$_box_0,_spaceship$_captured_this_4",
    call$2: function(proto, button) {
      var t1, probability;
      t1 = this._spaceship$_box_0;
      probability = S.Randomly_humanDescribeProbability(proto.calculateSuccessChance$3(this._spaceship$_captured_this_4, t1._captured_targetShip_0, t1._captured_targetSystem_1));
      button.set$name(Y.Storyline_capitalize(proto.get$commandText()) + " [" + probability + "]");
    }
  },
  ShipSystem_createSetupSection_closure: {
    "^": "Closure:2;",
    call$1: function(_) {
    }
  },
  ShipSystem_createSetupSection_closure0: {
    "^": "Closure:2;_spaceship$_box_0,_captured_allMoveSubmitButtons_5,_captured_recalculateProbabilities_6,_captured_allTargetSystemInputs_7",
    call$1: function(_) {
      this._spaceship$_box_0._captured_targetShip_0 = null;
      this._captured_allMoveSubmitButtons_5.forEach$1(0, new M.ShipSystem_createSetupSection__closure4());
      this._captured_allTargetSystemInputs_7.forEach$1(0, new M.ShipSystem_createSetupSection__closure5());
      this._captured_recalculateProbabilities_6.call$0();
    }
  },
  ShipSystem_createSetupSection__closure4: {
    "^": "Closure:33;",
    call$2: function(_, b) {
      var t1 = H.interceptedTypeCheck(b, "$isSubmitButton").attributes;
      t1.$indexSet(0, "disabled", "true");
      return true;
    }
  },
  ShipSystem_createSetupSection__closure5: {
    "^": "Closure:2;",
    call$1: function(i) {
      i.set$hidden(true);
      return true;
    }
  },
  ShipSystem_createSetupSection_closure1: {
    "^": "Closure:34;_spaceship$_captured_this_8",
    call$1: function(other) {
      H.interceptedTypeCheck(other, "$isSpaceship");
      return this._spaceship$_captured_this_8.spaceship.isEnemyOf$1(other) && other.get$isAlive() && H.boolConversionCheck(other.isActive);
    }
  },
  ShipSystem_createSetupSection_closure2: {
    "^": "Closure:34;_spaceship$_box_0,_captured_allMoveSubmitButtons_9,_captured_recalculateProbabilities_10,_captured_targetShipInput_11,_captured_allTargetSystemInputs_12",
    call$1: function(enemy) {
      var t1, t2, t3, t4, t5, targetSystemInput;
      H.interceptedTypeCheck(enemy, "$isSpaceship");
      t1 = new M.ShipSystem_createSetupSection__closure0();
      t2 = H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P.Object)]);
      t2._assertCheck$1(t1);
      t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t4 = H.setRuntimeTypeInfo([], [B.Node0]);
      t4 = new B.NodeList(null, H.assertSubtype(t4, "$isList", [B.Node0], "$asList"));
      t5 = t2._assertCheck$1(null);
      H.assertSubtype(t3, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      targetSystemInput = new G.MultipleChoiceInput(t5, null, "MultipleChoiceInput", null, t3, t4, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t4._parent = targetSystemInput;
      t3.$indexSet(0, "name", "Target system:");
      t2._assertCheck$1(t1);
      targetSystemInput.set$onInput(t1);
      t1 = this._spaceship$_box_0;
      t2 = t1._captured_targetShip_0;
      t3.$indexSet(0, "hidden", (t2 == null ? enemy != null : t2 !== enemy) ? "true" : "false");
      t3 = this._captured_allTargetSystemInputs_12;
      t3.add$1(0, targetSystemInput);
      t5 = this._captured_recalculateProbabilities_10;
      t2 = t1._captured_targetSystem_1;
      t2 = t2 == null || t2 === enemy.hull;
      H.voidTypeCheck(t4.add$1(0, G.Option$("ship", new M.ShipSystem_createSetupSection__closure1(t1, t5, enemy), null, t2)));
      enemy.get$allTargettableSystems().forEach$1(0, new M.ShipSystem_createSetupSection__closure2(t1, t5, targetSystemInput));
      H.voidTypeCheck(this._captured_targetShipInput_11.nodes.add$1(0, G.Option$(enemy.name, new M.ShipSystem_createSetupSection__closure3(t1, this._captured_allMoveSubmitButtons_9, t5, t3, enemy, targetSystemInput), null, t1._captured_targetShip_0 === enemy)));
    }
  },
  ShipSystem_createSetupSection__closure0: {
    "^": "Closure:2;",
    call$1: function(_) {
    }
  },
  ShipSystem_createSetupSection__closure1: {
    "^": "Closure:2;_spaceship$_box_0,_captured_recalculateProbabilities_13,_captured_enemy_14",
    call$1: function(_) {
      this._spaceship$_box_0._captured_targetSystem_1 = this._captured_enemy_14.hull;
      this._captured_recalculateProbabilities_13.call$0();
    }
  },
  ShipSystem_createSetupSection__closure2: {
    "^": "Closure:35;_spaceship$_box_0,_captured_recalculateProbabilities_15,_captured_targetSystemInput_16",
    call$1: function(enemyShipSystem) {
      var t1, t2, t3;
      H.interceptedTypeCheck(enemyShipSystem, "$isShipSystem");
      t1 = enemyShipSystem.ShipSystem_name;
      t2 = this._spaceship$_box_0;
      t3 = t2._captured_targetSystem_1;
      H.voidTypeCheck(this._captured_targetSystemInput_16.nodes.add$1(0, G.Option$(t1, new M.ShipSystem_createSetupSection___closure1(t2, this._captured_recalculateProbabilities_15, enemyShipSystem), null, t3 == null ? enemyShipSystem == null : t3 === enemyShipSystem)));
    }
  },
  ShipSystem_createSetupSection___closure1: {
    "^": "Closure:2;_spaceship$_box_0,_captured_recalculateProbabilities_17,_captured_enemyShipSystem_18",
    call$1: function(_) {
      this._spaceship$_box_0._captured_targetSystem_1 = this._captured_enemyShipSystem_18;
      this._captured_recalculateProbabilities_17.call$0();
    }
  },
  ShipSystem_createSetupSection__closure3: {
    "^": "Closure:2;_spaceship$_box_0,_captured_allMoveSubmitButtons_19,_captured_recalculateProbabilities_20,_captured_allTargetSystemInputs_21,_captured_enemy_22,_captured_targetSystemInput_23",
    call$1: function(_) {
      this._spaceship$_box_0._captured_targetShip_0 = this._captured_enemy_22;
      this._captured_allMoveSubmitButtons_19.forEach$1(0, new M.ShipSystem_createSetupSection___closure());
      this._captured_allTargetSystemInputs_21.forEach$1(0, new M.ShipSystem_createSetupSection___closure0());
      this._captured_targetSystemInput_23.attributes.$indexSet(0, "hidden", "false");
      this._captured_recalculateProbabilities_20.call$0();
    }
  },
  ShipSystem_createSetupSection___closure: {
    "^": "Closure:33;",
    call$2: function(_, b) {
      var t1 = H.interceptedTypeCheck(b, "$isSubmitButton").attributes;
      t1.$indexSet(0, "disabled", "false");
      return false;
    }
  },
  ShipSystem_createSetupSection___closure0: {
    "^": "Closure:2;",
    call$1: function(i) {
      i.set$hidden(true);
      return true;
    }
  },
  ShipSystem_createSetupSection_closure3: {
    "^": "Closure:36;_captured_section_24",
    call$1: function(input) {
      H.voidTypeCheck(this._captured_section_24.nodes.add$1(0, H.interceptedTypeCheck(input, "$isMultipleChoiceInput")));
    }
  },
  ShipSystem_createSetupSection_closure4: {
    "^": "Closure:2;",
    call$1: function(move) {
      return move.get$isActive();
    }
  },
  ShipSystem_createSetupSection_closure5: {
    "^": "Closure:37;_spaceship$_box_0,_spaceship$_captured_this_25,_captured_section_26,_captured_allMoveSubmitButtons_27",
    call$1: function(proto) {
      var t1, t2, t3, t4, t5, t6, button;
      H.interceptedTypeCheck(proto, "$isCombatMove");
      t1 = Y.Storyline_capitalize(proto.get$commandText());
      t2 = this._spaceship$_box_0;
      t3 = new M.ShipSystem_createSetupSection__closure(t2, this._spaceship$_captured_this_25, proto);
      t4 = H.buildFunctionType(H.getVoidRuntimeType());
      t4._assertCheck$1(t3);
      t5 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t6 = H.setRuntimeTypeInfo([], [B.Node0]);
      t6 = new B.NodeList(null, H.assertSubtype(t6, "$isList", [B.Node0], "$asList"));
      t3 = t4._assertCheck$1(t3);
      H.assertSubtype(t5, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      button = new G.SubmitButton(t3, null, "SubmitButton", null, t5, t6, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t6._parent = button;
      t5.$indexSet(0, "name", t1);
      t5.$indexSet(0, "helpMessage", null);
      t5.$indexSet(0, "disabled", t2._captured_targetShip_0 == null ? "true" : "false");
      this._captured_allMoveSubmitButtons_27.$indexSet(0, proto, button);
      H.voidTypeCheck(this._captured_section_26.nodes.add$1(0, button));
    }
  },
  ShipSystem_createSetupSection__closure: {
    "^": "Closure:1;_spaceship$_box_0,_spaceship$_captured_this_28,_captured_proto_29",
    call$0: function() {
      var t1, t2, move, t3;
      t1 = this._spaceship$_box_0;
      t2 = t1._captured_targetShip_0;
      if (t2 != null && t1._captured_targetSystem_1 == null)
        t1._captured_targetSystem_1 = t2.hull;
      t2 = this._spaceship$_captured_this_28;
      move = this._captured_proto_29.clone$1(t2);
      t3 = t1._captured_targetShip_0;
      move.targetShip = t3;
      move.targetSystem = t1._captured_targetSystem_1;
      if (!!t2.$isCanHaveTarget) {
        H.interceptedTypeCast(t2, "$isCanHaveTarget");
        t2.set$targetShip(t3);
        t2.set$targetSystem(t1._captured_targetSystem_1);
      }
      t2.currentMove = move;
      move.currentTimeToSetup = move.get$timeToSetup();
      move._isFinished = false;
      t2.spaceship.pilot.timeToNextInteraction = move.get$timeToSetup() + move.get$timeToFinish();
    }
  },
  CanHaveTarget: {
    "^": "ShipSystem;targetShip<,targetSystem<",
    set$targetShip: function(targetShip) {
      this.targetShip = H.interceptedTypeCheck(targetShip, "$isSpaceship");
    },
    set$targetSystem: function(targetSystem) {
      this.targetSystem = H.interceptedTypeCheck(targetSystem, "$isShipSystem");
    },
    getAimAt$1: function(targetShip) {
      var t1 = this._aimMap;
      if (!t1.containsKey$1(targetShip))
        t1.$indexSet(0, targetShip, 0);
      return H.intTypeCheck(t1.$index(0, targetShip));
    }
  },
  Weapon: {
    "^": "CanHaveTarget;isOutsideHull:Weapon_isOutsideHull<,targetShip:Weapon_targetShip<,targetSystem:Weapon_targetSystem<,ammo,projectile,accuracyModifier,shieldPenetration,damage,targetShip,targetSystem,_aimMap,ShipSystem_name,spaceship,hp,powerInput,isOutsideHull,availableMoves,currentMove,stringFullRepair,stringDestroy,nameIsProperNoun,name,categories,alreadyMentioned,team,isActive,isPlayer,pronoun",
    set$targetShip: function(targetShip) {
      this.Weapon_targetShip = H.interceptedTypeCheck(targetShip, "$isSpaceship");
    },
    set$targetSystem: function(targetSystem) {
      this.Weapon_targetSystem = H.interceptedTypeCheck(targetSystem, "$isShipSystem");
    },
    Weapon$9$accuracyModifier$ammo$damage$maxAmmo$maxHp$projectile$pronoun$shieldPenetration: function($name, accuracyModifier, ammo, damage, maxAmmo, maxHp, projectile, pronoun, shieldPenetration) {
      var t1, t2, t3;
      ammo = new R.IntScale("IntScale", null, null, H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), 0, maxAmmo, null, H.assertSubtype(null, "$isStream", [P.num], "$asStream"), "NumScale");
      ammo.NumScale$5$downwardsChangeCallbacks$initialValue$max$min$upwardsChangeCallbacks(null, null, maxAmmo, 0, null);
      t1 = ammo.onMin$0();
      t2 = new M.Weapon_closure(this);
      t3 = H.getVoidRuntimeType();
      H.buildFunctionType(t3, [t1.T5()])._assertCheck$1(t2);
      H.buildFunctionType(t3)._assertCheck$1(null);
      H.assertSubtype(t1._createSubscription$4(t2, null, null, false), "$isStreamSubscription", [H.getRuntimeTypeArgument(t1, "_ForwardingStream", 1)], "$asStreamSubscription");
      this.projectile = projectile;
      this.projectile.team = this.team;
      C.JSArray_methods.addAll$1(this.availableMoves, H.setRuntimeTypeInfo([new M.FireGun(true, true, false, 1, 4, null, 0.2, 0.2, 0.8, null, null, null, true, false, "<subject> {initiate|start}<s> the undefined move", "", "<subject> successfully finish<es> undefined move", "<subject> successfully finish<es> undefined move", "<subject> fail<s> to perform undefined move", "", true, true, false, false, 1, null, null, null, null, false), new M.QuickFireGun("take a quick shot", 1, 3, 0.1, 0, 0.6, true, true, false, 1, 4, null, 0.2, 0.2, 0.8, null, null, null, true, false, "<subject> {initiate|start}<s> the undefined move", "", "<subject> successfully finish<es> undefined move", "<subject> successfully finish<es> undefined move", "<subject> fail<s> to perform undefined move", "", true, true, false, false, 1, null, null, null, null, false), new M.ImproveAim(1, 3, true, true, null, "<subject> {start<s> {aiming at|taking aim at|fixing on|zeroing in on}|begin<s> to {{take |}aim at|fix on|zero in on}} <object>", 0.9, "<subject> successfully improve<s> <subject's> aim on <object>", "<subject's> aim on <object> doesn't improve", 1, null, null, null, true, false, "<subject> {initiate|start}<s> the undefined move", "", "<subject> successfully finish<es> undefined move", "<subject> successfully finish<es> undefined move", "<subject> fail<s> to perform undefined move", "", true, true, false, false, 1, null, null, null, null, false)], [M.CombatMove]));
    },
    static: {Weapon$: function($name, accuracyModifier, ammo, damage, maxAmmo, maxHp, projectile, pronoun, shieldPenetration) {
        var t1, t2, t3, t4;
        t1 = H.assertSubtype(H.setRuntimeTypeInfo([], [P.String]), "$isList", [P.String], "$asList");
        t2 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, M.Spaceship, P.$int), "$isMap", [M.Spaceship, P.$int], "$asMap");
        t3 = {};
        t3._captured_hp_0 = null;
        t4 = H.setRuntimeTypeInfo([], [P.String]);
        t4 = new M.Weapon(true, null, null, null, new Y.Entity(false, "projectile", t1, true, 0, true, false, C.Pronoun_it_it_its_itself), accuracyModifier, shieldPenetration, damage, null, null, H.assertSubtype(t2, "$isMap", [M.Spaceship, P.$int], "$asMap"), $name, null, null, null, false, H.assertSubtype([], "$isList", [M.CombatMove], "$asList"), null, "<owner's> <subject> <is> now {{fully|} repaired|fully operational}", "<owner's> <subject> {blow<s> {up|apart}|<is> {destroyed|no more}}", false, null, H.assertSubtype(t4, "$isList", [P.String], "$asList"), true, 0, true, false, pronoun);
        t4.ShipSystem$5$hp$maxHp$maxPowerInput$pronoun($name, maxHp, 1, pronoun, t3);
        t4.Weapon$9$accuracyModifier$ammo$damage$maxAmmo$maxHp$projectile$pronoun$shieldPenetration($name, accuracyModifier, ammo, damage, maxAmmo, maxHp, projectile, pronoun, shieldPenetration);
        return t4;
      }}
  },
  Weapon_closure: {
    "^": "Closure:2;_spaceship$_captured_this_0",
    call$1: function(_) {
      this._spaceship$_captured_this_0._report$2$negative("<subject> is out of ammo", true);
    }
  },
  AutoWeapon: {
    "^": "Weapon;Weapon_isOutsideHull,Weapon_targetShip,Weapon_targetSystem,ammo,projectile,accuracyModifier,shieldPenetration,damage,targetShip,targetSystem,_aimMap,ShipSystem_name,spaceship,hp,powerInput,isOutsideHull,availableMoves,currentMove,stringFullRepair,stringDestroy,nameIsProperNoun,name,categories,alreadyMentioned,team,isActive,isPlayer,pronoun"
  },
  Engine: {
    "^": "ShipSystem;maxPowerOutput,ShipSystem_name,spaceship,hp,powerInput,isOutsideHull,availableMoves,currentMove,stringFullRepair,stringDestroy,nameIsProperNoun,name,categories,alreadyMentioned,team,isActive,isPlayer,pronoun"
  },
  Thruster: {
    "^": "ShipSystem;isOutsideHull:Thruster_isOutsideHull<,maxForwardlyForce,maxManeuverability,ShipSystem_name,spaceship,hp,powerInput,isOutsideHull,availableMoves,currentMove,stringFullRepair,stringDestroy,nameIsProperNoun,name,categories,alreadyMentioned,team,isActive,isPlayer,pronoun",
    get$maneuverability: function() {
      return C.JSNumber_methods.toInt$0(this.hp.get$percentage() * this.maxManeuverability);
    },
    createSetupSection$0: function() {
      return;
    },
    Thruster$7$hp$maxForwardlyForce$maxHp$maxManeuverability$maxPowerInput$pronoun: function($name, hp, maxForwardlyForce, maxHp, maxManeuverability, maxPowerInput, pronoun) {
      this.hp.downwardsChangeCallbacks.$indexSet(0, 0.5, new M.Thruster_closure(this));
      this.hp.downwardsChangeCallbacks.$indexSet(0, 0.2, new M.Thruster_closure0(this));
    },
    static: {Thruster$: function($name, hp, maxForwardlyForce, maxHp, maxManeuverability, maxPowerInput, pronoun) {
        var t1, t2;
        t1 = {};
        t1._captured_hp_0 = hp;
        t2 = H.setRuntimeTypeInfo([], [P.String]);
        t2 = new M.Thruster(true, maxForwardlyForce, maxManeuverability, $name, null, null, null, false, H.assertSubtype([], "$isList", [M.CombatMove], "$asList"), null, "<owner's> <subject> <is> now {{fully|} repaired|fully operational}", "<owner's> <subject> {blow<s> {up|apart}|<is> {destroyed|no more}}", false, null, H.assertSubtype(t2, "$isList", [P.String], "$asList"), true, 0, true, false, pronoun);
        t2.ShipSystem$5$hp$maxHp$maxPowerInput$pronoun($name, maxHp, maxPowerInput, pronoun, t1);
        t2.Thruster$7$hp$maxForwardlyForce$maxHp$maxManeuverability$maxPowerInput$pronoun($name, hp, maxForwardlyForce, maxHp, maxManeuverability, maxPowerInput, pronoun);
        return t2;
      }}
  },
  Thruster_closure: {
    "^": "Closure:2;_spaceship$_captured_this_0",
    call$1: function(_) {
      var t1 = this._spaceship$_captured_this_0;
      t1._report$2$negative("<owner's> <subject> start<s> spewing sparks from its internals", true);
      t1._report$2$negative("<subject> lose<s> most of <subject's> thrust", true);
    }
  },
  Thruster_closure0: {
    "^": "Closure:2;_spaceship$_captured_this_1",
    call$1: function(_) {
      this._spaceship$_captured_this_1._report$2$negative("<owner's> <subject> <is> {now|} {almost {completely|}|nearly|close to} {destroyed|shattered|finished}", true);
    }
  },
  Hull: {
    "^": "ShipSystem;isOutsideHull:Hull_isOutsideHull<,stringDestroy:Hull_stringDestroy<,ShipSystem_name,spaceship,hp,powerInput,isOutsideHull,availableMoves,currentMove,stringFullRepair,stringDestroy,nameIsProperNoun,name,categories,alreadyMentioned,team,isActive,isPlayer,pronoun",
    createSetupSection$0: function() {
      return;
    },
    Hull$2$maxHp$name: function(maxHp, $name) {
      this.hp.downwardsChangeCallbacks.$indexSet(0, 0.8, new M.Hull_closure(this));
      this.hp.downwardsChangeCallbacks.$indexSet(0, 0.6, new M.Hull_closure0(this));
      this.hp.downwardsChangeCallbacks.$indexSet(0, 0.4, new M.Hull_closure1(this));
      this.hp.downwardsChangeCallbacks.$indexSet(0, 0.2, new M.Hull_closure2(this));
    },
    static: {Hull$: function(maxHp, $name) {
        var t1, t2;
        t1 = {};
        t1._captured_hp_0 = null;
        t2 = H.setRuntimeTypeInfo([], [P.String]);
        t2 = new M.Hull(false, null, $name, null, null, null, false, H.assertSubtype([], "$isList", [M.CombatMove], "$asList"), null, "<owner's> <subject> <is> now {{fully|} repaired|fully operational}", "<owner's> <subject> {blow<s> {up|apart}|<is> {destroyed|no more}}", false, null, H.assertSubtype(t2, "$isList", [P.String], "$asList"), true, 0, true, false, C.Pronoun_it_it_its_itself);
        t2.ShipSystem$5$hp$maxHp$maxPowerInput$pronoun($name, maxHp, 1, C.Pronoun_it_it_its_itself, t1);
        t2.Hull$2$maxHp$name(maxHp, $name);
        return t2;
      }}
  },
  Hull_closure: {
    "^": "Closure:2;_spaceship$_captured_this_0",
    call$1: function(_) {
      this._spaceship$_captured_this_0._report$2$negative("there are a number of battle-inflicted scars on <subject's> surface now", true);
    }
  },
  Hull_closure0: {
    "^": "Closure:2;_spaceship$_captured_this_1",
    call$1: function(_) {
      this._spaceship$_captured_this_1._report$2$negative("<owner's> <subject> <is> now torn on many places", true);
    }
  },
  Hull_closure1: {
    "^": "Closure:2;_spaceship$_captured_this_2",
    call$1: function(_) {
      this._spaceship$_captured_this_2._report$2$negative("<owner's> <subject> lose<s> <subject's> structural integrity", true);
    }
  },
  Hull_closure2: {
    "^": "Closure:2;_spaceship$_captured_this_3",
    call$1: function(_) {
      var t1 = this._spaceship$_captured_this_3;
      t1._report$2$negative("<owner's> <subject> <is> now full of gaping holes", true);
      t1._report$2$negative("<owner's> <subject> <is> {horribly |}deformed", true);
    }
  },
  Shield: {
    "^": "ShipSystem;pronoun:Shield_pronoun<,regenerationSpeed,sp,ShipSystem_name,spaceship,hp,powerInput,isOutsideHull,availableMoves,currentMove,stringFullRepair,stringDestroy,nameIsProperNoun,name,categories,alreadyMentioned,team,isActive,isPlayer,pronoun",
    Shield$6$maxHp$maxPowerInput$maxSp$name$pronoun$sp: function(maxHp, maxPowerInput, maxSp, $name, pronoun, sp) {
      this.sp = R.NumScale$(null, null, maxSp, 0, null);
    },
    static: {Shield$: function(maxHp, maxPowerInput, maxSp, $name, pronoun, sp) {
        var t1, t2;
        t1 = {};
        t1._captured_hp_0 = null;
        t2 = H.setRuntimeTypeInfo([], [P.String]);
        t2 = new M.Shield(C.Pronoun_they_them_their_themselves, null, null, $name, null, null, null, false, H.assertSubtype([], "$isList", [M.CombatMove], "$asList"), null, "<owner's> <subject> <is> now {{fully|} repaired|fully operational}", "<owner's> <subject> {blow<s> {up|apart}|<is> {destroyed|no more}}", false, null, H.assertSubtype(t2, "$isList", [P.String], "$asList"), true, 0, true, false, pronoun);
        t2.ShipSystem$5$hp$maxHp$maxPowerInput$pronoun($name, maxHp, maxPowerInput, pronoun, t1);
        t2.Shield$6$maxHp$maxPowerInput$maxSp$name$pronoun$sp(maxHp, maxPowerInput, maxSp, $name, pronoun, sp);
        return t2;
      }}
  },
  SpecialSystems: {
    "^": "ShipSystem;"
  },
  Spaceship: {
    "^": "Actor;currentCombat,availableMoves,currentMove,pilot<,_targetShip,hull,shield,engine,thrusters,weapons,systems,_positionMap,stringReportDestroy,nameIsProperNoun,name,categories,alreadyMentioned,team,isActive,isPlayer,pronoun",
    get$isAlive: function() {
      var t1 = this.hull.hp._numscale$_value;
      if (typeof t1 !== "number")
        return t1.$gt();
      return t1 > 0;
    },
    set$targetShip: function(value) {
      C.JSArray_methods.forEach$1(this.weapons, new M.Spaceship_targetShip_closure(value));
      this._targetShip = value;
    },
    get$allTargettableSystems: function() {
      var t1, t2, t3, t4;
      t1 = this.get$allSystems();
      t2 = new M.Spaceship_allTargettableSystems_closure();
      t3 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t3, [t1.E()])._assertCheck$1(t2);
      t4 = H.getRuntimeTypeArgument(t1, "IterableBase", 0);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
      return H.listSuperNativeTypeCheck(H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), H.buildFunctionType(t3, [H.getDynamicRuntimeType()])._assertCheck$1(t2)), [t4]), "$isIterable"), "$isIterable");
    },
    get$allSystems: function() {
      var t1, t2, t3, t4, t5;
      t1 = H.setRuntimeTypeInfo([this.weapons, this.thrusters, this.systems, [this.shield, this.engine, this.hull]], [[P.List, M.ShipSystem]]);
      t2 = new M.Spaceship_allSystems_closure();
      t3 = H.getDynamicRuntimeType();
      t4 = H.buildInterfaceType(P.Iterable, [t3]);
      H.buildFunctionType(t4, [H.convertRtiToRuntimeType(t1.$builtinTypeInfo && t1.$builtinTypeInfo[0])])._assertCheck$1(t2);
      t5 = H.getTypeArgumentByIndex(t1, 0);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      H.buildFunctionType(H.buildInterfaceType(P.Iterable, [H.convertRtiToRuntimeType(null)]), [H.convertRtiToRuntimeType(t5)])._assertCheck$1(t2);
      t5 = H.setRuntimeTypeInfo(new H.ExpandIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), H.buildFunctionType(t4, [t3])._assertCheck$1(t2)), [t5, null]);
      t2 = new M.Spaceship_allSystems_closure0();
      t4 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t4, [t5.E()])._assertCheck$1(t2);
      t1 = H.getRuntimeTypeArgument(t5, "IterableBase", 0);
      H.listSuperNativeTypeCheck(t5, "$isIterable");
      H.buildFunctionType(t4, [H.convertRtiToRuntimeType(t1)])._assertCheck$1(t2);
      return H.listSuperNativeTypeCheck(H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t5, "$isIterable"), H.buildFunctionType(t4, [t3])._assertCheck$1(t2)), [t1]), "$isIterable"), "$isIterable");
    },
    get$maneuverability: function() {
      return J.toInt$0$n(C.JSArray_methods.fold$2(this.thrusters, 0, new M.Spaceship_maneuverability_closure()));
    },
    getPositionTowards$1: function(targetShip) {
      var t1 = this._positionMap;
      if (!t1.containsKey$1(targetShip))
        t1.$indexSet(0, targetShip, 0);
      return H.intTypeCheck(t1.$index(0, targetShip));
    },
    setPositionTowards$2: function(targetShip, value) {
      if (value < -2)
        value = -2;
      if (value > 2)
        value = 2;
      this._positionMap.$indexSet(0, targetShip, value);
    },
    getPositionStringTowards$2$wrapInColor: function(targetShip, wrapInColor) {
      var pos, t1;
      pos = this.getPositionTowards$1(targetShip);
      t1 = new M.Spaceship_getPositionStringTowards_wrapInColorSpan(wrapInColor);
      switch (pos) {
        case -2:
          return H.stringTypeCheck(t1.call$2("very disadvategeous", "green"));
        case -1:
          return H.stringTypeCheck(t1.call$2("disadvategeous", "greenish"));
        case 0:
          return H.stringTypeCheck(t1.call$2("balanced", "black"));
        case 1:
          return H.stringTypeCheck(t1.call$2("advategeous", "orange"));
        case 2:
          return H.stringTypeCheck(t1.call$2("very advategeous", "red"));
        default:
          throw H.wrapException(P.StateError$("Position " + H.S(pos) + " is not a valid value."));
      }
    },
    update$0: function() {
      var t1, t2, t3, t4;
      t1 = this.currentMove;
      if (t1 != null) {
        t1.update$0();
        if (this.currentMove._isFinished)
          this.currentMove = null;
      }
      t1 = this.get$allSystems();
      t2 = new M.Spaceship_update_closure();
      t3 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t3, [t1.E()])._assertCheck$1(t2);
      t4 = H.getRuntimeTypeArgument(t1, "IterableBase", 0);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
      H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), H.buildFunctionType(t3, [H.getDynamicRuntimeType()])._assertCheck$1(t2)), [t4]), "$isIterable").forEach$1(0, new M.Spaceship_update_closure0());
      this.pilot.update$0();
    },
    getSystemSetupSections$0: function() {
      var sections, t1, t2, t3, t4;
      sections = H.assertSubtype(H.setRuntimeTypeInfo([], [G.FormSection]), "$isList", [G.FormSection], "$asList");
      t1 = this.get$allSystems();
      t2 = new M.Spaceship_getSystemSetupSections_closure();
      t3 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t3, [t1.E()])._assertCheck$1(t2);
      t4 = H.getRuntimeTypeArgument(t1, "IterableBase", 0);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
      H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), H.buildFunctionType(t3, [H.getDynamicRuntimeType()])._assertCheck$1(t2)), [t4]), "$isIterable").forEach$1(0, new M.Spaceship_getSystemSetupSections_closure0(sections));
      return H.assertSubtype(sections, "$isList", [G.FormSection], "$asList");
    },
    getManeuvreSetupSection$0: function() {
      var t1, t2, section, t3, text, t4;
      t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t2 = H.setRuntimeTypeInfo([], [B.Node0]);
      t2 = new B.NodeList(null, H.assertSubtype(t2, "$isList", [B.Node0], "$asList"));
      H.assertSubtype(t1, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      section = new G.FormSection(null, "FormSection", null, t1, t2, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t2._parent = section;
      t1.$indexSet(0, "name", "Maneuvres");
      t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t3 = H.setRuntimeTypeInfo([], [B.Node0]);
      t3 = new B.NodeList(null, H.assertSubtype(t3, "$isList", [B.Node0], "$asList"));
      text = new G.TextOutput(null, null, null, "TextOutput", null, H.assertSubtype(t1, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap"), t3, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t3._parent = text;
      text.html = "This is the maneuvres section.";
      H.voidTypeCheck(t2.add$1(0, text));
      t2 = this.availableMoves;
      t3 = new M.Spaceship_getManeuvreSetupSection_closure();
      t1 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t1, [H.convertRtiToRuntimeType(t2.$builtinTypeInfo && t2.$builtinTypeInfo[0])])._assertCheck$1(t3);
      t4 = H.getTypeArgumentByIndex(t2, 0);
      H.listSuperNativeTypeCheck(t2, "$isIterable");
      H.buildFunctionType(t1, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t3);
      H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t2, "$isIterable"), H.buildFunctionType(t1, [H.getDynamicRuntimeType()])._assertCheck$1(t3)), [t4]), "$isIterable").forEach$1(0, new M.Spaceship_getManeuvreSetupSection_closure0(this, section));
      return section;
    },
    Spaceship$8$engine$hull$pilot$shield$systems$thrusters$weapons: function($name, engine, hull, pilot, shield, systems, thrusters, weapons) {
      var t1, t2, t3;
      H.assertSubtype(systems, "$isList", [M.SpecialSystems], "$asList");
      H.assertSubtype(thrusters, "$isList", [M.Thruster], "$asList");
      H.assertSubtype(weapons, "$isList", [M.Weapon], "$asList");
      t1 = this.pilot;
      if (t1 == null) {
        t1 = new M.Pilot(this, 0, false, "pilot", H.assertSubtype(H.setRuntimeTypeInfo([], [P.String]), "$isList", [P.String], "$asList"), true, 2, true, false, C.Pronoun_he_him_his_himself);
        this.pilot = t1;
      }
      t1.spaceship = this;
      this.team = t1.team;
      this.get$allSystems().forEach$1(0, new M.Spaceship_closure(this));
      t1 = this.hull.hp.onMin$0();
      t2 = new M.Spaceship_closure0(this);
      t3 = H.getVoidRuntimeType();
      H.buildFunctionType(t3, [t1.T5()])._assertCheck$1(t2);
      H.buildFunctionType(t3)._assertCheck$1(null);
      H.assertSubtype(t1._createSubscription$4(t2, null, null, false), "$isStreamSubscription", [H.getRuntimeTypeArgument(t1, "_ForwardingStream", 1)], "$asStreamSubscription");
      C.JSArray_methods.addAll$1(this.availableMoves, H.setRuntimeTypeInfo([new M.ImprovePosition("improve position", 1, 5, 0.9, 1, true, null, "<subject> {start<s>|begin<s>} {trying|an attempt} to {improve|better} <subject's> position on <object>", "<subject> successfully improve<s> <subject's> position on <object>", "<subject> fail<s> to improve <subject's> position on <object>", false, null, null, null, true, false, "<subject> {initiate|start}<s> the undefined move", "", "<subject> successfully finish<es> undefined move", "<subject> successfully finish<es> undefined move", "<subject> fail<s> to perform undefined move", "", true, true, false, false, 1, null, null, null, null, false), new M.RiskyImprovePosition("reversal maneuvre", 0.3, 3, 0.2, "<subject> {start<s>|begin<s>} a {risky|daring} maneuvre to gain positional advantage on <object>", "<subject> successfully pull<s> off the maneuvre on <object>", "<subject's> maneuvre fails", "improve position", 1, 5, 0.9, 1, true, null, "<subject> {start<s>|begin<s>} {trying|an attempt} to {improve|better} <subject's> position on <object>", "<subject> successfully improve<s> <subject's> position on <object>", "<subject> fail<s> to improve <subject's> position on <object>", false, null, null, null, true, false, "<subject> {initiate|start}<s> the undefined move", "", "<subject> successfully finish<es> undefined move", "<subject> successfully finish<es> undefined move", "<subject> fail<s> to perform undefined move", "", true, true, false, false, 1, null, null, null, null, false)], [M.CombatMove]));
    }
  },
  Spaceship_closure: {
    "^": "Closure:2;_spaceship$_captured_this_0",
    call$1: function(system) {
      var t1 = this._spaceship$_captured_this_0;
      system.set$spaceship(t1);
      system.team = t1.team;
    }
  },
  Spaceship_closure0: {
    "^": "Closure:2;_spaceship$_captured_this_1",
    call$1: function(_) {
      var t1 = this._spaceship$_captured_this_1;
      $.get$storyline().add$4$negative$subject$time(0, t1.stringReportDestroy, true, t1, t1.currentCombat.timeline.time);
      return;
    }
  },
  Spaceship_targetShip_closure: {
    "^": "Closure:2;_captured_value_0",
    call$1: function(weapon) {
      weapon.set$targetShip(this._captured_value_0);
      weapon.set$targetSystem(null);
    }
  },
  Spaceship_allTargettableSystems_closure: {
    "^": "Closure:35;",
    call$1: function(system) {
      H.interceptedTypeCheck(system, "$isShipSystem");
      return system.get$isOutsideHull() && system.get$isAlive() && H.boolConversionCheck(system.isActive);
    }
  },
  Spaceship_allSystems_closure: {
    "^": "Closure:2;",
    call$1: function(s) {
      return s;
    }
  },
  Spaceship_allSystems_closure0: {
    "^": "Closure:2;",
    call$1: function(system) {
      return system != null;
    }
  },
  Spaceship_maneuverability_closure: {
    "^": "Closure:38;",
    call$2: function(prevValue, thruster) {
      var t1;
      H.numTypeCheck(prevValue);
      t1 = thruster.get$maneuverability();
      if (typeof prevValue !== "number")
        return prevValue.$add();
      return prevValue + t1;
    }
  },
  Spaceship_getPositionStringTowards_wrapInColorSpan: {
    "^": "Closure:39;_captured_wrapInColor_0",
    call$2: function(text, color) {
      if (!this._captured_wrapInColor_0)
        return text;
      return "<span class=\"" + color + "\">" + text + "</span>";
    }
  },
  Spaceship_update_closure: {
    "^": "Closure:2;",
    call$1: function(system) {
      return system.get$isAliveAndActive();
    }
  },
  Spaceship_update_closure0: {
    "^": "Closure:2;",
    call$1: function(system) {
      return system.update$0();
    }
  },
  Spaceship_getSystemSetupSections_closure: {
    "^": "Closure:2;",
    call$1: function(system) {
      return system.get$isActive();
    }
  },
  Spaceship_getSystemSetupSections_closure0: {
    "^": "Closure:2;_captured_sections_0",
    call$1: function(system) {
      var section = system.createSetupSection$0();
      if (section != null)
        C.JSArray_methods.add$1(this._captured_sections_0, section);
    }
  },
  Spaceship_getManeuvreSetupSection_closure: {
    "^": "Closure:2;",
    call$1: function(move) {
      return move.get$isActive();
    }
  },
  Spaceship_getManeuvreSetupSection_closure0: {
    "^": "Closure:37;_spaceship$_captured_this_0,_captured_section_1",
    call$1: function(proto) {
      var t1, t2, t3, t4, t5, t6, button;
      H.interceptedTypeCheck(proto, "$isCombatMove");
      t1 = Y.Storyline_capitalize(proto.get$commandText());
      t2 = this._spaceship$_captured_this_0;
      t3 = new M.Spaceship_getManeuvreSetupSection__closure(t2, proto);
      t4 = H.buildFunctionType(H.getVoidRuntimeType());
      t4._assertCheck$1(t3);
      t5 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t6 = H.setRuntimeTypeInfo([], [B.Node0]);
      t6 = new B.NodeList(null, H.assertSubtype(t6, "$isList", [B.Node0], "$asList"));
      t3 = t4._assertCheck$1(t3);
      H.assertSubtype(t5, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      button = new G.SubmitButton(t3, null, "SubmitButton", null, t5, t6, H.assertSubtype(null, "$isList", [B.Element], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t6._parent = button;
      t5.$indexSet(0, "name", t1);
      t5.$indexSet(0, "helpMessage", null);
      t5.$indexSet(0, "disabled", t2._targetShip == null ? "true" : "false");
      H.voidTypeCheck(this._captured_section_1.nodes.add$1(0, button));
    }
  },
  Spaceship_getManeuvreSetupSection__closure: {
    "^": "Closure:1;_spaceship$_captured_this_2,_captured_proto_3",
    call$0: function() {
      var t1, move;
      t1 = this._spaceship$_captured_this_2;
      move = this._captured_proto_3.clone$1(C.JSArray_methods.get$first(t1.thrusters));
      move.targetShip = t1._targetShip;
      move.currentTimeToSetup = move.get$timeToSetup();
      t1.currentMove = move;
      move.currentTimeToSetup = move.get$timeToSetup();
      move._isFinished = false;
      t1.pilot.timeToNextInteraction = move.get$timeToSetup() + move.get$timeToFinish();
    }
  }
}],
["spaceship_mock", "../libraries/spaceship_mock.dart", , F, {
  "^": "",
  SpaceshipMock: {
    "^": "Object;isAlive,components,className<",
    toMap$0: function() {
      return P.LinkedHashMap_LinkedHashMap$_literal(["isAlive", this.isAlive, "components", this.components], null, null);
    },
    updateFromMap$1: function(map) {
      H.interceptedTypeCheck(map, "$isMap");
      this.isAlive = H.boolTypeCheck(map.$index(0, "isAlive"));
      this.components.updateFromMap$1(map.$index(0, "components"));
    },
    $isSaveable: 1
  },
  ShipComponentCollection: {
    "^": "Object;_components,className<",
    $index: function(_, $name) {
      var t1, t2, t3;
      H.stringTypeCheck($name);
      t1 = this._components;
      if (t1.containsKey$1($name))
        return t1.$index(0, $name);
      else {
        t2 = new R.IntScale("IntScale", null, null, H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), 0, 10, null, H.assertSubtype(null, "$isStream", [P.num], "$asStream"), "NumScale");
        t2.NumScale$5$downwardsChangeCallbacks$initialValue$max$min$upwardsChangeCallbacks(null, null, 10, 0, null);
        t3 = new R.IntScale("IntScale", null, null, H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), 0, 10, null, H.assertSubtype(null, "$isStream", [P.num], "$asStream"), "NumScale");
        t3.NumScale$5$downwardsChangeCallbacks$initialValue$max$min$upwardsChangeCallbacks(null, null, 10, 0, null);
        t1.$indexSet(0, $name, new F.ShipComponentMock(t2, 5, t3, 5, true, "ShipComponentMock"));
        return t1.$index(0, $name);
      }
    },
    toMap$0: function() {
      return P.LinkedHashMap_LinkedHashMap$_literal(["components", this._components], null, null);
    },
    updateFromMap$1: function(map) {
      J.forEach$1$a(H.interceptedTypeCheck(map, "$isMap").$index(0, "components"), new F.ShipComponentCollection_updateFromMap_closure(this));
    },
    ShipComponentCollection$0: function() {
      var t1, t2, t3;
      t1 = this._components;
      t2 = new R.IntScale("IntScale", null, null, H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), 0, 10, null, H.assertSubtype(null, "$isStream", [P.num], "$asStream"), "NumScale");
      t2.NumScale$5$downwardsChangeCallbacks$initialValue$max$min$upwardsChangeCallbacks(null, null, 10, 0, null);
      t3 = new R.IntScale("IntScale", null, null, H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), 0, 10, null, H.assertSubtype(null, "$isStream", [P.num], "$asStream"), "NumScale");
      t3.NumScale$5$downwardsChangeCallbacks$initialValue$max$min$upwardsChangeCallbacks(null, null, 10, 0, null);
      t1.$indexSet(0, "hull", new F.ShipComponentMock(t2, 5, t3, 5, true, "ShipComponentMock"));
      t3 = new R.IntScale("IntScale", null, null, H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), 0, 10, null, H.assertSubtype(null, "$isStream", [P.num], "$asStream"), "NumScale");
      t3.NumScale$5$downwardsChangeCallbacks$initialValue$max$min$upwardsChangeCallbacks(null, null, 10, 0, null);
      t2 = new R.IntScale("IntScale", null, null, H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), 0, 10, null, H.assertSubtype(null, "$isStream", [P.num], "$asStream"), "NumScale");
      t2.NumScale$5$downwardsChangeCallbacks$initialValue$max$min$upwardsChangeCallbacks(null, null, 10, 0, null);
      t1.$indexSet(0, "shield", new F.ShipComponentMock(t3, 5, t2, 5, true, "ShipComponentMock"));
      t2 = new R.IntScale("IntScale", null, null, H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), 0, 10, null, H.assertSubtype(null, "$isStream", [P.num], "$asStream"), "NumScale");
      t2.NumScale$5$downwardsChangeCallbacks$initialValue$max$min$upwardsChangeCallbacks(null, null, 10, 0, null);
      t3 = new R.IntScale("IntScale", null, null, H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), 0, 10, null, H.assertSubtype(null, "$isStream", [P.num], "$asStream"), "NumScale");
      t3.NumScale$5$downwardsChangeCallbacks$initialValue$max$min$upwardsChangeCallbacks(null, null, 10, 0, null);
      t1.$indexSet(0, "engine", new F.ShipComponentMock(t2, 5, t3, 5, true, "ShipComponentMock"));
      t3 = new R.IntScale("IntScale", null, null, H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), 0, 10, null, H.assertSubtype(null, "$isStream", [P.num], "$asStream"), "NumScale");
      t3.NumScale$5$downwardsChangeCallbacks$initialValue$max$min$upwardsChangeCallbacks(null, null, 10, 0, null);
      t2 = new R.IntScale("IntScale", null, null, H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), H.assertSubtype(null, "$isMap", [P.num, {func: "", void: true, args: [P.num]}], "$asMap"), 0, 10, null, H.assertSubtype(null, "$isStream", [P.num], "$asStream"), "NumScale");
      t2.NumScale$5$downwardsChangeCallbacks$initialValue$max$min$upwardsChangeCallbacks(null, null, 10, 0, null);
      t1.$indexSet(0, "radar", new F.ShipComponentMock(t3, 5, t2, 5, true, "ShipComponentMock"));
    },
    $isSaveable: 1,
    static: {ShipComponentCollection$: function() {
        var t1 = new F.ShipComponentCollection(H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, F.ShipComponentMock), "$isMap", [P.String, F.ShipComponentMock], "$asMap"), "$isMap", [P.String, F.ShipComponentMock], "$asMap"), "ShipComponentCollection");
        t1.ShipComponentCollection$0();
        return t1;
      }}
  },
  ShipComponentCollection_updateFromMap_closure: {
    "^": "Closure:40;_spaceship_mock$_captured_this_0",
    call$2: function(key, value) {
      var t1;
      H.stringTypeCheck(key);
      H.interceptedTypeCheck(value, "$isMap");
      t1 = this._spaceship_mock$_captured_this_0._components;
      if (t1.containsKey$1(key))
        t1.$index(0, key).updateFromMap$1(value);
    }
  },
  ShipComponentMock: {
    "^": "Object;hp,minimalHp,charge,minimalCharge,active,className<",
    get$isActive: function() {
      if (H.boolConversionCheck(this.active)) {
        var t1 = this.charge;
        t1 = H.intTypeCheck(R.NumScale.prototype.get$value.call(t1));
        if (typeof t1 !== "number")
          return t1.$ge();
        if (t1 >= this.minimalCharge) {
          t1 = this.hp;
          t1 = H.intTypeCheck(R.NumScale.prototype.get$value.call(t1));
          if (typeof t1 !== "number")
            return t1.$ge();
          t1 = t1 >= this.minimalHp;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    toMap$0: function() {
      return P.LinkedHashMap_LinkedHashMap$_literal(["hp", this.hp, "charge", this.charge, "active", this.active], null, null);
    },
    updateFromMap$1: function(map) {
      H.interceptedTypeCheck(map, "$isMap");
      this.hp._numscale$_value = H.numTypeCheck(J.$index$as(map.$index(0, "hp"), "value"));
      this.charge._numscale$_value = H.numTypeCheck(J.$index$as(map.$index(0, "charge"), "value"));
      this.active = H.boolTypeCheck(map.$index(0, "active"));
    },
    $isSaveable: 1
  }
}],
["stat", "package:egamebook/src/shared/stat.dart", , Z, {
  "^": "",
  StatUpdate: {
    "^": "Object;show,string<",
    toMap$0: function() {
      return H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_literal(["show", this.show, "string", this.string], null, null), "$isMap", [P.String, P.Object], "$asMap");
    }
  },
  StatUpdateCollection: {
    "^": "Object;_updates",
    toMap$0: function() {
      var map = H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.Object), "$isMap", [P.String, P.Object], "$asMap"), "$isMap", [P.String, P.Object], "$asMap");
      this._updates.forEach$1(0, new Z.StatUpdateCollection_toMap_closure(map));
      return H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
    },
    forEach$1: function(_, $function) {
      this._updates.forEach$1(0, H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P.String), H.buildInterfaceType(Z.StatUpdate)])._assertCheck$1($function));
    }
  },
  StatUpdateCollection_toMap_closure: {
    "^": "Closure:41;_captured_map_0",
    call$2: function($name, update) {
      H.stringTypeCheck($name);
      H.interceptedTypeCheck(update, "$isStatUpdate");
      this._captured_map_0.$indexSet(0, $name, H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_literal(["show", update.show, "string", update.string], null, null), "$isMap", [P.String, P.Object], "$asMap"));
    }
  },
  Stat: {
    "^": "Object;name<,description,valueToString,color,priority<,_value,_show,notifyOnChange,changed<,className<",
    set$_value: function(_value) {
      this._value = H.assertSubtypeOfRuntimeType(_value, H.getTypeArgumentByIndex(this, 0));
    },
    set$value: function(val) {
      H.assertSubtypeOfRuntimeType(val, H.getTypeArgumentByIndex(this, 0));
      if (!J.$eq(this._value, val)) {
        this.set$_value(val);
        this.changed = true;
        $.Stat_someChanged = true;
      }
    },
    set$show: function(value) {
      var t1;
      H.boolTypeCheck(value);
      t1 = this._show;
      if (t1 == null ? value != null : t1 !== value) {
        this._show = value;
        this.changed = true;
        $.Stat_someChanged = true;
      }
    },
    get$string: function() {
      return H.stringTypeCheck(this.valueToString$1(H.assertSubtypeOfRuntimeType(this._value, H.getTypeArgumentByIndex(this, 0))));
    },
    toMap$0: function() {
      return H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_literal(["name", this.name, "value", H.assertSubtypeOfRuntimeType(this._value, H.getTypeArgumentByIndex(this, 0)), "show", this._show], null, null), "$isMap", [P.String, P.Object], "$asMap");
    },
    updateFromMap$1: function(map) {
      H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
      H.assertHelper(J.$eq(map.$index(0, "name"), this.name));
      this.set$value(map.$index(0, "value"));
      this.set$show(map.$index(0, "show"));
    },
    valueToString$1: function(arg0) {
      return this.valueToString.call$1(arg0);
    },
    $isSaveable: 1,
    static: {Stat_Stat: function($name, valueToString, color, description, initialValue, priority, show, $T) {
        var t1, t2, t3, stat;
        t1 = H.buildFunctionType(H.buildInterfaceType(P.String), [H.buildInterfaceType(P.Object)]);
        t2 = t1._assertCheck$1(valueToString);
        t3 = $.get$Stat__stats();
        if (t3.containsKey$1($name)) {
          stat = H.interceptedTypeCheck(t3.$index(0, $name), "$isStat");
          H.assertHelper(stat.description === description);
          H.assertHelper(stat.color === color);
          H.assertHelper(stat.priority === priority);
        } else {
          t1._assertCheck$1(t2);
          stat = H.setRuntimeTypeInfo(new Z.Stat($name, description, t1._assertCheck$1(t2), color, priority, H.assertSubtypeOfRuntimeType(null, null), null, true, false, "Stat"), [null]);
        }
        stat.set$_value(initialValue);
        stat._show = show;
        t3.$indexSet(0, $name, stat);
        return H.assertSubtype(stat, "$isStat", [$T], "$asStat");
      }, Stat_createUpdates: function() {
        var updates, t1, t2, t3, t4;
        updates = new Z.StatUpdateCollection(H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, Z.StatUpdate), "$isMap", [P.String, Z.StatUpdate], "$asMap"), "$isMap", [P.String, Z.StatUpdate], "$asMap"));
        t1 = $.get$Stat__stats().get$values();
        t2 = new Z.Stat_createUpdates_closure();
        t3 = H.buildInterfaceType(P.bool);
        H.buildFunctionType(t3, [t1.E()])._assertCheck$1(t2);
        t4 = H.getRuntimeTypeArgument(t1, "IterableBase", 0);
        H.listSuperNativeTypeCheck(t1, "$isIterable");
        H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
        H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), H.buildFunctionType(t3, [H.getDynamicRuntimeType()])._assertCheck$1(t2)), [t4]), "$isIterable").forEach$1(0, new Z.Stat_createUpdates_closure0(updates));
        $.Stat_someChanged = false;
        return updates;
      }, Stat_createStatList: function() {
        var list = H.assertSubtype(H.setRuntimeTypeInfo([], [[P.Map, P.String, P.Object]]), "$isList", [[P.Map, P.String, P.Object]], "$asList");
        $.get$Stat__stats().get$values().forEach$1(0, new Z.Stat_createStatList_closure(list));
        return H.assertSubtype(list, "$isList", [[P.Map, P.String, P.Object]], "$asList");
      }}
  },
  Stat_createUpdates_closure: {
    "^": "Closure:2;",
    call$1: function(stat) {
      return stat.get$changed();
    }
  },
  Stat_createUpdates_closure0: {
    "^": "Closure:42;_captured_updates_0",
    call$1: function(stat) {
      var t1, t2;
      H.interceptedTypeCheck(stat, "$isStat");
      t1 = stat._show;
      t2 = H.stringTypeCheck(stat.valueToString$1(H.assertSubtypeOfRuntimeType(stat._value, H.getTypeArgumentByIndex(stat, 0))));
      stat.changed = false;
      this._captured_updates_0._updates.$indexSet(0, stat.name, new Z.StatUpdate(t1, t2));
    }
  },
  Stat_createStatList_closure: {
    "^": "Closure:42;_captured_list_0",
    call$1: function(stat) {
      var statMap;
      H.interceptedTypeCheck(stat, "$isStat");
      statMap = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.Object), "$isMap", [P.String, P.Object], "$asMap");
      statMap.$indexSet(0, "name", stat.name);
      statMap.$indexSet(0, "description", stat.description);
      statMap.$indexSet(0, "color", stat.color);
      statMap.$indexSet(0, "priority", stat.priority);
      statMap.$indexSet(0, "show", stat._show);
      statMap.$indexSet(0, "notifyOnChange", stat.notifyOnChange);
      statMap.$indexSet(0, "string", H.stringTypeCheck(stat.valueToString$1(H.assertSubtypeOfRuntimeType(stat._value, H.getTypeArgumentByIndex(stat, 0)))));
      C.JSArray_methods.add$1(this._captured_list_0, statMap);
    }
  }
}],
["storyline", "../libraries/storyline.dart", , Y, {
  "^": "",
  Report: {
    "^": "Object;string<,subject<,object<,owner<,objectOwner<,but<,positive<,negative<,endSentence<,startSentence<,wholeSentence<,actionThread,isSupportiveActionInThread,time<",
    set$but: function(but) {
      this.but = H.boolTypeCheck(but);
    },
    $index: function(_, key) {
      switch (key) {
        case "string":
          return this.string;
        case "subject":
          return this.subject;
        case "object":
          return this.object;
        case "owner":
          return this.owner;
        case "but":
          return this.but;
        case "positive":
          return this.positive;
        case "negative":
          return this.negative;
        case "endSentence":
          return this.endSentence;
        case "startSentence":
          return this.startSentence;
        case "wholeSentence":
          return this.wholeSentence;
        case "time":
          return this.time;
        default:
          throw H.wrapException(P.ArgumentError$("Invalid key " + H.S(key) + "."));
      }
    }
  },
  Storyline: {
    "^": "Object;strBuf,reports,time<",
    set$time: function(time) {
      this.time = H.intTypeCheck(time);
    },
    add$14$actionThread$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$startSentence$subject$time$wholeSentence: function(_, str, actionThread, but, endSentence, isSupportiveActionInThread, negative, object, objectOwner, owner, positive, startSentence, subject, time, wholeSentence) {
      H.interceptedTypeCheck(owner, "$isEntity");
      H.interceptedTypeCheck(subject, "$isEntity");
      if (str == null || str === "")
        return;
      if (time != null)
        this.time = time;
      if ((J.getInterceptor$s(str).endsWith$1(str, ".") || C.JSString_methods.endsWith$1(str, "!") || C.JSString_methods.endsWith$1(str, "?")) && C.JSString_methods.startsWith$1(str, new H.JSSyntaxRegExp("[A-Z]", H.JSSyntaxRegExp_makeNative("[A-Z]", false, true, false), null, null)))
        wholeSentence = true;
      C.JSArray_methods.add$1(this.reports, new Y.Report(str, subject, object, owner, objectOwner, but, positive, negative, endSentence, startSentence, wholeSentence, actionThread, isSupportiveActionInThread, time));
    },
    add$4$negative$subject$time: function($receiver, str, negative, subject, time) {
      return this.add$14$actionThread$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$startSentence$subject$time$wholeSentence($receiver, str, null, false, false, false, negative, null, null, null, false, false, subject, time, false);
    },
    add$6$negative$owner$positive$subject$time: function($receiver, str, negative, owner, positive, subject, time) {
      return this.add$14$actionThread$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$startSentence$subject$time$wholeSentence($receiver, str, null, false, false, false, negative, null, null, owner, positive, false, subject, time, false);
    },
    add$1: function($receiver, str) {
      return this.add$14$actionThread$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$startSentence$subject$time$wholeSentence($receiver, str, null, false, false, false, false, null, null, null, false, false, null, null, false);
    },
    add$2$wholeSentence: function($receiver, str, wholeSentence) {
      return this.add$14$actionThread$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$startSentence$subject$time$wholeSentence($receiver, str, null, false, false, false, false, null, null, null, false, false, null, null, wholeSentence);
    },
    add$5$object$owner$subject$wholeSentence: function($receiver, str, object, owner, subject, wholeSentence) {
      return this.add$14$actionThread$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$startSentence$subject$time$wholeSentence($receiver, str, null, false, false, false, false, object, null, owner, false, false, subject, null, wholeSentence);
    },
    add$3$object$subject: function($receiver, str, object, subject) {
      return this.add$14$actionThread$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$startSentence$subject$time$wholeSentence($receiver, str, null, false, false, false, false, object, null, null, false, false, subject, null, false);
    },
    add$4$object$objectOwner$subject: function($receiver, str, object, objectOwner, subject) {
      return this.add$14$actionThread$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$startSentence$subject$time$wholeSentence($receiver, str, null, false, false, false, false, object, objectOwner, null, false, false, subject, null, false);
    },
    add$5$object$objectOwner$owner$subject: function($receiver, str, object, objectOwner, owner, subject) {
      return this.add$14$actionThread$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$startSentence$subject$time$wholeSentence($receiver, str, null, false, false, false, false, object, objectOwner, owner, false, false, subject, null, false);
    },
    add$4$object$subject$wholeSentence: function($receiver, str, object, subject, wholeSentence) {
      return this.add$14$actionThread$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$startSentence$subject$time$wholeSentence($receiver, str, null, false, false, false, false, object, null, null, false, false, subject, null, wholeSentence);
    },
    add$6$object$owner$positive$subject$time: function($receiver, str, object, owner, positive, subject, time) {
      return this.add$14$actionThread$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$startSentence$subject$time$wholeSentence($receiver, str, null, false, false, false, false, object, null, owner, positive, false, subject, time, false);
    },
    add$12$actionThread$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$subject$time: function($receiver, str, actionThread, but, endSentence, isSupportiveActionInThread, negative, object, objectOwner, owner, positive, subject, time) {
      return this.add$14$actionThread$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$startSentence$subject$time$wholeSentence($receiver, str, actionThread, but, endSentence, isSupportiveActionInThread, negative, object, objectOwner, owner, positive, false, subject, time, false);
    },
    add$5$object$positive$subject$time: function($receiver, str, object, positive, subject, time) {
      return this.add$14$actionThread$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$startSentence$subject$time$wholeSentence($receiver, str, null, false, false, false, false, object, null, null, positive, false, subject, time, false);
    },
    add$7$actionThread$isSupportiveActionInThread$object$owner$subject$time: function($receiver, str, actionThread, isSupportiveActionInThread, object, owner, subject, time) {
      return this.add$14$actionThread$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$startSentence$subject$time$wholeSentence($receiver, str, actionThread, false, false, isSupportiveActionInThread, false, object, null, owner, false, false, subject, time, false);
    },
    add$6$actionThread$isSupportiveActionInThread$object$subject$time: function($receiver, str, actionThread, isSupportiveActionInThread, object, subject, time) {
      return this.add$14$actionThread$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$startSentence$subject$time$wholeSentence($receiver, str, actionThread, false, false, isSupportiveActionInThread, false, object, null, null, false, false, subject, time, false);
    },
    add$4$object$subject$time: function($receiver, str, object, subject, time) {
      return this.add$14$actionThread$but$endSentence$isSupportiveActionInThread$negative$object$objectOwner$owner$positive$startSentence$subject$time$wholeSentence($receiver, str, null, false, false, false, false, object, null, null, false, false, subject, time, false);
    },
    addEnumeration$8$conjuction$maxPerSentence$object$owner$subject: function(start, articles, end, conjuction, maxPerSentence, object, owner, subject) {
      var buf, t1, t2, t3, t4, t5, i, sentenceCount, article;
      H.listSuperNativeTypeCheck(articles, "$isIterable");
      H.assertHelper(true);
      H.assertHelper(true);
      if (articles.get$length(articles) === 0)
        return;
      buf = new P.StringBuffer("");
      t1 = new Y.Storyline_addEnumeration_removeAlso();
      t2 = H.S(t1.call$1(start));
      buf._contents = t2;
      buf._contents = t2 + " ";
      for (t2 = J.get$iterator$a(articles.__internal$_iterable), t3 = articles._f, t4 = H.getTypeArgumentByIndex(articles, 0), H.assertSubtype(t2, "$isIterator", [t4], "$asIterator"), t5 = H.buildInterfaceType(P.bool), H.buildFunctionType(t5, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t3), t4 = H.assertSubtype(H.setRuntimeTypeInfo(new H.WhereIterator(H.assertSubtype(t2, "$isIterator", [t4], "$asIterator"), H.buildFunctionType(t5, [H.getDynamicRuntimeType()])._assertCheck$1(t3)), [t4]), "$isIterator", [H.getTypeArgumentByIndex(articles, 0)], "$asIterator"), t3 = maxPerSentence - 1, t5 = t4._iterator, i = 0, sentenceCount = 0; t4.moveNext$0();) {
        article = H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t5.get$current(), H.getTypeArgumentByIndex(t4, 0)), "$isEntity");
        if (i > 0) {
          if (i === 1) {
            t2 = articles.get$last(articles);
            t2 = article == null ? t2 == null : article === t2;
          } else
            t2 = false;
          if (t2) {
            t2 = buf._contents += " ";
            t2 += conjuction;
            buf._contents = t2;
          } else {
            t2 = buf._contents;
            if (i === t3) {
              t2 += ", " + conjuction;
              buf._contents = t2;
            } else {
              t2 += ",";
              buf._contents = t2;
            }
          }
          buf._contents = t2 + " ";
        }
        buf._contents += H.S(Y.Storyline_addParticleToFirstOccurence(article.get$name(), article.get$name(), article, null));
        ++i;
        if (i > t3 || article === articles.get$last(articles)) {
          buf._contents += " ";
          if (sentenceCount === 0)
            buf._contents += H.S(t1.call$1(end));
          else
            buf._contents += H.S(H.stringReplaceAllUnchecked(end, "<also>", "also"));
          t2 = buf._contents += ".";
          this.add$5$object$owner$subject$wholeSentence(0, t2.charCodeAt(0) == 0 ? t2 : t2, object, owner, subject, true);
          ++sentenceCount;
          buf._contents = "";
          t2 = buf._contents += H.S(H.stringReplaceAllUnchecked(start, "<also>", "also"));
          buf._contents = t2 + " ";
          i = 0;
        }
      }
    },
    addEnumeration$4$subject: function(start, articles, end, subject) {
      return this.addEnumeration$8$conjuction$maxPerSentence$object$owner$subject(start, articles, end, "and", 3, null, null, subject);
    },
    string$1: [function(i) {
      var t1;
      H.intTypeCheck(i);
      if (typeof i !== "number")
        return i.$lt();
      if (i < 0 || i >= this.reports.length)
        return;
      else {
        t1 = this.reports;
        if (i < 0 || i >= t1.length)
          return H.ioore(t1, i);
        return H.stringTypeCheck(t1[i].get$string());
      }
    }, "call$1", "get$string", 2, 0, 20],
    subject$1: [function(i) {
      var t1;
      H.intTypeCheck(i);
      if (typeof i !== "number")
        return i.$lt();
      if (i < 0 || i >= this.reports.length)
        return;
      else {
        t1 = this.reports;
        if (i < 0 || i >= t1.length)
          return H.ioore(t1, i);
        return H.interceptedTypeCheck(t1[i].get$subject(), "$isEntity");
      }
    }, "call$1", "get$subject", 2, 0, 43],
    object$1: [function(i) {
      var t1;
      H.intTypeCheck(i);
      if (typeof i !== "number")
        return i.$lt();
      if (i < 0 || i >= this.reports.length)
        return;
      else {
        t1 = this.reports;
        if (i < 0 || i >= t1.length)
          return H.ioore(t1, i);
        return H.interceptedTypeCheck(t1[i].get$object(), "$isEntity");
      }
    }, "call$1", "get$object", 2, 0, 43],
    timeSincePrevious$1: function(i) {
      var t1, t2, t3;
      t1 = this.reports;
      if (i >= t1.length)
        return H.ioore(t1, i);
      if (t1[i].get$time() != null) {
        t2 = i - 1;
        if (this.valid$1(t2)) {
          if (t2 < 0 || t2 >= t1.length)
            return H.ioore(t1, t2);
          t2 = t1[t2].get$time() == null;
        } else
          t2 = true;
      } else
        t2 = true;
      if (t2)
        return 1000;
      else {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t2 = t1[i].get$time();
        t3 = i - 1;
        if (t3 < 0 || t3 >= t1.length)
          return H.ioore(t1, t3);
        t3 = t1[t3].get$time();
        if (typeof t2 !== "number")
          return t2.$sub();
        return C.JSInt_methods.$sub(t2, t3);
      }
    },
    same$3: function(key, i, j) {
      var t1, t2;
      if (!this.valid$1(i) || !this.valid$1(j))
        return false;
      t1 = this.reports;
      if (i >= t1.length)
        return H.ioore(t1, i);
      if (J.$index$as(t1[i], key) != null) {
        if (j < 0 || j >= t1.length)
          return H.ioore(t1, j);
        t2 = J.$index$as(t1[j], key) == null;
      } else
        t2 = true;
      if (t2)
        return false;
      if (i >= t1.length)
        return H.ioore(t1, i);
      t2 = J.$index$as(t1[i], key);
      if (j < 0 || j >= t1.length)
        return H.ioore(t1, j);
      if (J.$eq(t2, J.$index$as(t1[j], key)))
        return true;
      else
        return false;
    },
    exchanged$4: function(key1, key2, i, j) {
      var t1, t2;
      if (!this.valid$1(i) || !this.valid$1(j))
        return false;
      t1 = this.reports;
      if (i < 0 || i >= t1.length)
        return H.ioore(t1, i);
      if (J.$index$as(t1[i], key1) != null) {
        if (j < 0 || j >= t1.length)
          return H.ioore(t1, j);
        t2 = J.$index$as(t1[j], key1) == null;
      } else
        t2 = true;
      if (t2)
        return false;
      if (i >= t1.length)
        return H.ioore(t1, i);
      if (J.$index$as(t1[i], key2) != null) {
        if (j < 0 || j >= t1.length)
          return H.ioore(t1, j);
        t2 = J.$index$as(t1[j], key2) == null;
      } else
        t2 = true;
      if (t2)
        return false;
      if (i >= t1.length)
        return H.ioore(t1, i);
      t2 = J.$index$as(t1[i], key1);
      if (j < 0 || j >= t1.length)
        return H.ioore(t1, j);
      if (J.$eq(t2, J.$index$as(t1[j], key2))) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t2 = J.$index$as(t1[i], key2);
        if (j >= t1.length)
          return H.ioore(t1, j);
        t1 = J.$eq(t2, J.$index$as(t1[j], key1));
      } else
        t1 = false;
      if (t1)
        return true;
      else
        return false;
    },
    valid$1: function(i) {
      if (i >= this.reports.length || i < 0)
        return false;
      else
        return true;
    },
    sameSentiment$2: function(i, j) {
      var t1, t2;
      if (!this.valid$1(i) || !this.valid$1(j))
        return false;
      if (this.exchanged$4("subject", "object", i, j) && this.subject$1(i).isEnemyOf$1(this.subject$1(j))) {
        t1 = this.reports;
        if (i >= t1.length)
          return H.ioore(t1, i);
        if (t1[i].get$positive()) {
          if (j >= t1.length)
            return H.ioore(t1, j);
          t2 = t1[j].get$negative();
        } else
          t2 = false;
        if (t2)
          return true;
        if (i >= t1.length)
          return H.ioore(t1, i);
        if (t1[i].get$negative()) {
          if (j >= t1.length)
            return H.ioore(t1, j);
          t1 = t1[j].get$positive();
        } else
          t1 = false;
        if (t1)
          return true;
      }
      if (!this.same$3("subject", i, j))
        return false;
      t1 = this.reports;
      if (i >= t1.length)
        return H.ioore(t1, i);
      if (t1[i].get$positive()) {
        if (j >= t1.length)
          return H.ioore(t1, j);
        t2 = t1[j].get$positive();
      } else
        t2 = false;
      if (t2)
        return true;
      if (i >= t1.length)
        return H.ioore(t1, i);
      if (t1[i].get$negative()) {
        if (j >= t1.length)
          return H.ioore(t1, j);
        t1 = t1[j].get$negative();
      } else
        t1 = false;
      if (t1)
        return true;
      else
        return false;
    },
    oppositeSentiment$2: function(i, j) {
      var t1, t2;
      if (!this.valid$1(i) || !this.valid$1(j))
        return false;
      if (this.exchanged$4("subject", "object", i, j) && this.subject$1(i).isEnemyOf$1(this.subject$1(j))) {
        t1 = this.reports;
        if (i >= t1.length)
          return H.ioore(t1, i);
        if (t1[i].get$positive()) {
          if (j < 0 || j >= t1.length)
            return H.ioore(t1, j);
          t2 = t1[j].get$positive();
        } else
          t2 = false;
        if (t2)
          return true;
        if (i >= t1.length)
          return H.ioore(t1, i);
        if (t1[i].get$negative()) {
          if (j < 0 || j >= t1.length)
            return H.ioore(t1, j);
          t1 = t1[j].get$negative();
        } else
          t1 = false;
        if (t1)
          return true;
      }
      t1 = this.reports;
      if (i >= t1.length)
        return H.ioore(t1, i);
      t2 = t1[i].get$subject();
      if (j < 0 || j >= t1.length)
        return H.ioore(t1, j);
      if (this._sameTeam$2(t2, t1[j].get$subject())) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        if (t1[i].get$positive()) {
          if (j >= t1.length)
            return H.ioore(t1, j);
          t2 = t1[j].get$negative();
        } else
          t2 = false;
        if (t2)
          return true;
        if (i >= t1.length)
          return H.ioore(t1, i);
        if (t1[i].get$negative()) {
          if (j >= t1.length)
            return H.ioore(t1, j);
          t1 = t1[j].get$positive();
        } else
          t1 = false;
        if (t1)
          return true;
      }
      return false;
    },
    _sameTeam$2: function(a, b) {
      var t1, t2;
      H.interceptedTypeCheck(a, "$isEntity");
      H.interceptedTypeCheck(b, "$isEntity");
      if (a == null || b == null)
        return false;
      t1 = a.team;
      t2 = b.team;
      return t1 == null ? t2 == null : t1 === t2;
    },
    toString$0: function(_) {
      var t1, t2, t3, $length, lastEndSentence, endPreviousSentence, endThisSentence, but, i, t4, t5, objectSubjectSwitch, t6, t7, report, result, t8, s;
      t1 = this.reports;
      t2 = new Y.Storyline_toString_closure();
      t3 = H.buildFunctionType(H.buildInterfaceType(P.bool), [H.convertRtiToRuntimeType(t1.$builtinTypeInfo && t1.$builtinTypeInfo[0])]);
      t3._assertCheck$1(t2);
      C.JSArray_methods.checkGrowable$1(t1, "removeWhere");
      C.JSArray_methods._removeWhere$2(t1, t2, true);
      t2 = new Y.Storyline_toString_closure0(H.assertSubtype(C.JSArray_methods.fold$2(t1, [], new Y.Storyline_toString_closure1()), "$isList", [Y.Report], "$asList"));
      t3._assertCheck$1(t2);
      C.JSArray_methods.checkGrowable$1(t1, "retainWhere");
      C.JSArray_methods._removeWhere$2(t1, t2, false);
      $length = t1.length;
      if ($length < 1)
        return "";
      for (t2 = this.strBuf, t3 = $length - 1, lastEndSentence = -1, endPreviousSentence = true, endThisSentence = false, but = false, i = 0; i < $length; ++i) {
        t4 = i === 0;
        if (!t4) {
          t5 = i - 1;
          objectSubjectSwitch = this.exchanged$4("subject", "object", t5, i);
          if (i >= t1.length)
            return H.ioore(t1, i);
          if (t1[i].get$but() || this.oppositeSentiment$2(i, t5)) {
            if (t5 < 0 || t5 >= t1.length)
              return H.ioore(t1, t5);
            but = !t1[t5].get$but();
          } else
            but = false;
          if (i >= t1.length)
            return H.ioore(t1, i);
          t1[i].set$but(but);
          t6 = i - lastEndSentence;
          if (t6 < 3)
            if (!endThisSentence) {
              if (i >= t1.length)
                return H.ioore(t1, i);
              if (!t1[i].get$startSentence()) {
                if (t5 < 0 || t5 >= t1.length)
                  return H.ioore(t1, t5);
                if (!t1[t5].get$endSentence()) {
                  if (i >= t1.length)
                    return H.ioore(t1, i);
                  if (!t1[i].get$wholeSentence())
                    if (this.same$3("subject", i, t5) || objectSubjectSwitch)
                      if (!(but && t6 > 1)) {
                        if (but) {
                          if (t5 >= t1.length)
                            return H.ioore(t1, t5);
                          t7 = t1[t5].get$but();
                        } else
                          t7 = false;
                        t7 = t7 || this.timeSincePrevious$1(i) > 4;
                      } else
                        t7 = true;
                    else
                      t7 = true;
                  else
                    t7 = true;
                } else
                  t7 = true;
              } else
                t7 = true;
              endPreviousSentence = t7;
            } else
              endPreviousSentence = true;
          else
            endPreviousSentence = true;
          if (endPreviousSentence) {
            if (t5 < 0 || t5 >= t1.length)
              return H.ioore(t1, t5);
            t5 = t1[t5].get$wholeSentence();
            t6 = t2._contents;
            if (t5)
              t2._contents = t6 + " ";
            else
              t2._contents = t6 + ". ";
            if (but) {
              if (i >= t1.length)
                return H.ioore(t1, i);
              t5 = !t1[i].get$wholeSentence();
            } else
              t5 = false;
            if (t5)
              t2._contents += H.S(S.Randomly_choose(["But ", "But ", "However, ", "Nonetheless, ", "Nevertheless, "]));
            endThisSentence = false;
          } else if (but) {
            t2._contents += H.S(S.Randomly_choose([" but ", " but ", " yet ", ", but "]));
            endThisSentence = !this.sameSentiment$2(i, i + 1) && true;
          } else if (this.same$3("subject", i, t5) && J.startsWith$1$s(this.string$1(i), "<subject> ") && i < t3 && t6 < 2 && this.timeSincePrevious$1(i + 1) <= 4) {
            t2._contents += ", ";
            endThisSentence = false;
          } else {
            t2._contents += H.S(S.Randomly_choose([" and ", " and ", ", and "]));
            endThisSentence = true;
          }
        }
        report = this.string$1(i);
        t5 = !endPreviousSentence;
        if (t5) {
          t6 = i - 1;
          if (this.same$3("subject", i, t6))
            if (J.startsWith$1$s(this.string$1(t6), "<subject> "))
              if (J.startsWith$1$s(report, "<subject> ")) {
                t6 = report.length;
                report = H.stringReplaceFirstUnchecked(report, "<subject> ", "", 0);
              }
        }
        result = J.replaceAll$2$s(report, "<action>", this.string$1(i));
        if (this.same$3("object", i, i - 1))
          t6 = !(this.object$1(i).get$pronoun() === C.Pronoun_it_it_its_itself && this.subject$1(i).get$pronoun() === C.Pronoun_it_it_its_itself);
        else
          t6 = false;
        if (t6)
          result = J.replaceAll$2$s(J.replaceAll$2$s(J.replaceAll$2$s(J.replaceAll$2$s(result, "<object-owner's> <object>", this.object$1(i).get$pronoun().accusative), "<object-ownerPronoun's> <object>", this.object$1(i).get$pronoun().accusative), "<object>", this.object$1(i).get$pronoun().accusative), "<object's>", this.object$1(i).get$pronoun().genitive);
        if (this.same$3("subject", i, i - 1))
          result = J.replaceAll$2$s(J.replaceAll$2$s(J.replaceAll$2$s(J.replaceAll$2$s(result, "<owner's> <subject>", this.subject$1(i).get$pronoun().nominative), "<ownerPronoun's> <subject>", this.subject$1(i).get$pronoun().nominative), "<subject>", this.subject$1(i).get$pronoun().nominative), "<subject's>", this.subject$1(i).get$pronoun().genitive);
        t6 = i - 1;
        if (this.object$1(t6) != null)
          if (this.subject$1(i) != null)
            if (this.subject$1(t6) != null) {
              t7 = this.object$1(t6);
              t8 = this.subject$1(i);
              t7 = (t7 == null ? t8 == null : t7 === t8) && this.subject$1(t6).get$pronoun() !== this.subject$1(i).get$pronoun();
            } else
              t7 = false;
          else
            t7 = false;
        else
          t7 = false;
        if (t7)
          result = J.replaceAll$2$s(J.replaceAll$2$s(J.replaceAll$2$s(J.replaceAll$2$s(result, "<owner's> <subject>", this.subject$1(i).get$pronoun().nominative), "<ownerPronoun's> <subject>", this.subject$1(i).get$pronoun().nominative), "<subject>", this.subject$1(i).get$pronoun().nominative), "<subject's>", this.subject$1(i).get$pronoun().genitive);
        if (this.subject$1(t6) != null)
          if (this.object$1(i) != null)
            if (this.subject$1(t6) != null) {
              t7 = this.subject$1(t6);
              t8 = this.object$1(i);
              t6 = (t7 == null ? t8 == null : t7 === t8) && this.subject$1(t6).get$pronoun() !== this.subject$1(i).get$pronoun();
            } else
              t6 = false;
          else
            t6 = false;
        else
          t6 = false;
        if (t6)
          result = J.replaceAll$2$s(J.replaceAll$2$s(J.replaceAll$2$s(J.replaceAll$2$s(result, "<object-owner's> <object>", this.object$1(i).get$pronoun().nominative), "<object-ownerPronoun's> <object>", this.object$1(i).get$pronoun().nominative), "<object>", this.object$1(i).get$pronoun().accusative), "<object's>", this.object$1(i).get$pronoun().genitive);
        if (i >= t1.length)
          return H.ioore(t1, i);
        t6 = t1[i].get$subject();
        if (i >= t1.length)
          return H.ioore(t1, i);
        t7 = t1[i].get$object();
        if (i >= t1.length)
          return H.ioore(t1, i);
        t8 = t1[i].get$owner();
        if (i >= t1.length)
          return H.ioore(t1, i);
        report = Y.Storyline_getString(result, t7, t1[i].get$objectOwner(), t8, t6);
        t2._contents += (!t5 || t4) && !but ? Y.Storyline_capitalize(report) : report;
        if (endPreviousSentence)
          lastEndSentence = i;
        if (i >= t1.length)
          return H.ioore(t1, i);
        if (t1[i].get$wholeSentence())
          endThisSentence = true;
      }
      if (t3 >= t1.length)
        return H.ioore(t1, t3);
      if (!t1[t3].get$wholeSentence())
        t2._contents += ".";
      t1 = t2._contents;
      s = t1.charCodeAt(0) == 0 ? t1 : t1;
      t1 = $.get$Storyline_QUOTE_INTERPUNCTION_DUPLICATION();
      t2 = new Y.Storyline_toString_closure2();
      t3 = H.buildInterfaceType(P.String);
      t4 = H.buildFunctionType(t3, [H.buildInterfaceType(P.Match)]);
      t4._assertCheck$1(t2);
      t4._assertCheck$1(t2);
      H.buildFunctionType(t3, [t3])._assertCheck$1(null);
      return H.stringReplaceAllFuncUnchecked(s, t1, t2, null);
    },
    static: {Storyline_capitalize: function(str) {
        var t1, firstLetter;
        if (!J.getInterceptor$as(str).contains$1(str, "\n\n"))
          str = C.JSString_methods.trimLeft$0(str);
        t1 = str.length;
        if (t1 === 0)
          return str;
        if (0 >= t1)
          return H.ioore(str, 0);
        firstLetter = str[0].toUpperCase();
        if (t1 === 1)
          return firstLetter;
        else
          return firstLetter + C.JSString_methods.substring$1(str, 1);
      }, Storyline_getString: function(str, object, objectOwner, owner, subject) {
        var result, t1, t2;
        H.interceptedTypeCheck(object, "$isEntity");
        H.interceptedTypeCheck(subject, "$isEntity");
        if (subject != null) {
          result = subject.isPlayer ? J.replaceAll$2$s(J.replaceAll$2$s(str, "<subject>", "you"), "<subject's>", "your") : str;
          t1 = subject.get$pronoun() === C.Pronoun_you_you_your_yourself || subject.get$pronoun() === C.Pronoun_they_them_their_themselves;
          t2 = J.getInterceptor$s(result);
          result = J.replaceFirst$2$s(t1 ? J.replaceAll$2$s(J.replaceAll$2$s(J.replaceAll$2$s(J.replaceAll$2$s(J.replaceAll$2$s(t2.replaceAll$2(result, "<s>", ""), "<es>", ""), "<ies>", "y"), "<does>", "do"), "<is>", "are"), "<has>", "have") : J.replaceAll$2$s(J.replaceAll$2$s(J.replaceAll$2$s(J.replaceAll$2$s(J.replaceAll$2$s(t2.replaceAll$2(result, "<s>", "s"), "<es>", "es"), "<ies>", "ies"), "<does>", "does"), "<is>", "is"), "<has>", "has"), "<subject>", "<subjectNoun>");
          t2 = subject.get$pronoun().nominative;
          H.checkString(t2);
          result = J.replaceFirst$2$s(Y.Storyline_addParticleToFirstOccurence(H.stringReplaceAllUnchecked(result, "<subject>", t2), "<subjectNoun>", subject, owner), "<subjectNoun>", subject.get$name());
          t2 = subject.get$pronoun().nominative;
          H.checkString(t2);
          result = H.stringReplaceAllUnchecked(result, "<subjectPronoun>", t2);
          result = J.replaceFirst$2$s(Y.Storyline_addParticleToFirstOccurence(J.contains$1$as(str, new H.JSSyntaxRegExp("<subject>.+<subject's>", H.JSSyntaxRegExp_makeNative("<subject>.+<subject's>", false, true, false), null, null)) ? J.replaceAll$2$s(result, "<subject's>", subject.get$pronoun().genitive) : result, "<subject's>", subject, owner), "<subject's>", H.S(subject.get$name()) + "'s");
          t1 = subject.get$pronoun().genitive;
          H.checkString(t1);
          result = J.replaceAll$2$s(H.stringReplaceAllUnchecked(result, "<subject's>", t1), "<subjectPronoun's>", subject.get$pronoun().genitive);
        } else
          result = str;
        if (object != null) {
          result = object.isPlayer ? J.replaceAll$2$s(J.replaceAll$2$s(result, "<object>", "you"), "<object's>", "your") : J.replaceAll$2$s(Y.Storyline_addParticleToFirstOccurence(result, "<object>", object, objectOwner), "<object>", object.get$name());
          result = J.replaceAll$2$s(result, "<objectPronoun>", object.get$pronoun().accusative);
          result = J.replaceFirst$2$s(Y.Storyline_addParticleToFirstOccurence(J.contains$1$as(str, new H.JSSyntaxRegExp("<object>.+<object's>", H.JSSyntaxRegExp_makeNative("<object>.+<object's>", false, true, false), null, null)) ? J.replaceAll$2$s(result, "<object's>", object.get$pronoun().genitive) : result, "<object's>", object, objectOwner), "<object's>", H.S(object.get$name()) + "'s");
          t1 = object.get$pronoun().genitive;
          H.checkString(t1);
          result = J.replaceAll$2$s(H.stringReplaceAllUnchecked(result, "<object's>", t1), "<objectPronoun's>", object.get$pronoun().genitive);
        }
        return S.Randomly_parse(Y.Storyline__realizeOwner(objectOwner, Y.Storyline__realizeOwner(owner, result, str, "<owner>", "<owner's>", "<ownerPronoun>", "<ownerPronoun's>"), str, "<object-owner>", "<object-owner's>", "<object-ownerPronoun>", "<object-ownerPronoun's>"));
      }, Storyline__realizeOwner: function(owner, result, str, OWNER_OR_OBJECT_OWNER, OWNER_OR_OBJECT_OWNER_POSSESSIVE, OWNER_OR_OBJECT_OWNER_PRONOUN, OWNER_OR_OBJECT_OWNER_PRONOUN_POSSESSIVE) {
        var t1, t2;
        H.interceptedTypeCheck(owner, "$isEntity");
        if (owner != null) {
          result = owner.isPlayer ? J.replaceAll$2$s(J.replaceAll$2$s(result, OWNER_OR_OBJECT_OWNER, "you"), OWNER_OR_OBJECT_OWNER_POSSESSIVE, "your") : J.replaceAll$2$s(Y.Storyline_addParticleToFirstOccurence(result, OWNER_OR_OBJECT_OWNER, owner, null), OWNER_OR_OBJECT_OWNER, owner.get$name());
          result = J.replaceAll$2$s(result, OWNER_OR_OBJECT_OWNER_PRONOUN, owner.get$pronoun().nominative);
          t1 = OWNER_OR_OBJECT_OWNER + ".+" + OWNER_OR_OBJECT_OWNER_POSSESSIVE;
          result = J.replaceFirst$2$s(Y.Storyline_addParticleToFirstOccurence(J.contains$1$as(str, new H.JSSyntaxRegExp(t1, H.JSSyntaxRegExp_makeNative(t1, false, true, false), null, null)) ? J.replaceAll$2$s(result, OWNER_OR_OBJECT_OWNER_POSSESSIVE, owner.get$pronoun().genitive) : result, OWNER_OR_OBJECT_OWNER_POSSESSIVE, owner, null), OWNER_OR_OBJECT_OWNER_POSSESSIVE, H.S(owner.get$name()) + "'s");
          t2 = owner.get$pronoun().genitive;
          H.checkString(t2);
          result = J.replaceAll$2$s(H.stringReplaceAllUnchecked(result, OWNER_OR_OBJECT_OWNER_POSSESSIVE, t2), OWNER_OR_OBJECT_OWNER_PRONOUN_POSSESSIVE, owner.get$pronoun().genitive);
        } else
          result = J.replaceAll$2$s(J.replaceAll$2$s(J.replaceAll$2$s(J.replaceAll$2$s(result, OWNER_OR_OBJECT_OWNER, ""), OWNER_OR_OBJECT_OWNER_POSSESSIVE, ""), OWNER_OR_OBJECT_OWNER_PRONOUN, ""), OWNER_OR_OBJECT_OWNER_PRONOUN_POSSESSIVE, "");
        return result;
      }, Storyline_addParticleToFirstOccurence: function(string, SUB_STRING, entity, entityOwner) {
        var t1;
        H.interceptedTypeCheck(entity, "$isEntity");
        if (H.interceptedTypeCheck(entityOwner, "$isEntity") != null)
          t1 = J.getInterceptor$as(string).indexOf$1(string, "<owner's> " + H.S(SUB_STRING)) !== -1 || C.JSString_methods.indexOf$1(string, "<ownerPronoun's> " + H.S(SUB_STRING)) !== -1 || C.JSString_methods.indexOf$1(string, "<object-owner's> " + H.S(SUB_STRING)) !== -1 || C.JSString_methods.indexOf$1(string, "<object-ownerPronoun's> " + H.S(SUB_STRING)) !== -1;
        else
          t1 = false;
        if (t1)
          return string;
        if (!entity.nameIsProperNoun)
          if (entity.alreadyMentioned)
            string = J.replaceFirst$2$s(string, SUB_STRING, "the " + H.S(SUB_STRING));
          else {
            t1 = J.getInterceptor$s(string);
            string = J.startsWith$1$s(entity.get$name(), new H.JSSyntaxRegExp("[aeiouy]", H.JSSyntaxRegExp_makeNative("[aeiouy]", false, false, false), null, null)) ? t1.replaceFirst$2(string, SUB_STRING, "an " + H.S(SUB_STRING)) : t1.replaceFirst$2(string, SUB_STRING, "a " + H.S(SUB_STRING));
            entity.alreadyMentioned = true;
          }
        return string;
      }}
  },
  Storyline_addEnumeration_removeAlso: {
    "^": "Closure:44;",
    call$1: function(s) {
      H.checkString("");
      return J.trim$0$s(J.replaceAll$2$s(H.stringReplaceAllUnchecked(s, "<also> ", ""), "  ", " "));
    }
  },
  Storyline_toString_closure: {
    "^": "Closure:2;",
    call$1: function(report) {
      return J.$eq(report.get$string(), "");
    }
  },
  Storyline_toString_closure1: {
    "^": "Closure:45;",
    call$2: function(list, report) {
      var t1, previousReport, t2, t3;
      H.assertSubtype(list, "$isList", [Y.Report], "$asList");
      H.interceptedTypeCheck(report, "$isReport");
      t1 = J.getInterceptor$as(list);
      previousReport = H.interceptedTypeCheck(t1.get$isNotEmpty(list) ? t1.get$last(list) : null, "$isReport");
      if (previousReport != null)
        if (previousReport.isSupportiveActionInThread) {
          t2 = report.actionThread;
          t3 = previousReport.actionThread;
          t3 = t2 == null ? t3 == null : t2 === t3;
          t2 = t3;
        } else
          t2 = false;
      else
        t2 = false;
      if (t2)
        t1.$indexSet(list, t1.get$length(list) - 1, report);
      else
        t1.add$1(list, report);
      return list;
    }
  },
  Storyline_toString_closure0: {
    "^": "Closure:46;_captured_cleanedReports_0",
    call$1: function(report) {
      return J.contains$1$as(this._captured_cleanedReports_0, H.interceptedTypeCheck(report, "$isReport"));
    }
  },
  Storyline_toString_closure2: {
    "^": "Closure:47;",
    call$1: function(m) {
      return H.S(m.$index(0, 1)) + H.S(m.$index(0, 2)) + H.S(m.$index(0, 3));
    }
  },
  Entity: {
    "^": "Object;nameIsProperNoun,name<,categories,alreadyMentioned,team,isActive<,isPlayer,pronoun<",
    isEnemyOf$1: function(other) {
      var t1, t2;
      H.interceptedTypeCheck(other, "$isActor");
      t1 = this.team;
      if (t1 === 0 || other.team === 0)
        return false;
      t2 = other.team;
      return t1 == null ? t2 != null : t1 !== t2;
    },
    report$2$object: function(text, object) {
      $.get$storyline().add$3$object$subject(0, text, object, this);
    },
    report$1: function(text) {
      return this.report$2$object(text, null);
    },
    static: {Entity$withOptions: function($name, alreadyMentioned, isPlayer, nameIsProperNoun, pronoun, team) {
        return new Y.Entity(nameIsProperNoun, $name, H.assertSubtype(H.setRuntimeTypeInfo([], [P.String]), "$isList", [P.String], "$asList"), alreadyMentioned, team, true, isPlayer, pronoun);
      }}
  },
  Actor: {
    "^": "Entity;",
    get$isAlive: function() {
      return true;
    },
    get$isAliveAndActive: function() {
      return H.boolConversionCheck(this.get$isAlive()) && H.boolConversionCheck(this.isActive);
    }
  },
  Pronoun: {
    "^": "Object;nominative,accusative,genitive,self",
    toString$0: function(_) {
      return this.nominative;
    }
  }
}],
["timeline", "../libraries/timeline.dart", , L, {
  "^": "",
  TimedEvent: {
    "^": "Object;",
    get$isSingular: function() {
      return this.get$type() === 4;
    }
  },
  FunctionTimedEvent: {
    "^": "TimedEvent;type<,action,priority<,text",
    run$0: function() {
      var $returnValue = this.action$0();
      if ($returnValue != null && typeof $returnValue === "string")
        return H.stringTypeCheck($returnValue);
      else
        return;
    },
    action$0: function() {
      return this.action.call$0();
    }
  },
  Timeline: {
    "^": "Object;time<,maxTime,_whileString,_events,_schedule,_mainLoop,finished,className<,_singularAlreadyFired",
    set$time: function(time) {
      this.time = H.intTypeCheck(time);
    },
    generateWhileOutput$2: function(template, otherwise) {
      var t1 = this._whileString;
      if (t1 == null)
        return otherwise;
      H.checkString(t1);
      return H.stringReplaceAllUnchecked(template, "<whileString>", t1);
    },
    schedule$4$priority$type: function(time, action, priority, type) {
      var t1, t2, $event;
      O.throwIfNotInInitOrDeclareBlock("");
      t1 = H.buildFunctionType(H.getDynamicRuntimeType());
      t2 = t1._isTest$1(action);
      if (t2) {
        t1._assertCheck$1(action);
        $event = new L.FunctionTimedEvent(type, t1._assertCheck$1(action), priority, null);
        t1._assertCheck$1(action);
      } else
        throw H.wrapException(P.ArgumentError$("Only String or a function can be scheduled. Instead, on object of type " + H.getRuntimeType(action).toString$0(0) + " was recieved."));
      t1 = this._events;
      C.JSArray_methods.add$1(t1, $event);
      if (time != null) {
        H.assertHelper(C.JSArray_methods.lastIndexOf$1(t1, $event) === t1.length - 1);
        this._schedule.$indexSet(0, t1.length - 1, time);
      }
      return $event;
    },
    schedule$2: function(time, action) {
      return this.schedule$4$priority$type(time, action, 0, 4);
    },
    schedule$3$type: function(time, action, type) {
      return this.schedule$4$priority$type(time, action, 0, type);
    },
    reschedule$2: function($event, time) {
      var i = C.JSArray_methods.indexOf$1(this._events, $event);
      if (i === -1)
        throw H.wrapException(P.ArgumentError$("Event " + J.toString$0($event) + " wasn't found in the timeline. You must first add it to timeline in the init block before being able to reschedule it."));
      this._schedule.$indexSet(0, i, time);
    },
    toMap$0: function() {
      var map, s;
      map = H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.Object), "$isMap", [P.String, P.Object], "$asMap"), "$isMap", [P.String, P.Object], "$asMap");
      map.$indexSet(0, "time", this.time);
      s = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.$int), "$isMap", [P.String, P.$int], "$asMap");
      map.$indexSet(0, "schedule", s);
      this._schedule.forEach$1(0, new L.Timeline_toMap_closure(s));
      return H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
    },
    updateFromMap$1: function(map) {
      H.interceptedTypeCheck(map, "$isMap");
      this.time = H.intTypeCheck(map.$index(0, "time"));
      this._schedule.clear$0(0);
      H.subtypeCast(map.$index(0, "schedule"), "$isMap", [P.String, P.$int], "$asMap").forEach$1(0, new L.Timeline_updateFromMap_closure(this));
    },
    _handleEventOutput$1: function(s) {
      var t1, t2;
      H.stringTypeCheck(s);
      if (s == null)
        return;
      t1 = $.get$textBuffer();
      t2 = t1._contents;
      if (t2.length > 0) {
        t2 += " ";
        t1._contents = t2;
      }
      t1._contents = t2 + s;
    },
    _goOneTick$1: function(interactive) {
      var currentEvents, t1, t2, t3, $event;
      if (this._mainLoop != null)
        this._handleEventOutput$1(this._mainLoop$0());
      if (this.finished)
        return;
      currentEvents = H.assertSubtype(this._getOrPostponeEvents$1(interactive), "$isList", [L.TimedEvent], "$asList");
      t1 = new L.Timeline__goOneTick_closure();
      t2 = H.buildInterfaceType(P.$int);
      t3 = H.convertRtiToRuntimeType(currentEvents.$builtinTypeInfo && currentEvents.$builtinTypeInfo[0]);
      H.buildFunctionType(t2, [t3, t3])._assertCheck$1(t1);
      t3 = H.getDynamicRuntimeType();
      t3 = H.buildFunctionType(t2, [t3, t3]);
      t3._assertCheck$1(t1);
      t2 = currentEvents.length - 1;
      t3._assertCheck$1(t1);
      if (t2 - 0 <= 32)
        H.Sort__insertionSort(currentEvents, 0, t2, t1);
      else
        H.Sort__dualPivotQuicksort(currentEvents, 0, t2, t1);
      t1 = H.getTypeArgumentByIndex(currentEvents, 0);
      H.assertSubtype(currentEvents, "$isJSArray", [t1], "$asJSArray");
      t2 = currentEvents.length;
      t2 = new J.ArrayIterator(H.assertSubtype(currentEvents, "$isJSArray", [t1], "$asJSArray"), t2, 0, H.assertSubtypeOfRuntimeType(null, t1));
      H.assertHelper(true);
      t2.$builtinTypeInfo = [t1];
      H.assertSubtype(t2, "$isIterator", [H.getTypeArgumentByIndex(currentEvents, 0)], "$asIterator");
      for (; t2.moveNext$0();) {
        $event = H.assertSubtypeOfRuntimeType(t2._current, H.getTypeArgumentByIndex(t2, 0));
        this._handleEventOutput$1($event.run$0());
        if ($event.get$isSingular()) {
          this._singularAlreadyFired = true;
          return;
        }
        if (this.finished)
          return;
      }
    },
    _getOrPostponeEvents$1: function(interactive) {
      var currentEvents, t1, t2, i, waitingForInteractivity, waitingBecauseOfSingularEvent, indexesToPush;
      currentEvents = H.assertSubtype(H.setRuntimeTypeInfo([], [L.TimedEvent]), "$isList", [L.TimedEvent], "$asList");
      for (t1 = this._events, t2 = this._schedule, i = 0; i < t1.length; ++i)
        if (J.$eq(t2.$index(0, i), this.time)) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          C.JSArray_methods.add$1(currentEvents, t1[i]);
        }
      waitingForInteractivity = !interactive && C.JSArray_methods.any$1(currentEvents, new L.Timeline__getOrPostponeEvents_closure());
      waitingBecauseOfSingularEvent = this._singularAlreadyFired && C.JSArray_methods.any$1(currentEvents, new L.Timeline__getOrPostponeEvents_closure0());
      if (waitingForInteractivity || waitingBecauseOfSingularEvent) {
        indexesToPush = H.assertSubtype(H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int), "$isSet", [P.$int], "$asSet"), "$isSet", [P.$int], "$asSet");
        t2.forEach$1(0, new L.Timeline__getOrPostponeEvents_closure1(this, currentEvents, waitingForInteractivity, waitingBecauseOfSingularEvent, indexesToPush));
        indexesToPush.forEach$1(0, new L.Timeline__getOrPostponeEvents_closure2(this));
      }
      return H.assertSubtype(currentEvents, "$isList", [L.TimedEvent], "$asList");
    },
    elapse$3$interactive$whileString: function(t, interactive, whileString) {
      var t1, i, t2;
      if (this.finished)
        return;
      if (this.time == null)
        this.time = -1;
      this._whileString = whileString;
      for (t1 = t - 1, i = 0; i < t; ++i) {
        t2 = this.time;
        if (typeof t2 !== "number")
          return t2.$add();
        this.time = t2 + 1;
        this._goOneTick$1(interactive && i === t1);
        if (this.finished)
          break;
        if ($.gotoPageName != null)
          break;
      }
      if (interactive)
        this._singularAlreadyFired = false;
      this._whileString = null;
    },
    elapse$1: function(t) {
      return this.elapse$3$interactive$whileString(t, true, null);
    },
    _mainLoop$0: function() {
      return this._mainLoop.call$0();
    },
    $isSaveable: 1
  },
  Timeline_toMap_closure: {
    "^": "Closure:48;_captured_s_0",
    call$2: function(key, value) {
      H.intTypeCheck(key);
      H.intTypeCheck(value);
      this._captured_s_0.$indexSet(0, H.S(key), value);
    }
  },
  Timeline_updateFromMap_closure: {
    "^": "Closure:49;_timeline$_captured_this_0",
    call$2: function(key, value) {
      H.stringTypeCheck(key);
      H.intTypeCheck(value);
      H.buildFunctionType(H.buildInterfaceType(P.$int), [H.buildInterfaceType(P.String)])._assertCheck$1(null);
      this._timeline$_captured_this_0._schedule.$indexSet(0, H.Primitives_parseInt(key, null, null), value);
    }
  },
  Timeline__goOneTick_closure: {
    "^": "Closure:6;",
    call$2: function(a, b) {
      return b.get$priority() - a.get$priority();
    }
  },
  Timeline__getOrPostponeEvents_closure: {
    "^": "Closure:50;",
    call$1: function(e) {
      return H.interceptedTypeCheck(e, "$isTimedEvent").get$type() === 3;
    }
  },
  Timeline__getOrPostponeEvents_closure0: {
    "^": "Closure:50;",
    call$1: function(e) {
      return H.interceptedTypeCheck(e, "$isTimedEvent").get$type() === 4;
    }
  },
  Timeline__getOrPostponeEvents_closure1: {
    "^": "Closure:48;_timeline$_captured_this_0,_captured_currentEvents_1,_captured_waitingForInteractivity_2,_captured_waitingBecauseOfSingularEvent_3,_captured_indexesToPush_4",
    call$2: function(eventIndex, eventTime) {
      var t1, t2;
      H.intTypeCheck(eventIndex);
      H.intTypeCheck(eventTime);
      t1 = this._timeline$_captured_this_0;
      t2 = t1.time;
      if (typeof eventTime !== "number")
        return eventTime.$gt();
      if (!C.JSInt_methods.$gt(eventTime, t2))
        if (!(this._captured_waitingForInteractivity_2 && eventTime === t1.time && C.JSArray_methods.$index(t1._events, eventIndex).get$type() === 3))
          t2 = this._captured_waitingBecauseOfSingularEvent_3 && C.JSInt_methods.$ge(eventTime, t1.time);
        else
          t2 = true;
      else
        t2 = true;
      if (t2) {
        this._captured_indexesToPush_4.add$1(0, eventIndex);
        C.JSArray_methods.remove$1(this._captured_currentEvents_1, C.JSArray_methods.$index(t1._events, eventIndex));
      }
    }
  },
  Timeline__getOrPostponeEvents_closure2: {
    "^": "Closure:0;_timeline$_captured_this_5",
    call$1: function(index) {
      var t1, t2;
      H.intTypeCheck(index);
      t1 = this._timeline$_captured_this_5._schedule;
      t2 = J.$add$ns(t1.$index(0, index), 1);
      t1.$indexSet(0, index, t2);
      return t2;
    }
  }
}],
["zil", "../libraries/zil.dart", , K, {
  "^": "",
  Zil: {
    "^": "Object;_scripter,rooms,player,actors,items,timeline<",
    update$4$describe$interactive$whileString: function(ticks, describe, interactive, whileString) {
      var e, t1, t2, pageName, exception;
      this.rooms._checkNetworkReady$0();
      try {
        t1 = this.player;
        t2 = t1._zil;
        H.assertHelper(true);
        H.assertHelper(true);
        t2 = t2._scripter;
        H.assertHelper(t2.currentPage != null);
        pageName = t2.currentPage.name;
        t1.location = t1._zil.rooms.getFromPageName$1(pageName);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (t1 instanceof K.PageNotDefinedInZilException) {
          e = t1;
          if (this.player.location == null)
            throw H.wrapException(e);
        } else
          throw exception;
      }
      this.player.location.update$4$describe$interactive$whileString(ticks, describe, interactive, whileString);
    },
    update$2$describe: function(ticks, describe) {
      return this.update$4$describe$interactive$whileString(ticks, describe, true, null);
    },
    update$1: function(ticks) {
      return this.update$4$describe$interactive$whileString(ticks, true, true, null);
    },
    update$3$describe$interactive: function(ticks, describe, interactive) {
      return this.update$4$describe$interactive$whileString(ticks, describe, interactive, null);
    },
    update$3$describe$whileString: function(ticks, describe, whileString) {
      return this.update$4$describe$interactive$whileString(ticks, describe, true, whileString);
    },
    createChoices$0: function() {
      this.rooms._checkNetworkReady$0();
      this.player.createChoices$0();
    },
    get$className: function() {
      return "Zil";
    },
    toMap$0: function() {
      var map = H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, null), "$isMap", [P.String, null], "$asMap"), "$isMap", [P.String, null], "$asMap");
      map.$indexSet(0, "timeline", this.timeline);
      map.$indexSet(0, "items", this.items.toMap$0());
      map.$indexSet(0, "actors", this.actors.toMap$0());
      map.$indexSet(0, "rooms", this.rooms.toMap$0());
      return H.assertSubtype(map, "$isMap", [P.String, null], "$asMap");
    },
    updateFromMap$1: function(map) {
      H.assertSubtype(map, "$isMap", [P.String, null], "$asMap");
      this.timeline.updateFromMap$1(map.$index(0, "timeline"));
      this.items.updateFromMap$1(map.$index(0, "items"));
      this.actors.updateFromMap$1(map.$index(0, "actors"));
      this.rooms.updateFromMap$1(map.$index(0, "rooms"));
    },
    $isSaveable: 1
  },
  Action: {
    "^": "Object;name<,$function,item,room,actor,requirement,roomCheck,performerCheck,itemCheck,needsToBeCarried,submenu,performCount<,maxPerformCount,isActive<",
    set$item: function(item) {
      this.item = H.interceptedTypeCheck(item, "$isItem");
    },
    set$room: function(room) {
      this.room = H.interceptedTypeCheck(room, "$isRoom");
    },
    set$actor: function(actor) {
      this.actor = H.interceptedTypeCheck(actor, "$isZilActor");
    },
    _checkSuitability$2: function(currentRoom, performer) {
      var t1, t2;
      if (!H.boolConversionCheck(this.isActive))
        return false;
      t1 = this.maxPerformCount;
      if (t1 != null) {
        t2 = this.performCount;
        if (typeof t2 !== "number")
          return t2.$ge();
        t1 = C.JSInt_methods.$ge(t2, t1);
      } else
        t1 = false;
      if (t1)
        return false;
      t1 = this.room;
      if (t1 != null && (currentRoom == null ? t1 != null : currentRoom !== t1))
        return false;
      t1 = this.item;
      if (t1 != null && !t1.isIn$1(currentRoom))
        return false;
      if (this.needsToBeCarried) {
        t1 = this.item;
        t1 = !(t1._carrier === performer && H.boolConversionCheck(performer.isActive) && H.boolConversionCheck(t1.isActive));
      } else
        t1 = false;
      if (t1)
        return false;
      t1 = this.actor;
      if (t1 != null) {
        t2 = t1.location;
        t1 = !((t2 == null ? currentRoom == null : t2 === currentRoom) && H.boolConversionCheck(t1.isActive));
      } else
        t1 = false;
      if (t1)
        return false;
      if (this.requirement != null && !H.boolConversionCheck(this.requirement$0()))
        return false;
      if (this.performerCheck != null && !H.boolConversionCheck(this.performerCheck$1(performer)))
        return false;
      if (this.item != null)
        t1 = false;
      else
        t1 = false;
      if (t1)
        return false;
      return true;
    },
    createChoiceForPlayer$1: function(player) {
      if (this._checkSuitability$2(player.location, player))
        O.choice(Y.Storyline_getString(Y.Storyline_capitalize(this.name), null, null, null, player), false, false, null, new K.Action_createChoiceForPlayer_closure(this, player), this.submenu);
    },
    function$0: function() {
      return this.$function.call$0();
    },
    requirement$0: function() {
      return this.requirement.call$0();
    },
    performerCheck$1: function(arg0) {
      return this.performerCheck.call$1(arg0);
    },
    static: {Action$Goto: function($name, pageName, isActive, itemCheck, maxPerformCount, needsToBeCarried, onlyOnce, performerCheck, requirement, roomCheck, submenu) {
        var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16;
        t1 = H.buildInterfaceType(P.bool);
        t2 = H.buildFunctionType(t1, [H.buildInterfaceType(K.Item)]);
        t3 = t2._assertCheck$1(itemCheck);
        t4 = H.buildFunctionType(t1, [H.buildInterfaceType(K.ZilActor)]);
        t5 = t4._assertCheck$1(performerCheck);
        t6 = H.buildFunctionType(t1);
        t7 = t6._assertCheck$1(requirement);
        t1 = H.buildFunctionType(t1, [H.buildInterfaceType(K.Room)]);
        t8 = t1._assertCheck$1(roomCheck);
        t9 = new K.Action$Goto_closure(pageName);
        t10 = onlyOnce ? 1 : maxPerformCount;
        t11 = H.buildFunctionType(H.getVoidRuntimeType());
        t12 = t11._assertCheck$1(t9);
        t13 = t6._assertCheck$1(t7);
        t14 = t1._assertCheck$1(t8);
        t15 = t4._assertCheck$1(t5);
        t16 = t2._assertCheck$1(t3);
        t11._assertCheck$1(t9);
        t2._assertCheck$1(t3);
        t4._assertCheck$1(t5);
        t6._assertCheck$1(t7);
        t1._assertCheck$1(t8);
        O.throwIfNotInInitOrDeclareBlock("");
        return new K.Action($name, t12, null, null, null, t13, t14, t15, t16, needsToBeCarried, submenu, 0, t10, isActive);
      }, Action_iterableToMap: function(actions) {
        var map;
        H.listSuperNativeTypeCheck(actions, "$isIterable");
        map = H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, null), "$isMap", [P.String, null], "$asMap"), "$isMap", [P.String, null], "$asMap");
        C.JSArray_methods.forEach$1(actions, new K.Action_iterableToMap_closure(map));
        return H.assertSubtype(map, "$isMap", [P.String, P.Map], "$asMap");
      }, Action_updateIterableFromMap: function(map, actions) {
        H.assertSubtype(map, "$isMap", [P.String, P.Map], "$asMap").forEach$1(0, new K.Action_updateIterableFromMap_closure(H.listSuperNativeTypeCheck(actions, "$isIterable")));
      }}
  },
  Action$Goto_closure: {
    "^": "Closure:1;_captured_pageName_0",
    call$0: function() {
      $.gotoPageName = this._captured_pageName_0;
      return;
    }
  },
  Action_createChoiceForPlayer_closure: {
    "^": "Closure:1;_zil$_captured_this_0,_captured_player_1",
    call$0: function() {
      var t1, t2;
      t1 = this._zil$_captured_this_0;
      t1.function$0();
      t2 = t1.performCount;
      if (typeof t2 !== "number")
        return t2.$add();
      t1.performCount = t2 + 1;
      t2 = $.get$storyline();
      O.echo(J.toString$0(t2));
      C.JSArray_methods.set$length(t2.reports, 0);
      t2.strBuf._contents = "";
      if ($.gotoPageName == null)
        $.gotoPageName = this._captured_player_1.location.name;
    }
  },
  Action_iterableToMap_closure: {
    "^": "Closure:2;_zil$_captured_map_0",
    call$1: function(action) {
      var t1 = this._zil$_captured_map_0;
      H.assertHelper(!t1.containsKey$1(action.get$name()));
      t1.$indexSet(0, action.get$name(), P.LinkedHashMap_LinkedHashMap$_literal(["isActive", action.get$isActive(), "performCount", action.get$performCount()], null, null));
    }
  },
  Action_updateIterableFromMap_closure: {
    "^": "Closure:51;_captured_actions_0",
    call$2: function(key, actionMap) {
      var action;
      H.interceptedTypeCheck(actionMap, "$isMap");
      action = C.JSArray_methods.singleWhere$1(this._captured_actions_0, new K.Action_updateIterableFromMap__closure(key));
      action.isActive = H.boolTypeCheck(actionMap.$index(0, "isActive"));
      action.performCount = H.intTypeCheck(actionMap.$index(0, "performCount"));
    }
  },
  Action_updateIterableFromMap__closure: {
    "^": "Closure:2;_captured_key_1",
    call$1: function(action) {
      var t1, t2;
      t1 = action.get$name();
      t2 = this._captured_key_1;
      return t1 == null ? t2 == null : t1 === t2;
    }
  },
  ZilActor: {
    "^": "Actor;isAlive<,location",
    set$location: function($location) {
      this.location = H.interceptedTypeCheck($location, "$isRoom");
    },
    get$items: function() {
      var t1, t2, t3, t4;
      t1 = this._zil.items.items;
      t2 = new K.ZilActor_items_closure(this);
      t3 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t1.$builtinTypeInfo && t1.$builtinTypeInfo[0])])._assertCheck$1(t2);
      t4 = H.getTypeArgumentByIndex(t1, 0);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
      return H.listSuperNativeTypeCheck(H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), H.buildFunctionType(t3, [H.getDynamicRuntimeType()])._assertCheck$1(t2)), [t4]), "$isIterable"), "$isIterable");
    },
    isIn$1: function(room) {
      var t1 = this.location;
      return (t1 == null ? room == null : t1 === room) && H.boolConversionCheck(this.isActive);
    },
    createChoicesForPlayer$1: function(player) {
      var t1, t2;
      t1 = player.location;
      t2 = this.location;
      H.assertHelper(t1 == null ? t2 == null : t1 === t2);
      C.JSArray_methods.forEach$1(this.actions, new K.ZilActor_createChoicesForPlayer_closure(player));
    },
    toMap$0: function() {
      var t1, t2, t3, t4;
      t1 = this.isActive;
      t2 = this.team;
      t3 = this.isAlive;
      t4 = this.location;
      t4 = t4 != null ? t4.name : null;
      return H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_literal(["isActive", t1, "team", t2, "isAlive", t3, "location", t4, "actions", K.Action_iterableToMap(this.actions)], null, null), "$isMap", [P.String, null], "$asMap");
    },
    updateFromMap$1: function(map) {
      H.assertSubtype(map, "$isMap", [P.String, null], "$asMap");
      this.isActive = H.boolTypeCheck(map.$index(0, "isActive"));
      this.team = H.intTypeCheck(map.$index(0, "team"));
      this.isAlive = H.boolTypeCheck(map.$index(0, "isAlive"));
      if (map.$index(0, "location") != null)
        this.location = this._zil.rooms.getFromPageName$1(map.$index(0, "location"));
      else
        this.location = null;
      K.Action_updateIterableFromMap(map.$index(0, "actions"), this.actions);
    },
    ZilActor$8$actions$isPlayer$items$nameIsProperNoun$pronoun$team: function(_zil, $name, actions, isPlayer, items, nameIsProperNoun, pronoun, team) {
      var t1;
      H.listSuperNativeTypeCheck(actions, "$isIterable");
      H.listSuperNativeTypeCheck(items, "$isIterable");
      O.throwIfNotInInitOrDeclareBlock("");
      C.JSArray_methods.forEach$1(this.actions, new K.ZilActor_closure(this, $name));
      C.JSArray_methods.forEach$1(items, new K.ZilActor_closure0(this, $name));
      if (!!this.$isAIActor) {
        t1 = this._zil.actors;
        t1.toString;
        O.throwIfNotInInitOrDeclareBlock("");
        C.JSArray_methods.add$1(t1.npcs, this);
      } else if (!!this.$isZilPlayer)
        this._zil.actors.player = this;
    }
  },
  ZilActor_closure: {
    "^": "Closure:2;_zil$_captured_this_0,_captured_name_1",
    call$1: function(action) {
      if (action == null)
        throw H.wrapException(K.NullInOptionalParametersList$("ZilActor", this._captured_name_1, "actions"));
      action.set$actor(this._zil$_captured_this_0);
    }
  },
  ZilActor_closure0: {
    "^": "Closure:2;_zil$_captured_this_2,_captured_name_3",
    call$1: function(item) {
      if (item == null)
        throw H.wrapException(K.NullInOptionalParametersList$("ZilActor", this._captured_name_3, "items"));
      item.set$carrier(this._zil$_captured_this_2);
    }
  },
  ZilActor_items_closure: {
    "^": "Closure:2;_zil$_captured_this_0",
    call$1: function(item) {
      var t1 = this._zil$_captured_this_0;
      H.interceptedTypeCheck(item, "$isItem");
      return item._carrier === t1 && H.boolConversionCheck(item.isActive) && H.boolConversionCheck(t1.isActive);
    }
  },
  ZilActor_createChoicesForPlayer_closure: {
    "^": "Closure:52;_captured_player_0",
    call$1: function(action) {
      H.interceptedTypeCheck(action, "$isAction").createChoiceForPlayer$1(this._captured_player_0);
    }
  },
  ZilPlayer: {
    "^": "ZilActor;_lastTickLocation,isAlive,_zil,location,actions,nameIsProperNoun,name,categories,alreadyMentioned,team,isActive,isPlayer,pronoun",
    createChoices$0: function() {
      this.location.createChoicesForPlayer$1(this);
      this.location.get$actors().forEach$1(0, new K.ZilPlayer_createChoices_closure(this));
      this.get$items().forEach$1(0, new K.ZilPlayer_createChoices_closure0(this));
      this.location.get$items().forEach$1(0, new K.ZilPlayer_createChoices_closure1(this));
      this.location.exits.forEach$1(0, new K.ZilPlayer_createChoices_closure2(this));
    }
  },
  ZilPlayer_createChoices_closure: {
    "^": "Closure:53;_zil$_captured_this_0",
    call$1: function(actor) {
      H.interceptedTypeCheck(actor, "$isZilActor").createChoicesForPlayer$1(this._zil$_captured_this_0);
    }
  },
  ZilPlayer_createChoices_closure0: {
    "^": "Closure:54;_zil$_captured_this_1",
    call$1: function(item) {
      H.interceptedTypeCheck(item, "$isItem").createChoicesForPlayer$1(this._zil$_captured_this_1);
    }
  },
  ZilPlayer_createChoices_closure1: {
    "^": "Closure:54;_zil$_captured_this_2",
    call$1: function(item) {
      H.interceptedTypeCheck(item, "$isItem").createChoicesForPlayer$1(this._zil$_captured_this_2);
    }
  },
  ZilPlayer_createChoices_closure2: {
    "^": "Closure:2;_zil$_captured_this_3",
    call$1: function(exit) {
      var t1 = this._zil$_captured_this_3;
      exit.createChoiceForPlayer$2(t1._zil, t1);
    }
  },
  ActorSociety: {
    "^": "Object;_zil,npcs,player,rooms",
    updateAll$3$currentRoom$describe: function(ticks, currentRoom, describe) {
      var t1, i, t2, t3;
      for (t1 = this.npcs, i = 0; i < ticks; ++i) {
        t2 = H.getTypeArgumentByIndex(t1, 0);
        H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray");
        t3 = t1.length;
        t3 = new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2));
        H.assertHelper(true);
        t3.$builtinTypeInfo = [t2];
        H.assertSubtype(t3, "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator");
        for (; t3.moveNext$0();) {
          H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t3._current, H.getTypeArgumentByIndex(t3, 0)), "$isAIActor").update$2$currentRoom$describe(currentRoom, describe);
          if ($.gotoPageName != null)
            return;
        }
      }
    },
    findByName$1: function($name) {
      var t1, t2;
      H.stringTypeCheck($name);
      t1 = this.player;
      t2 = t1.name;
      if ($name == null ? t2 == null : $name === t2)
        return t1;
      return C.JSArray_methods.singleWhere$1(this.npcs, new K.ActorSociety_findByName_closure($name));
    },
    toMap$0: function() {
      var t1, t2, t3;
      t1 = this.npcs;
      t2 = new K.ActorSociety_toMap_closure();
      H.buildFunctionType(H.getDynamicRuntimeType(), [H.convertRtiToRuntimeType(t1.$builtinTypeInfo && t1.$builtinTypeInfo[0])])._assertCheck$1(t2);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      t3 = H.buildFunctionType(H.convertRtiToRuntimeType(null), [H.convertRtiToRuntimeType(null)]);
      t3._assertCheck$1(t2);
      return H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_literal(["npcs", H.setRuntimeTypeInfo(new H.MappedListIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), t3._assertCheck$1(t2)), [null, null]).toList$0(0), "player", this.player.toMap$0()], null, null), "$isMap", [P.String, null], "$asMap");
    },
    updateFromMap$1: function(map) {
      var list, t1, t2, i;
      H.assertSubtype(map, "$isMap", [P.String, null], "$asMap");
      list = H.assertSubtype(map.$index(0, "npcs"), "$isList", [[P.Map, P.String,,]], "$asList");
      t1 = J.getInterceptor$as(list);
      t2 = this.npcs;
      H.assertHelper(t1.get$length(list) === t2.length);
      for (i = 0; i < t2.length; ++i)
        t2[i].updateFromMap$1(t1.$index(list, i));
      this.player.updateFromMap$1(map.$index(0, "player"));
    }
  },
  ActorSociety_findByName_closure: {
    "^": "Closure:2;_captured_name_0",
    call$1: function(npc) {
      var t1, t2;
      t1 = npc.get$name();
      t2 = this._captured_name_0;
      return t1 == null ? t2 == null : t1 === t2;
    }
  },
  ActorSociety_toMap_closure: {
    "^": "Closure:2;",
    call$1: function(actor) {
      return actor.toMap$0();
    }
  },
  AIActor: {
    "^": "ZilActor;currentGoal,isAlive,_zil,location,actions,nameIsProperNoun,name,categories,alreadyMentioned,team,isActive,isPlayer,pronoun",
    update$2$currentRoom$describe: function(currentRoom, describe) {
      var t1, reports, t2, t3;
      t1 = this.currentGoal;
      if (t1 == null || t1.status === 3 || t1.get$failed())
        this.currentGoal = new K.Think("", H.assertSubtype(H.assertSubtype(P.ListQueue$(null, K.Goal), "$isQueue", [K.Goal], "$asQueue"), "$isQueue", [K.Goal], "$asQueue"), null, 0, this);
      reports = this.currentGoal._processInternal$0();
      t1 = this._zil.player;
      t2 = t1.location;
      t3 = this.location;
      if ((t2 == null ? t3 == null : t2 === t3) && H.boolConversionCheck(t1.isActive) && H.boolConversionCheck(this.isActive) && describe)
        C.JSArray_methods.addAll$1($.get$storyline().reports, reports);
    },
    update$0: function() {
      return this.update$2$currentRoom$describe(null, true);
    }
  },
  ZilException: {
    "^": "Object;message",
    toString$0: function(_) {
      return "ZIL Exception: " + this.message;
    },
    $isException: 1,
    static: {ZilException$: function(message) {
        return new K.ZilException(message);
      }}
  },
  NullInOptionalParametersList: {
    "^": "ZilException;message",
    static: {NullInOptionalParametersList$: function(className, objectBeingCreated, optionalParameterName) {
        return new K.NullInOptionalParametersList("Trying to assign a null item to " + className + " object '" + objectBeingCreated + "'. Make sure all the variables in the `" + optionalParameterName + ": [...]` optional parameter actually exist.");
      }}
  },
  PageNotDefinedInZilException: {
    "^": "ZilException;message"
  },
  Exit: {
    "^": "Entity;from,to,requirement,cost,destinationPageName,descriptionInfinitive,arriveDescription,nameIsProperNoun,name,categories,alreadyMentioned,team,isActive,isPlayer,pronoun",
    set$from: function(from) {
      this.from = H.interceptedTypeCheck(from, "$isRoom");
    },
    isPassable$1: function(actor) {
      if (!H.boolConversionCheck(this.isActive))
        return false;
      return true;
    },
    createChoiceForPlayer$2: function(zil, player) {
      var t1, t2;
      t1 = player.location;
      t2 = this.from;
      H.assertHelper(t1 == null ? t2 == null : t1 === t2);
      if (H.boolConversionCheck(this.isPassable$1(player)))
        O.choice(Y.Storyline_getString(Y.Storyline_capitalize(this.descriptionInfinitive), this, null, null, player), false, false, null, new K.Exit_createChoiceForPlayer_closure(this, zil, player), null);
    },
    get$_uniqueIdentifier: function() {
      return C.JSString_methods.get$hashCode(this.destinationPageName + ">>" + this.descriptionInfinitive + ">>" + this.arriveDescription);
    },
    static: {Exit_iterableToMap: function(exits) {
        var map;
        H.listSuperNativeTypeCheck(exits, "$isIterable");
        map = H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, null), "$isMap", [P.String, null], "$asMap"), "$isMap", [P.String, null], "$asMap");
        exits.forEach$1(0, new K.Exit_iterableToMap_closure(map));
        return H.assertSubtype(map, "$isMap", [P.String, null], "$asMap");
      }, Exit_updateIterableFromMap: function(map, exits) {
        H.assertSubtype(map, "$isMap", [P.String, null], "$asMap").forEach$1(0, new K.Exit_updateIterableFromMap_closure(H.listSuperNativeTypeCheck(exits, "$isIterable")));
      }}
  },
  Exit_createChoiceForPlayer_closure: {
    "^": "Closure:1;_zil$_captured_this_0,_captured_zil_1,_captured_player_2",
    call$0: function() {
      var t1, t2, t3;
      t1 = this._zil$_captured_this_0;
      t2 = t1.cost;
      if (t2 > 1) {
        this._captured_player_2.location = null;
        this._captured_zil_1.update$3$describe$whileString(t2 - 1, false, Y.Storyline_addParticleToFirstOccurence("on your way to <object>", "<object>", t1.to, null));
      }
      t2 = t1.to;
      t3 = $.get$storyline();
      t3.add$3$object$subject(0, t1.arriveDescription, t2, this._captured_player_2);
      O.echo(t3.toString$0(0));
      C.JSArray_methods.set$length(t3.reports, 0);
      t3.strBuf._contents = "";
      $.gotoPageName = t1.to.name;
    }
  },
  Exit_iterableToMap_closure: {
    "^": "Closure:55;_zil$_captured_map_0",
    call$1: function(exit) {
      var t1;
      H.interceptedTypeCheck(exit, "$isExit");
      t1 = this._zil$_captured_map_0;
      H.assertHelper(!t1.containsKey$1("" + exit.get$_uniqueIdentifier()));
      t1.$indexSet(0, "" + exit.get$_uniqueIdentifier(), P.LinkedHashMap_LinkedHashMap$_literal(["isActive", exit.isActive], null, null));
    }
  },
  Exit_updateIterableFromMap_closure: {
    "^": "Closure:51;_captured_exits_0",
    call$2: function(key, exitMap) {
      H.interceptedTypeCheck(exitMap, "$isMap");
      H.interceptedTypeCheck(this._captured_exits_0.singleWhere$1(0, new K.Exit_updateIterableFromMap__closure(key)), "$isExit").isActive = H.boolTypeCheck(exitMap.$index(0, "isActive"));
    }
  },
  Exit_updateIterableFromMap__closure: {
    "^": "Closure:2;_captured_key_1",
    call$1: function(exit) {
      var t1, t2;
      t1 = exit.get$_uniqueIdentifier();
      t2 = H.stringTypeCheck(this._captured_key_1);
      H.buildFunctionType(H.buildInterfaceType(P.$int), [H.buildInterfaceType(P.String)])._assertCheck$1(null);
      return t1 === H.Primitives_parseInt(t2, null, null);
    }
  },
  Goal: {
    "^": "Object;",
    get$failed: function() {
      if (!!this.$isCompositeGoal) {
        if (this.status === 2)
          return true;
        return this.subgoals.any$1(0, new K.Goal_failed_closure());
      }
      return this.status === 2;
    },
    get$completed: function() {
      return this.status === 3;
    },
    set$completed: function(value) {
      if (this.status === 2)
        return;
      this.status = 3;
    },
    createReportGoalInProgress$0: function() {
      return new Y.Report(this.get$inProgressReport(), this.performer, null, null, null, false, false, false, false, false, false, null, false, null);
    },
    _processInternal$0: function() {
      var reports = H.assertSubtype(H.setRuntimeTypeInfo([], [Y.Report]), "$isList", [Y.Report], "$asList");
      if (this.status === 0) {
        C.JSArray_methods.addAll$1(reports, this.onActivate$0());
        this.status = 1;
      }
      if (!!this.$isCompositeGoal) {
        C.JSArray_methods.addAll$1(reports, this._processSubgoals$0());
        if (this.get$failed())
          return H.assertSubtype(reports, "$isList", [Y.Report], "$asList");
      }
      C.JSArray_methods.addAll$1(reports, this.onUpdate$0());
      return H.assertSubtype(reports, "$isList", [Y.Report], "$asList");
    }
  },
  Goal_failed_closure: {
    "^": "Closure:56;",
    call$1: function(goal) {
      return H.interceptedTypeCheck(goal, "$isGoal").get$failed();
    }
  },
  AtomicGoal: {
    "^": "Goal;time<"
  },
  TimedAtomicGoal: {
    "^": "AtomicGoal;",
    onUpdate$0: function() {
      var t1 = this.currentTime;
      if (t1 >= this.time) {
        this.set$completed(true);
        return H.assertSubtype(this.onTerminate$0(), "$isList", [Y.Report], "$asList");
      }
      this.currentTime = t1 + 1;
      return H.assertSubtype([], "$isList", [Y.Report], "$asList");
    }
  },
  CompositeGoal: {
    "^": "Goal;",
    get$time: function() {
      return H.intTypeCheck(this.subgoals.fold$2(0, 0, new K.CompositeGoal_time_closure()));
    },
    createReportGoalInProgress$0: function() {
      if (this.get$inProgressReport() === "" && this._currentlyActiveSubgoal != null)
        return this._currentlyActiveSubgoal.createReportGoalInProgress$0();
      return new Y.Report(this.inProgressReport, this.performer, null, null, null, false, false, false, false, false, false, null, false, null);
    },
    _processSubgoals$0: function() {
      var reports, t1, t2, t3, next;
      reports = H.assertSubtype(H.setRuntimeTypeInfo([], [Y.Report]), "$isList", [Y.Report], "$asList");
      t1 = this.subgoals;
      if (t1._head === t1._tail) {
        this.set$completed(true);
        C.JSArray_methods.addAll$1(reports, this.onTerminate$0());
        return H.assertSubtype(reports, "$isList", [Y.Report], "$asList");
      }
      while (true) {
        t2 = t1._head;
        if (t2 === t1._tail)
          H.throwExpression(H.IterableElementError_noElement());
        t3 = t1._table;
        if (t2 >= t3.length)
          return H.ioore(t3, t2);
        if (!H.assertSubtypeOfRuntimeType(t3[t2], H.getTypeArgumentByIndex(t1, 0)).get$completed())
          break;
        t1.removeFirst$0();
      }
      for (; !t1.get$isEmpty(t1);) {
        t2 = t1._head;
        if (t2 === t1._tail)
          H.throwExpression(H.IterableElementError_noElement());
        t3 = t1._table;
        if (t2 >= t3.length)
          return H.ioore(t3, t2);
        next = H.assertSubtypeOfRuntimeType(t3[t2], H.getTypeArgumentByIndex(t1, 0));
        C.JSArray_methods.addAll$1(reports, next._processInternal$0());
        if (next.status === 3)
          t1.removeFirst$0();
        else if (next.get$failed()) {
          this.status = 2;
          C.JSArray_methods.addAll$1(reports, H.assertSubtype(this.onFail$0(), "$isList", [Y.Report], "$asList"));
          return H.assertSubtype(reports, "$isList", [Y.Report], "$asList");
        } else {
          this._currentlyActiveSubgoal = next;
          return H.assertSubtype(reports, "$isList", [Y.Report], "$asList");
        }
      }
      this.set$completed(true);
      return H.assertSubtype(reports, "$isList", [Y.Report], "$asList");
    }
  },
  CompositeGoal_time_closure: {
    "^": "Closure:57;",
    call$2: function(sum, component) {
      var t1;
      H.intTypeCheck(sum);
      t1 = component.get$time();
      if (typeof sum !== "number")
        return sum.$add();
      return C.JSInt_methods.$add(sum, t1);
    }
  },
  Wait: {
    "^": "TimedAtomicGoal;inProgressReport<,currentTime,time,status,performer",
    onActivate$0: function() {
      return H.assertSubtype([], "$isList", [Y.Report], "$asList");
    },
    onTerminate$0: function() {
      return H.assertSubtype([], "$isList", [Y.Report], "$asList");
    }
  },
  Think: {
    "^": "CompositeGoal;inProgressReport<,subgoals,_currentlyActiveSubgoal,status,performer",
    onActivate$0: function() {
      var t1, t2;
      this.set$completed(false);
      t1 = this.subgoals;
      t1.clear$0(0);
      t2 = new K.Wait("<subject> {<is> {just |}waiting|do<es>n't do anything in particular}", 0, 3, 0, this.performer);
      H.assertSubtypeOfRuntimeType(t2, H.getTypeArgumentByIndex(t1, 0));
      t1._add$1(t2);
      return H.assertSubtype([], "$isList", [Y.Report], "$asList");
    },
    onUpdate$0: function() {
      return H.assertSubtype([], "$isList", [Y.Report], "$asList");
    },
    onTerminate$0: function() {
      return H.assertSubtype([], "$isList", [Y.Report], "$asList");
    },
    onFail$0: function() {
      return H.assertSubtype([], "$isList", [Y.Report], "$asList");
    }
  },
  Item: {
    "^": "Entity;actions,takeable,plural,count,firstDescription,describedForTheFirstTimeAlready,description,_takeDescription,_takeInfinitive,_zil,_location,_carrier,nameIsProperNoun,name,categories,alreadyMentioned,team,isActive,isPlayer,pronoun",
    get$takeDescription: function() {
      var t1 = this._takeDescription;
      if (t1 != null)
        return t1;
      return "<subject> take<s> the " + H.S(this.description);
    },
    get$takeInfinitive: function() {
      return "take the " + H.S(this.description);
    },
    set$carrier: function(value) {
      this._location = null;
      this._carrier = value;
    },
    set$location: function(value) {
      H.interceptedTypeCheck(value, "$isRoom");
      this._carrier = null;
      this._location = value;
    },
    isIn$2$countIfInPossession: function(room, countIfInPossession) {
      var t1;
      if (!H.boolConversionCheck(this.isActive))
        return false;
      if (countIfInPossession) {
        t1 = this._carrier;
        if (t1 != null) {
          t1 = t1.location;
          t1 = t1 == null ? room == null : t1 === room;
        } else
          t1 = false;
      } else
        t1 = false;
      if (t1)
        return true;
      t1 = this._location;
      return t1 == null ? room == null : t1 === room;
    },
    isIn$1: function(room) {
      return this.isIn$2$countIfInPossession(room, true);
    },
    createChoicesForPlayer$1: function(player) {
      var t1, t2;
      t1 = player.location;
      t2 = this._location;
      H.assertHelper((t1 == null ? t2 == null : t1 === t2) || this._carrier === player);
      if (H.boolConversionCheck(this.takeable))
        t1 = !(this._carrier === player && H.boolConversionCheck(this.isActive) && H.boolConversionCheck(player.isActive));
      else
        t1 = false;
      if (t1)
        O.choice(Y.Storyline_getString(Y.Storyline_capitalize(this.get$takeInfinitive()), this, null, null, player), false, false, null, new K.Item_createChoicesForPlayer_closure(this, player), null);
      C.JSArray_methods.forEach$1(this.actions, new K.Item_createChoicesForPlayer_closure0(player));
    },
    toMap$0: function() {
      var t1, t2, t3, t4;
      t1 = this.isActive;
      t2 = this.team;
      t3 = this._location;
      t3 = t3 != null ? t3.name : null;
      t4 = this._carrier;
      t4 = t4 != null ? t4.name : null;
      return H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_literal(["isActive", t1, "team", t2, "location", t3, "carrier", t4, "takeable", this.takeable, "count", this.count, "describedForTheFirstTimeAlready", this.describedForTheFirstTimeAlready, "actions", K.Action_iterableToMap(this.actions)], null, null), "$isMap", [P.String, null], "$asMap");
    },
    updateFromMap$1: function(map) {
      var t1;
      H.assertSubtype(map, "$isMap", [P.String, null], "$asMap");
      this.isActive = H.boolTypeCheck(map.$index(0, "isActive"));
      this.team = H.intTypeCheck(map.$index(0, "team"));
      if (map.$index(0, "location") != null) {
        t1 = this._zil.rooms.getFromPageName$1(map.$index(0, "location"));
        this._carrier = null;
        this._location = t1;
      } else if (map.$index(0, "carrier") != null) {
        t1 = this._zil.actors.findByName$1(map.$index(0, "carrier"));
        this._location = null;
        this._carrier = t1;
      } else {
        this._carrier = null;
        this._location = null;
        this._location = null;
        this._carrier = null;
      }
      this.takeable = H.boolTypeCheck(map.$index(0, "takeable"));
      this.count = H.intTypeCheck(map.$index(0, "count"));
      this.describedForTheFirstTimeAlready = H.boolTypeCheck(map.$index(0, "describedForTheFirstTimeAlready"));
      K.Action_updateIterableFromMap(map.$index(0, "actions"), this.actions);
    },
    Item$13$actions$count$description$firstDescription$isActive$nameIsProperNoun$plural$pronoun$takeDescription$takeInfinitive$takeable: function(_zil, $name, actions, count, description, firstDescription, isActive, nameIsProperNoun, plural, pronoun, takeDescription, takeInfinitive, takeable) {
      H.listSuperNativeTypeCheck(actions, "$isIterable");
      O.throwIfNotInInitOrDeclareBlock("");
      C.JSArray_methods.forEach$1(this.actions, new K.Item_closure(this));
      this.isActive = isActive;
      if (this.description == null)
        this.description = $name;
      C.JSArray_methods.add$1(this._zil.items.items, this);
    },
    static: {Item$: function(_zil, $name, actions, count, description, firstDescription, isActive, nameIsProperNoun, plural, pronoun, takeDescription, takeInfinitive, takeable) {
        var t1;
        H.listSuperNativeTypeCheck(actions, "$isIterable");
        t1 = H.setRuntimeTypeInfo([], [P.String]);
        t1 = new K.Item(H.listSuperNativeTypeCheck(actions, "$isIterable"), takeable, plural, count, firstDescription, false, description, takeDescription, takeInfinitive, _zil, null, null, nameIsProperNoun, $name, H.assertSubtype(t1, "$isList", [P.String], "$asList"), true, 0, true, false, pronoun);
        t1.Item$13$actions$count$description$firstDescription$isActive$nameIsProperNoun$plural$pronoun$takeDescription$takeInfinitive$takeable(_zil, $name, actions, count, description, firstDescription, isActive, nameIsProperNoun, plural, pronoun, takeDescription, takeInfinitive, takeable);
        return t1;
      }}
  },
  Item_closure: {
    "^": "Closure:2;_zil$_captured_this_0",
    call$1: function(action) {
      var t1 = this._zil$_captured_this_0;
      action.set$item(t1);
      return t1;
    }
  },
  Item_createChoicesForPlayer_closure: {
    "^": "Closure:1;_zil$_captured_this_0,_captured_player_1",
    call$0: function() {
      var t1, t2;
      t1 = this._zil$_captured_this_0;
      t2 = this._captured_player_1;
      $.get$storyline().add$3$object$subject(0, t1.get$takeDescription(), t1, t2);
      t1._location = null;
      t1._carrier = t2;
      $.gotoPageName = t2.location.name;
    }
  },
  Item_createChoicesForPlayer_closure0: {
    "^": "Closure:52;_captured_player_2",
    call$1: function(action) {
      H.interceptedTypeCheck(action, "$isAction").createChoiceForPlayer$1(this._captured_player_2);
    }
  },
  ItemPool: {
    "^": "Object;_zil,items",
    toMap$0: function() {
      var t1, t2, t3;
      t1 = this.items;
      t2 = new K.ItemPool_toMap_closure();
      H.buildFunctionType(H.getDynamicRuntimeType(), [H.convertRtiToRuntimeType(t1.$builtinTypeInfo && t1.$builtinTypeInfo[0])])._assertCheck$1(t2);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      t3 = H.buildFunctionType(H.convertRtiToRuntimeType(null), [H.convertRtiToRuntimeType(null)]);
      t3._assertCheck$1(t2);
      return H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_literal(["items", H.setRuntimeTypeInfo(new H.MappedListIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), t3._assertCheck$1(t2)), [null, null]).toList$0(0)], null, null), "$isMap", [P.String, null], "$asMap");
    },
    updateFromMap$1: function(map) {
      var list, t1, i, t2;
      list = H.assertSubtype(H.assertSubtype(map, "$isMap", [P.String, null], "$asMap").$index(0, "items"), "$isList", [[P.Map, P.String,,]], "$asList");
      t1 = J.getInterceptor$as(list);
      H.assertHelper(t1.get$length(list) === this.items.length);
      for (i = 0; t2 = this.items, i < t2.length; ++i)
        t2[i].updateFromMap$1(t1.$index(list, i));
    }
  },
  ItemPool_toMap_closure: {
    "^": "Closure:2;",
    call$1: function(item) {
      return item.toMap$0();
    }
  },
  Room: {
    "^": "Entity_Node;coordinates,exits,actions,onUpdate,description,descriptionPage,visited,_zil,Node__f,Node__g,Node__parent,Node__isInOpenSet,Node__isInClosedSet,nameIsProperNoun,name,categories,alreadyMentioned,team,isActive,isPlayer,pronoun",
    toString$0: function(_) {
      return "Room<" + H.S(this.name) + ">";
    },
    update$4$describe$interactive$whileString: function(ticks, describe, interactive, whileString) {
      var t1, t2, i, t3;
      if (!H.boolConversionCheck(this.visited)) {
        t1 = $.get$storyline();
        O.echo(J.toString$0(t1));
        C.JSArray_methods.set$length(t1.reports, 0);
        t1.strBuf._contents = "";
        $.gotoPageName = this.descriptionPage;
        this.visited = true;
        this._zil.player._lastTickLocation = null;
        return;
      }
      this.visited = true;
      if (this.onUpdate != null)
        if (!H.boolTypeCheck(this.onUpdate$0()))
          return;
      t1 = this._zil;
      if (t1.actors != null) {
        t1 = t1.player;
        t2 = t1.location;
        t1 = t1._lastTickLocation;
        t1 = t2 == null ? t1 != null : t2 !== t1;
      } else
        t1 = false;
      if (t1)
        this.showActors$1$describe(describe);
      for (t1 = this._zil, t2 = ticks - 1, i = 0; i < ticks; ++i) {
        if (t1.actors != null) {
          t1.actors.updateAll$3$currentRoom$describe(1, t1.player.location, describe);
          if ($.gotoPageName != null)
            return;
        }
        if (t1.timeline != null) {
          t3 = t1.timeline;
          t3.elapse$3$interactive$whileString(1, interactive && i === t2, whileString);
          if ($.gotoPageName != null)
            return;
        }
      }
      t2 = t1.player;
      t3 = t2.location;
      t2 = t2._lastTickLocation;
      if (t3 == null ? t2 != null : t3 !== t2) {
        if (describe)
          H.voidTypeCheck($.get$storyline().add$2$wholeSentence(0, "\n\n", true));
        if (describe)
          $.get$storyline().addEnumeration$4$subject("<subject> {{can|} <also> see|<also> notice}", this.get$items(), "{in |}here", t1.player);
      }
      t2 = $.get$storyline();
      O.echo(J.toString$0(t2));
      C.JSArray_methods.set$length(t2.reports, 0);
      t2.strBuf._contents = "";
      t1.player._lastTickLocation = this;
    },
    update$2$describe: function(ticks, describe) {
      return this.update$4$describe$interactive$whileString(ticks, describe, true, null);
    },
    update$1: function(ticks) {
      return this.update$4$describe$interactive$whileString(ticks, true, true, null);
    },
    update$3$describe$interactive: function(ticks, describe, interactive) {
      return this.update$4$describe$interactive$whileString(ticks, describe, interactive, null);
    },
    update$3$describe$whileString: function(ticks, describe, whileString) {
      return this.update$4$describe$interactive$whileString(ticks, describe, true, whileString);
    },
    showActors$1$describe: function(describe) {
      var t1, t2, t3, t4;
      if (describe) {
        t1 = this.get$actors();
        if (t1.get$length(t1) > 1)
          $.get$storyline().addEnumeration$4$subject("<subject> {|can }see<s>", this.get$actors(), "{|in }here", this._zil.player);
        else {
          t1 = this.get$actors();
          if (t1.get$length(t1) === 1) {
            t1 = this.get$actors();
            t1.get$single(t1).report$1("<subject> is {|in }here");
          }
        }
        t1 = this.get$actors();
        t2 = new K.Room_showActors_closure();
        t3 = H.buildInterfaceType(P.bool);
        H.buildFunctionType(t3, [t1.E()])._assertCheck$1(t2);
        t4 = H.getRuntimeTypeArgument(t1, "IterableBase", 0);
        H.listSuperNativeTypeCheck(t1, "$isIterable");
        H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
        H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), H.buildFunctionType(t3, [H.getDynamicRuntimeType()])._assertCheck$1(t2)), [t4]), "$isIterable").forEach$1(0, new K.Room_showActors_closure0());
      }
    },
    get$actors: function() {
      var t1, t2, t3, t4;
      t1 = this._zil.actors.npcs;
      t2 = new K.Room_actors_closure(this);
      t3 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t1.$builtinTypeInfo && t1.$builtinTypeInfo[0])])._assertCheck$1(t2);
      t4 = H.getTypeArgumentByIndex(t1, 0);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
      return H.listSuperNativeTypeCheck(H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), H.buildFunctionType(t3, [H.getDynamicRuntimeType()])._assertCheck$1(t2)), [t4]), "$isIterable"), "$isIterable");
    },
    get$items: function() {
      var t1, t2, t3, t4;
      t1 = this._zil.items.items;
      t2 = new K.Room_items_closure(this);
      t3 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t1.$builtinTypeInfo && t1.$builtinTypeInfo[0])])._assertCheck$1(t2);
      t4 = H.getTypeArgumentByIndex(t1, 0);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
      return H.listSuperNativeTypeCheck(H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), H.buildFunctionType(t3, [H.getDynamicRuntimeType()])._assertCheck$1(t2)), [t4]), "$isIterable"), "$isIterable");
    },
    createChoicesForPlayer$1: function(player) {
      H.assertHelper(player.location === this);
      C.JSArray_methods.forEach$1(this.actions, new K.Room_createChoicesForPlayer_closure(player));
    },
    toMap$0: function() {
      return H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_literal(["isActive", this.isActive, "team", this.team, "visited", this.visited, "actions", K.Action_iterableToMap(this.actions), "exits", K.Exit_iterableToMap(this.exits)], null, null), "$isMap", [P.String, null], "$asMap");
    },
    updateFromMap$1: function(map) {
      H.assertSubtype(map, "$isMap", [P.String, null], "$asMap");
      this.isActive = H.boolTypeCheck(map.$index(0, "isActive"));
      this.team = H.intTypeCheck(map.$index(0, "team"));
      this.visited = H.boolTypeCheck(map.$index(0, "visited"));
      K.Action_updateIterableFromMap(map.$index(0, "actions"), this.actions);
      K.Exit_updateIterableFromMap(map.$index(0, "exits"), this.exits);
    },
    Room$11$actions$actors$coordinates$descriptionPage$items$nameIsProperNoun$onUpdate: function(_zil, pageName, description, exits, actions, actors, coordinates, descriptionPage, items, nameIsProperNoun, onUpdate) {
      var t1, t2;
      H.listSuperNativeTypeCheck(actions, "$isIterable");
      H.listSuperNativeTypeCheck(actors, "$isIterable");
      H.assertSubtype(coordinates, "$isList", [P.$int], "$asList");
      H.listSuperNativeTypeCheck(items, "$isIterable");
      H.buildFunctionType(H.buildInterfaceType(P.bool))._assertCheck$1(onUpdate);
      O.throwIfNotInInitOrDeclareBlock("Cannot create room on the fly.");
      this.exits.forEach$1(0, new K.Room_closure(this));
      C.JSArray_methods.forEach$1(items, new K.Room_closure0(this));
      C.JSArray_methods.forEach$1(this.actions, new K.Room_closure1(this));
      C.JSArray_methods.forEach$1(items, new K.Room_closure2(this));
      C.JSArray_methods.forEach$1(actors, new K.Room_closure3(this));
      t1 = this._zil.rooms;
      t1.toString;
      O.throwIfNotInInitOrDeclareBlock("Author can only set up room network on init.");
      t1 = t1._rooms;
      t2 = this.name;
      H.assertHelper(!H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]), "$isIterable")._map.containsKey$1(t2));
      t1.$indexSet(0, t2, this);
    },
    onUpdate$0: function() {
      return this.onUpdate.call$0();
    },
    static: {Room$: function(_zil, pageName, description, exits, actions, actors, coordinates, descriptionPage, items, nameIsProperNoun, onUpdate) {
        var t1, t2, t3, t4;
        H.listSuperNativeTypeCheck(actions, "$isIterable");
        H.listSuperNativeTypeCheck(actors, "$isIterable");
        H.assertSubtype(coordinates, "$isList", [P.$int], "$asList");
        H.listSuperNativeTypeCheck(items, "$isIterable");
        t1 = H.buildFunctionType(H.buildInterfaceType(P.bool));
        t2 = t1._assertCheck$1(onUpdate);
        t3 = P.LinkedHashSet_LinkedHashSet$from(exits, null);
        t4 = H.setRuntimeTypeInfo([], [P.String]);
        t4 = new K.Room(H.assertSubtype(coordinates, "$isList", [P.$int], "$asList"), H.assertSubtype(t3, "$isSet", [K.Exit], "$asSet"), H.listSuperNativeTypeCheck(actions, "$isIterable"), t1._assertCheck$1(t2), description, descriptionPage, false, _zil, null, null, null, false, false, nameIsProperNoun, pageName, H.assertSubtype(t4, "$isList", [P.String], "$asList"), true, 0, true, false, C.Pronoun_it_it_its_itself);
        t4.Room$11$actions$actors$coordinates$descriptionPage$items$nameIsProperNoun$onUpdate(_zil, pageName, description, exits, actions, actors, coordinates, descriptionPage, items, nameIsProperNoun, t2);
        return t4;
      }}
  },
  Entity_Node: {
    "^": "Entity+Node;",
    $isNode: 1
  },
  Room_closure: {
    "^": "Closure:2;_zil$_captured_this_0",
    call$1: function(exit) {
      var t1 = this._zil$_captured_this_0;
      exit.set$from(t1);
      return t1;
    }
  },
  Room_closure0: {
    "^": "Closure:54;_zil$_captured_this_1",
    call$1: function(item) {
      var t1;
      H.interceptedTypeCheck(item, "$isItem");
      t1 = this._zil$_captured_this_1;
      item._carrier = null;
      item._location = t1;
      return t1;
    }
  },
  Room_closure1: {
    "^": "Closure:2;_zil$_captured_this_2",
    call$1: function(action) {
      var t1 = this._zil$_captured_this_2;
      action.set$room(t1);
      return t1;
    }
  },
  Room_closure2: {
    "^": "Closure:2;_zil$_captured_this_3",
    call$1: function(item) {
      item.set$location(this._zil$_captured_this_3);
    }
  },
  Room_closure3: {
    "^": "Closure:58;_zil$_captured_this_4",
    call$1: function(actor) {
      H.interceptedTypeCheck(actor, "$isAIActor").location = this._zil$_captured_this_4;
    }
  },
  Room_showActors_closure: {
    "^": "Closure:2;",
    call$1: function(actor) {
      return actor instanceof K.AIActor && actor.currentGoal != null;
    }
  },
  Room_showActors_closure0: {
    "^": "Closure:58;",
    call$1: function(actor) {
      H.interceptedTypeCheck(actor, "$isAIActor");
      C.JSArray_methods.add$1($.get$storyline().reports, actor.currentGoal.createReportGoalInProgress$0());
    }
  },
  Room_actors_closure: {
    "^": "Closure:53;_zil$_captured_this_0",
    call$1: function(actor) {
      H.interceptedTypeCheck(actor, "$isZilActor");
      return actor.location === this._zil$_captured_this_0 && H.boolConversionCheck(actor.isActive);
    }
  },
  Room_items_closure: {
    "^": "Closure:54;_zil$_captured_this_0",
    call$1: function(item) {
      return H.interceptedTypeCheck(item, "$isItem").isIn$2$countIfInPossession(this._zil$_captured_this_0, false);
    }
  },
  Room_createChoicesForPlayer_closure: {
    "^": "Closure:52;_captured_player_0",
    call$1: function(action) {
      H.interceptedTypeCheck(action, "$isAction").createChoiceForPlayer$1(this._captured_player_0);
    }
  },
  RoomNetwork: {
    "^": "Object;_zil,_rooms,aStar,_networkReady",
    getFromPageName$1: function(pageName) {
      var t1;
      H.stringTypeCheck(pageName);
      t1 = this._rooms;
      if (!t1.containsKey$1(pageName))
        throw H.wrapException(new K.PageNotDefinedInZilException("Page '" + H.S(pageName) + "' is not defined in ZIL. Define it in a <variable> block with zil.addRoom(new Room ...)."));
      return H.interceptedTypeCheck(t1.$index(0, pageName), "$isRoom");
    },
    _setExitToFields$0: function() {
      this._rooms.get$values().forEach$1(0, new K.RoomNetwork__setExitToFields_closure(this));
    },
    _checkNetworkReady$0: function() {
      if (!this._networkReady) {
        this._setExitToFields$0();
        H.assertSubtype(this, "$isGraph", [null], "$asGraph");
        var t1 = H.assertSubtype(P.ListQueue$(null, null), "$isQueue", [null], "$asQueue");
        this.aStar = H.setRuntimeTypeInfo(new S.AStar(H.assertSubtype(this, "$isGraph", [null], "$asGraph"), true, H.assertSubtype(t1, "$isQueue", [null], "$asQueue")), [null]);
        this._networkReady = true;
      }
    },
    toMap$0: function() {
      var map = H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, null), "$isMap", [P.String, null], "$asMap"), "$isMap", [P.String, null], "$asMap");
      this._rooms.forEach$1(0, new K.RoomNetwork_toMap_closure(map));
      return H.assertSubtype(map, "$isMap", [P.String, null], "$asMap");
    },
    updateFromMap$1: function(map) {
      var t1;
      H.assertSubtype(map, "$isMap", [P.String, null], "$asMap");
      t1 = this._rooms;
      H.assertHelper(map.get$length(map) === t1.__js_helper$_length);
      t1.forEach$1(0, new K.RoomNetwork_updateFromMap_closure(map));
    },
    $isGraph: 1,
    $asGraph: function() {
      return [K.Room];
    }
  },
  RoomNetwork__setExitToFields_closure: {
    "^": "Closure:59;_zil$_captured_this_0",
    call$1: function(origin) {
      H.interceptedTypeCheck(origin, "$isRoom");
      origin.exits.forEach$1(0, new K.RoomNetwork__setExitToFields__closure(this._zil$_captured_this_0, origin));
    }
  },
  RoomNetwork__setExitToFields__closure: {
    "^": "Closure:55;_zil$_captured_this_1,_captured_origin_2",
    call$1: function(exit) {
      var t1, t2, t3;
      H.interceptedTypeCheck(exit, "$isExit");
      t1 = this._zil$_captured_this_1._rooms;
      t2 = H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]), "$isIterable");
      t3 = exit.destinationPageName;
      if (!t2._map.containsKey$1(t3))
        throw H.wrapException(K.ZilException$("Couldn't find '" + t3 + "' among the rooms in the RoomNetwork. This is linked from the page '" + H.S(exit.from.name) + "'"));
      H.assertHelper(exit.from === this._captured_origin_2);
      exit.to = H.interceptedTypeCheck(t1.$index(0, t3), "$isRoom");
    }
  },
  RoomNetwork_toMap_closure: {
    "^": "Closure:6;_zil$_captured_map_0",
    call$2: function($name, room) {
      this._zil$_captured_map_0.$indexSet(0, $name, room.toMap$0());
    }
  },
  RoomNetwork_updateFromMap_closure: {
    "^": "Closure:6;_zil$_captured_map_0",
    call$2: function($name, room) {
      room.updateFromMap$1(this._zil$_captured_map_0.$index(0, $name));
    }
  }
}],
];
setupProgram(dart);
// getInterceptor methods
J.getInterceptor = function(receiver) {
  if (typeof receiver == "number") {
    if (Math.floor(receiver) == receiver)
      return J.JSInt.prototype;
    return J.JSDouble.prototype;
  }
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return J.JSNull.prototype;
  if (typeof receiver == "boolean")
    return J.JSBool.prototype;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$a = function(receiver) {
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$as = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$n = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$ns = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$s = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.$add$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver + a0;
  return J.getInterceptor$ns(receiver).$add(receiver, a0);
};
J.$eq = function(receiver, a0) {
  if (receiver == null)
    return a0 == null;
  if (typeof receiver != "object")
    return a0 != null && receiver === a0;
  return J.getInterceptor(receiver).$eq(receiver, a0);
};
J.$gt$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver > a0;
  return J.getInterceptor$n(receiver).$gt(receiver, a0);
};
J.$index$as = function(receiver, a0) {
  if (receiver.constructor == Array || typeof receiver == "string")
    if (a0 >>> 0 === a0 && a0 < receiver.length)
      return receiver[a0];
  return J.getInterceptor$as(receiver).$index(receiver, a0);
};
J.$sub$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver - a0;
  return J.getInterceptor$n(receiver).$sub(receiver, a0);
};
J.add$1$a = function(receiver, a0) {
  return J.getInterceptor$a(receiver).add$1(receiver, a0);
};
J.allMatches$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).allMatches$2(receiver, a0, a1);
};
J.compareTo$1$ns = function(receiver, a0) {
  return J.getInterceptor$ns(receiver).compareTo$1(receiver, a0);
};
J.contains$1$as = function(receiver, a0) {
  return J.getInterceptor$as(receiver).contains$1(receiver, a0);
};
J.elementAt$1$a = function(receiver, a0) {
  return J.getInterceptor$a(receiver).elementAt$1(receiver, a0);
};
J.forEach$1$a = function(receiver, a0) {
  return J.getInterceptor$a(receiver).forEach$1(receiver, a0);
};
J.get$hashCode$ = function(receiver) {
  return J.getInterceptor(receiver).get$hashCode(receiver);
};
J.get$isEmpty$as = function(receiver) {
  return J.getInterceptor$as(receiver).get$isEmpty(receiver);
};
J.get$isNotEmpty$as = function(receiver) {
  return J.getInterceptor$as(receiver).get$isNotEmpty(receiver);
};
J.get$iterator$a = function(receiver) {
  return J.getInterceptor$a(receiver).get$iterator(receiver);
};
J.get$length$as = function(receiver) {
  return J.getInterceptor$as(receiver).get$length(receiver);
};
J.indexOf$1$as = function(receiver, a0) {
  return J.getInterceptor$as(receiver).indexOf$1(receiver, a0);
};
J.insert$2$a = function(receiver, a0, a1) {
  return J.getInterceptor$a(receiver).insert$2(receiver, a0, a1);
};
J.map$1$a = function(receiver, a0) {
  return J.getInterceptor$a(receiver).map$1(receiver, a0);
};
J.matchAsPrefix$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).matchAsPrefix$2(receiver, a0, a1);
};
J.remove$0$a = function(receiver) {
  return J.getInterceptor$a(receiver).remove$0(receiver);
};
J.remove$1$a = function(receiver, a0) {
  return J.getInterceptor$a(receiver).remove$1(receiver, a0);
};
J.replaceAll$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).replaceAll$2(receiver, a0, a1);
};
J.replaceFirst$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).replaceFirst$2(receiver, a0, a1);
};
J.startsWith$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).startsWith$1(receiver, a0);
};
J.substring$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).substring$2(receiver, a0, a1);
};
J.toInt$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).toInt$0(receiver);
};
J.toString$0 = function(receiver) {
  return J.getInterceptor(receiver).toString$0(receiver);
};
J.trim$0$s = function(receiver) {
  return J.getInterceptor$s(receiver).trim$0(receiver);
};
Isolate.makeConstantList = function(list) {
  list.immutable$list = Array;
  list.fixed$length = Array;
  return list;
};
;
C.JSArray_methods = J.JSArray.prototype;
C.JSDouble_methods = J.JSDouble.prototype;
C.JSInt_methods = J.JSInt.prototype;
C.JSNumber_methods = J.JSNumber.prototype;
C.JSString_methods = J.JSString.prototype;
C.C_DynamicRuntimeType = new H.DynamicRuntimeType();
C.C_EmptyIterator = new H.EmptyIterator();
C.C_OutOfMemoryError = new P.OutOfMemoryError();
C.C_VoidRuntimeType = new H.VoidRuntimeType();
C.C__DelayedDone = new P._DelayedDone();
C.C__JSRandom = new P._JSRandom();
C.C__RootZone = new P._RootZone();
C.Duration_0 = new P.Duration(0);
C.JS_CONST_8ZY = function getTagFallback(o) {
  var constructor = o.constructor;
  if (typeof constructor == "function") {
    var name = constructor.name;
    if (typeof name == "string" &&
        name.length > 2 &&
        name !== "Object" &&
        name !== "Function.prototype") {
      return name;
    }
  }
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
C.JsonCodec_null_null = new P.JsonCodec(null, null);
C.JsonDecoder_null = new P.JsonDecoder(null);
C.JsonEncoder_null_null = new P.JsonEncoder(null, null);
C.List_0 = Isolate.makeConstantList(["quite tired", "really tired", "extremely tired", "exhausted", "absolutely exhausted"]);
C.List_0_0_0 = Isolate.makeConstantList([0, 0, 0]);
C.List_empty = Isolate.makeConstantList([]);
C.Pronoun_he_him_his_himself = new Y.Pronoun("he", "him", "his", "himself");
C.Pronoun_it_it_its_itself = new Y.Pronoun("it", "it", "its", "itself");
C.Pronoun_they_them_their_themselves = new Y.Pronoun("they", "them", "their", "themselves");
C.Pronoun_you_you_your_yourself = new Y.Pronoun("you", "you", "your", "yourself");
{
  init.isHunkLoaded = function(hunkHash) {
    return !!$dart_deferred_initializers[hunkHash];
  };
  init.deferredInitialized = new Object(null);
  init.isHunkInitialized = function(hunkHash) {
    return init.deferredInitialized[hunkHash];
  };
  init.initializeLoadedHunk = function(hunkHash) {
    $dart_deferred_initializers[hunkHash](globalsHolder, $);
    init.deferredInitialized[hunkHash] = true;
  };
}
init.deferredLibraryUris = {};
init.deferredLibraryHashes = {};
$.IsolateNatives_enableSpawnWorker = null;
$.RawReceivePortImpl__nextFreeId = 1;
$.Primitives_mirrorFunctionCacheName = "$cachedFunction";
$.Primitives_mirrorInvokeCacheName = "$cachedInvocation";
$.Closure_functionCounter = 0;
$.BoundClosure_selfFieldNameCache = null;
$.BoundClosure_receiverFieldNameCache = null;
$.RuntimeFunctionType_inAssert = false;
$.printToZone = null;
$._nextCallback = null;
$._lastCallback = null;
$._lastPriorityCallback = null;
$._isInCallbackLoop = false;
$.Zone__current = C.C__RootZone;
$.Expando__keyCount = 0;
$.gotoPageName = null;
$._pointsEmbargo = false;
$._currentForm = null;
$._repeatBlockBit = false;
$.isInInitOrDeclareBlock = true;
$.Stat_someChanged = false;
(function(lazies) {
  var descriptorLength = 4;
  for (var i = 0; i < lazies.length; i += descriptorLength) {
    var fieldName = lazies[i];
    var getterName = lazies[i + 1];
    var lazyValue = lazies[i + 2];
    var staticName = lazies[i + 3];
    Isolate.$lazy(fieldName, getterName, lazyValue, staticName);
  }
})(["IsolateNatives_thisScript", "get$IsolateNatives_thisScript", function() {
  return H.IsolateNatives_computeThisScript();
}, "thisScript", "IsolateNatives_workerIds", "get$IsolateNatives_workerIds", function() {
  return H.assertSubtype(H.setRuntimeTypeInfo(new P.Expando(null), [P.$int]), "$isExpando", [P.$int], "$asExpando");
}, "workerIds", "TypeErrorDecoder_noSuchMethodPattern", "get$TypeErrorDecoder_noSuchMethodPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({toString: function() {
      return "$receiver$";
    }}));
}, "noSuchMethodPattern", "TypeErrorDecoder_notClosurePattern", "get$TypeErrorDecoder_notClosurePattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({$method$: null, toString: function() {
      return "$receiver$";
    }}));
}, "notClosurePattern", "TypeErrorDecoder_nullCallPattern", "get$TypeErrorDecoder_nullCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(null));
}, "nullCallPattern", "TypeErrorDecoder_nullLiteralCallPattern", "get$TypeErrorDecoder_nullLiteralCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    var $argumentsExpr$ = '$arguments$';
    try {
      null.$method$($argumentsExpr$);
    } catch (e) {
      return e.message;
    }
  }());
}, "nullLiteralCallPattern", "TypeErrorDecoder_undefinedCallPattern", "get$TypeErrorDecoder_undefinedCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(void 0));
}, "undefinedCallPattern", "TypeErrorDecoder_undefinedLiteralCallPattern", "get$TypeErrorDecoder_undefinedLiteralCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    var $argumentsExpr$ = '$arguments$';
    try {
      (void 0).$method$($argumentsExpr$);
    } catch (e) {
      return e.message;
    }
  }());
}, "undefinedLiteralCallPattern", "TypeErrorDecoder_nullPropertyPattern", "get$TypeErrorDecoder_nullPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(null));
}, "nullPropertyPattern", "TypeErrorDecoder_nullLiteralPropertyPattern", "get$TypeErrorDecoder_nullLiteralPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    try {
      null.$method$;
    } catch (e) {
      return e.message;
    }
  }());
}, "nullLiteralPropertyPattern", "TypeErrorDecoder_undefinedPropertyPattern", "get$TypeErrorDecoder_undefinedPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(void 0));
}, "undefinedPropertyPattern", "TypeErrorDecoder_undefinedLiteralPropertyPattern", "get$TypeErrorDecoder_undefinedLiteralPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    try {
      (void 0).$method$;
    } catch (e) {
      return e.message;
    }
  }());
}, "undefinedLiteralPropertyPattern", "playerPilot", "get$playerPilot", function() {
  return new M.Pilot(null, 0, false, "player", H.assertSubtype(H.setRuntimeTypeInfo([], [P.String]), "$isList", [P.String], "$asList"), true, 1, true, true, C.Pronoun_you_you_your_yourself);
}, "playerPilot", "_AsyncRun_scheduleImmediateClosure", "get$_AsyncRun_scheduleImmediateClosure", function() {
  return P._AsyncRun__initializeScheduleImmediate();
}, "scheduleImmediateClosure", "Future__nullFuture", "get$Future__nullFuture", function() {
  return P.Future_Future$value(null, null);
}, "_nullFuture", "IterableBase__toStringVisiting", "get$IterableBase__toStringVisiting", function() {
  return [];
}, "_toStringVisiting", "Form__random", "get$Form__random", function() {
  return P.Random_Random(null);
}, "_random", "textBuffer", "get$textBuffer", function() {
  return P.StringBuffer$("");
}, "textBuffer", "_points", "get$_points", function() {
  var t1 = new O.PointsCounter(0, H.assertSubtype(null, "$isQueue", [A.PointsAward], "$asQueue"), null, "PointsCounter");
  t1.PointsCounter$0();
  return t1;
}, "_points", "choices", "get$choices", function() {
  return new L.EgbChoiceList(null, H.assertSubtype(H.setRuntimeTypeInfo([], [L.EgbChoice]), "$isList", [L.EgbChoice], "$asList"));
}, "choices", "vars", "get$vars", function() {
  return H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.Object), "$isMap", [P.String, P.Object], "$asMap"), "$isMap", [P.String, P.Object], "$asMap");
}, "vars", "_nextScriptStack", "get$_nextScriptStack", function() {
  return H.assertSubtype(H.assertSubtype(P.ListQueue$(null, {func: "", void: true}), "$isQueue", [{func: "", void: true}], "$asQueue"), "$isQueue", [{func: "", void: true}], "$asQueue");
}, "_nextScriptStack", "EgbChoice_GO_BACK", "get$EgbChoice_GO_BACK", function() {
  return P.RegExp_RegExp("^\\s*<<<\\s*$", true, false);
}, "GO_BACK", "_footnotes", "get$_footnotes", function() {
  return H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.String), "$isMap", [P.String, P.String], "$asMap"), "$isMap", [P.String, P.String], "$asMap");
}, "_footnotes", "Randomly__random", "get$Randomly__random", function() {
  return P.Random_Random(null);
}, "_random", "Stat__stats", "get$Stat__stats", function() {
  return H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, Z.Stat), "$isMap", [P.String, Z.Stat], "$asMap"), "$isMap", [P.String, Z.Stat], "$asMap");
}, "_stats", "storyline", "get$storyline", function() {
  return new Y.Storyline(P.StringBuffer$(""), H.assertSubtype(H.setRuntimeTypeInfo([], [Y.Report]), "$isList", [Y.Report], "$asList"), 0);
}, "storyline", "Storyline_QUOTE_INTERPUNCTION_DUPLICATION", "get$Storyline_QUOTE_INTERPUNCTION_DUPLICATION", function() {
  return P.RegExp_RegExp("(\\w)([\\.\\?\\!])([\"'])\\.(?=$|\\s)", true, false);
}, "QUOTE_INTERPUNCTION_DUPLICATION", "Entity_NOTHING", "get$Entity_NOTHING", function() {
  return Y.Entity$withOptions("__NOTHING__", true, false, false, C.Pronoun_it_it_its_itself, 0);
}, "NOTHING"]);
;

init.metadata = [,
false,
];
init.types = [{func: "", args: [P.$int]},
{func: ""},
{func: "", args: [,]},
{func: "", args: [P.String]},
{func: "", void: true},
{func: "", args: [T.BarBrawlOption]},
{func: "", args: [,,]},
{func: "", ret: P.String},
{func: "", void: true, args: [P.bool]},
{func: "", args: [P.bool]},
{func: "", args: [{func: "", void: true}]},
{func: "", void: true, args: [P.Object], opt: [P.StackTrace]},
{func: "", ret: P.Future},
{func: "", void: true, args: [,], opt: [P.StackTrace]},
{func: "", args: [,], opt: [,]},
{func: "", ret: P.bool},
{func: "", args: [, P.StackTrace]},
{func: "", void: true, args: [, P.StackTrace]},
{func: "", args: [P.String,,]},
{func: "", args: [P.Symbol,,]},
{func: "", ret: P.String, args: [P.$int]},
{func: "", args: [B.Element]},
{func: "", args: [G._NewValueCallback]},
{func: "", args: [G.FormElement]},
{func: "", args: [P.Object]},
{func: "", void: true, args: [P.Object]},
{func: "", void: true, args: [P.$int]},
{func: "", ret: P.bool, args: [L.EgbChoice]},
{func: "", args: [L.EgbChoice]},
{func: "", args: [G.CurrentState]},
{func: "", args: [P.num]},
{func: "", args: [Y.Actor]},
{func: "", args: [G.FormSection]},
{func: "", args: [, G.SubmitButton]},
{func: "", args: [M.Spaceship]},
{func: "", args: [M.ShipSystem]},
{func: "", args: [G.MultipleChoiceInput]},
{func: "", args: [M.CombatMove]},
{func: "", args: [P.num,,]},
{func: "", ret: P.String, args: [P.String, P.String]},
{func: "", args: [P.String, P.Map]},
{func: "", args: [P.String, Z.StatUpdate]},
{func: "", args: [Z.Stat]},
{func: "", ret: Y.Entity, args: [P.$int]},
{func: "", ret: P.String, args: [P.String]},
{func: "", args: [[P.List, Y.Report], Y.Report]},
{func: "", args: [Y.Report]},
{func: "", args: [P.Match]},
{func: "", args: [P.$int, P.$int]},
{func: "", args: [P.String, P.$int]},
{func: "", args: [L.TimedEvent]},
{func: "", args: [, P.Map]},
{func: "", args: [K.Action]},
{func: "", args: [K.ZilActor]},
{func: "", args: [K.Item]},
{func: "", args: [K.Exit]},
{func: "", args: [K.Goal]},
{func: "", args: [P.$int,,]},
{func: "", args: [K.AIActor]},
{func: "", args: [K.Room]},
{func: "", void: true, args: [[P.List, P.String], P.SendPort]},
{func: "", ret: P.String, args: [P.Match]},
{func: "", void: true, args: [{func: "", void: true}]},
{func: "", void: true, args: [,]},
{func: "", ret: P.bool, args: [,,]},
{func: "", ret: P.$int, args: [,]},
{func: "", ret: P.Object, args: [,]},
{func: "", ret: P.$int, args: [P.Comparable, P.Comparable]},
{func: "", ret: P.bool, args: [P.Object, P.Object]},
{func: "", ret: P.$int, args: [P.Object]},
{func: "", void: true, args: [P.String]},
{func: "", ret: L.EgbChoice, args: [P.String], named: {deferToChoiceList: P.bool, deferToEndOfPage: P.bool, goto: P.String, script: {func: "", void: true}, submenu: P.String}},
{func: "", void: true, args: [G.Form]},
];
$ = null;
Isolate = Isolate.$finishIsolateConstructor(Isolate);
$ = new Isolate();
function convertToFastObject(properties) {
  function MyClass() {
  }
  MyClass.prototype = properties;
  new MyClass();
  return properties;
}
;
function convertToSlowObject(properties) {
  properties.__MAGIC_SLOW_PROPERTY = 1;
  delete properties.__MAGIC_SLOW_PROPERTY;
  return properties;
}
;
A = convertToFastObject(A);
B = convertToFastObject(B);
C = convertToFastObject(C);
D = convertToFastObject(D);
E = convertToFastObject(E);
F = convertToFastObject(F);
G = convertToFastObject(G);
H = convertToFastObject(H);
J = convertToFastObject(J);
K = convertToFastObject(K);
L = convertToFastObject(L);
M = convertToFastObject(M);
N = convertToFastObject(N);
O = convertToFastObject(O);
P = convertToFastObject(P);
Q = convertToFastObject(Q);
R = convertToFastObject(R);
S = convertToFastObject(S);
T = convertToFastObject(T);
U = convertToFastObject(U);
V = convertToFastObject(V);
W = convertToFastObject(W);
X = convertToFastObject(X);
Y = convertToFastObject(Y);
Z = convertToFastObject(Z);
function init() {
  Isolate.$isolateProperties = Object.create(null);
  init.allClasses = Object.create(null);
  init.getTypeFromName = function(name) {
    return init.allClasses[name];
  };
  init.interceptorsByTag = Object.create(null);
  init.leafTags = Object.create(null);
  init.finishedClasses = Object.create(null);
  Isolate.$lazy = function(fieldName, getterName, lazyValue, staticName, prototype) {
    if (!init.lazies)
      init.lazies = Object.create(null);
    init.lazies[fieldName] = getterName;
    prototype = prototype || Isolate.$isolateProperties;
    var sentinelUndefined = {};
    var sentinelInProgress = {};
    prototype[fieldName] = sentinelUndefined;
    prototype[getterName] = function() {
      var result = this[fieldName];
      try {
        if (result === sentinelUndefined) {
          this[fieldName] = sentinelInProgress;
          try {
            result = this[fieldName] = lazyValue();
          } finally {
            if (result === sentinelUndefined)
              this[fieldName] = null;
          }
        } else
          if (result === sentinelInProgress)
            H.throwCyclicInit(staticName || fieldName);
        return result;
      } finally {
        this[getterName] = function() {
          return this[fieldName];
        };
      }
    };
  };
  Isolate.$finishIsolateConstructor = function(oldIsolate) {
    var isolateProperties = oldIsolate.$isolateProperties;
    function Isolate() {
      var staticNames = Object.keys(isolateProperties);
      for (var i = 0; i < staticNames.length; i++) {
        var staticName = staticNames[i];
        this[staticName] = isolateProperties[staticName];
      }
      var lazies = init.lazies;
      var lazyInitializers = lazies ? Object.keys(lazies) : [];
      for (var i = 0; i < lazyInitializers.length; i++)
        this[lazies[lazyInitializers[i]]] = null;
      function ForceEfficientMap() {
      }
      ForceEfficientMap.prototype = this;
      new ForceEfficientMap();
      for (var i = 0; i < lazyInitializers.length; i++) {
        var lazyInitName = lazies[lazyInitializers[i]];
        this[lazyInitName] = isolateProperties[lazyInitName];
      }
    }
    Isolate.prototype = oldIsolate.prototype;
    Isolate.prototype.constructor = Isolate;
    Isolate.$isolateProperties = isolateProperties;
    Isolate.makeConstantList = oldIsolate.makeConstantList;
    return Isolate;
  };
}
;// BEGIN invoke [main].
(function(callback) {
  if (typeof document === "undefined") {
    callback(null);
    return;
  }
  if (document.currentScript) {
    callback(document.currentScript);
    return;
  }
  var scripts = document.scripts;
  function onLoad(event) {
    for (var i = 0; i < scripts.length; ++i)
      scripts[i].removeEventListener("load", onLoad, false);
    callback(event.target);
  }
  for (var i = 0; i < scripts.length; ++i)
    scripts[i].addEventListener("load", onLoad, false);
})(function(currentScript) {
  init.currentScript = currentScript;
  if (typeof dartMainRunner === "function")
    dartMainRunner(function(a) {
      H.startRootIsolate(N.main$closure(), a);
    }, []);
  else
    (function(a) {
      H.startRootIsolate(N.main$closure(), a);
    })([]);
});
;
// END invoke [main].
})()

//# sourceMappingURL=bodega.dart.js.map
