// Generated by dart2js, the Dart to JavaScript compiler version: 1.10.1.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
//
// dartDeferredLibraryLoader(uri, successCallback, errorCallback):
//    if this function is defined, it will be called when a deferered library
//    is loaded. It should load and eval the javascript of `uri`, and call
//    successCallback. If it fails to do so, it should call errorCallback with
//    an error.
(function($) {
var supportsDirectProtoAccess = function() {
  var cls = function() {
  };
  cls.prototype = {p: {}};
  var object = new cls();
  return object.__proto__ && object.__proto__.p === cls.prototype.p;
}();
;
function map(x) {
  x = Object.create(null);
  x.x = 0;
  delete x.x;
  return x;
}
var A = map();
var B = map();
var C = map();
var D = map();
var E = map();
var F = map();
var G = map();
var H = map();
var J = map();
var K = map();
var L = map();
var M = map();
var N = map();
var O = map();
var P = map();
var Q = map();
var R = map();
var S = map();
var T = map();
var U = map();
var V = map();
var W = map();
var X = map();
var Y = map();
var Z = map();
function Isolate() {}
init();

$ = Isolate.$isolateProperties;
$.functionThatReturnsNull = function() {
};
;
function setupProgram(programData) {
  "use strict";
  function generateAccessor(fieldDescriptor, accessors, cls) {
    var fieldInformation = fieldDescriptor.split("-");
    var field = fieldInformation[0];
    var len = field.length;
    var code = field.charCodeAt(len - 1);
    var reflectable;
    if (fieldInformation.length > 1)
      reflectable = true;
    else
      reflectable = false;
    code = code >= 60 && code <= 64 ? code - 59 : code >= 123 && code <= 126 ? code - 117 : code >= 37 && code <= 43 ? code - 27 : 0;
    if (code) {
      var getterCode = code & 3;
      var setterCode = code >> 2;
      var accessorName = field = field.substring(0, len - 1);
      var divider = field.indexOf(":");
      if (divider > 0) {
        accessorName = field.substring(0, divider);
        field = field.substring(divider + 1);
      }
      if (getterCode) {
        var args = getterCode & 2 ? "receiver" : "";
        var receiver = getterCode & 1 ? "this" : "receiver";
        var body = "return " + receiver + "." + field;
        var property = cls + ".prototype.get$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
      if (setterCode) {
        var args = setterCode & 2 ? "receiver, value" : "value";
        var receiver = setterCode & 1 ? "this" : "receiver";
        var body = receiver + "." + field + " = value";
        var property = cls + ".prototype.set$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
    }
    return field;
  }
  function defineClass(name, fields) {
    var accessors = [];
    var str = "function " + name + "(";
    var body = "";
    var fieldNames = "";
    for (var i = 0; i < fields.length; i++) {
      if (i != 0)
        str += ", ";
      var field = generateAccessor(fields[i], accessors, name);
      fieldNames += "'" + field + "',";
      var parameter = "p_" + field;
      str += parameter;
      body += "this." + field + " = " + parameter + ";\n";
    }
    if (supportsDirectProtoAccess)
      body += "this." + "$deferredAction" + "();";
    str += ") {\n" + body + "}\n";
    str += name + ".builtin$cls=\"" + name + "\";\n";
    str += "$desc=$collectedClasses." + name + "[1];\n";
    str += name + ".prototype = $desc;\n";
    if (typeof defineClass.name != "string")
      str += name + ".name=\"" + name + "\";\n";
    str += name + "." + "$__fields__" + "=[" + fieldNames + "];\n";
    str += accessors.join("");
    return str;
  }
  init.createNewIsolate = function() {
    return new Isolate();
  };
  init.classIdExtractor = function(o) {
    return o.constructor.name;
  };
  init.classFieldsExtractor = function(o) {
    var fieldNames = o.constructor.$__fields__;
    if (!fieldNames)
      return [];
    var result = [];
    result.length = fieldNames.length;
    for (var i = 0; i < fieldNames.length; i++)
      result[i] = o[fieldNames[i]];
    return result;
  };
  init.instanceFromClassId = function(name) {
    return new init.allClasses[name]();
  };
  init.initializeEmptyInstance = function(name, o, fields) {
    init.allClasses[name].apply(o, fields);
    return o;
  };
  var inheritFrom = supportsDirectProtoAccess ? function(constructor, superConstructor) {
    var prototype = constructor.prototype;
    prototype.__proto__ = superConstructor.prototype;
    prototype.constructor = constructor;
    prototype["$is" + constructor.name] = constructor;
    return convertToFastObject(prototype);
  } : function() {
    function tmp() {
    }
    return function(constructor, superConstructor) {
      tmp.prototype = superConstructor.prototype;
      var object = new tmp();
      convertToSlowObject(object);
      var properties = constructor.prototype;
      var members = Object.keys(properties);
      for (var i = 0; i < members.length; i++) {
        var member = members[i];
        object[member] = properties[member];
      }
      object["$is" + constructor.name] = constructor;
      object.constructor = constructor;
      constructor.prototype = object;
      return object;
    };
  }();
  function finishClasses(processedClasses) {
    var allClasses = init.allClasses;
    processedClasses.combinedConstructorFunction += "return [\n" + processedClasses.constructorsList.join(",\n  ") + "\n]";
    var constructors = new Function("$collectedClasses", processedClasses.combinedConstructorFunction)(processedClasses.collected);
    processedClasses.combinedConstructorFunction = null;
    for (var i = 0; i < constructors.length; i++) {
      var constructor = constructors[i];
      var cls = constructor.name;
      var desc = processedClasses.collected[cls];
      var globalObject = desc[0];
      desc = desc[1];
      allClasses[cls] = constructor;
      globalObject[cls] = constructor;
    }
    constructors = null;
    var finishedClasses = init.finishedClasses;
    function finishClass(cls) {
      if (finishedClasses[cls])
        return;
      finishedClasses[cls] = true;
      var superclass = processedClasses.pending[cls];
      if (superclass && superclass.indexOf("+") > 0) {
        var s = superclass.split("+");
        superclass = s[0];
        var mixinClass = s[1];
        finishClass(mixinClass);
        var mixin = allClasses[mixinClass];
        var mixinPrototype = mixin.prototype;
        var clsPrototype = allClasses[cls].prototype;
        var properties = Object.keys(mixinPrototype);
        for (var i = 0; i < properties.length; i++) {
          var d = properties[i];
          if (!hasOwnProperty.call(clsPrototype, d))
            clsPrototype[d] = mixinPrototype[d];
        }
      }
      if (!superclass || typeof superclass != "string") {
        var constructor = allClasses[cls];
        var prototype = constructor.prototype;
        prototype.constructor = constructor;
        prototype.$isObject = constructor;
        prototype.$deferredAction = function() {
        };
        return;
      }
      finishClass(superclass);
      var superConstructor = allClasses[superclass];
      if (!superConstructor)
        superConstructor = existingIsolateProperties[superclass];
      var constructor = allClasses[cls];
      var prototype = inheritFrom(constructor, superConstructor);
      if (mixinPrototype)
        prototype.$deferredAction = mixinDeferredActionHelper(mixinPrototype, prototype);
      if (Object.prototype.hasOwnProperty.call(prototype, "%")) {
        var nativeSpec = prototype["%"].split(";");
        if (nativeSpec[0]) {
          var tags = nativeSpec[0].split("|");
          for (var i = 0; i < tags.length; i++) {
            init.interceptorsByTag[tags[i]] = constructor;
            init.leafTags[tags[i]] = true;
          }
        }
        if (nativeSpec[1]) {
          tags = nativeSpec[1].split("|");
          if (nativeSpec[2]) {
            var subclasses = nativeSpec[2].split("|");
            for (var i = 0; i < subclasses.length; i++) {
              var subclass = allClasses[subclasses[i]];
              subclass.$nativeSuperclassTag = tags[0];
            }
          }
          for (i = 0; i < tags.length; i++) {
            init.interceptorsByTag[tags[i]] = constructor;
            init.leafTags[tags[i]] = false;
          }
        }
        prototype.$deferredAction();
      }
      if (prototype.$isInterceptor)
        prototype.$deferredAction();
    }
    var properties = Object.keys(processedClasses.pending);
    for (var i = 0; i < properties.length; i++)
      finishClass(properties[i]);
  }
  function finishAddStubsHelper() {
    var prototype = this;
    while (!prototype.hasOwnProperty("$deferredAction"))
      prototype = prototype.__proto__;
    delete prototype.$deferredAction;
    var properties = Object.keys(prototype);
    for (var index = 0; index < properties.length; index++) {
      var property = properties[index];
      var firstChar = property.charCodeAt(0);
      var elem;
      if (property !== "^" && property !== "$reflectable" && firstChar !== 43 && firstChar !== 42 && (elem = prototype[property]) != null && elem.constructor === Array && property !== "<>")
        addStubs(prototype, elem, property, false, []);
    }
    convertToFastObject(prototype);
    prototype = prototype.__proto__;
    prototype.$deferredAction();
  }
  function mixinDeferredActionHelper(mixinPrototype, targetPrototype) {
    var chain;
    if (targetPrototype.hasOwnProperty("$deferredAction"))
      chain = targetPrototype.$deferredAction;
    return function foo() {
      var prototype = this;
      while (!prototype.hasOwnProperty("$deferredAction"))
        prototype = prototype.__proto__;
      if (chain)
        prototype.$deferredAction = chain;
      else {
        delete prototype.$deferredAction;
        convertToFastObject(prototype);
      }
      mixinPrototype.$deferredAction();
      prototype.$deferredAction();
    };
  }
  function processClassData(cls, descriptor, processedClasses) {
    descriptor = convertToSlowObject(descriptor);
    var previousProperty;
    var properties = Object.keys(descriptor);
    var hasDeferredWork = false;
    var shouldDeferWork = supportsDirectProtoAccess && cls != "Object";
    for (var i = 0; i < properties.length; i++) {
      var property = properties[i];
      var firstChar = property.charCodeAt(0);
      if (property === "static") {
        processStatics(init.statics[cls] = descriptor.static, processedClasses);
        delete descriptor.static;
      } else if (firstChar === 43) {
        mangledNames[previousProperty] = property.substring(1);
        var flag = descriptor[property];
        if (flag > 0)
          descriptor[previousProperty].$reflectable = flag;
      } else if (firstChar === 42) {
        descriptor[previousProperty].$defaultValues = descriptor[property];
        var optionalMethods = descriptor.$methodsWithOptionalArguments;
        if (!optionalMethods)
          descriptor.$methodsWithOptionalArguments = optionalMethods = {};
        optionalMethods[property] = previousProperty;
      } else {
        var elem = descriptor[property];
        if (property !== "^" && elem != null && elem.constructor === Array && property !== "<>")
          if (shouldDeferWork)
            hasDeferredWork = true;
          else
            addStubs(descriptor, elem, property, false, []);
        else
          previousProperty = property;
      }
    }
    if (hasDeferredWork)
      descriptor.$deferredAction = finishAddStubsHelper;
    var classData = descriptor["^"], split, supr, fields = classData;
    var s = fields.split(";");
    fields = s[1] == "" ? [] : s[1].split(",");
    supr = s[0];
    split = supr.split(":");
    if (split.length == 2) {
      supr = split[0];
      var functionSignature = split[1];
      if (functionSignature)
        descriptor.$signature = function(s) {
          return function() {
            return init.types[s];
          };
        }(functionSignature);
    }
    if (supr)
      processedClasses.pending[cls] = supr;
    processedClasses.combinedConstructorFunction += defineClass(cls, fields);
    processedClasses.constructorsList.push(cls);
    processedClasses.collected[cls] = [globalObject, descriptor];
    classes.push(cls);
  }
  function processStatics(descriptor, processedClasses) {
    var properties = Object.keys(descriptor);
    for (var i = 0; i < properties.length; i++) {
      var property = properties[i];
      if (property === "^")
        continue;
      var element = descriptor[property];
      var firstChar = property.charCodeAt(0);
      var previousProperty;
      if (firstChar === 43) {
        mangledGlobalNames[previousProperty] = property.substring(1);
        var flag = descriptor[property];
        if (flag > 0)
          descriptor[previousProperty].$reflectable = flag;
        if (element && element.length)
          init.typeInformation[previousProperty] = element;
      } else if (firstChar === 42) {
        globalObject[previousProperty].$defaultValues = element;
        var optionalMethods = descriptor.$methodsWithOptionalArguments;
        if (!optionalMethods)
          descriptor.$methodsWithOptionalArguments = optionalMethods = {};
        optionalMethods[property] = previousProperty;
      } else if (typeof element === "function") {
        globalObject[previousProperty = property] = element;
        functions.push(property);
        init.globalFunctions[property] = element;
      } else if (element.constructor === Array)
        addStubs(globalObject, element, property, true, functions);
      else {
        previousProperty = property;
        processClassData(property, element, processedClasses);
      }
    }
  }
  function addStubs(prototype, array, name, isStatic, functions) {
    var index = 0, alias = array[index], f;
    if (typeof alias == "string")
      f = array[++index];
    else {
      f = alias;
      alias = name;
    }
    var funcs = [prototype[name] = prototype[alias] = f];
    f.$stubName = name;
    functions.push(name);
    for (; index < array.length; index += 2) {
      f = array[index + 1];
      if (typeof f != "function")
        break;
      f.$stubName = array[index + 2];
      funcs.push(f);
      if (f.$stubName) {
        prototype[f.$stubName] = f;
        functions.push(f.$stubName);
      }
    }
    index++;
    for (var i = 0; i < funcs.length; index++, i++)
      funcs[i].$callName = array[index];
    var getterStubName = array[index];
    array = array.slice(++index);
    var requiredParameterInfo = array[0];
    var requiredParameterCount = requiredParameterInfo >> 1;
    var isAccessor = (requiredParameterInfo & 1) === 1;
    var isSetter = requiredParameterInfo === 3;
    var isGetter = requiredParameterInfo === 1;
    var optionalParameterInfo = array[1];
    var optionalParameterCount = optionalParameterInfo >> 1;
    var optionalParametersAreNamed = (optionalParameterInfo & 1) === 1;
    var isIntercepted = requiredParameterCount + optionalParameterCount != funcs[0].length;
    var functionTypeIndex = array[2];
    var unmangledNameIndex = 2 * optionalParameterCount + requiredParameterCount + 3;
    if (getterStubName) {
      f = tearOff(funcs, array, isStatic, name, isIntercepted);
      prototype[name].$getter = f;
      f.$getterStub = true;
      if (isStatic) {
        init.globalFunctions[name] = f;
        functions.push(getterStubName);
      }
      prototype[getterStubName] = f;
      funcs.push(f);
      f.$stubName = getterStubName;
      f.$callName = null;
    }
  }
  function tearOffGetter(funcs, reflectionInfo, name, isIntercepted) {
    return isIntercepted ? new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(x) {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [x], name);" + "return new c(this, funcs[0], x, name);" + "}")(funcs, reflectionInfo, name, H, null) : new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [], name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, reflectionInfo, name, H, null);
  }
  function tearOff(funcs, reflectionInfo, isStatic, name, isIntercepted) {
    var cache;
    return isStatic ? function() {
      if (cache === void 0)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, true, [], name).prototype;
      return cache;
    } : tearOffGetter(funcs, reflectionInfo, name, isIntercepted);
  }
  var functionCounter = 0;
  if (!init.libraries)
    init.libraries = [];
  if (!init.mangledNames)
    init.mangledNames = map();
  if (!init.mangledGlobalNames)
    init.mangledGlobalNames = map();
  if (!init.statics)
    init.statics = map();
  if (!init.typeInformation)
    init.typeInformation = map();
  if (!init.globalFunctions)
    init.globalFunctions = map();
  var libraries = init.libraries;
  var mangledNames = init.mangledNames;
  var mangledGlobalNames = init.mangledGlobalNames;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var length = programData.length;
  var processedClasses = map();
  processedClasses.collected = map();
  processedClasses.pending = map();
  processedClasses.constructorsList = [];
  processedClasses.combinedConstructorFunction = "function $reflectable(fn){fn.$reflectable=1;return fn};\n" + "var $desc;\n";
  for (var i = 0; i < length; i++) {
    var data = programData[i];
    var name = data[0];
    var uri = data[1];
    var metadata = data[2];
    var globalObject = data[3];
    var descriptor = data[4];
    var isRoot = !!data[5];
    var fields = descriptor && descriptor["^"];
    if (fields instanceof Array)
      fields = fields[0];
    var classes = [];
    var functions = [];
    processStatics(descriptor, processedClasses);
    libraries.push([name, uri, classes, functions, metadata, fields, isRoot, globalObject]);
  }
  finishClasses(processedClasses);
}
var dart = [
["_foreign_helper", "dart:_foreign_helper", , H, {
  "^": "",
  JS_CONST: {
    "^": "Object;code"
  }
}],
["_interceptors", "dart:_interceptors", , J, {
  "^": "",
  getInterceptor: function(object) {
    return void 0;
  },
  makeDispatchRecord: function(interceptor, proto, extension, indexability) {
    return {i: interceptor, p: proto, e: extension, x: indexability};
  },
  getNativeInterceptor: function(object) {
    var record, proto, objectProto, interceptor;
    record = object[init.dispatchPropertyName];
    if (record == null)
      if ($.initNativeDispatchFlag == null) {
        H.initNativeDispatch();
        record = object[init.dispatchPropertyName];
      }
    if (record != null) {
      proto = record.p;
      if (false === proto)
        return record.i;
      if (true === proto)
        return object;
      objectProto = Object.getPrototypeOf(object);
      if (proto === objectProto)
        return record.i;
      if (record.e === objectProto)
        throw H.wrapException(P.UnimplementedError$("Return interceptor for " + H.S(proto(object, record))));
    }
    interceptor = H.lookupAndCacheInterceptor(object);
    if (interceptor == null) {
      proto = Object.getPrototypeOf(object);
      if (proto == null || proto === Object.prototype)
        return C.PlainJavaScriptObject_methods;
      else
        return C.UnknownJavaScriptObject_methods;
    }
    return interceptor;
  },
  Interceptor: {
    "^": "Object;",
    $eq: function(receiver, other) {
      return receiver === other;
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    toString$0: ["super$Interceptor$toString$0", function(receiver) {
      return H.Primitives_objectToString(receiver);
    }],
    get$runtimeType: function(receiver) {
      return new H.TypeImpl(H.getRuntimeTypeString(receiver), null);
    },
    "%": "MediaKeyError|PositionError|SQLError|SVGAnimatedEnumeration|SVGAnimatedLengthList|SVGAnimatedNumber|SVGAnimatedNumberList"
  },
  JSBool: {
    "^": "Interceptor;",
    toString$0: function(receiver) {
      return String(receiver);
    },
    get$hashCode: function(receiver) {
      return receiver ? 519018 : 218159;
    },
    get$runtimeType: function(receiver) {
      return C.Type_EsU;
    },
    $isbool: 1
  },
  JSNull: {
    "^": "Interceptor;",
    $eq: function(receiver, other) {
      return null == other;
    },
    toString$0: function(receiver) {
      return "null";
    },
    get$hashCode: function(receiver) {
      return 0;
    },
    get$runtimeType: function(receiver) {
      return C.Type_eZO;
    }
  },
  JavaScriptObject: {
    "^": "Interceptor;",
    get$hashCode: function(_) {
      return 0;
    },
    get$runtimeType: function(_) {
      return C.Type_XXD;
    },
    $isJSObject: 1
  },
  PlainJavaScriptObject: {
    "^": "JavaScriptObject;"
  },
  UnknownJavaScriptObject: {
    "^": "JavaScriptObject;",
    toString$0: function(receiver) {
      return String(receiver);
    }
  },
  JSArray: {
    "^": "Interceptor;",
    checkMutable$1: function(receiver, reason) {
      if (!!receiver.immutable$list)
        throw H.wrapException(P.UnsupportedError$(reason));
    },
    checkGrowable$1: function(receiver, reason) {
      if (!!receiver.fixed$length)
        throw H.wrapException(P.UnsupportedError$(reason));
    },
    add$1: function(receiver, value) {
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(receiver, 0));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("add"));
      receiver.push(value);
    },
    removeAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index, null, null));
      this.checkGrowable$1(receiver, "removeAt");
      return H.assertSubtypeOfRuntimeType(receiver.splice(index, 1)[0], H.getTypeArgumentByIndex(receiver, 0));
    },
    insertAll$2: function(receiver, index, iterable) {
      var insertionLength, end;
      H.listSuperNativeTypeCheck(iterable, "$isIterable");
      this.checkGrowable$1(receiver, "insertAll");
      P.RangeError_checkValueInInterval(index, 0, receiver.length, "index", null);
      insertionLength = iterable.length;
      this.set$length(receiver, receiver.length + insertionLength);
      end = index + insertionLength;
      this.setRange$4(receiver, end, receiver.length, receiver, index);
      this.setRange$3(receiver, index, end, iterable);
    },
    remove$1: function(receiver, element) {
      var i;
      this.checkGrowable$1(receiver, "remove");
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], element)) {
          receiver.splice(i, 1);
          return true;
        }
      return false;
    },
    _removeWhere$2: function(receiver, test, removeMatching) {
      var t1, retained, end, i, element;
      t1 = H.buildFunctionType(H.buildInterfaceType(P.bool), [H.convertRtiToRuntimeType(receiver.$builtinTypeInfo && receiver.$builtinTypeInfo[0])])._assertCheck$1(test);
      retained = [];
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        element = receiver[i];
        if (!H.boolConversionCheck(t1.call$1(element)) === removeMatching)
          this.add$1(retained, element);
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      t1 = retained.length;
      if (t1 === end)
        return;
      this.set$length(receiver, t1);
      for (i = 0; i < retained.length; ++i)
        this.$indexSet(receiver, i, retained[i]);
    },
    addAll$1: function(receiver, collection) {
      var t1;
      for (t1 = J.get$iterator$ax(H.listSuperNativeTypeCheck(collection, "$isIterable")); t1.moveNext$0();)
        this.add$1(receiver, H.assertSubtypeOfRuntimeType(H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0)), H.getTypeArgumentByIndex(receiver, 0)));
    },
    forEach$1: function(receiver, f) {
      var t1, end, i;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [H.convertRtiToRuntimeType(receiver.$builtinTypeInfo && receiver.$builtinTypeInfo[0])])._assertCheck$1(f);
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        t1.call$1(receiver[i]);
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
    },
    map$1: function(receiver, f) {
      var t1, t2;
      t1 = H.buildFunctionType(H.getDynamicRuntimeType(), [H.convertRtiToRuntimeType(receiver.$builtinTypeInfo && receiver.$builtinTypeInfo[0])])._assertCheck$1(f);
      H.listSuperNativeTypeCheck(receiver, "$isIterable");
      t2 = H.buildFunctionType(H.convertRtiToRuntimeType(null), [H.convertRtiToRuntimeType(null)]);
      t2._assertCheck$1(t1);
      return H.setRuntimeTypeInfo(new H.MappedListIterable(H.listSuperNativeTypeCheck(receiver, "$isIterable"), t2._assertCheck$1(t1)), [null, null]);
    },
    join$1: function(receiver, separator) {
      var t1, list, i, t2;
      t1 = receiver.length;
      list = Array(t1);
      list.fixed$length = Array;
      for (i = 0; i < receiver.length; ++i) {
        t2 = H.S(receiver[i]);
        if (i >= t1)
          return H.ioore(list, i);
        list[i] = t2;
      }
      return list.join(separator);
    },
    fold$2: function(receiver, initialValue, combine) {
      var t1, $length, value, i;
      t1 = H.getDynamicRuntimeType();
      t1 = H.buildFunctionType(t1, [t1, H.convertRtiToRuntimeType(receiver.$builtinTypeInfo && receiver.$builtinTypeInfo[0])])._assertCheck$1(combine);
      $length = receiver.length;
      for (value = initialValue, i = 0; i < $length; ++i) {
        value = t1.call$2(value, receiver[i]);
        if (receiver.length !== $length)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return value;
    },
    singleWhere$1: function(receiver, test) {
      var t1, $length, match, matchFound, i, element;
      t1 = H.buildFunctionType(H.buildInterfaceType(P.bool), [H.convertRtiToRuntimeType(receiver.$builtinTypeInfo && receiver.$builtinTypeInfo[0])])._assertCheck$1(test);
      $length = receiver.length;
      H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(receiver, 0));
      for (match = null, matchFound = false, i = 0; i < $length; ++i) {
        element = receiver[i];
        if (H.boolConversionCheck(t1.call$1(element))) {
          if (matchFound)
            throw H.wrapException(H.IterableElementError_tooMany());
          H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(receiver, 0));
          match = element;
          matchFound = true;
        }
        if ($length !== receiver.length)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      if (matchFound)
        return H.assertSubtypeOfRuntimeType(match, H.getTypeArgumentByIndex(receiver, 0));
      throw H.wrapException(H.IterableElementError_noElement());
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return H.assertSubtypeOfRuntimeType(receiver[index], H.getTypeArgumentByIndex(receiver, 0));
    },
    sublist$2: function(receiver, start, end) {
      var t1;
      if (start == null)
        H.throwExpression(P.ArgumentError$(null));
      if (typeof start !== "number" || Math.floor(start) !== start)
        throw H.wrapException(P.ArgumentError$(start));
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
      if (end == null)
        end = receiver.length;
      else if (end < start || end > receiver.length)
        throw H.wrapException(P.RangeError$range(end, start, receiver.length, null, null));
      if (start === end)
        return H.assertSubtype(H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(receiver, 0)]), "$isList", [H.getTypeArgumentByIndex(receiver, 0)], "$asList");
      t1 = H.getTypeArgumentByIndex(receiver, 0);
      return H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(H.assertSubtype(receiver.slice(start, end), "$isJSArray", [t1], "$asJSArray"), [t1]), "$isJSArray", [t1], "$asJSArray"), "$isList", [H.getTypeArgumentByIndex(receiver, 0)], "$asList");
    },
    sublist$1: function($receiver, start) {
      return this.sublist$2($receiver, start, null);
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return H.assertSubtypeOfRuntimeType(receiver[0], H.getTypeArgumentByIndex(receiver, 0));
      throw H.wrapException(H.IterableElementError_noElement());
    },
    get$last: function(receiver) {
      var t1 = receiver.length;
      if (t1 > 0)
        return H.assertSubtypeOfRuntimeType(receiver[t1 - 1], H.getTypeArgumentByIndex(receiver, 0));
      throw H.wrapException(H.IterableElementError_noElement());
    },
    get$single: function(receiver) {
      var t1 = receiver.length;
      if (t1 === 1) {
        if (0 >= t1)
          return H.ioore(receiver, 0);
        return H.assertSubtypeOfRuntimeType(receiver[0], H.getTypeArgumentByIndex(receiver, 0));
      }
      if (t1 === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      throw H.wrapException(H.IterableElementError_tooMany());
    },
    removeRange$2: function(receiver, start, end) {
      this.checkGrowable$1(receiver, "removeRange");
      P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
      receiver.splice(start, end - start);
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      var $length, t1, i;
      H.listSuperNativeTypeCheck(iterable, "$isIterable");
      this.checkMutable$1(receiver, "set range");
      P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
      $length = end - start;
      if ($length === 0)
        return;
      if (skipCount < 0)
        H.throwExpression(P.RangeError$range(skipCount, 0, null, "skipCount", null));
      t1 = J.getInterceptor$asx(iterable);
      if (skipCount + $length > t1.get$length(iterable))
        throw H.wrapException(H.IterableElementError_tooFew());
      if (skipCount < start)
        for (i = $length - 1; i >= 0; --i)
          receiver[start + i] = H.assertSubtypeOfRuntimeType(t1.$index(iterable, skipCount + i), H.getTypeArgumentByIndex(receiver, 0));
      else
        for (i = 0; i < $length; ++i)
          receiver[start + i] = H.assertSubtypeOfRuntimeType(t1.$index(iterable, skipCount + i), H.getTypeArgumentByIndex(receiver, 0));
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    any$1: function(receiver, test) {
      var t1, end, i;
      t1 = H.buildFunctionType(H.buildInterfaceType(P.bool), [H.convertRtiToRuntimeType(receiver.$builtinTypeInfo && receiver.$builtinTypeInfo[0])])._assertCheck$1(test);
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        if (H.boolConversionCheck(t1.call$1(receiver[i])))
          return true;
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return false;
    },
    sort$1: function(receiver, compare) {
      var t1, t2, t3;
      t1 = H.buildInterfaceType(P.$int);
      t2 = H.convertRtiToRuntimeType(receiver.$builtinTypeInfo && receiver.$builtinTypeInfo[0]);
      t2 = H.buildFunctionType(t1, [t2, t2])._assertCheck$1(compare);
      this.checkMutable$1(receiver, "sort");
      t3 = H.getDynamicRuntimeType();
      H.buildFunctionType(t1, [t3, t3])._assertCheck$1(t2);
      H.Sort__doSort(receiver, 0, receiver.length - 1, t2);
    },
    indexOf$2: function(receiver, element, start) {
      var i;
      if (start >= receiver.length)
        return -1;
      for (i = start; i < receiver.length; ++i)
        if (J.$eq(receiver[i], element))
          return i;
      return -1;
    },
    indexOf$1: function($receiver, element) {
      return this.indexOf$2($receiver, element, 0);
    },
    contains$1: function(receiver, other) {
      var i;
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], other))
          return true;
      return false;
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.length !== 0;
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    toSet$0: function(receiver) {
      return H.assertSubtype(H.assertSubtype(P.LinkedHashSet_LinkedHashSet$from(receiver, H.getTypeArgumentByIndex(receiver, 0)), "$isSet", [H.getTypeArgumentByIndex(receiver, 0)], "$asSet"), "$isSet", [H.getTypeArgumentByIndex(receiver, 0)], "$asSet");
    },
    get$iterator: function(receiver) {
      var t1, t2;
      t1 = H.getTypeArgumentByIndex(receiver, 0);
      H.assertSubtype(receiver, "$isJSArray", [t1], "$asJSArray");
      t2 = receiver.length;
      return H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(receiver, "$isJSArray", [t1], "$asJSArray"), t2, 0, H.assertSubtypeOfRuntimeType(null, t1)), [t1]), "$isIterator", [H.getTypeArgumentByIndex(receiver, 0)], "$asIterator");
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    set$length: function(receiver, newLength) {
      if (newLength < 0)
        throw H.wrapException(P.RangeError$value(newLength, null, null));
      this.checkGrowable$1(receiver, "set length");
      receiver.length = newLength;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      return H.assertSubtypeOfRuntimeType(receiver[index], H.getTypeArgumentByIndex(receiver, 0));
    },
    $indexSet: function(receiver, index, value) {
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(receiver, 0));
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("indexed set"));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      receiver[index] = value;
    },
    $isJSIndexable: 1,
    $isList: 1,
    $asList: null,
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: null
  },
  ArrayIterator: {
    "^": "Object;_iterable,_length,_index,_current",
    set$_current: function(_current) {
      this._current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    get$current: function() {
      return H.assertSubtypeOfRuntimeType(this._current, H.getTypeArgumentByIndex(this, 0));
    },
    moveNext$0: function() {
      var t1, $length, t2;
      t1 = this._iterable;
      $length = t1.length;
      if (this._length !== $length)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t2 = this._index;
      if (t2 >= $length) {
        this.set$_current(null);
        return false;
      }
      this.set$_current(t1[t2]);
      ++this._index;
      return true;
    },
    $isIterator: 1
  },
  JSNumber: {
    "^": "Interceptor;",
    compareTo$1: function(receiver, b) {
      var bIsNegative;
      H.numTypeCheck(b);
      if (typeof b !== "number")
        throw H.wrapException(P.ArgumentError$(b));
      if (receiver < b)
        return -1;
      else if (receiver > b)
        return 1;
      else if (receiver === b) {
        if (receiver === 0) {
          bIsNegative = this.get$isNegative(b);
          if (this.get$isNegative(receiver) === bIsNegative)
            return 0;
          if (this.get$isNegative(receiver))
            return -1;
          return 1;
        }
        return 0;
      } else if (isNaN(receiver)) {
        if (this.get$isNaN(b))
          return 0;
        return 1;
      } else
        return -1;
    },
    get$isNegative: function(receiver) {
      return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
    },
    get$isNaN: function(receiver) {
      return isNaN(receiver);
    },
    get$isFinite: function(receiver) {
      return isFinite(receiver);
    },
    remainder$1: function(receiver, b) {
      return receiver % b;
    },
    toInt$0: function(receiver) {
      var t1;
      if (receiver >= -2147483648 && receiver <= 2147483647)
        return receiver | 0;
      if (isFinite(receiver)) {
        t1 = receiver < 0 ? H.doubleTypeCheck(Math.ceil(receiver)) : H.doubleTypeCheck(Math.floor(receiver));
        return t1 + 0;
      }
      throw H.wrapException(P.UnsupportedError$("" + receiver));
    },
    round$0: function(receiver) {
      if (receiver > 0) {
        if (receiver !== 1 / 0)
          return Math.round(receiver);
      } else if (receiver > -1 / 0)
        return 0 - Math.round(0 - receiver);
      throw H.wrapException(P.UnsupportedError$("" + receiver));
    },
    toString$0: function(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    get$hashCode: function(receiver) {
      return receiver & 0x1FFFFFFF;
    },
    $add: function(receiver, other) {
      H.numTypeCheck(other);
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    $sub: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver - other;
    },
    $tdiv: function(receiver, other) {
      if ((receiver | 0) === receiver && (other | 0) === other && 0 !== other && -1 !== other)
        return receiver / other | 0;
      else {
        if (typeof other !== "number")
          H.throwExpression(P.ArgumentError$(other));
        return this.toInt$0(receiver / other);
      }
    },
    _tdivFast$1: function(receiver, other) {
      return (receiver | 0) === receiver ? receiver / other | 0 : this.toInt$0(receiver / other);
    },
    $shl: function(receiver, other) {
      if (other < 0)
        throw H.wrapException(P.ArgumentError$(other));
      return other > 31 ? 0 : receiver << other >>> 0;
    },
    _shlPositive$1: function(receiver, other) {
      return other > 31 ? 0 : receiver << other >>> 0;
    },
    _shrOtherPositive$1: function(receiver, other) {
      var t1;
      if (receiver > 0)
        t1 = other > 31 ? 0 : receiver >>> other;
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    _shrReceiverPositive$1: function(receiver, other) {
      if (other < 0)
        throw H.wrapException(P.ArgumentError$(other));
      return other > 31 ? 0 : receiver >>> other;
    },
    $or: function(receiver, other) {
      H.numTypeCheck(other);
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return (receiver | other) >>> 0;
    },
    $xor: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return (receiver ^ other) >>> 0;
    },
    $lt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver < other;
    },
    $gt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver > other;
    },
    $le: function(receiver, other) {
      H.numTypeCheck(other);
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver <= other;
    },
    $ge: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver >= other;
    },
    get$runtimeType: function(receiver) {
      return C.Type_xM7;
    },
    $isnum: 1,
    $isComparable: 1,
    $asComparable: function() {
      return [P.num];
    }
  },
  JSInt: {
    "^": "JSNumber;",
    get$runtimeType: function(receiver) {
      return C.Type_SnA;
    },
    $is$double: 1,
    $isnum: 1,
    $isComparable: 1,
    $asComparable: function() {
      return [P.num];
    },
    $is$int: 1
  },
  JSDouble: {
    "^": "JSNumber;",
    get$runtimeType: function(receiver) {
      return C.Type_qq1;
    },
    $is$double: 1,
    $isnum: 1,
    $isComparable: 1,
    $asComparable: function() {
      return [P.num];
    }
  },
  JSString: {
    "^": "Interceptor;",
    codeUnitAt$1: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      if (index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index, null, null));
      return receiver.charCodeAt(index);
    },
    allMatches$2: function(receiver, string, start) {
      H.checkString(string);
      H.checkInt(start);
      if (start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      return H.listSuperNativeTypeCheck(H.allMatchesInStringUnchecked(receiver, string, start), "$isIterable");
    },
    allMatches$1: function($receiver, string) {
      return this.allMatches$2($receiver, string, 0);
    },
    matchAsPrefix$2: function(receiver, string, start) {
      var t1, i;
      if (start < 0 || start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      t1 = receiver.length;
      if (start + t1 > string.length)
        return;
      for (i = 0; i < t1; ++i)
        if (this.codeUnitAt$1(string, start + i) !== this.codeUnitAt$1(receiver, i))
          return;
      return new H.StringMatch(start, string, receiver);
    },
    $add: function(receiver, other) {
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    endsWith$1: function(receiver, other) {
      var otherLength, t1;
      H.checkString(other);
      otherLength = other.length;
      t1 = receiver.length;
      if (otherLength > t1)
        return false;
      return other === this.substring$1(receiver, t1 - otherLength);
    },
    replaceAll$2: function(receiver, from, to) {
      H.checkString(to);
      return H.stringReplaceAllUnchecked(receiver, from, to);
    },
    startsWith$2: function(receiver, pattern, index) {
      var endIndex;
      H.stringSuperNativeTypeCheck(pattern, "$isPattern");
      H.checkInt(index);
      if (index < 0 || index > receiver.length)
        throw H.wrapException(P.RangeError$range(index, 0, receiver.length, null, null));
      if (typeof pattern === "string") {
        endIndex = index + pattern.length;
        if (endIndex > receiver.length)
          return false;
        return pattern === receiver.substring(index, endIndex);
      }
      return J.matchAsPrefix$2$s(pattern, receiver, index) != null;
    },
    startsWith$1: function($receiver, pattern) {
      return this.startsWith$2($receiver, pattern, 0);
    },
    substring$2: function(receiver, startIndex, endIndex) {
      H.intTypeCheck(endIndex);
      if (typeof startIndex !== "number" || Math.floor(startIndex) !== startIndex)
        H.throwExpression(P.ArgumentError$(startIndex));
      if (endIndex == null)
        endIndex = receiver.length;
      if (typeof endIndex !== "number" || Math.floor(endIndex) !== endIndex)
        H.throwExpression(P.ArgumentError$(endIndex));
      if (typeof startIndex !== "number")
        return startIndex.$lt();
      if (startIndex < 0)
        throw H.wrapException(P.RangeError$value(startIndex, null, null));
      if (C.JSInt_methods.$gt(startIndex, endIndex))
        throw H.wrapException(P.RangeError$value(startIndex, null, null));
      if (typeof endIndex !== "number")
        return endIndex.$gt();
      if (endIndex > receiver.length)
        throw H.wrapException(P.RangeError$value(endIndex, null, null));
      return receiver.substring(startIndex, endIndex);
    },
    substring$1: function($receiver, startIndex) {
      return this.substring$2($receiver, startIndex, null);
    },
    toLowerCase$0: function(receiver) {
      return receiver.toLowerCase();
    },
    trim$0: function(receiver) {
      var result, endIndex, startIndex, t1, endIndex0;
      result = receiver.trim();
      endIndex = result.length;
      if (endIndex === 0)
        return result;
      if (this.codeUnitAt$1(result, 0) === 133) {
        startIndex = J.JSString__skipLeadingWhitespace(result, 1);
        if (startIndex === endIndex)
          return "";
      } else
        startIndex = 0;
      t1 = endIndex - 1;
      endIndex0 = this.codeUnitAt$1(result, t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
      if (startIndex === 0 && endIndex0 === endIndex)
        return result;
      return result.substring(startIndex, endIndex0);
    },
    $mul: function(receiver, times) {
      var s, result;
      if (0 >= times)
        return "";
      if (times === 1 || receiver.length === 0)
        return receiver;
      if (times !== times >>> 0)
        throw H.wrapException(C.C_OutOfMemoryError);
      for (s = receiver, result = ""; true;) {
        if ((times & 1) === 1)
          result = s + result;
        times = times >>> 1;
        if (times === 0)
          break;
        s += s;
      }
      return result;
    },
    indexOf$2: function(receiver, pattern, start) {
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
      return receiver.indexOf(pattern, start);
    },
    contains$2: function(receiver, other, startIndex) {
      if (other == null)
        H.throwExpression(P.ArgumentError$(null));
      if (startIndex > receiver.length)
        throw H.wrapException(P.RangeError$range(startIndex, 0, receiver.length, null, null));
      return H.stringContainsUnchecked(receiver, other, startIndex);
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    compareTo$1: function(receiver, other) {
      var t1;
      H.stringTypeCheck(other);
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      if (receiver === other)
        t1 = 0;
      else
        t1 = receiver < other ? -1 : 1;
      return t1;
    },
    toString$0: function(receiver) {
      return receiver;
    },
    get$hashCode: function(receiver) {
      var t1, hash, i;
      for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
        hash = 536870911 & hash + receiver.charCodeAt(i);
        hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
        hash ^= hash >> 6;
      }
      hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
      hash ^= hash >> 11;
      return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
    },
    get$runtimeType: function(receiver) {
      return C.Type_Ejg;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index, null, null));
      return receiver[index];
    },
    $isJSIndexable: 1,
    $isString: 1,
    $isPattern: 1,
    $isComparable: 1,
    $asComparable: function() {
      return [P.String];
    },
    static: {JSString__isWhitespace: function(codeUnit) {
        if (codeUnit < 256)
          switch (codeUnit) {
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 32:
            case 133:
            case 160:
              return true;
            default:
              return false;
          }
        switch (codeUnit) {
          case 5760:
          case 6158:
          case 8192:
          case 8193:
          case 8194:
          case 8195:
          case 8196:
          case 8197:
          case 8198:
          case 8199:
          case 8200:
          case 8201:
          case 8202:
          case 8232:
          case 8233:
          case 8239:
          case 8287:
          case 12288:
          case 65279:
            return true;
          default:
            return false;
        }
      }, JSString__skipLeadingWhitespace: function(string, index) {
        var t1, codeUnit;
        for (t1 = string.length; index < t1;) {
          codeUnit = C.JSString_methods.codeUnitAt$1(string, index);
          if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
            break;
          ++index;
        }
        return index;
      }, JSString__skipTrailingWhitespace: function(string, index) {
        var index0, codeUnit;
        for (; index > 0; index = index0) {
          index0 = index - 1;
          codeUnit = C.JSString_methods.codeUnitAt$1(string, index0);
          if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
            break;
        }
        return index;
      }}
  }
}],
["_isolate_helper", "dart:_isolate_helper", , H, {
  "^": "",
  _callInIsolate: function(isolate, $function) {
    var result = isolate.eval$1($function);
    if (!init.globalState.currentContext._isExecutingEvent)
      init.globalState.topEventLoop.run$0();
    return result;
  },
  leaveJsAsync: function() {
    --init.globalState.topEventLoop._activeJsAsyncCount;
    H.assertHelper(init.globalState.topEventLoop._activeJsAsyncCount >= 0);
  },
  startRootIsolate: function(entry, args) {
    var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, rootContext;
    t1 = {};
    t1._captured_args_0 = args;
    args = args;
    t1._captured_args_0 = args;
    if (args == null) {
      args = [];
      t1._captured_args_0 = args;
      t2 = args;
    } else
      t2 = args;
    if (!J.getInterceptor(t2).$isList)
      throw H.wrapException(P.ArgumentError$("Arguments to main must be a List: " + H.S(t2)));
    t2 = new H._Manager(0, 0, 1, null, null, null, null, null, null, H.assertSubtype(null, "$isMap", [P.$int, H._IsolateContext], "$asMap"), null, H.assertSubtype(null, "$isMap", [P.$int, null], "$asMap"), entry);
    t2._nativeDetectEnvironment$0();
    t2.topEventLoop = new H._EventLoop(H.assertSubtype(H.assertSubtype(P.ListQueue$(null, H._IsolateEvent), "$isQueue", [H._IsolateEvent], "$asQueue"), "$isQueue", [H._IsolateEvent], "$asQueue"), 0);
    t2.set$isolates(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H._IsolateContext), "$isMap", [P.$int, H._IsolateContext], "$asMap"));
    t2.set$managers(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, null), "$isMap", [P.$int, null], "$asMap"));
    if (H.boolConversionCheck(t2.isWorker)) {
      t2.mainManager = new H._MainManagerStub();
      t2._nativeInitWorkerMessageHandler$0();
    }
    init.globalState = t2;
    if (H.boolConversionCheck(init.globalState.isWorker))
      return;
    t2 = init.globalState.nextIsolateId++;
    t3 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H.RawReceivePortImpl), "$isMap", [P.$int, H.RawReceivePortImpl], "$asMap");
    t4 = H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int), "$isSet", [P.$int], "$asSet");
    t5 = init.createNewIsolate();
    t6 = new H.RawReceivePortImpl(0, null, false);
    t7 = H.random64();
    t8 = H.random64();
    t9 = P.LinkedHashSet_LinkedHashSet(null, null, null, null);
    t10 = P.LinkedHashSet_LinkedHashSet(null, null, null, null);
    H.assertSubtype(t3, "$isMap", [P.$int, H.RawReceivePortImpl], "$asMap");
    H.assertSubtype(t4, "$isSet", [P.$int], "$asSet");
    rootContext = new H._IsolateContext(t2, t3, t4, t5, t6, new H.CapabilityImpl(t7), new H.CapabilityImpl(t8), false, false, H.assertSubtype([], "$isList", [H._IsolateEvent], "$asList"), H.assertSubtype(t9, "$isSet", [P.Capability], "$asSet"), null, null, false, true, H.assertSubtype(t10, "$isSet", [P.SendPort], "$asSet"));
    t4.add$1(0, 0);
    rootContext._addRegistration$2(0, t6);
    init.globalState.rootContext = rootContext;
    init.globalState.currentContext = rootContext;
    t2 = H.getDynamicRuntimeType();
    t3 = H.buildFunctionType(t2, [t2])._isTest$1(entry);
    if (t3)
      rootContext.eval$1(new H.startRootIsolate_closure(t1, entry));
    else {
      t2 = H.buildFunctionType(t2, [t2, t2])._isTest$1(entry);
      if (t2)
        rootContext.eval$1(new H.startRootIsolate_closure0(t1, entry));
      else
        rootContext.eval$1(entry);
    }
    init.globalState.topEventLoop.run$0();
  },
  IsolateNatives_computeThisScript: function() {
    var currentScript = init.currentScript;
    if (currentScript != null)
      return String(currentScript.src);
    if (typeof version == "function" && typeof os == "object" && "setenv" in os)
      return H.IsolateNatives_computeThisScriptFromTrace();
    if (typeof version == "function" && typeof os == "object" && "getenv" in os)
      return thisFilename();
    if (H.boolConversionCheck(init.globalState.isWorker))
      return H.IsolateNatives_computeThisScriptFromTrace();
    return;
  },
  IsolateNatives_computeThisScriptFromTrace: function() {
    var stack, matches;
    stack = new Error().stack;
    if (stack == null) {
      stack = function() {
        try {
          throw new Error();
        } catch (e) {
          return e.stack;
        }
      }();
      if (stack == null)
        throw H.wrapException(P.UnsupportedError$("No stack trace"));
    }
    matches = stack.match(new RegExp("^ *at [^(]*\\((.*):[0-9]*:[0-9]*\\)$", "m"));
    if (matches != null)
      return matches[1];
    matches = stack.match(new RegExp("^[^@]*@(.*):[0-9]*$", "m"));
    if (matches != null)
      return matches[1];
    throw H.wrapException(P.UnsupportedError$("Cannot extract URI from \"" + H.S(stack) + "\""));
  },
  IsolateNatives__processWorkerMessage: function(sender, e) {
    var msg, t1, functionName, entryPoint, args, message, isSpawnUri, startPaused, replyTo, t2, t3, t4, t5, t6, t7, t8, t9, context;
    msg = new H._Deserializer(true, []).deserialize$1(e.data);
    t1 = J.getInterceptor$asx(msg);
    switch (t1.$index(msg, "command")) {
      case "start":
        init.globalState.currentManagerId = H.intTypeCheck(t1.$index(msg, "id"));
        functionName = H.stringTypeCheck(t1.$index(msg, "functionName"));
        entryPoint = H.interceptedTypeCheck(functionName == null ? init.globalState.entry : H.IsolateNatives__getJSFunctionFromName(functionName), "$isFunction");
        args = t1.$index(msg, "args");
        message = new H._Deserializer(true, []).deserialize$1(t1.$index(msg, "msg"));
        isSpawnUri = t1.$index(msg, "isSpawnUri");
        startPaused = t1.$index(msg, "startPaused");
        replyTo = new H._Deserializer(true, []).deserialize$1(t1.$index(msg, "replyTo"));
        t1 = init.globalState.nextIsolateId++;
        t2 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H.RawReceivePortImpl), "$isMap", [P.$int, H.RawReceivePortImpl], "$asMap");
        t3 = H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int), "$isSet", [P.$int], "$asSet");
        t4 = init.createNewIsolate();
        t5 = new H.RawReceivePortImpl(0, null, false);
        t6 = H.random64();
        t7 = H.random64();
        t8 = P.LinkedHashSet_LinkedHashSet(null, null, null, null);
        t9 = P.LinkedHashSet_LinkedHashSet(null, null, null, null);
        H.assertSubtype(t2, "$isMap", [P.$int, H.RawReceivePortImpl], "$asMap");
        H.assertSubtype(t3, "$isSet", [P.$int], "$asSet");
        context = new H._IsolateContext(t1, t2, t3, t4, t5, new H.CapabilityImpl(t6), new H.CapabilityImpl(t7), false, false, H.assertSubtype([], "$isList", [H._IsolateEvent], "$asList"), H.assertSubtype(t8, "$isSet", [P.Capability], "$asSet"), null, null, false, true, H.assertSubtype(t9, "$isSet", [P.SendPort], "$asSet"));
        t3.add$1(0, 0);
        context._addRegistration$2(0, t5);
        t5 = init.globalState.topEventLoop.events;
        t3 = new H._IsolateEvent(context, new H.IsolateNatives__processWorkerMessage_closure(entryPoint, args, message, isSpawnUri, startPaused, replyTo), "worker-start");
        H.assertSubtypeOfRuntimeType(t3, H.getTypeArgumentByIndex(t5, 0));
        t5._add$1(t3);
        init.globalState.currentContext = context;
        init.globalState.topEventLoop.run$0();
        break;
      case "spawn-worker":
        if ($.IsolateNatives_enableSpawnWorker != null)
          H.IsolateNatives_handleSpawnWorkerRequest(msg);
        break;
      case "message":
        if (H.interceptedTypeCheck(t1.$index(msg, "port"), "$isSendPort") != null)
          J.send$1$x(t1.$index(msg, "port"), t1.$index(msg, "msg"));
        init.globalState.topEventLoop.run$0();
        break;
      case "close":
        init.globalState.managers.remove$1(0, $.get$IsolateNatives_workerIds().$index(0, sender));
        sender.terminate();
        init.globalState.topEventLoop.run$0();
        break;
      case "log":
        H.IsolateNatives__log(t1.$index(msg, "msg"));
        break;
      case "print":
        if (H.boolConversionCheck(init.globalState.isWorker)) {
          t1 = init.globalState.mainManager;
          t2 = P.LinkedHashMap_LinkedHashMap$_literal(["command", "print", "msg", msg], null, null);
          t2 = new H._Serializer(true, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$identity(null, P.$int), "$isMap", [null, P.$int], "$asMap"), "$isMap", [null, P.$int], "$asMap")).serialize$1(t2);
          t1.toString;
          self.postMessage(t2);
        } else
          P.print(t1.$index(msg, "msg"));
        break;
      case "error":
        throw H.wrapException(t1.$index(msg, "msg"));
    }
  },
  IsolateNatives_handleSpawnWorkerRequest: function(msg) {
    var t1, replyPort;
    t1 = J.getInterceptor$asx(msg);
    replyPort = t1.$index(msg, "replyPort");
    H.IsolateNatives_spawn(t1.$index(msg, "functionName"), t1.$index(msg, "uri"), t1.$index(msg, "args"), t1.$index(msg, "msg"), false, t1.$index(msg, "isSpawnUri"), t1.$index(msg, "startPaused")).then$2$onError(new H.IsolateNatives_handleSpawnWorkerRequest_closure(replyPort), new H.IsolateNatives_handleSpawnWorkerRequest_closure0(replyPort));
  },
  IsolateNatives__log: function(msg) {
    var trace, t1, t2, exception;
    if (H.boolConversionCheck(init.globalState.isWorker)) {
      t1 = init.globalState.mainManager;
      t2 = P.LinkedHashMap_LinkedHashMap$_literal(["command", "log", "msg", msg], null, null);
      t2 = new H._Serializer(true, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$identity(null, P.$int), "$isMap", [null, P.$int], "$asMap"), "$isMap", [null, P.$int], "$asMap")).serialize$1(t2);
      t1.toString;
      self.postMessage(t2);
    } else
      try {
        self.console.log(msg);
      } catch (exception) {
        H.unwrapException(exception);
        trace = H.getTraceFromException(exception);
        throw H.wrapException(P.Exception_Exception(trace));
      }
  },
  IsolateNatives__getJSFunctionFromName: function(functionName) {
    return init.globalFunctions[functionName]();
  },
  IsolateNatives_spawn: function(functionName, uri, args, message, isLight, isSpawnUri, startPaused) {
    var t1, t2, t3, port, completer, signalReply, worker;
    H.stringTypeCheck(functionName);
    H.stringTypeCheck(uri);
    H.assertSubtype(args, "$isList", [P.String], "$asList");
    H.boolTypeCheck(isSpawnUri);
    H.boolTypeCheck(startPaused);
    if (uri != null && C.JSString_methods.endsWith$1(uri, ".dart")) {
      if (typeof uri !== "string")
        return uri.$add();
      uri += ".js";
    }
    t1 = $.RawReceivePortImpl__nextFreeId;
    $.RawReceivePortImpl__nextFreeId = t1 + 1;
    t2 = new H.RawReceivePortImpl(t1, null, false);
    t3 = init.globalState.currentContext;
    t3._addRegistration$2(t1, t2);
    t3._updateGlobalState$0();
    port = new H.ReceivePortImpl(t2, null);
    port.ReceivePortImpl$fromRawReceivePort$1(t2);
    completer = H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new P._AsyncCompleter(H.assertSubtype(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]), "$is_Future", [null], "$as_Future")), [null]), "$isCompleter", [null], "$asCompleter"), "$isCompleter", [P.List], "$asCompleter");
    port.get$first(port).then$1(new H.IsolateNatives_spawn_closure(completer));
    signalReply = new H._NativeJsSendPort(t2, init.globalState.currentContext.id);
    if (init.globalState.supportsWorkers && !isLight) {
      t1 = new H.IsolateNatives_spawn_closure0(completer);
      H.assertSubtype(args, "$isList", [P.String], "$asList");
      t2 = H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P.String)]);
      t2._assertCheck$1(t1);
      if (args != null)
        args = H.assertSubtype(P.List_List$from(args, true, P.String), "$isList", [P.String], "$asList");
      if (H.boolConversionCheck(init.globalState.isWorker)) {
        t1 = init.globalState.mainManager;
        t2 = P.LinkedHashMap_LinkedHashMap$_literal(["command", "spawn-worker", "functionName", functionName, "args", args, "msg", message, "uri", uri, "isSpawnUri", isSpawnUri, "startPaused", startPaused, "replyPort", signalReply], null, null);
        t2 = new H._Serializer(true, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$identity(null, P.$int), "$isMap", [null, P.$int], "$asMap"), "$isMap", [null, P.$int], "$asMap")).serialize$1(t2);
        t1.toString;
        self.postMessage(t2);
      } else {
        H.assertSubtype(args, "$isList", [P.String], "$asList");
        t2._assertCheck$1(t1);
        if (uri == null)
          uri = $.get$IsolateNatives_thisScript();
        worker = new Worker(uri);
        worker.onerror = function(f, u, c) {
          return function(e) {
            return f(e, u, c);
          };
        }(H.IsolateNatives_workerOnError, uri, t1);
        worker.onmessage = function(f, a) {
          return function(e) {
            e.onerror = null;
            return f(a, e);
          };
        }(H.IsolateNatives__processWorkerMessage, worker);
        t1 = init.globalState.nextManagerId++;
        $.get$IsolateNatives_workerIds().$indexSet(0, worker, t1);
        init.globalState.managers.$indexSet(0, t1, worker);
        t1 = P.LinkedHashMap_LinkedHashMap$_literal(["command", "start", "id", t1, "replyTo", new H._Serializer(true, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$identity(null, P.$int), "$isMap", [null, P.$int], "$asMap"), "$isMap", [null, P.$int], "$asMap")).serialize$1(signalReply), "args", args, "msg", new H._Serializer(true, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$identity(null, P.$int), "$isMap", [null, P.$int], "$asMap"), "$isMap", [null, P.$int], "$asMap")).serialize$1(message), "isSpawnUri", isSpawnUri, "startPaused", startPaused, "functionName", functionName], null, null);
        worker.postMessage(new H._Serializer(true, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$identity(null, P.$int), "$isMap", [null, P.$int], "$asMap"), "$isMap", [null, P.$int], "$asMap")).serialize$1(t1));
      }
    } else
      H.IsolateNatives__startNonWorker(functionName, uri, args, message, isSpawnUri, startPaused, signalReply);
    return H.assertSubtype(completer.future, "$isFuture", [P.List], "$asFuture");
  },
  IsolateNatives__startNonWorker: function(functionName, uri, args, message, isSpawnUri, startPaused, replyPort) {
    var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11;
    t1 = {};
    t1._captured_args_0 = args;
    t1._captured_message_1 = message;
    H.assertSubtype(args, "$isList", [P.String], "$asList");
    if (uri != null)
      throw H.wrapException(P.UnsupportedError$("Currently spawnUri is not supported without web workers."));
    t1._captured_message_1 = H._clone(message);
    t2 = t1._captured_args_0;
    if (t2 != null)
      t1._captured_args_0 = H.assertSubtype(P.List_List$from(t2, true, P.String), "$isList", [P.String], "$asList");
    t2 = init.globalState.topEventLoop;
    t3 = init.globalState.nextIsolateId++;
    t4 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H.RawReceivePortImpl), "$isMap", [P.$int, H.RawReceivePortImpl], "$asMap");
    t5 = H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int), "$isSet", [P.$int], "$asSet");
    t6 = init.createNewIsolate();
    t7 = new H.RawReceivePortImpl(0, null, false);
    t8 = H.random64();
    t9 = H.random64();
    t10 = P.LinkedHashSet_LinkedHashSet(null, null, null, null);
    t11 = P.LinkedHashSet_LinkedHashSet(null, null, null, null);
    H.assertSubtype(t4, "$isMap", [P.$int, H.RawReceivePortImpl], "$asMap");
    H.assertSubtype(t5, "$isSet", [P.$int], "$asSet");
    t11 = new H._IsolateContext(t3, t4, t5, t6, t7, new H.CapabilityImpl(t8), new H.CapabilityImpl(t9), false, false, H.assertSubtype([], "$isList", [H._IsolateEvent], "$asList"), H.assertSubtype(t10, "$isSet", [P.Capability], "$asSet"), null, null, false, true, H.assertSubtype(t11, "$isSet", [P.SendPort], "$asSet"));
    t5.add$1(0, 0);
    t11._addRegistration$2(0, t7);
    t2 = t2.events;
    t1 = new H._IsolateEvent(t11, new H.IsolateNatives__startNonWorker_closure(t1, functionName, isSpawnUri, startPaused, replyPort), "nonworker start");
    H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(t2, 0));
    t2._add$1(t1);
  },
  IsolateNatives__startIsolate: function(topLevel, args, message, isSpawnUri, startPaused, replyTo) {
    var context, t1, t2, t3;
    H.interceptedTypeCheck(topLevel, "$isFunction");
    H.assertSubtype(args, "$isList", [P.String], "$asList");
    H.boolTypeCheck(isSpawnUri);
    H.boolTypeCheck(startPaused);
    H.interceptedTypeCheck(replyTo, "$isSendPort");
    context = init.globalState.currentContext;
    t1 = context.id;
    $.Primitives_mirrorFunctionCacheName = $.Primitives_mirrorFunctionCacheName + ("_" + t1);
    $.Primitives_mirrorInvokeCacheName = $.Primitives_mirrorInvokeCacheName + ("_" + t1);
    t1 = context.controlPort;
    t2 = init.globalState.currentContext.id;
    t3 = context.pauseCapability;
    replyTo.send$1(0, ["spawned", new H._NativeJsSendPort(t1, t2), t3, context.terminateCapability]);
    t2 = new H.IsolateNatives__startIsolate_runStartFunction(topLevel, args, message, isSpawnUri, context);
    if (startPaused) {
      context.addPause$2(t3, t3);
      t1 = init.globalState.topEventLoop.events;
      t2 = new H._IsolateEvent(context, t2, "start isolate");
      H.assertSubtypeOfRuntimeType(t2, H.getTypeArgumentByIndex(t1, 0));
      t1._add$1(t2);
    } else
      t2.call$0();
  },
  IsolateNatives_workerOnError: function($event, uri, onError) {
    var t1, message;
    H.stringTypeCheck(uri);
    t1 = H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P.String)])._assertCheck$1(onError);
    $event.preventDefault();
    message = $event.message;
    t1.call$1(message == null ? "Error spawning worker for " + H.S(uri) : "Error spawning worker for " + H.S(uri) + " (" + message + ")");
    return true;
  },
  _clone: function(message) {
    return new H._Deserializer(true, []).deserialize$1(new H._Serializer(false, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$identity(null, P.$int), "$isMap", [null, P.$int], "$asMap"), "$isMap", [null, P.$int], "$asMap")).serialize$1(message));
  },
  startRootIsolate_closure: {
    "^": "Closure:0;__isolate_helper$_box_0,_captured_entry_1",
    call$0: function() {
      this._captured_entry_1.call$1(this.__isolate_helper$_box_0._captured_args_0);
    }
  },
  startRootIsolate_closure0: {
    "^": "Closure:0;__isolate_helper$_box_0,_captured_entry_2",
    call$0: function() {
      this._captured_entry_2.call$2(this.__isolate_helper$_box_0._captured_args_0, null);
    }
  },
  _Manager: {
    "^": "Object;nextIsolateId,currentManagerId,nextManagerId,currentContext,rootContext,topEventLoop,fromCommandLine,isWorker,supportsWorkers,isolates,mainManager,managers,entry",
    set$isolates: function(isolates) {
      this.isolates = H.assertSubtype(isolates, "$isMap", [P.$int, H._IsolateContext], "$asMap");
    },
    set$managers: function(managers) {
      this.managers = H.assertSubtype(managers, "$isMap", [P.$int, null], "$asMap");
    },
    _nativeDetectEnvironment$0: function() {
      var t1, t2, t3;
      t1 = self.window == null;
      t2 = self.Worker;
      t3 = t1 && !!self.postMessage;
      this.isWorker = t3;
      if (!t3)
        t2 = t2 != null && $.get$IsolateNatives_thisScript() != null;
      else
        t2 = true;
      this.supportsWorkers = t2;
      this.fromCommandLine = t1 && !t3;
    },
    _nativeInitWorkerMessageHandler$0: function() {
      self.onmessage = function(f, a) {
        return function(e) {
          f(a, e);
        };
      }(H.IsolateNatives__processWorkerMessage, this.mainManager);
      self.dartPrint = self.dartPrint || function(serialize) {
        return function(object) {
          if (self.console && self.console.log)
            self.console.log(object);
          else
            self.postMessage(serialize(object));
        };
      }(H._Manager__serializePrintMessage);
    },
    static: {_Manager__serializePrintMessage: function(object) {
        var t1 = P.LinkedHashMap_LinkedHashMap$_literal(["command", "print", "msg", object], null, null);
        return new H._Serializer(true, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$identity(null, P.$int), "$isMap", [null, P.$int], "$asMap"), "$isMap", [null, P.$int], "$asMap")).serialize$1(t1);
      }}
  },
  _IsolateContext: {
    "^": "Object;id>,ports,weakPorts,isolateStatics<,controlPort<,pauseCapability,terminateCapability,initialized,isPaused,delayedEvents,pauseTokens,doneHandlers,_scheduledControlEvents,_isExecutingEvent,errorsAreFatal,errorPorts",
    addPause$2: function(authentification, resume) {
      H.interceptedTypeCheck(authentification, "$isCapability");
      H.interceptedTypeCheck(resume, "$isCapability");
      if (!this.pauseCapability.$eq(0, authentification))
        return;
      if (this.pauseTokens.add$1(0, resume) && !this.isPaused)
        this.isPaused = true;
      this._updateGlobalState$0();
    },
    removePause$1: function(resume) {
      var t1, t2, $event, t3, t4, t5;
      H.interceptedTypeCheck(resume, "$isCapability");
      if (!this.isPaused)
        return;
      t1 = this.pauseTokens;
      t1.remove$1(0, resume);
      if (t1._collection$_length === 0) {
        for (t1 = this.delayedEvents; t2 = t1.length, t2 !== 0;) {
          if (0 >= t2)
            return H.ioore(t1, 0);
          $event = t1.pop();
          t2 = init.globalState.topEventLoop.events;
          H.assertSubtypeOfRuntimeType($event, H.getTypeArgumentByIndex(t2, 0));
          t3 = t2._head;
          t4 = t2._table;
          t5 = t4.length;
          t3 = (t3 - 1 & t5 - 1) >>> 0;
          t2._head = t3;
          if (t3 < 0 || t3 >= t5)
            return H.ioore(t4, t3);
          t4[t3] = $event;
          if (t3 === t2._tail)
            t2._grow$0();
          ++t2._modificationCount;
        }
        this.isPaused = false;
      }
      this._updateGlobalState$0();
    },
    addDoneListener$1: function(responsePort) {
      var t1;
      H.interceptedTypeCheck(responsePort, "$isSendPort");
      t1 = this.doneHandlers;
      if (t1 == null) {
        t1 = [];
        this.doneHandlers = t1;
      }
      if ((t1 && C.JSArray_methods).contains$1(t1, responsePort))
        return;
      t1 = this.doneHandlers;
      (t1 && C.JSArray_methods).add$1(t1, responsePort);
    },
    removeDoneListener$1: function(responsePort) {
      var t1;
      H.interceptedTypeCheck(responsePort, "$isSendPort");
      t1 = this.doneHandlers;
      if (t1 == null)
        return;
      (t1 && C.JSArray_methods).remove$1(t1, responsePort);
    },
    setErrorsFatal$2: function(authentification, errorsAreFatal) {
      H.interceptedTypeCheck(authentification, "$isCapability");
      H.boolTypeCheck(errorsAreFatal);
      if (!this.terminateCapability.$eq(0, authentification))
        return;
      this.errorsAreFatal = errorsAreFatal;
    },
    handlePing$2: function(responsePort, pingType) {
      var t1, t2;
      H.interceptedTypeCheck(responsePort, "$isSendPort");
      H.intTypeCheck(pingType);
      if (pingType !== 0)
        t1 = pingType === 1 && !this._isExecutingEvent;
      else
        t1 = true;
      if (t1) {
        responsePort.send$1(0, null);
        return;
      }
      t1 = new H._IsolateContext_handlePing_respond(responsePort);
      if (pingType === 2) {
        t2 = init.globalState.topEventLoop.events;
        t1 = new H._IsolateEvent(this, t1, "ping");
        H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(t2, 0));
        t2._add$1(t1);
        return;
      }
      H.assertHelper(pingType === 1);
      t2 = this._scheduledControlEvents;
      if (t2 == null) {
        t2 = P.ListQueue$(null, null);
        this._scheduledControlEvents = t2;
      }
      t2.toString;
      H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(t2, 0));
      t2._add$1(t1);
    },
    handleKill$2: function(authentification, priority) {
      var t1, t2;
      H.interceptedTypeCheck(authentification, "$isCapability");
      H.intTypeCheck(priority);
      if (!this.terminateCapability.$eq(0, authentification))
        return;
      if (priority !== 0)
        t1 = priority === 1 && !this._isExecutingEvent;
      else
        t1 = true;
      if (t1) {
        this.kill$0();
        return;
      }
      if (priority === 2) {
        t1 = init.globalState.topEventLoop;
        t2 = this.get$kill();
        t1 = t1.events;
        t2 = new H._IsolateEvent(this, t2, "kill");
        H.assertSubtypeOfRuntimeType(t2, H.getTypeArgumentByIndex(t1, 0));
        t1._add$1(t2);
        return;
      }
      H.assertHelper(priority === 1);
      t1 = this._scheduledControlEvents;
      if (t1 == null) {
        t1 = P.ListQueue$(null, null);
        this._scheduledControlEvents = t1;
      }
      t2 = this.get$kill();
      t1.toString;
      H.assertSubtypeOfRuntimeType(t2, H.getTypeArgumentByIndex(t1, 0));
      t1._add$1(t2);
    },
    handleUncaughtError$2: function(error, stackTrace) {
      var t1, message, t2;
      t1 = this.errorPorts;
      if (t1._collection$_length === 0) {
        if (H.boolConversionCheck(this.errorsAreFatal) && this === init.globalState.rootContext)
          return;
        if (self.console && self.console.error)
          self.console.error(error, stackTrace);
        else {
          P.print(error);
          if (stackTrace != null)
            P.print(stackTrace);
        }
        return;
      }
      message = Array(2);
      message.fixed$length = Array;
      message[0] = J.toString$0(error);
      message[1] = stackTrace == null ? null : stackTrace.toString$0(0);
      for (t2 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._collection$_modifications, null, H.assertSubtypeOfRuntimeType(null, null)), [null]), t2._cell = t2._set._collection$_first, H.assertSubtype(t2, "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"); t2.moveNext$0();)
        H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t2._collection$_current, H.getTypeArgumentByIndex(t2, 0)), "$isSendPort").send$1(0, message);
    },
    eval$1: function(code) {
      var old, result, oldIsExecutingEvent, e, s, exception, t1;
      old = init.globalState.currentContext;
      init.globalState.currentContext = this;
      $ = this.isolateStatics;
      result = null;
      oldIsExecutingEvent = this._isExecutingEvent;
      this._isExecutingEvent = true;
      try {
        result = code.call$0();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        this.handleUncaughtError$2(e, s);
        if (H.boolConversionCheck(this.errorsAreFatal)) {
          this.kill$0();
          if (this === init.globalState.rootContext)
            throw exception;
        }
      } finally {
        this._isExecutingEvent = H.boolTypeCheck(oldIsExecutingEvent);
        init.globalState.currentContext = H.interceptedTypeCheck(old, "$is_IsolateContext");
        if (old != null)
          $ = old.get$isolateStatics();
        if (this._scheduledControlEvents != null)
          for (; t1 = this._scheduledControlEvents, !t1.get$isEmpty(t1);)
            this._scheduledControlEvents.removeFirst$0().call$0();
      }
      return result;
    },
    handleControlMessage$1: function(message) {
      var t1 = J.getInterceptor$asx(message);
      switch (t1.$index(message, 0)) {
        case "pause":
          this.addPause$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        case "resume":
          this.removePause$1(t1.$index(message, 1));
          break;
        case "add-ondone":
          this.addDoneListener$1(t1.$index(message, 1));
          break;
        case "remove-ondone":
          this.removeDoneListener$1(t1.$index(message, 1));
          break;
        case "set-errors-fatal":
          this.setErrorsFatal$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        case "ping":
          this.handlePing$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        case "kill":
          this.handleKill$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        case "getErrors":
          this.errorPorts.add$1(0, H.interceptedTypeCheck(t1.$index(message, 1), "$isSendPort"));
          break;
        case "stopErrors":
          this.errorPorts.remove$1(0, H.interceptedTypeCheck(t1.$index(message, 1), "$isSendPort"));
          break;
      }
    },
    lookup$1: function(portId) {
      return H.interceptedTypeCheck(this.ports.$index(0, portId), "$isRawReceivePortImpl");
    },
    _addRegistration$2: function(portId, port) {
      var t1 = this.ports;
      if (t1.containsKey$1(0, portId))
        throw H.wrapException(P.Exception_Exception("Registry: ports must be registered only once."));
      t1.$indexSet(0, portId, port);
    },
    _updateGlobalState$0: function() {
      if (this.ports.__js_helper$_length - this.weakPorts._collection$_length > 0 || this.isPaused || !this.initialized)
        init.globalState.isolates.$indexSet(0, this.id, this);
      else
        this.kill$0();
    },
    kill$0: [function() {
      var t1, t2, t3, t4, t5, t6, t7;
      t1 = this._scheduledControlEvents;
      if (t1 != null)
        t1.clear$0(0);
      for (t1 = this.ports, t2 = t1.get$values(t1), t3 = J.get$iterator$ax(t2.__internal$_iterable), t4 = t2._f, t5 = H.getTypeArgumentByIndex(t2, 0), t6 = H.getTypeArgumentByIndex(t2, 1), H.assertSubtype(t3, "$isIterator", [t5], "$asIterator"), t7 = H.buildFunctionType(H.convertRtiToRuntimeType(t6), [H.convertRtiToRuntimeType(t5)]), t7._assertCheck$1(t4), t2 = H.assertSubtype(H.setRuntimeTypeInfo(new H.MappedIterator(H.assertSubtypeOfRuntimeType(null, t6), H.assertSubtype(t3, "$isIterator", [t5], "$asIterator"), t7._assertCheck$1(t4)), [t5, t6]), "$isIterator", [H.getTypeArgumentByIndex(t2, 1)], "$asIterator"); t2.moveNext$0();)
        H.assertSubtypeOfRuntimeType(t2.__internal$_current, H.getTypeArgumentByIndex(t2, 1)).__isolate_helper$_close$0();
      t1.clear$0(0);
      this.weakPorts.clear$0(0);
      init.globalState.isolates.remove$1(0, this.id);
      this.errorPorts.clear$0(0);
      t1 = this.doneHandlers;
      if (t1 != null) {
        for (t1.toString, t2 = H.getTypeArgumentByIndex(t1, 0), H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3 = t1.length, t1 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"); t1.moveNext$0();)
          H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0)), "$isSendPort").send$1(0, null);
        this.doneHandlers = null;
      }
    }, "call$0", "get$kill", 0, 0, 1]
  },
  _IsolateContext_handlePing_respond: {
    "^": "Closure:1;_captured_responsePort_0",
    call$0: function() {
      this._captured_responsePort_0.send$1(0, null);
    }
  },
  _EventLoop: {
    "^": "Object;events,_activeJsAsyncCount",
    dequeue$0: function() {
      var t1 = this.events;
      if (t1._head === t1._tail)
        return;
      return H.interceptedTypeCheck(t1.removeFirst$0(), "$is_IsolateEvent");
    },
    runIteration$0: function() {
      var $event, t1, t2;
      $event = this.dequeue$0();
      if ($event == null) {
        if (init.globalState.rootContext != null && init.globalState.isolates.containsKey$1(0, init.globalState.rootContext.id) && H.boolConversionCheck(init.globalState.fromCommandLine) && init.globalState.rootContext.ports.__js_helper$_length === 0)
          H.throwExpression(P.Exception_Exception("Program exited with open ReceivePorts."));
        t1 = init.globalState;
        if (H.boolConversionCheck(t1.isWorker) && t1.isolates.__js_helper$_length === 0 && t1.topEventLoop._activeJsAsyncCount === 0) {
          t1 = t1.mainManager;
          t2 = P.LinkedHashMap_LinkedHashMap$_literal(["command", "close"], null, null);
          t2 = new H._Serializer(true, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$identity(null, P.$int), "$isMap", [null, P.$int], "$asMap"), "$isMap", [null, P.$int], "$asMap")).serialize$1(t2);
          t1.toString;
          self.postMessage(t2);
        }
        return false;
      }
      $event.process$0();
      return true;
    },
    _runHelper$0: function() {
      if (self.window != null)
        new H._EventLoop__runHelper_next(this).call$0();
      else
        for (; this.runIteration$0();)
          ;
    },
    run$0: function() {
      var e, trace, exception, t1, t2;
      if (!H.boolConversionCheck(init.globalState.isWorker))
        this._runHelper$0();
      else
        try {
          this._runHelper$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          trace = H.getTraceFromException(exception);
          t1 = init.globalState.mainManager;
          t2 = P.LinkedHashMap_LinkedHashMap$_literal(["command", "error", "msg", H.S(e) + "\n" + H.S(trace)], null, null);
          t2 = new H._Serializer(true, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$identity(null, P.$int), "$isMap", [null, P.$int], "$asMap"), "$isMap", [null, P.$int], "$asMap")).serialize$1(t2);
          t1.toString;
          self.postMessage(t2);
        }
    }
  },
  _EventLoop__runHelper_next: {
    "^": "Closure:1;_captured_this_0",
    call$0: function() {
      if (!this._captured_this_0.runIteration$0())
        return;
      H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(this);
      P.Timer_Timer(C.Duration_0, this);
    }
  },
  _IsolateEvent: {
    "^": "Object;isolate,fn,message",
    process$0: function() {
      var t1 = this.isolate;
      if (t1.isPaused) {
        C.JSArray_methods.add$1(t1.delayedEvents, this);
        return;
      }
      t1.eval$1(this.fn);
    }
  },
  _MainManagerStub: {
    "^": "Object;"
  },
  IsolateNatives__processWorkerMessage_closure: {
    "^": "Closure:0;_captured_entryPoint_0,_captured_args_1,_captured_message_2,_captured_isSpawnUri_3,_captured_startPaused_4,_captured_replyTo_5",
    call$0: function() {
      H.IsolateNatives__startIsolate(this._captured_entryPoint_0, this._captured_args_1, this._captured_message_2, this._captured_isSpawnUri_3, this._captured_startPaused_4, this._captured_replyTo_5);
    }
  },
  IsolateNatives_handleSpawnWorkerRequest_closure: {
    "^": "Closure:2;_captured_replyPort_0",
    call$1: function(msg) {
      J.send$1$x(this._captured_replyPort_0, msg);
    }
  },
  IsolateNatives_handleSpawnWorkerRequest_closure0: {
    "^": "Closure:3;_captured_replyPort_1",
    call$1: function(errorMessage) {
      J.send$1$x(this._captured_replyPort_1, ["spawn failed", H.stringTypeCheck(errorMessage)]);
    }
  },
  IsolateNatives_spawn_closure: {
    "^": "Closure:2;__isolate_helper$_captured_completer_0",
    call$1: function(msg) {
      var t1, t2;
      t1 = J.getInterceptor$asx(msg);
      t2 = this.__isolate_helper$_captured_completer_0;
      if (J.$eq(t1.$index(msg, 0), "spawned"))
        t2.complete$1(0, msg);
      else {
        H.assertHelper(J.$eq(t1.$index(msg, 0), "spawn failed"));
        t2.completeError$1(t1.$index(msg, 1));
      }
    }
  },
  IsolateNatives_spawn_closure0: {
    "^": "Closure:3;__isolate_helper$_captured_completer_1",
    call$1: function(message) {
      return this.__isolate_helper$_captured_completer_1.completeError$1(H.stringTypeCheck(message));
    }
  },
  IsolateNatives__startNonWorker_closure: {
    "^": "Closure:0;__isolate_helper$_box_0,_captured_functionName_1,_captured_isSpawnUri_2,_captured_startPaused_3,_captured_replyPort_4",
    call$0: function() {
      var t1 = this.__isolate_helper$_box_0;
      H.IsolateNatives__startIsolate(H.IsolateNatives__getJSFunctionFromName(this._captured_functionName_1), t1._captured_args_0, t1._captured_message_1, this._captured_isSpawnUri_2, this._captured_startPaused_3, this._captured_replyPort_4);
    }
  },
  IsolateNatives__startIsolate_runStartFunction: {
    "^": "Closure:1;_captured_topLevel_0,_captured_args_1,_captured_message_2,_captured_isSpawnUri_3,_captured_context_4",
    call$0: function() {
      var t1, t2, t3;
      this._captured_context_4.initialized = true;
      if (!H.boolConversionCheck(this._captured_isSpawnUri_3))
        this._captured_topLevel_0.call$1(this._captured_message_2);
      else {
        t1 = this._captured_topLevel_0;
        t2 = H.getDynamicRuntimeType();
        t3 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
        if (t3)
          t1.call$2(this._captured_args_1, this._captured_message_2);
        else {
          t2 = H.buildFunctionType(t2, [t2])._isTest$1(t1);
          if (t2)
            t1.call$1(this._captured_args_1);
          else
            t1.call$0();
        }
      }
    }
  },
  _BaseSendPort: {
    "^": "Object;",
    $isSendPort: 1,
    $isCapability: 1
  },
  _NativeJsSendPort: {
    "^": "_BaseSendPort;__isolate_helper$_receivePort,_isolateId",
    send$1: function(_, message) {
      var isolate, t1, msg, t2;
      isolate = init.globalState.isolates.$index(0, this._isolateId);
      if (isolate == null)
        return;
      t1 = this.__isolate_helper$_receivePort;
      if (t1._isClosed)
        return;
      msg = H._clone(message);
      if (J.$eq(isolate.get$controlPort(), t1)) {
        isolate.handleControlMessage$1(msg);
        return;
      }
      t1 = init.globalState.topEventLoop;
      t2 = "receive " + H.S(message);
      t1 = t1.events;
      t2 = new H._IsolateEvent(H.interceptedTypeCheck(isolate, "$is_IsolateContext"), new H._NativeJsSendPort_send_closure(this, msg), t2);
      H.assertSubtypeOfRuntimeType(t2, H.getTypeArgumentByIndex(t1, 0));
      t1._add$1(t2);
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (other instanceof H._NativeJsSendPort) {
        t1 = this.__isolate_helper$_receivePort;
        t2 = other.__isolate_helper$_receivePort;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return this.__isolate_helper$_receivePort._id;
    },
    $isSendPort: 1,
    $isCapability: 1
  },
  _NativeJsSendPort_send_closure: {
    "^": "Closure:0;_captured_this_0,_captured_msg_1",
    call$0: function() {
      var t1 = this._captured_this_0.__isolate_helper$_receivePort;
      if (!t1._isClosed)
        t1.__isolate_helper$_add$1(this._captured_msg_1);
    }
  },
  _WorkerSendPort: {
    "^": "_BaseSendPort;_workerId,_receivePortId,_isolateId",
    send$1: function(_, message) {
      var t1, workerMessage, manager;
      t1 = P.LinkedHashMap_LinkedHashMap$_literal(["command", "message", "port", this, "msg", message], null, null);
      workerMessage = new H._Serializer(true, H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$identity(null, P.$int), "$isMap", [null, P.$int], "$asMap"), "$isMap", [null, P.$int], "$asMap")).serialize$1(t1);
      if (H.boolConversionCheck(init.globalState.isWorker)) {
        init.globalState.mainManager.toString;
        self.postMessage(workerMessage);
      } else {
        manager = init.globalState.managers.$index(0, this._workerId);
        if (manager != null)
          manager.postMessage(workerMessage);
      }
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (other instanceof H._WorkerSendPort) {
        t1 = this._workerId;
        t2 = other._workerId;
        if (t1 == null ? t2 == null : t1 === t2) {
          t1 = this._isolateId;
          t2 = other._isolateId;
          if (t1 == null ? t2 == null : t1 === t2) {
            t1 = this._receivePortId;
            t2 = other._receivePortId;
            t2 = t1 == null ? t2 == null : t1 === t2;
            t1 = t2;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1, t2;
      t1 = this._workerId;
      if (typeof t1 !== "number")
        return t1.$shl();
      t2 = this._isolateId;
      if (typeof t2 !== "number")
        return t2.$shl();
      return C.JSInt_methods.$xor((t1 << 16 ^ t2 << 8) >>> 0, this._receivePortId);
    },
    $isSendPort: 1,
    $isCapability: 1
  },
  RawReceivePortImpl: {
    "^": "Object;_id,_handler,_isClosed",
    __isolate_helper$_close$0: function() {
      this._isClosed = true;
      this._handler = null;
    },
    close$0: function(_) {
      var t1, t2;
      if (this._isClosed)
        return;
      this._isClosed = true;
      this._handler = null;
      t1 = init.globalState.currentContext;
      t2 = this._id;
      t1.ports.remove$1(0, t2);
      t1.weakPorts.remove$1(0, t2);
      t1._updateGlobalState$0();
    },
    __isolate_helper$_add$1: function(dataEvent) {
      if (this._isClosed)
        return;
      this._handler$1(dataEvent);
    },
    _handler$1: function(arg0) {
      return this._handler.call$1(arg0);
    },
    $isRawReceivePort: 1
  },
  ReceivePortImpl: {
    "^": "Stream;_rawPort,_controller",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1, t2, t3;
      t1 = H.getVoidRuntimeType();
      t2 = H.buildFunctionType(t1, [H.getDynamicRuntimeType()])._assertCheck$1(onData);
      t1 = H.buildFunctionType(t1)._assertCheck$1(onDone);
      t3 = this._controller;
      t3.toString;
      H.assertSubtype(t3, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle");
      return H.assertSubtype(H.setRuntimeTypeInfo(new P._ControllerStream(H.assertSubtype(t3, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle")), [null]), "$isStream", [H.getRuntimeTypeArgument(t3, "_StreamController", 0)], "$asStream").listen$4$cancelOnError$onDone$onError(t2, cancelOnError, t1, onError);
    },
    close$0: [function(_) {
      this._rawPort.close$0(0);
      this._controller.close$0(0);
    }, "call$0", "get$close", 0, 0, 1],
    ReceivePortImpl$fromRawReceivePort$1: function(_rawPort) {
      var t1 = P.StreamController_StreamController(this.get$close(this), null, null, null, true, null);
      this._controller = t1;
      this._rawPort._handler = t1.get$add(t1);
    },
    T: function() {
      return H.convertRtiToRuntimeType($.functionThatReturnsNull.apply(null, this.$builtinTypeInfo));
    },
    $asStream: $.functionThatReturnsNull,
    $isReceivePort: 1
  },
  TimerImpl: {
    "^": "Object;_once,_inEventLoop,_handle",
    cancel$0: function() {
      if (self.setTimeout != null) {
        if (this._inEventLoop)
          throw H.wrapException(P.UnsupportedError$("Timer in event loop cannot be canceled."));
        if (this._handle == null)
          return;
        H.leaveJsAsync();
        var t1 = this._handle;
        if (this._once)
          self.clearTimeout(t1);
        else
          self.clearInterval(t1);
        this._handle = null;
      } else
        throw H.wrapException(P.UnsupportedError$("Canceling a timer."));
    },
    TimerImpl$periodic$2: function(milliseconds, callback) {
      var t1 = H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P.Timer)])._assertCheck$1(callback);
      if (self.setTimeout != null) {
        ++init.globalState.topEventLoop._activeJsAsyncCount;
        this._handle = self.setInterval(H.convertDartClosureToJS(new H.TimerImpl$periodic_closure(this, t1), 0), milliseconds);
      } else
        throw H.wrapException(P.UnsupportedError$("Periodic timer."));
    },
    TimerImpl$2: function(milliseconds, callback) {
      var t1, t2, t3;
      t1 = H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(callback);
      if (milliseconds === 0)
        t2 = self.setTimeout == null || H.boolConversionCheck(init.globalState.isWorker);
      else
        t2 = false;
      if (t2) {
        this._handle = 1;
        t2 = init.globalState.topEventLoop;
        t3 = init.globalState.currentContext;
        t2 = t2.events;
        t1 = new H._IsolateEvent(t3, new H.TimerImpl_internalCallback(this, t1), "timer");
        H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(t2, 0));
        t2._add$1(t1);
        this._inEventLoop = true;
      } else if (self.setTimeout != null) {
        ++init.globalState.topEventLoop._activeJsAsyncCount;
        this._handle = self.setTimeout(H.convertDartClosureToJS(new H.TimerImpl_internalCallback0(this, t1), 0), milliseconds);
      } else {
        H.assertHelper(milliseconds > 0);
        throw H.wrapException(P.UnsupportedError$("Timer greater than 0."));
      }
    },
    $isTimer: 1,
    static: {TimerImpl$: function(milliseconds, callback) {
        var t1 = new H.TimerImpl(true, false, null);
        t1.TimerImpl$2(milliseconds, H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(callback));
        return t1;
      }, TimerImpl$periodic: function(milliseconds, callback) {
        var t1 = new H.TimerImpl(false, false, null);
        t1.TimerImpl$periodic$2(milliseconds, H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P.Timer)])._assertCheck$1(callback));
        return t1;
      }}
  },
  TimerImpl_internalCallback: {
    "^": "Closure:1;_captured_this_0,_captured_callback_1",
    call$0: function() {
      this._captured_this_0._handle = null;
      this._captured_callback_1.call$0();
    }
  },
  TimerImpl_internalCallback0: {
    "^": "Closure:1;_captured_this_2,_captured_callback_3",
    call$0: function() {
      this._captured_this_2._handle = null;
      H.leaveJsAsync();
      this._captured_callback_3.call$0();
    }
  },
  TimerImpl$periodic_closure: {
    "^": "Closure:0;_captured_this_0,_captured_callback_1",
    call$0: function() {
      this._captured_callback_1.call$1(this._captured_this_0);
    }
  },
  CapabilityImpl: {
    "^": "Object;_id",
    get$hashCode: function(_) {
      var hash = this._id;
      hash = C.JSInt_methods._shrOtherPositive$1(hash, 0) ^ C.JSInt_methods._tdivFast$1(hash, 4294967296);
      hash = (~hash >>> 0) + (hash << 15 >>> 0) & 4294967295;
      hash = ((hash ^ hash >>> 12) >>> 0) * 5 & 4294967295;
      hash = ((hash ^ hash >>> 4) >>> 0) * 2057 & 4294967295;
      return (hash ^ hash >>> 16) >>> 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (other === this)
        return true;
      if (other instanceof H.CapabilityImpl)
        return this._id === other._id;
      return false;
    },
    $isCapability: 1
  },
  _Serializer: {
    "^": "Object;_serializeSendPorts,serializedObjectIds",
    serialize$1: [function(x) {
      var t1, serializationId, serializeTearOff, t2, t3, $name;
      if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
        return x;
      t1 = this.serializedObjectIds;
      serializationId = H.intTypeCheck(t1.$index(0, x));
      if (serializationId != null)
        return ["ref", serializationId];
      t1.$indexSet(0, x, t1.__js_helper$_length);
      t1 = J.getInterceptor(x);
      if (!!t1.$isNativeByteBuffer)
        return ["buffer", x];
      if (!!t1.$isNativeTypedData)
        return ["typed", x];
      if (!!t1.$isJSIndexable)
        return this.serializeJSIndexable$1(x);
      if (!!t1.$isInternalMap) {
        H.interceptedTypeCheck(x, "$isMap");
        serializeTearOff = this.get$serialize();
        t2 = new H.LinkedHashMapKeyIterable(x);
        H.assertHelper(true);
        t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(x, 0)];
        H.listSuperNativeTypeCheck(t2, "$isIterable");
        t3 = H.getDynamicRuntimeType();
        H.buildFunctionType(t3, [t2.E()])._assertCheck$1(serializeTearOff);
        t2 = H.MappedIterable_MappedIterable(t2, serializeTearOff, H.getRuntimeTypeArgument(t2, "IterableBase", 0), null);
        t2 = H.assertSubtype(P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "IterableBase", 0)), "$isList", [H.getRuntimeTypeArgument(t2, "IterableBase", 0)], "$asList");
        t1 = t1.get$values(x);
        H.buildFunctionType(t3, [t1.E()])._assertCheck$1(serializeTearOff);
        t1 = H.MappedIterable_MappedIterable(t1, serializeTearOff, H.getRuntimeTypeArgument(t1, "IterableBase", 0), null);
        return ["map", t2, H.assertSubtype(P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0)), "$isList", [H.getRuntimeTypeArgument(t1, "IterableBase", 0)], "$asList")];
      }
      if (!!t1.$isJSObject)
        return this.serializeJSObject$1(x);
      if (!!t1.$isInterceptor)
        this.unsupported$1(x);
      if (!!t1.$isRawReceivePort)
        this.unsupported$2(x, "RawReceivePorts can't be transmitted:");
      if (!!t1.$is_NativeJsSendPort)
        return this.serializeJsSendPort$1(x);
      if (!!t1.$is_WorkerSendPort)
        return this.serializeWorkerSendPort$1(x);
      if (!!t1.$isClosure) {
        $name = x.$name;
        if ($name == null)
          this.unsupported$2(x, "Closures can't be transmitted:");
        return ["function", $name];
      }
      return ["dart", init.classIdExtractor(x), this.serializeArrayInPlace$1(init.classFieldsExtractor(x))];
    }, "call$1", "get$serialize", 2, 0, 2],
    unsupported$2: function(x, message) {
      throw H.wrapException(P.UnsupportedError$(H.S(message == null ? "Can't transmit:" : message) + " " + H.S(x)));
    },
    unsupported$1: function(x) {
      return this.unsupported$2(x, null);
    },
    serializeJSIndexable$1: function(indexable) {
      var serialized;
      H.assertHelper(typeof indexable !== "string");
      serialized = this.serializeArray$1(indexable);
      if (!!indexable.fixed$length)
        return ["fixed", serialized];
      if (!indexable.fixed$length)
        return ["extendable", serialized];
      if (!indexable.immutable$list)
        return ["mutable", serialized];
      if (indexable.constructor === Array)
        return ["const", serialized];
      this.unsupported$2(indexable, "Can't serialize indexable: ");
    },
    serializeArray$1: function(x) {
      var serialized, i, t1;
      H.listTypeCheck(x);
      serialized = [];
      C.JSArray_methods.set$length(serialized, x.length);
      for (i = 0; i < x.length; ++i) {
        t1 = this.serialize$1(x[i]);
        if (i >= serialized.length)
          return H.ioore(serialized, i);
        serialized[i] = t1;
      }
      return serialized;
    },
    serializeArrayInPlace$1: function(x) {
      var i;
      for (i = 0; i < x.length; ++i)
        C.JSArray_methods.$indexSet(x, i, this.serialize$1(x[i]));
      return x;
    },
    serializeJSObject$1: function(x) {
      var keys, values, i, t1;
      if (!!x.constructor && x.constructor !== Object)
        this.unsupported$2(x, "Only plain JS Objects are supported:");
      keys = Object.keys(x);
      values = [];
      C.JSArray_methods.set$length(values, keys.length);
      for (i = 0; i < keys.length; ++i) {
        t1 = this.serialize$1(x[keys[i]]);
        if (i >= values.length)
          return H.ioore(values, i);
        values[i] = t1;
      }
      return ["js-object", keys, values];
    },
    serializeWorkerSendPort$1: function(x) {
      if (this._serializeSendPorts)
        return ["sendport", x._workerId, x._isolateId, x._receivePortId];
      return ["raw sendport", x];
    },
    serializeJsSendPort$1: function(x) {
      if (this._serializeSendPorts)
        return ["sendport", init.globalState.currentManagerId, x._isolateId, x.__isolate_helper$_receivePort._id];
      return ["raw sendport", x];
    }
  },
  _Deserializer: {
    "^": "Object;_adjustSendPorts,deserializedObjects",
    deserialize$1: [function(x) {
      var result, t1, classId, fields, emptyInstance;
      if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
        return x;
      if (typeof x !== "object" || x === null || x.constructor !== Array)
        throw H.wrapException(P.ArgumentError$("Bad serialized message: " + H.S(x)));
      switch (C.JSArray_methods.get$first(x)) {
        case "ref":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "ref"));
          if (1 >= x.length)
            return H.ioore(x, 1);
          return C.JSArray_methods.$index(this.deserializedObjects, H.intTypeCheck(x[1]));
        case "buffer":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "buffer"));
          if (1 >= x.length)
            return H.ioore(x, 1);
          result = H.interceptedTypeCheck(x[1], "$isNativeByteBuffer");
          C.JSArray_methods.add$1(this.deserializedObjects, result);
          return result;
        case "typed":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "typed"));
          if (1 >= x.length)
            return H.ioore(x, 1);
          result = H.interceptedTypeCheck(x[1], "$isNativeTypedData");
          C.JSArray_methods.add$1(this.deserializedObjects, result);
          return result;
        case "fixed":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "fixed"));
          if (1 >= x.length)
            return H.ioore(x, 1);
          result = H.listTypeCheck(x[1]);
          C.JSArray_methods.add$1(this.deserializedObjects, result);
          t1 = H.assertSubtype(this.deserializeArrayInPlace$1(result), "$isJSArray", [null], "$asJSArray");
          H.assertHelper(true);
          t1.$builtinTypeInfo = [null];
          t1.fixed$length = Array;
          return H.assertSubtype(t1, "$isJSArray", [null], "$asJSArray");
        case "extendable":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "extendable"));
          if (1 >= x.length)
            return H.ioore(x, 1);
          result = H.listTypeCheck(x[1]);
          C.JSArray_methods.add$1(this.deserializedObjects, result);
          t1 = H.assertSubtype(this.deserializeArrayInPlace$1(result), "$isJSArray", [null], "$asJSArray");
          H.assertHelper(true);
          t1.$builtinTypeInfo = [null];
          return H.assertSubtype(t1, "$isJSArray", [null], "$asJSArray");
        case "mutable":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "mutable"));
          if (1 >= x.length)
            return H.ioore(x, 1);
          result = H.listTypeCheck(x[1]);
          C.JSArray_methods.add$1(this.deserializedObjects, result);
          return this.deserializeArrayInPlace$1(result);
        case "const":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "const"));
          if (1 >= x.length)
            return H.ioore(x, 1);
          result = H.listTypeCheck(x[1]);
          C.JSArray_methods.add$1(this.deserializedObjects, result);
          t1 = H.assertSubtype(this.deserializeArrayInPlace$1(result), "$isJSArray", [null], "$asJSArray");
          H.assertHelper(true);
          t1.$builtinTypeInfo = [null];
          t1.fixed$length = Array;
          return H.assertSubtype(t1, "$isJSArray", [null], "$asJSArray");
        case "map":
          return this.deserializeMap$1(x);
        case "sendport":
          return this.deserializeSendPort$1(x);
        case "raw sendport":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "raw sendport"));
          if (1 >= x.length)
            return H.ioore(x, 1);
          result = H.interceptedTypeCheck(x[1], "$isSendPort");
          C.JSArray_methods.add$1(this.deserializedObjects, result);
          return result;
        case "js-object":
          return this.deserializeJSObject$1(x);
        case "function":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "function"));
          if (1 >= x.length)
            return H.ioore(x, 1);
          result = H.interceptedTypeCheck(init.globalFunctions[H.stringTypeCheck(x[1])](), "$isFunction");
          C.JSArray_methods.add$1(this.deserializedObjects, result);
          return result;
        case "dart":
          if (0 >= x.length)
            return H.ioore(x, 0);
          H.assertHelper(J.$eq(x[0], "dart"));
          t1 = x.length;
          if (1 >= t1)
            return H.ioore(x, 1);
          classId = H.stringTypeCheck(x[1]);
          if (2 >= t1)
            return H.ioore(x, 2);
          fields = H.listTypeCheck(x[2]);
          emptyInstance = init.instanceFromClassId(classId);
          C.JSArray_methods.add$1(this.deserializedObjects, emptyInstance);
          this.deserializeArrayInPlace$1(fields);
          return init.initializeEmptyInstance(classId, emptyInstance, fields);
        default:
          throw H.wrapException("couldn't deserialize: " + H.S(x));
      }
    }, "call$1", "get$deserialize", 2, 0, 2],
    deserializeArrayInPlace$1: function(x) {
      var i;
      H.listTypeCheck(x);
      for (i = 0; i < x.length; ++i)
        C.JSArray_methods.$indexSet(x, i, this.deserialize$1(x[i]));
      return x;
    },
    deserializeMap$1: function(x) {
      var t1, keys, values, result, i;
      if (0 >= x.length)
        return H.ioore(x, 0);
      H.assertHelper(J.$eq(x[0], "map"));
      t1 = x.length;
      if (1 >= t1)
        return H.ioore(x, 1);
      keys = H.listTypeCheck(x[1]);
      if (2 >= t1)
        return H.ioore(x, 2);
      values = H.listTypeCheck(x[2]);
      result = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      C.JSArray_methods.add$1(this.deserializedObjects, result);
      keys = J.map$1$ax(keys, this.get$deserialize()).toList$0(0);
      for (t1 = J.getInterceptor$asx(values), i = 0; i < keys.length; ++i)
        result.$indexSet(0, keys[i], this.deserialize$1(t1.$index(values, i)));
      return result;
    },
    deserializeSendPort$1: function(x) {
      var t1, managerId, isolateId, receivePortId, isolate, receivePort, result;
      if (0 >= x.length)
        return H.ioore(x, 0);
      H.assertHelper(J.$eq(x[0], "sendport"));
      t1 = x.length;
      if (1 >= t1)
        return H.ioore(x, 1);
      managerId = H.intTypeCheck(x[1]);
      if (2 >= t1)
        return H.ioore(x, 2);
      isolateId = H.intTypeCheck(x[2]);
      if (3 >= t1)
        return H.ioore(x, 3);
      receivePortId = H.intTypeCheck(x[3]);
      t1 = init.globalState.currentManagerId;
      if (managerId == null ? t1 == null : managerId === t1) {
        isolate = init.globalState.isolates.$index(0, isolateId);
        if (isolate == null)
          return;
        receivePort = isolate.lookup$1(receivePortId);
        if (receivePort == null)
          return;
        result = new H._NativeJsSendPort(H.interceptedTypeCheck(receivePort, "$isRawReceivePortImpl"), isolateId);
      } else
        result = new H._WorkerSendPort(managerId, receivePortId, isolateId);
      C.JSArray_methods.add$1(this.deserializedObjects, result);
      return result;
    },
    deserializeJSObject$1: function(x) {
      var t1, keys, values, o, t2, i;
      if (0 >= x.length)
        return H.ioore(x, 0);
      H.assertHelper(J.$eq(x[0], "js-object"));
      t1 = x.length;
      if (1 >= t1)
        return H.ioore(x, 1);
      keys = H.listTypeCheck(x[1]);
      if (2 >= t1)
        return H.ioore(x, 2);
      values = H.listTypeCheck(x[2]);
      o = {};
      C.JSArray_methods.add$1(this.deserializedObjects, o);
      for (t1 = J.getInterceptor$asx(keys), t2 = J.getInterceptor$asx(values), i = 0; i < t1.get$length(keys); ++i)
        o[t1.$index(keys, i)] = this.deserialize$1(t2.$index(values, i));
      return o;
    }
  }
}],
["_js_helper", "dart:_js_helper", , H, {
  "^": "",
  isJsIndexable: function(object, record) {
    var result;
    if (record != null) {
      result = record.x;
      if (result != null)
        return result;
    }
    return !!J.getInterceptor(object).$isJavaScriptIndexingBehavior;
  },
  S: function(value) {
    var res;
    if (typeof value === "string")
      return value;
    if (typeof value === "number") {
      if (value !== 0)
        return "" + value;
    } else if (true === value)
      return "true";
    else if (false === value)
      return "false";
    else if (value == null)
      return "null";
    res = J.toString$0(value);
    if (typeof res !== "string")
      throw H.wrapException(P.ArgumentError$(value));
    return res;
  },
  Primitives_objectHashCode: function(object) {
    var hash = object.$identityHash;
    if (hash == null) {
      hash = Math.random() * 0x3fffffff | 0;
      object.$identityHash = hash;
    }
    return hash;
  },
  Primitives__parseIntError: function(source, handleError) {
    H.buildFunctionType(H.buildInterfaceType(P.$int), [H.buildInterfaceType(P.String)])._assertCheck$1(handleError);
    throw H.wrapException(P.FormatException$(source, null, null));
  },
  Primitives_parseInt: function(source, radix, handleError) {
    var t1, match, decimalMatch, maxCharCode, t2, digitsPart, i;
    t1 = H.buildFunctionType(H.buildInterfaceType(P.$int), [H.buildInterfaceType(P.String)])._assertCheck$1(handleError);
    H.checkString(source);
    match = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(source);
    if (match == null)
      return H.Primitives__parseIntError(source, t1);
    if (3 >= match.length)
      return H.ioore(match, 3);
    decimalMatch = H.stringTypeCheck(match[3]);
    if (radix == null) {
      if (decimalMatch != null)
        return parseInt(source, 10);
      if (match[2] != null)
        return parseInt(source, 16);
      return H.Primitives__parseIntError(source, t1);
    }
    if (radix < 2 || radix > 36)
      throw H.wrapException(P.RangeError$range(radix, 2, 36, "radix", null));
    if (radix === 10 && decimalMatch != null)
      return parseInt(source, 10);
    if (radix < 10 || decimalMatch == null) {
      maxCharCode = radix <= 10 ? 47 + radix : 86 + radix;
      t2 = match[1];
      H.assertHelper(typeof t2 === "string");
      digitsPart = match[1];
      for (t2 = digitsPart.length, i = 0; i < t2; ++i)
        if ((C.JSString_methods.codeUnitAt$1(digitsPart, i) | 32) > maxCharCode)
          return H.Primitives__parseIntError(source, t1);
    }
    return parseInt(source, radix);
  },
  Primitives_objectTypeName: function(object) {
    var $name, decompiled;
    $name = C.JS_CONST_8ZY(J.getInterceptor(object));
    if ($name === "Object") {
      decompiled = String(object.constructor).match(/^\s*function\s*(\S*)\s*\(/)[1];
      if (typeof decompiled === "string")
        $name = /^\w+$/.test(decompiled) ? decompiled : $name;
    }
    if ($name.length > 1 && C.JSString_methods.codeUnitAt$1($name, 0) === 36)
      $name = C.JSString_methods.substring$1($name, 1);
    return ($name + H.joinArguments(H.listTypeCheck(H.getRuntimeTypeInfo(object)), 0, null)).replace(/[^<,> ]+/g, function(m) {
      return init.mangledGlobalNames[m] || m;
    });
  },
  Primitives_objectToString: function(object) {
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Primitives_dateNow: [function() {
    return Date.now();
  }, "call$0", "Primitives_dateNow$closure", 0, 0, 42],
  Primitives_initTicker: function() {
    var $window, performance;
    if ($.Primitives_timerFrequency != null)
      return;
    $.Primitives_timerFrequency = 1000;
    $.Primitives_timerTicks = H.interceptedTypeCheck(H.Primitives_dateNow$closure(), "$isFunction");
    if (typeof window == "undefined")
      return;
    $window = window;
    if ($window == null)
      return;
    performance = $window.performance;
    if (performance == null)
      return;
    if (typeof performance.now != "function")
      return;
    $.Primitives_timerFrequency = 1000000;
    $.Primitives_timerTicks = new H.Primitives_initTicker_closure(performance);
  },
  Primitives__fromCharCodeApply: function(array) {
    var end, result, i, i0, chunkEnd;
    H.assertSubtype(array, "$isList", [P.$int], "$asList");
    end = array.length;
    if (end <= 500)
      return String.fromCharCode.apply(null, array);
    for (result = "", i = 0; i < end; i = i0) {
      i0 = i + 500;
      chunkEnd = i0 < end ? i0 : end;
      result += String.fromCharCode.apply(null, array.slice(i, chunkEnd));
    }
    return result;
  },
  Primitives_stringFromCodePoints: function(codePoints) {
    var a, t1, t2, i;
    a = [];
    H.assertHelper(true);
    a.$builtinTypeInfo = [P.$int];
    H.assertSubtype(a, "$isList", [P.$int], "$asList");
    t1 = H.getTypeArgumentByIndex(codePoints, 0);
    H.assertSubtype(codePoints, "$isJSArray", [t1], "$asJSArray");
    t2 = codePoints.length;
    t2 = new J.ArrayIterator(H.assertSubtype(codePoints, "$isJSArray", [t1], "$asJSArray"), t2, 0, H.assertSubtypeOfRuntimeType(null, t1));
    H.assertHelper(true);
    t2.$builtinTypeInfo = [t1];
    H.assertSubtype(t2, "$isIterator", [H.getTypeArgumentByIndex(codePoints, 0)], "$asIterator");
    for (; t2.moveNext$0();) {
      i = H.assertSubtypeOfRuntimeType(t2._current, H.getTypeArgumentByIndex(t2, 0));
      if (typeof i !== "number" || Math.floor(i) !== i)
        throw H.wrapException(P.ArgumentError$(i));
      if (i <= 65535)
        C.JSArray_methods.add$1(a, i);
      else if (i <= 1114111) {
        C.JSArray_methods.add$1(a, 55296 + (C.JSInt_methods._shrOtherPositive$1(i - 65536, 10) & 1023));
        C.JSArray_methods.add$1(a, 56320 + (i & 1023));
      } else
        throw H.wrapException(P.ArgumentError$(i));
    }
    return H.Primitives__fromCharCodeApply(a);
  },
  Primitives_stringFromCharCodes: function(charCodes) {
    var t1, t2, i;
    for (t1 = H.getTypeArgumentByIndex(charCodes, 0), H.assertSubtype(charCodes, "$isJSArray", [t1], "$asJSArray"), t2 = charCodes.length, t1 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(charCodes, "$isJSArray", [t1], "$asJSArray"), t2, 0, H.assertSubtypeOfRuntimeType(null, t1)), [t1]), "$isIterator", [H.getTypeArgumentByIndex(charCodes, 0)], "$asIterator"); t1.moveNext$0();) {
      i = H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0));
      if (typeof i !== "number" || Math.floor(i) !== i)
        throw H.wrapException(P.ArgumentError$(i));
      if (i < 0)
        throw H.wrapException(P.ArgumentError$(i));
      if (i > 65535)
        return H.Primitives_stringFromCodePoints(charCodes);
    }
    return H.Primitives__fromCharCodeApply(charCodes);
  },
  Primitives_stringFromCharCode: function(charCode) {
    var bits;
    if (0 <= charCode) {
      if (charCode <= 65535)
        return String.fromCharCode(charCode);
      if (charCode <= 1114111) {
        bits = charCode - 65536;
        return String.fromCharCode((55296 | C.JSInt_methods._shrOtherPositive$1(bits, 10)) >>> 0, 56320 | bits & 1023);
      }
    }
    throw H.wrapException(P.RangeError$range(charCode, 0, 1114111, null, null));
  },
  Primitives_getProperty: function(object, key) {
    if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
      throw H.wrapException(P.ArgumentError$(object));
    return object[key];
  },
  Primitives_setProperty: function(object, key, value) {
    if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
      throw H.wrapException(P.ArgumentError$(object));
    object[key] = value;
  },
  iae: function(argument) {
    throw H.wrapException(P.ArgumentError$(argument));
  },
  ioore: function(receiver, index) {
    if (receiver == null)
      J.get$length$asx(receiver);
    if (typeof index !== "number" || Math.floor(index) !== index)
      H.iae(index);
    throw H.wrapException(P.RangeError$value(index, null, null));
  },
  checkInt: function(value) {
    if (typeof value !== "number" || Math.floor(value) !== value)
      throw H.wrapException(P.ArgumentError$(value));
    return value;
  },
  checkString: function(value) {
    if (typeof value !== "string")
      throw H.wrapException(P.ArgumentError$(value));
    return value;
  },
  wrapException: function(ex) {
    var wrapper;
    if (ex == null)
      ex = new P.NullThrownError();
    wrapper = new Error();
    wrapper.dartException = ex;
    if ("defineProperty" in Object) {
      Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
      wrapper.name = "";
    } else
      wrapper.toString = H.toStringWrapper;
    return wrapper;
  },
  toStringWrapper: function() {
    return J.toString$0(this.dartException);
  },
  throwExpression: function(ex) {
    throw H.wrapException(ex);
  },
  unwrapException: function(ex) {
    var t1, message, number, ieErrorCode, t2, t3, t4, nullLiteralCall, t5, t6, t7, t8, t9, match;
    t1 = new H.unwrapException_saveStackTrace(ex);
    if (ex == null)
      return;
    if (typeof ex !== "object")
      return ex;
    if ("dartException" in ex)
      return t1.call$1(ex.dartException);
    else if (!("message" in ex))
      return ex;
    message = ex.message;
    if ("number" in ex && typeof ex.number == "number") {
      number = ex.number;
      ieErrorCode = number & 65535;
      if ((C.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
        switch (ieErrorCode) {
          case 438:
            return t1.call$1(H.JsNoSuchMethodError$(H.S(message) + " (Error " + ieErrorCode + ")", null));
          case 445:
          case 5007:
            t2 = H.S(message) + " (Error " + ieErrorCode + ")";
            return t1.call$1(new H.NullError(t2, null));
        }
    }
    if (ex instanceof TypeError) {
      t2 = $.get$TypeErrorDecoder_noSuchMethodPattern();
      t3 = $.get$TypeErrorDecoder_notClosurePattern();
      t4 = $.get$TypeErrorDecoder_nullCallPattern();
      nullLiteralCall = $.get$TypeErrorDecoder_nullLiteralCallPattern();
      t5 = $.get$TypeErrorDecoder_undefinedCallPattern();
      t6 = $.get$TypeErrorDecoder_undefinedLiteralCallPattern();
      t7 = $.get$TypeErrorDecoder_nullPropertyPattern();
      $.get$TypeErrorDecoder_nullLiteralPropertyPattern();
      t8 = $.get$TypeErrorDecoder_undefinedPropertyPattern();
      t9 = $.get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
      match = t2.matchTypeError$1(message);
      if (match != null)
        return t1.call$1(H.JsNoSuchMethodError$(message, match));
      else {
        match = t3.matchTypeError$1(message);
        if (match != null) {
          match.method = "call";
          return t1.call$1(H.JsNoSuchMethodError$(message, match));
        } else {
          match = t4.matchTypeError$1(message);
          if (match == null) {
            match = nullLiteralCall.matchTypeError$1(message);
            if (match == null) {
              match = t5.matchTypeError$1(message);
              if (match == null) {
                match = t6.matchTypeError$1(message);
                if (match == null) {
                  match = t7.matchTypeError$1(message);
                  if (match == null) {
                    match = nullLiteralCall.matchTypeError$1(message);
                    if (match == null) {
                      match = t8.matchTypeError$1(message);
                      if (match == null) {
                        match = t9.matchTypeError$1(message);
                        t2 = match != null;
                      } else
                        t2 = true;
                    } else
                      t2 = true;
                  } else
                    t2 = true;
                } else
                  t2 = true;
              } else
                t2 = true;
            } else
              t2 = true;
          } else
            t2 = true;
          if (t2) {
            H.stringTypeCheck(message);
            return t1.call$1(new H.NullError(message, H.stringTypeCheck(match == null ? null : match.method)));
          }
        }
      }
      return t1.call$1(new H.UnknownJsTypeError(H.stringTypeCheck(typeof message === "string" ? message : "")));
    }
    if (ex instanceof RangeError) {
      if (typeof message === "string" && message.indexOf("call stack") !== -1)
        return new P.StackOverflowError();
      return t1.call$1(new P.ArgumentError(false, null, null, null));
    }
    if (typeof InternalError == "function" && ex instanceof InternalError)
      if (typeof message === "string" && message === "too much recursion")
        return new P.StackOverflowError();
    return ex;
  },
  getTraceFromException: function(exception) {
    return new H._StackTrace(exception, null);
  },
  objectHashCode: function(object) {
    if (object == null || typeof object != 'object')
      return J.get$hashCode$(object);
    else
      return H.Primitives_objectHashCode(object);
  },
  fillLiteralMap: function(keyValuePairs, result) {
    var t1, $length, index, index0, key;
    t1 = typeof keyValuePairs === "object" && keyValuePairs !== null && keyValuePairs.constructor === Array;
    H.assertHelper(t1);
    $length = keyValuePairs.length;
    for (index = 0; index < $length;) {
      index0 = index + 1;
      H.assertHelper(t1);
      key = keyValuePairs[index];
      index = index0 + 1;
      H.assertHelper(t1);
      result.$indexSet(0, key, keyValuePairs[index0]);
    }
    return result;
  },
  invokeClosure: function(closure, isolate, numberOfArguments, arg1, arg2, arg3, arg4) {
    H.interceptedTypeCheck(closure, "$isFunction");
    H.intTypeCheck(numberOfArguments);
    if (numberOfArguments === 0)
      return H._callInIsolate(isolate, new H.invokeClosure_closure(closure));
    else if (numberOfArguments === 1)
      return H._callInIsolate(isolate, new H.invokeClosure_closure0(closure, arg1));
    else if (numberOfArguments === 2)
      return H._callInIsolate(isolate, new H.invokeClosure_closure1(closure, arg1, arg2));
    else if (numberOfArguments === 3)
      return H._callInIsolate(isolate, new H.invokeClosure_closure2(closure, arg1, arg2, arg3));
    else if (numberOfArguments === 4)
      return H._callInIsolate(isolate, new H.invokeClosure_closure3(closure, arg1, arg2, arg3, arg4));
    else
      throw H.wrapException(P.Exception_Exception("Unsupported number of arguments for wrapped closure"));
  },
  convertDartClosureToJS: function(closure, arity) {
    var $function;
    H.intTypeCheck(arity);
    if (closure == null)
      return;
    $function = closure.$identity;
    if (!!$function)
      return $function;
    $function = function(closure, arity, context, invoke) {
      return function(a1, a2, a3, a4) {
        return invoke(closure, context, arity, a1, a2, a3, a4);
      };
    }(closure, arity, init.globalState.currentContext, H.invokeClosure);
    closure.$identity = $function;
    return $function;
  },
  Closure_fromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, propertyName) {
    var $function, callName, functionType, $prototype, $constructor, t1, isIntercepted, trampoline, signatureFunction, getReceiver, i, stub, stubCallName, t2;
    $function = functions[0];
    $function.$stubName;
    callName = $function.$callName;
    if (!!J.getInterceptor(reflectionInfo).$isList) {
      $function.$reflectionInfo = reflectionInfo;
      functionType = H.ReflectionInfo_ReflectionInfo($function).functionType;
    } else
      functionType = reflectionInfo;
    $prototype = isStatic ? Object.create(new H.TearOffClosure().constructor.prototype) : Object.create(new H.BoundClosure(null, null, null, null).constructor.prototype);
    $prototype.$initialize = $prototype.constructor;
    if (isStatic)
      $constructor = function() {
        this.$initialize();
      };
    else {
      t1 = $.Closure_functionCounter;
      if (typeof t1 !== "number")
        return t1.$add();
      $.Closure_functionCounter = t1 + 1;
      t1 = new Function("a", "b", "c", "d", "this.$initialize(a,b,c,d);" + t1);
      $constructor = t1;
    }
    $prototype.constructor = $constructor;
    $constructor.prototype = $prototype;
    t1 = !isStatic;
    if (t1) {
      isIntercepted = jsArguments.length == 1 && true;
      trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
      trampoline.$reflectionInfo = reflectionInfo;
    } else {
      $prototype.$name = propertyName;
      trampoline = $function;
      isIntercepted = false;
    }
    if (typeof functionType == "number")
      signatureFunction = function(s) {
        return function() {
          return init.types[s];
        };
      }(functionType);
    else if (t1 && typeof functionType == "function") {
      getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
      signatureFunction = function(f, r) {
        return function() {
          return f.apply({$receiver: r(this)}, arguments);
        };
      }(functionType, getReceiver);
    } else
      throw H.wrapException("Error in reflectionInfo.");
    $prototype.$signature = signatureFunction;
    $prototype[callName] = trampoline;
    for (t1 = functions.length, i = 1; i < t1; ++i) {
      stub = functions[i];
      stubCallName = stub.$callName;
      if (stubCallName != null) {
        t2 = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
        $prototype[stubCallName] = t2;
      }
    }
    $prototype["call*"] = trampoline;
    $prototype.$requiredArgCount = $function.$requiredArgCount;
    $prototype.$defaultValues = $function.$defaultValues;
    return $constructor;
  },
  Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
    var getSelf = H.BoundClosure_selfOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        return function(n, S) {
          return function() {
            return S(this)[n]();
          };
        }(stubName, getSelf);
      case 1:
        return function(n, S) {
          return function(a) {
            return S(this)[n](a);
          };
        }(stubName, getSelf);
      case 2:
        return function(n, S) {
          return function(a, b) {
            return S(this)[n](a, b);
          };
        }(stubName, getSelf);
      case 3:
        return function(n, S) {
          return function(a, b, c) {
            return S(this)[n](a, b, c);
          };
        }(stubName, getSelf);
      case 4:
        return function(n, S) {
          return function(a, b, c, d) {
            return S(this)[n](a, b, c, d);
          };
        }(stubName, getSelf);
      case 5:
        return function(n, S) {
          return function(a, b, c, d, e) {
            return S(this)[n](a, b, c, d, e);
          };
        }(stubName, getSelf);
      default:
        return function(f, s) {
          return function() {
            return f.apply(s(this), arguments);
          };
        }($function, getSelf);
    }
  },
  Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
    var stubName, arity, lookedUpFunction, t1, t2, $arguments;
    if (isIntercepted)
      return H.Closure_forwardInterceptedCallTo(receiver, $function);
    stubName = $function.$stubName;
    arity = $function.length;
    lookedUpFunction = receiver[stubName];
    t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    t2 = !t1 || arity >= 27;
    if (t2)
      return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
    if (arity === 0) {
      t1 = $.BoundClosure_selfFieldNameCache;
      if (t1 == null) {
        t1 = H.BoundClosure_computeFieldNamed("self");
        $.BoundClosure_selfFieldNameCache = t1;
      }
      t1 = "return function(){return this." + H.S(t1) + "." + H.S(stubName) + "();";
      t2 = $.Closure_functionCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.Closure_functionCounter = t2 + 1;
      return new Function(t1 + t2 + "}")();
    }
    H.assertHelper(1 <= arity && arity < 27);
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
    t1 = "return function(" + $arguments + "){return this.";
    t2 = $.BoundClosure_selfFieldNameCache;
    if (t2 == null) {
      t2 = H.BoundClosure_computeFieldNamed("self");
      $.BoundClosure_selfFieldNameCache = t2;
    }
    t2 = t1 + H.S(t2) + "." + H.S(stubName) + "(" + $arguments + ");";
    t1 = $.Closure_functionCounter;
    if (typeof t1 !== "number")
      return t1.$add();
    $.Closure_functionCounter = t1 + 1;
    return new Function(t2 + t1 + "}")();
  },
  Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
    var getSelf, getReceiver;
    getSelf = H.BoundClosure_selfOf;
    getReceiver = H.BoundClosure_receiverOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        throw H.wrapException(H.RuntimeError$("Intercepted function with no arguments."));
      case 1:
        return function(n, s, r) {
          return function() {
            return s(this)[n](r(this));
          };
        }($name, getSelf, getReceiver);
      case 2:
        return function(n, s, r) {
          return function(a) {
            return s(this)[n](r(this), a);
          };
        }($name, getSelf, getReceiver);
      case 3:
        return function(n, s, r) {
          return function(a, b) {
            return s(this)[n](r(this), a, b);
          };
        }($name, getSelf, getReceiver);
      case 4:
        return function(n, s, r) {
          return function(a, b, c) {
            return s(this)[n](r(this), a, b, c);
          };
        }($name, getSelf, getReceiver);
      case 5:
        return function(n, s, r) {
          return function(a, b, c, d) {
            return s(this)[n](r(this), a, b, c, d);
          };
        }($name, getSelf, getReceiver);
      case 6:
        return function(n, s, r) {
          return function(a, b, c, d, e) {
            return s(this)[n](r(this), a, b, c, d, e);
          };
        }($name, getSelf, getReceiver);
      default:
        return function(f, s, r, a) {
          return function() {
            a = [r(this)];
            Array.prototype.push.apply(a, arguments);
            return f.apply(s(this), a);
          };
        }($function, getSelf, getReceiver);
    }
  },
  Closure_forwardInterceptedCallTo: function(receiver, $function) {
    var selfField, t1, stubName, arity, lookedUpFunction, t2, t3, $arguments;
    selfField = H.BoundClosure_selfFieldName();
    t1 = $.BoundClosure_receiverFieldNameCache;
    if (t1 == null) {
      t1 = H.BoundClosure_computeFieldNamed("receiver");
      $.BoundClosure_receiverFieldNameCache = t1;
    }
    stubName = $function.$stubName;
    arity = $function.length;
    lookedUpFunction = receiver[stubName];
    t2 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    t3 = !t2 || arity >= 28;
    if (t3)
      return H.Closure_cspForwardInterceptedCall(arity, !t2, stubName, $function);
    if (arity === 1) {
      t1 = "return function(){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ");";
      t2 = $.Closure_functionCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.Closure_functionCounter = t2 + 1;
      return new Function(t1 + t2 + "}")();
    }
    H.assertHelper(1 < arity && arity < 28);
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
    t1 = "return function(" + $arguments + "){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ", " + $arguments + ");";
    t2 = $.Closure_functionCounter;
    if (typeof t2 !== "number")
      return t2.$add();
    $.Closure_functionCounter = t2 + 1;
    return new Function(t1 + t2 + "}")();
  },
  closureFromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, $name) {
    var t1;
    H.listTypeCheck(functions);
    functions.fixed$length = Array;
    if (!!J.getInterceptor(reflectionInfo).$isList) {
      reflectionInfo.fixed$length = Array;
      t1 = reflectionInfo;
    } else
      t1 = reflectionInfo;
    return H.Closure_fromTearOff(receiver, functions, t1, !!isStatic, jsArguments, $name);
  },
  boolConversionCheck: function(value) {
    if (typeof value === "boolean")
      return value;
    H.boolTypeCheck(value);
    H.assertHelper(value != null);
    return false;
  },
  stringTypeCheck: function(value) {
    if (value == null)
      return value;
    if (typeof value === "string")
      return value;
    throw H.wrapException(H.TypeErrorImplementation$(value, "String"));
  },
  doubleTypeCheck: function(value) {
    if (value == null)
      return value;
    if (typeof value === "number")
      return value;
    throw H.wrapException(H.TypeErrorImplementation$(value, "double"));
  },
  numTypeCheck: function(value) {
    if (value == null)
      return value;
    if (typeof value === "number")
      return value;
    throw H.wrapException(H.TypeErrorImplementation$(value, "num"));
  },
  boolTypeCheck: function(value) {
    if (value == null)
      return value;
    if (typeof value === "boolean")
      return value;
    throw H.wrapException(H.TypeErrorImplementation$(value, "bool"));
  },
  intTypeCheck: function(value) {
    if (value == null)
      return value;
    if (typeof value === "number" && Math.floor(value) === value)
      return value;
    throw H.wrapException(H.TypeErrorImplementation$(value, "int"));
  },
  propertyTypeError: function(value, property) {
    var t1 = J.getInterceptor$asx(property);
    throw H.wrapException(H.TypeErrorImplementation$(value, t1.substring$2(property, 3, t1.get$length(property))));
  },
  propertyTypeCastError: function(value, property) {
    var t1 = J.getInterceptor$asx(property);
    throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), t1.substring$2(property, 3, t1.get$length(property))));
  },
  interceptedTypeCheck: function(value, property) {
    if (value == null)
      return value;
    if (typeof value === "object" && J.getInterceptor(value)[property])
      return value;
    H.propertyTypeError(value, property);
  },
  interceptedTypeCast: function(value, property) {
    var t1;
    if (value != null)
      t1 = typeof value === "object" && J.getInterceptor(value)[property];
    else
      t1 = true;
    if (t1)
      return value;
    H.propertyTypeCastError(value, property);
  },
  numberOrStringSuperNativeTypeCheck: function(value, property) {
    if (value == null)
      return value;
    if (typeof value === "string")
      return value;
    if (typeof value === "number")
      return value;
    if (J.getInterceptor(value)[property])
      return value;
    H.propertyTypeError(value, property);
  },
  stringSuperNativeTypeCheck: function(value, property) {
    if (value == null)
      return value;
    if (typeof value === "string")
      return value;
    if (J.getInterceptor(value)[property])
      return value;
    H.propertyTypeError(value, property);
  },
  listTypeCheck: function(value) {
    if (value == null)
      return value;
    if (!!J.getInterceptor(value).$isList)
      return value;
    throw H.wrapException(H.TypeErrorImplementation$(value, "List"));
  },
  listTypeCast: function(value) {
    if (!!J.getInterceptor(value).$isList || value == null)
      return value;
    throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), "List"));
  },
  listSuperNativeTypeCheck: function(value, property) {
    if (value == null)
      return value;
    if (!!J.getInterceptor(value).$isList)
      return value;
    if (J.getInterceptor(value)[property])
      return value;
    H.propertyTypeError(value, property);
  },
  voidTypeCheck: function(value) {
    if (value == null)
      return value;
    throw H.wrapException(H.TypeErrorImplementation$(value, "void"));
  },
  assertHelper: function(condition) {
    if (typeof condition !== "boolean") {
      if (!!J.getInterceptor(condition).$isFunction)
        condition = condition.call$0();
      if (typeof condition !== "boolean")
        throw H.wrapException(H.TypeErrorImplementation$(condition, "bool"));
    }
    if (true !== condition)
      throw H.wrapException(new P.AssertionError());
  },
  throwCyclicInit: function(staticName) {
    throw H.wrapException(new P.CyclicInitializationError("Cyclic initialization for static " + H.S(H.stringTypeCheck(staticName))));
  },
  buildFunctionType: function(returnType, parameterTypes, optionalParameterTypes) {
    H.interceptedTypeCheck(returnType, "$isRuntimeType");
    H.assertSubtype(parameterTypes, "$isList", [H.RuntimeType], "$asList");
    H.assertSubtype(optionalParameterTypes, "$isList", [H.RuntimeType], "$asList");
    return new H.RuntimeFunctionType(returnType, H.assertSubtype(parameterTypes, "$isList", [H.RuntimeType], "$asList"), H.assertSubtype(optionalParameterTypes, "$isList", [H.RuntimeType], "$asList"), null);
  },
  buildInterfaceType: function(rti, typeArguments) {
    var $name = rti.name;
    if (typeArguments == null || typeArguments.length === 0)
      return new H.RuntimeTypePlain($name);
    H.assertSubtype(typeArguments, "$isList", [H.RuntimeType], "$asList");
    return new H.RuntimeTypeGeneric($name, H.assertSubtype(typeArguments, "$isList", [H.RuntimeType], "$asList"), null);
  },
  getDynamicRuntimeType: function() {
    return C.C_DynamicRuntimeType;
  },
  getVoidRuntimeType: function() {
    return C.C_VoidRuntimeType;
  },
  convertRtiToRuntimeType: function(rti) {
    var list, t1, $name, $arguments, i;
    if (rti == null)
      return C.C_DynamicRuntimeType;
    else if (typeof rti == "function")
      return new H.RuntimeTypePlain(rti.name);
    else if (rti.constructor == Array) {
      list = rti;
      t1 = list.length;
      if (0 >= t1)
        return H.ioore(list, 0);
      $name = list[0].name;
      $arguments = [];
      for (i = 1; i < t1; ++i)
        C.JSArray_methods.add$1($arguments, H.convertRtiToRuntimeType(list[i]));
      H.assertSubtype($arguments, "$isList", [H.RuntimeType], "$asList");
      return new H.RuntimeTypeGeneric($name, H.assertSubtype($arguments, "$isList", [H.RuntimeType], "$asList"), rti);
    } else if ("func" in rti)
      return C.C_DynamicRuntimeType;
    else
      throw H.wrapException(H.RuntimeError$("Cannot convert '" + JSON.stringify(rti) + "' to RuntimeType."));
  },
  random64: function() {
    return (Math.random() * 0x100000000 >>> 0) + (Math.random() * 0x100000000 >>> 0) * 4294967296;
  },
  createRuntimeType: function($name) {
    return new H.TypeImpl(H.stringTypeCheck($name), null);
  },
  setRuntimeTypeInfo: function(target, typeInfo) {
    H.assertHelper(typeInfo == null || typeof typeInfo === "object" && typeInfo !== null && typeInfo.constructor === Array);
    if (target != null)
      target.$builtinTypeInfo = typeInfo;
    return target;
  },
  getRuntimeTypeInfo: function(target) {
    if (target == null)
      return;
    return target.$builtinTypeInfo;
  },
  getRuntimeTypeArguments: function(target, substitutionName) {
    return H.substitute(target["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
  },
  getRuntimeTypeArgument: function(target, substitutionName, index) {
    var $arguments, t1;
    H.stringTypeCheck(substitutionName);
    H.intTypeCheck(index);
    $arguments = H.getRuntimeTypeArguments(target, substitutionName);
    if ($arguments == null)
      t1 = null;
    else {
      H.assertHelper(typeof $arguments === "object" && $arguments !== null && $arguments.constructor === Array);
      t1 = $arguments[index];
    }
    return t1;
  },
  getTypeArgumentByIndex: function(target, index) {
    var rti, t1;
    H.intTypeCheck(index);
    rti = H.getRuntimeTypeInfo(target);
    if (rti == null)
      t1 = null;
    else {
      H.assertHelper(typeof rti === "object" && rti !== null && rti.constructor === Array);
      t1 = rti[index];
    }
    return t1;
  },
  runtimeTypeToString: function(type, onTypeVariable) {
    var t1, t2;
    t1 = H.buildFunctionType(H.buildInterfaceType(P.String), [H.buildInterfaceType(P.$int)]);
    t2 = t1._assertCheck$1(onTypeVariable);
    if (type == null)
      return "dynamic";
    else if (typeof type === "object" && type !== null && type.constructor === Array) {
      t1._assertCheck$1(t2);
      H.assertHelper(true);
      H.assertHelper(true);
      return type[0].builtin$cls + H.joinArguments(type, 1, t2);
    } else if (typeof type == "function")
      return type.builtin$cls;
    else if (typeof type === "number" && Math.floor(type) === type)
      return C.JSInt_methods.toString$0(type);
    else
      return;
  },
  joinArguments: function(types, startIndex, onTypeVariable) {
    var t1, t2, buffer, index, firstArgument, allDynamic, argument;
    t1 = H.buildFunctionType(H.buildInterfaceType(P.String), [H.buildInterfaceType(P.$int)])._assertCheck$1(onTypeVariable);
    if (types == null)
      return "";
    t2 = typeof types === "object" && types !== null && types.constructor === Array;
    H.assertHelper(t2);
    buffer = new P.StringBuffer("");
    for (index = startIndex, firstArgument = true, allDynamic = true; H.assertHelper(t2), index < types.length; ++index) {
      if (firstArgument)
        firstArgument = false;
      else
        buffer._contents += ", ";
      H.assertHelper(t2);
      argument = types[index];
      if (argument != null)
        allDynamic = false;
      buffer._contents += H.S(H.runtimeTypeToString(argument, t1));
    }
    return allDynamic ? "" : "<" + H.S(buffer) + ">";
  },
  getRuntimeTypeString: function(object) {
    var className = J.getInterceptor(object).constructor.builtin$cls;
    if (object == null)
      return className;
    return className + H.joinArguments(object.$builtinTypeInfo, 0, null);
  },
  substitute: function(substitution, $arguments) {
    H.assertHelper(substitution == null || typeof substitution == "function");
    H.assertHelper($arguments == null || typeof $arguments === "object" && $arguments !== null && $arguments.constructor === Array);
    if (typeof substitution == "function") {
      substitution = H.invokeOn(substitution, null, $arguments);
      if (substitution == null || typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
        $arguments = substitution;
      else if (typeof substitution == "function")
        $arguments = H.invokeOn(substitution, null, $arguments);
    }
    return $arguments;
  },
  checkSubtype: function(object, isField, checks, asField) {
    var $arguments, interceptor;
    H.stringTypeCheck(isField);
    H.listTypeCheck(checks);
    H.stringTypeCheck(asField);
    if (object == null)
      return false;
    $arguments = H.getRuntimeTypeInfo(object);
    interceptor = J.getInterceptor(object);
    if (interceptor[isField] == null)
      return false;
    return H.areSubtypes(H.substitute(interceptor[asField], $arguments), checks);
  },
  computeTypeName: function(isField, $arguments) {
    return (J.substring$2$s(isField, 3, isField.length) + H.joinArguments($arguments, 0, null)).replace(/[^<,> ]+/g, function(m) {
      return init.mangledGlobalNames[m] || m;
    });
  },
  subtypeCast: function(object, isField, checks, asField) {
    H.stringTypeCheck(isField);
    H.listTypeCheck(checks);
    H.stringTypeCheck(asField);
    if (object != null && !H.checkSubtype(object, isField, checks, asField))
      throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(object), H.computeTypeName(isField, checks)));
    return object;
  },
  assertSubtype: function(object, isField, checks, asField) {
    H.stringTypeCheck(isField);
    H.listTypeCheck(checks);
    H.stringTypeCheck(asField);
    if (object != null && !H.checkSubtype(object, isField, checks, asField))
      throw H.wrapException(H.TypeErrorImplementation$(object, H.computeTypeName(isField, checks)));
    return object;
  },
  areSubtypes: function(s, t) {
    var t1, t2, t3, len, i;
    if (s == null || t == null)
      return true;
    t1 = typeof s === "object" && s !== null && s.constructor === Array;
    H.assertHelper(t1);
    t2 = typeof t === "object" && t !== null && t.constructor === Array;
    H.assertHelper(t2);
    H.assertHelper(t1);
    t3 = s.length;
    H.assertHelper(t2);
    H.assertHelper(t3 === t.length);
    H.assertHelper(t1);
    len = s.length;
    for (i = 0; i < len; ++i) {
      H.assertHelper(t1);
      t3 = s[i];
      H.assertHelper(t2);
      if (!H.isSubtype(t3, t[i]))
        return false;
    }
    return true;
  },
  computeSignature: function(signature, context, contextName) {
    return H.invokeOn(signature, context, H.getRuntimeTypeArguments(context, contextName));
  },
  checkSubtypeOfRuntimeType: function(o, t) {
    var rti, type, targetSignatureFunction;
    if (o == null)
      return t == null || t.builtin$cls === "Object" || t.builtin$cls === "Null";
    if (t == null)
      return true;
    rti = H.getRuntimeTypeInfo(o);
    o = J.getInterceptor(o);
    type = o.constructor;
    if (rti != null) {
      rti = rti.slice();
      rti.splice(0, 0, type);
      type = rti;
    } else if ("func" in t) {
      if ("$is_" + H.S(t.func) in o)
        return true;
      targetSignatureFunction = o.$signature;
      if (targetSignatureFunction == null)
        return false;
      return H.isFunctionSubtype(H.invokeOn(targetSignatureFunction, o, null), t);
    }
    return H.isSubtype(type, t);
  },
  assertSubtypeOfRuntimeType: function(object, type) {
    if (object != null && !H.checkSubtypeOfRuntimeType(object, type))
      throw H.wrapException(H.TypeErrorImplementation$(object, H.runtimeTypeToString(type, null)));
    return object;
  },
  isSubtype: function(s, t) {
    var t1, typeOfS, t2, typeOfT, $name, test, typeOfSPrototype, substitution;
    if (s === t)
      return true;
    if (s == null || t == null)
      return true;
    if ("func" in t)
      return H.isFunctionSubtype(s, t);
    if ("func" in s)
      return t.builtin$cls === "Function";
    t1 = typeof s === "object" && s !== null && s.constructor === Array;
    if (t1) {
      H.assertHelper(true);
      typeOfS = s[0];
    } else
      typeOfS = s;
    t2 = typeof t === "object" && t !== null && t.constructor === Array;
    if (t2) {
      H.assertHelper(true);
      typeOfT = t[0];
    } else
      typeOfT = t;
    $name = H.runtimeTypeToString(typeOfT, null);
    if (typeOfT !== typeOfS) {
      test = "$is" + H.S($name);
      typeOfSPrototype = typeOfS.prototype;
      if (!(test in typeOfSPrototype))
        return false;
      substitution = typeOfSPrototype["$as" + H.S(H.runtimeTypeToString(typeOfT, null))];
    } else
      substitution = null;
    if (!t1 && substitution == null || !t2)
      return true;
    t1 = t1 ? s.slice(1) : null;
    t2 = t2 ? t.slice(1) : null;
    return H.areSubtypes(H.substitute(substitution, t1), t2);
  },
  areAssignable: function(s, t, allowShorter) {
    var t1, t2, sLength, tLength, i, t3, t4;
    H.listTypeCheck(s);
    H.listTypeCheck(t);
    t1 = t == null;
    if (t1 && s == null)
      return true;
    if (t1)
      return allowShorter;
    if (s == null)
      return false;
    t1 = typeof s === "object" && s !== null && s.constructor === Array;
    H.assertHelper(t1);
    t2 = typeof t === "object" && t !== null && t.constructor === Array;
    H.assertHelper(t2);
    H.assertHelper(t1);
    sLength = s.length;
    H.assertHelper(t2);
    tLength = t.length;
    if (allowShorter) {
      if (sLength < tLength)
        return false;
    } else if (sLength !== tLength)
      return false;
    for (i = 0; i < tLength; ++i) {
      H.assertHelper(t1);
      t3 = s[i];
      H.assertHelper(t2);
      t4 = t[i];
      if (!(H.isSubtype(t3, t4) || H.isSubtype(t4, t3)))
        return false;
    }
    return true;
  },
  areAssignableMaps: function(s, t) {
    var t1, names, i, $name, tType, sType;
    if (t == null)
      return true;
    if (s == null)
      return false;
    H.assertHelper(typeof s == 'object');
    H.assertHelper(typeof t == 'object');
    t1 = H.listTypeCheck(Object.getOwnPropertyNames(t));
    t1.fixed$length = Array;
    names = t1;
    for (t1 = names.length, i = 0; i < t1; ++i) {
      $name = names[i];
      if (!Object.hasOwnProperty.call(s, $name))
        return false;
      tType = t[$name];
      sType = s[$name];
      if (!(H.isSubtype(tType, sType) || H.isSubtype(sType, tType)))
        return false;
    }
    return true;
  },
  isFunctionSubtype: function(s, t) {
    var sReturnType, tReturnType, sParameterTypes, tParameterTypes, sOptionalParameterTypes, tOptionalParameterTypes, sParametersLen, tParametersLen, sOptionalParametersLen, tOptionalParametersLen, t1, t2, pos, t3, t4, tPos, sPos;
    H.assertHelper("func" in t);
    if (!("func" in s))
      return false;
    if ("void" in s) {
      if (!("void" in t) && "ret" in t)
        return false;
    } else if (!("void" in t)) {
      sReturnType = s.ret;
      tReturnType = t.ret;
      if (!(H.isSubtype(sReturnType, tReturnType) || H.isSubtype(tReturnType, sReturnType)))
        return false;
    }
    sParameterTypes = s.args;
    tParameterTypes = t.args;
    sOptionalParameterTypes = s.opt;
    tOptionalParameterTypes = t.opt;
    if (sParameterTypes != null) {
      H.assertHelper(typeof sParameterTypes === "object" && sParameterTypes !== null && sParameterTypes.constructor === Array);
      sParametersLen = sParameterTypes.length;
    } else
      sParametersLen = 0;
    if (tParameterTypes != null) {
      H.assertHelper(typeof tParameterTypes === "object" && tParameterTypes !== null && tParameterTypes.constructor === Array);
      tParametersLen = tParameterTypes.length;
    } else
      tParametersLen = 0;
    if (sOptionalParameterTypes != null) {
      H.assertHelper(typeof sOptionalParameterTypes === "object" && sOptionalParameterTypes !== null && sOptionalParameterTypes.constructor === Array);
      sOptionalParametersLen = sOptionalParameterTypes.length;
    } else
      sOptionalParametersLen = 0;
    if (tOptionalParameterTypes != null) {
      H.assertHelper(typeof tOptionalParameterTypes === "object" && tOptionalParameterTypes !== null && tOptionalParameterTypes.constructor === Array);
      tOptionalParametersLen = tOptionalParameterTypes.length;
    } else
      tOptionalParametersLen = 0;
    if (sParametersLen > tParametersLen)
      return false;
    if (sParametersLen + sOptionalParametersLen < tParametersLen + tOptionalParametersLen)
      return false;
    if (sParametersLen === tParametersLen) {
      if (!H.areAssignable(sParameterTypes, tParameterTypes, false))
        return false;
      if (!H.areAssignable(sOptionalParameterTypes, tOptionalParameterTypes, true))
        return false;
    } else {
      for (t1 = typeof sParameterTypes === "object" && sParameterTypes !== null && sParameterTypes.constructor === Array, t2 = typeof tParameterTypes === "object" && tParameterTypes !== null && tParameterTypes.constructor === Array, pos = 0; pos < sParametersLen; ++pos) {
        H.assertHelper(t1);
        t3 = sParameterTypes[pos];
        H.assertHelper(t2);
        t4 = tParameterTypes[pos];
        if (!(H.isSubtype(t3, t4) || H.isSubtype(t4, t3)))
          return false;
      }
      for (t1 = typeof sOptionalParameterTypes === "object" && sOptionalParameterTypes !== null && sOptionalParameterTypes.constructor === Array, tPos = pos, sPos = 0; tPos < tParametersLen; ++sPos, ++tPos) {
        H.assertHelper(t1);
        t3 = sOptionalParameterTypes[sPos];
        H.assertHelper(t2);
        t4 = tParameterTypes[tPos];
        if (!(H.isSubtype(t3, t4) || H.isSubtype(t4, t3)))
          return false;
      }
      for (t2 = typeof tOptionalParameterTypes === "object" && tOptionalParameterTypes !== null && tOptionalParameterTypes.constructor === Array, tPos = 0; tPos < tOptionalParametersLen; ++sPos, ++tPos) {
        H.assertHelper(t1);
        t3 = sOptionalParameterTypes[sPos];
        H.assertHelper(t2);
        t4 = tOptionalParameterTypes[tPos];
        if (!(H.isSubtype(t3, t4) || H.isSubtype(t4, t3)))
          return false;
      }
    }
    return H.areAssignableMaps(s.named, t.named);
  },
  invokeOn: function($function, receiver, $arguments) {
    H.assertHelper(typeof $function == "function");
    H.assertHelper($arguments == null || typeof $arguments === "object" && $arguments !== null && $arguments.constructor === Array);
    return $function.apply(receiver, $arguments);
  },
  toStringForNativeObject: function(obj) {
    var t1 = $.getTagFunction;
    return "Instance of " + (t1 == null ? "<Unknown>" : t1.call$1(obj));
  },
  hashCodeForNativeObject: function(object) {
    return H.Primitives_objectHashCode(object);
  },
  defineProperty: function(obj, property, value) {
    Object.defineProperty(obj, H.stringTypeCheck(property), {value: value, enumerable: false, writable: true, configurable: true});
  },
  lookupAndCacheInterceptor: function(obj) {
    var tag, record, interceptor, interceptorClass, mark, t1;
    H.assertHelper(!(obj instanceof P.Object));
    tag = H.stringTypeCheck($.getTagFunction.call$1(obj));
    record = $.dispatchRecordsForInstanceTags[tag];
    if (record != null) {
      Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
      return record.i;
    }
    interceptor = $.interceptorsForUncacheableTags[tag];
    if (interceptor != null)
      return interceptor;
    interceptorClass = init.interceptorsByTag[tag];
    if (interceptorClass == null) {
      tag = H.stringTypeCheck($.alternateTagFunction.call$2(obj, tag));
      if (tag != null) {
        record = $.dispatchRecordsForInstanceTags[tag];
        if (record != null) {
          Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
          return record.i;
        }
        interceptor = $.interceptorsForUncacheableTags[tag];
        if (interceptor != null)
          return interceptor;
        interceptorClass = init.interceptorsByTag[tag];
      }
    }
    if (interceptorClass == null)
      return;
    interceptor = interceptorClass.prototype;
    mark = tag[0];
    if (mark === "!") {
      record = H.makeLeafDispatchRecord(interceptor);
      $.dispatchRecordsForInstanceTags[tag] = record;
      Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
      return record.i;
    }
    if (mark === "~") {
      $.interceptorsForUncacheableTags[tag] = interceptor;
      return interceptor;
    }
    if (mark === "-") {
      t1 = H.makeLeafDispatchRecord(interceptor);
      Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
      return t1.i;
    }
    if (mark === "+")
      return H.patchInteriorProto(obj, interceptor);
    if (mark === "*")
      throw H.wrapException(P.UnimplementedError$(tag));
    if (init.leafTags[tag] === true) {
      t1 = H.makeLeafDispatchRecord(interceptor);
      Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
      return t1.i;
    } else
      return H.patchInteriorProto(obj, interceptor);
  },
  patchInteriorProto: function(obj, interceptor) {
    var proto = Object.getPrototypeOf(obj);
    Object.defineProperty(proto, init.dispatchPropertyName, {value: J.makeDispatchRecord(interceptor, proto, null, null), enumerable: false, writable: true, configurable: true});
    return interceptor;
  },
  makeLeafDispatchRecord: function(interceptor) {
    return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
  },
  makeDefaultDispatchRecord: function(tag, interceptorClass, proto) {
    var interceptor = interceptorClass.prototype;
    if (init.leafTags[tag] === true)
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    else
      return J.makeDispatchRecord(interceptor, proto, null, null);
  },
  initNativeDispatch: function() {
    if (true === $.initNativeDispatchFlag)
      return;
    $.initNativeDispatchFlag = true;
    H.initNativeDispatchContinue();
  },
  initNativeDispatchContinue: function() {
    var map, tags, fun, i, tag, proto, record, interceptorClass;
    $.dispatchRecordsForInstanceTags = Object.create(null);
    $.interceptorsForUncacheableTags = Object.create(null);
    H.initHooks();
    map = init.interceptorsByTag;
    tags = Object.getOwnPropertyNames(map);
    if (typeof window != "undefined") {
      window;
      fun = function() {
      };
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        proto = $.prototypeForTagFunction.call$1(tag);
        if (proto != null) {
          record = H.makeDefaultDispatchRecord(tag, map[tag], proto);
          if (record != null) {
            Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
            fun.prototype = proto;
          }
        }
      }
    }
    for (i = 0; i < tags.length; ++i) {
      tag = tags[i];
      if (/^[A-Za-z_]/.test(tag)) {
        interceptorClass = map[tag];
        map["!" + tag] = interceptorClass;
        map["~" + tag] = interceptorClass;
        map["-" + tag] = interceptorClass;
        map["+" + tag] = interceptorClass;
        map["*" + tag] = interceptorClass;
      }
    }
  },
  initHooks: function() {
    var hooks, transformers, i, transformer, getTag, getUnknownTag, prototypeForTag;
    hooks = C.JS_CONST_gkc();
    hooks = H.applyHooksTransformer(C.JS_CONST_0, H.applyHooksTransformer(C.JS_CONST_rr7, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_gkc0, H.applyHooksTransformer(C.JS_CONST_4hp, H.applyHooksTransformer(C.JS_CONST_QJm(C.JS_CONST_8ZY), hooks)))))));
    if (typeof dartNativeDispatchHooksTransformer != "undefined") {
      transformers = dartNativeDispatchHooksTransformer;
      if (typeof transformers == "function")
        transformers = [transformers];
      if (transformers.constructor == Array)
        for (i = 0; i < transformers.length; ++i) {
          transformer = transformers[i];
          if (typeof transformer == "function")
            hooks = transformer(hooks) || hooks;
        }
    }
    getTag = hooks.getTag;
    getUnknownTag = hooks.getUnknownTag;
    prototypeForTag = hooks.prototypeForTag;
    $.getTagFunction = new H.initHooks_closure(getTag);
    $.alternateTagFunction = new H.initHooks_closure0(getUnknownTag);
    $.prototypeForTagFunction = new H.initHooks_closure1(prototypeForTag);
  },
  applyHooksTransformer: function(transformer, hooks) {
    return transformer(hooks) || hooks;
  },
  allMatchesInStringUnchecked: function(pattern, string, startIndex) {
    var result, $length, patternLength, position, endIndex;
    result = H.assertSubtype(H.setRuntimeTypeInfo([], [P.Match]), "$isList", [P.Match], "$asList");
    $length = string.length;
    patternLength = pattern.length;
    for (; true;) {
      position = string.indexOf(pattern, startIndex);
      if (position === -1)
        break;
      C.JSArray_methods.add$1(result, new H.StringMatch(position, string, pattern));
      endIndex = position + patternLength;
      if (endIndex === $length)
        break;
      else
        startIndex = position === endIndex ? startIndex + 1 : endIndex;
    }
    return H.assertSubtype(result, "$isList", [P.Match], "$asList");
  },
  stringContainsUnchecked: function(receiver, other, startIndex) {
    var t1;
    if (typeof other === "string")
      return receiver.indexOf(other, startIndex) >= 0;
    else {
      t1 = J.getInterceptor(other);
      if (!!t1.$isJSSyntaxRegExp) {
        t1 = C.JSString_methods.substring$1(receiver, startIndex);
        return other._nativeRegExp.test(H.checkString(t1));
      } else
        return J.get$isNotEmpty$asx(t1.allMatches$1(other, C.JSString_methods.substring$1(receiver, startIndex)));
    }
  },
  stringReplaceAllUnchecked: function(receiver, pattern, replacement) {
    var $length, t1, i, nativeRegexp;
    H.checkString(replacement);
    if (typeof pattern === "string")
      if (pattern === "")
        if (receiver === "")
          return replacement;
        else {
          $length = receiver.length;
          for (t1 = replacement, i = 0; i < $length; ++i)
            t1 = t1 + receiver[i] + replacement;
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        }
      else
        return receiver.replace(new RegExp(pattern.replace(new RegExp("[[\\]{}()*+?.\\\\^$|]", 'g'), "\\$&"), 'g'), replacement.replace(/\$/g, "$$$$"));
    else if (pattern instanceof H.JSSyntaxRegExp) {
      nativeRegexp = pattern.get$_nativeGlobalVersion();
      nativeRegexp.lastIndex = 0;
      return receiver.replace(nativeRegexp, replacement.replace(/\$/g, "$$$$"));
    } else
      throw H.wrapException("String.replaceAll(Pattern) UNIMPLEMENTED");
  },
  ReflectionInfo: {
    "^": "Object;jsFunction,data,isAccessor,requiredParameterCount,optionalParameterCount,areOptionalParametersNamed,functionType,cachedSortedIndices",
    static: {ReflectionInfo_ReflectionInfo: function(jsFunction) {
        var data, requiredParametersInfo, optionalParametersInfo;
        data = jsFunction.$reflectionInfo;
        if (data == null)
          return;
        data.fixed$length = Array;
        data = data;
        requiredParametersInfo = data[0];
        optionalParametersInfo = data[1];
        return new H.ReflectionInfo(jsFunction, data, (requiredParametersInfo & 1) === 1, requiredParametersInfo >> 1, optionalParametersInfo >> 1, (optionalParametersInfo & 1) === 1, data[2], null);
      }}
  },
  Primitives_initTicker_closure: {
    "^": "Closure:0;_captured_performance_0",
    call$0: function() {
      return C.JSDouble_methods.toInt$0(H.doubleTypeCheck(Math.floor(1000 * this._captured_performance_0.now())));
    }
  },
  TypeErrorDecoder: {
    "^": "Object;_pattern,_arguments,_argumentsExpr,_expr,_method,_receiver",
    matchTypeError$1: function(message) {
      var match, result, t1;
      match = new RegExp(this._pattern).exec(message);
      if (match == null)
        return;
      result = Object.create(null);
      t1 = this._arguments;
      if (t1 !== -1)
        result.arguments = match[t1 + 1];
      t1 = this._argumentsExpr;
      if (t1 !== -1)
        result.argumentsExpr = match[t1 + 1];
      t1 = this._expr;
      if (t1 !== -1)
        result.expr = match[t1 + 1];
      t1 = this._method;
      if (t1 !== -1)
        result.method = match[t1 + 1];
      t1 = this._receiver;
      if (t1 !== -1)
        result.receiver = match[t1 + 1];
      return result;
    },
    static: {TypeErrorDecoder_extractPattern: function(message) {
        var match, $arguments, argumentsExpr, expr, method, receiver;
        message = message.replace(String({}), '$receiver$').replace(new RegExp("[[\\]{}()*+?.\\\\^$|]", 'g'), '\\$&');
        match = H.assertSubtype(message.match(/\\\$[a-zA-Z]+\\\$/g), "$isList", [P.String], "$asList");
        if (match == null)
          match = H.assertSubtype([], "$isList", [P.String], "$asList");
        $arguments = match.indexOf("\\$arguments\\$");
        argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
        expr = match.indexOf("\\$expr\\$");
        method = match.indexOf("\\$method\\$");
        receiver = match.indexOf("\\$receiver\\$");
        return new H.TypeErrorDecoder(message.replace('\\$arguments\\$', '((?:x|[^x])*)').replace('\\$argumentsExpr\\$', '((?:x|[^x])*)').replace('\\$expr\\$', '((?:x|[^x])*)').replace('\\$method\\$', '((?:x|[^x])*)').replace('\\$receiver\\$', '((?:x|[^x])*)'), $arguments, argumentsExpr, expr, method, receiver);
      }, TypeErrorDecoder_provokeCallErrorOn: function(expression) {
        return function($expr$) {
          var $argumentsExpr$ = '$arguments$';
          try {
            $expr$.$method$($argumentsExpr$);
          } catch (e) {
            return e.message;
          }
        }(expression);
      }, TypeErrorDecoder_provokePropertyErrorOn: function(expression) {
        return function($expr$) {
          try {
            $expr$.$method$;
          } catch (e) {
            return e.message;
          }
        }(expression);
      }}
  },
  NullError: {
    "^": "Error;_message,_method",
    toString$0: function(_) {
      var t1 = this._method;
      if (t1 == null)
        return "NullError: " + H.S(this._message);
      return "NullError: Cannot call \"" + H.S(t1) + "\" on null";
    }
  },
  JsNoSuchMethodError: {
    "^": "Error;_message,_method,_receiver",
    toString$0: function(_) {
      var t1, t2;
      t1 = this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + H.S(this._message);
      t2 = this._receiver;
      if (t2 == null)
        return "NoSuchMethodError: Cannot call \"" + H.S(t1) + "\" (" + H.S(this._message) + ")";
      return "NoSuchMethodError: Cannot call \"" + H.S(t1) + "\" on \"" + H.S(t2) + "\" (" + H.S(this._message) + ")";
    },
    static: {JsNoSuchMethodError$: function(_message, match) {
        var t1, t2;
        H.stringTypeCheck(_message);
        t1 = match == null;
        t2 = t1 ? null : match.method;
        return new H.JsNoSuchMethodError(_message, t2, t1 ? null : match.receiver);
      }}
  },
  UnknownJsTypeError: {
    "^": "Error;_message",
    toString$0: function(_) {
      var t1 = this._message;
      return C.JSString_methods.get$isEmpty(t1) ? "Error" : "Error: " + t1;
    }
  },
  unwrapException_saveStackTrace: {
    "^": "Closure:2;_captured_ex_0",
    call$1: function(error) {
      if (!!J.getInterceptor(error).$isError)
        if (error.$thrownJsError == null)
          error.$thrownJsError = this._captured_ex_0;
      return error;
    }
  },
  _StackTrace: {
    "^": "Object;_exception,_trace",
    toString$0: function(_) {
      var t1, trace;
      t1 = this._trace;
      if (t1 != null)
        return t1;
      t1 = this._exception;
      trace = t1 !== null && typeof t1 === "object" ? t1.stack : null;
      t1 = trace == null ? "" : trace;
      this._trace = t1;
      return t1;
    },
    $isStackTrace: 1
  },
  invokeClosure_closure: {
    "^": "Closure:0;_captured_closure_0",
    call$0: function() {
      return this._captured_closure_0.call$0();
    }
  },
  invokeClosure_closure0: {
    "^": "Closure:0;_captured_closure_1,_captured_arg1_2",
    call$0: function() {
      return this._captured_closure_1.call$1(this._captured_arg1_2);
    }
  },
  invokeClosure_closure1: {
    "^": "Closure:0;_captured_closure_3,_captured_arg1_4,_captured_arg2_5",
    call$0: function() {
      return this._captured_closure_3.call$2(this._captured_arg1_4, this._captured_arg2_5);
    }
  },
  invokeClosure_closure2: {
    "^": "Closure:0;_captured_closure_6,_captured_arg1_7,_captured_arg2_8,_captured_arg3_9",
    call$0: function() {
      return this._captured_closure_6.call$3(this._captured_arg1_7, this._captured_arg2_8, this._captured_arg3_9);
    }
  },
  invokeClosure_closure3: {
    "^": "Closure:0;_captured_closure_10,_captured_arg1_11,_captured_arg2_12,_captured_arg3_13,_captured_arg4_14",
    call$0: function() {
      return this._captured_closure_10.call$4(this._captured_arg1_11, this._captured_arg2_12, this._captured_arg3_13, this._captured_arg4_14);
    }
  },
  Closure: {
    "^": "Object;",
    toString$0: function(_) {
      return "Closure";
    },
    get$$call: function() {
      return this;
    },
    $isFunction: 1,
    get$$call: function() {
      return this;
    }
  },
  TearOffClosure: {
    "^": "Closure;"
  },
  BoundClosure: {
    "^": "TearOffClosure;_self,_target,_receiver,__js_helper$_name",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!(other instanceof H.BoundClosure))
        return false;
      return this._self === other._self && this._target === other._target && this._receiver === other._receiver;
    },
    get$hashCode: function(_) {
      var t1, receiverHashCode;
      t1 = this._receiver;
      if (t1 == null)
        receiverHashCode = H.Primitives_objectHashCode(this._self);
      else
        receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
      return (receiverHashCode ^ H.Primitives_objectHashCode(this._target)) >>> 0;
    },
    static: {BoundClosure_selfOf: function(closure) {
        return closure._self;
      }, BoundClosure_receiverOf: function(closure) {
        return closure._receiver;
      }, BoundClosure_selfFieldName: function() {
        var t1 = $.BoundClosure_selfFieldNameCache;
        if (t1 == null) {
          t1 = H.BoundClosure_computeFieldNamed("self");
          $.BoundClosure_selfFieldNameCache = t1;
        }
        return t1;
      }, BoundClosure_computeFieldNamed: function(fieldName) {
        var template, t1, names, i, $name;
        template = new H.BoundClosure("self", "target", "receiver", "name");
        t1 = H.listTypeCheck(Object.getOwnPropertyNames(template));
        t1.fixed$length = Array;
        names = t1;
        for (t1 = names.length, i = 0; i < t1; ++i) {
          $name = names[i];
          if (template[$name] === fieldName)
            return $name;
        }
      }}
  },
  TypeErrorImplementation: {
    "^": "Error;message",
    toString$0: function(_) {
      return this.message;
    },
    static: {TypeErrorImplementation$: function(value, type) {
        return new H.TypeErrorImplementation("type '" + H.Primitives_objectTypeName(value) + "' is not a subtype of type '" + H.S(type) + "'");
      }}
  },
  CastErrorImplementation: {
    "^": "Error;message",
    toString$0: function(_) {
      return this.message;
    },
    static: {CastErrorImplementation$: function(actualType, expectedType) {
        return new H.CastErrorImplementation("CastError: Casting value of type " + H.S(actualType) + " to incompatible type " + H.S(expectedType));
      }}
  },
  RuntimeError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "RuntimeError: " + H.S(this.message);
    },
    static: {RuntimeError$: function(message) {
        return new H.RuntimeError(message);
      }}
  },
  RuntimeType: {
    "^": "Object;"
  },
  RuntimeFunctionType: {
    "^": "RuntimeType;returnType,parameterTypes,optionalParameterTypes,namedParameters",
    _isTest$1: function(expression) {
      var functionTypeObject = this._extractFunctionTypeObjectFrom$1(expression);
      return functionTypeObject == null ? false : H.isFunctionSubtype(functionTypeObject, this.toRti$0());
    },
    _assertCheck$1: function(expression) {
      var t1;
      if ($.RuntimeFunctionType_inAssert)
        return;
      $.RuntimeFunctionType_inAssert = true;
      try {
        t1 = this._check$2(expression, false);
        return t1;
      } finally {
        $.RuntimeFunctionType_inAssert = false;
      }
    },
    _check$2: function(expression, isCast) {
      var $self, functionTypeObject;
      if (expression == null)
        return;
      if (this._isTest$1(expression))
        return expression;
      $self = new H.FunctionTypeInfoDecoderRing(this.toRti$0(), null).toString$0(0);
      if (isCast) {
        functionTypeObject = this._extractFunctionTypeObjectFrom$1(expression);
        throw H.wrapException(H.CastErrorImplementation$(functionTypeObject != null ? new H.FunctionTypeInfoDecoderRing(functionTypeObject, null).toString$0(0) : H.Primitives_objectTypeName(expression), $self));
      } else
        throw H.wrapException(H.TypeErrorImplementation$(expression, $self));
    },
    _extractFunctionTypeObjectFrom$1: function(o) {
      var interceptor = J.getInterceptor(o);
      return "$signature" in interceptor ? interceptor.$signature() : null;
    },
    toRti$0: function() {
      var result, t1, t2, namedRti, keys, i, $name;
      result = {func: "dynafunc"};
      t1 = this.returnType;
      t2 = J.getInterceptor(t1);
      if (!!t2.$isVoidRuntimeType)
        result.void = true;
      else if (!t2.$isDynamicRuntimeType)
        result.ret = t1.toRti$0();
      t1 = this.parameterTypes;
      if (t1 != null && t1.length !== 0)
        result.args = H.RuntimeFunctionType_listToRti(t1);
      t1 = this.optionalParameterTypes;
      if (t1 != null && t1.length !== 0)
        result.opt = H.RuntimeFunctionType_listToRti(t1);
      t1 = this.namedParameters;
      if (t1 != null) {
        namedRti = Object.create(null);
        keys = H.extractKeys(t1);
        for (t2 = keys.length, i = 0; i < t2; ++i) {
          $name = keys[i];
          namedRti[$name] = t1[$name].toRti$0();
        }
        result.named = namedRti;
      }
      return result;
    },
    toString$0: function(_) {
      var t1, t2, result, needsComma, i, type, keys, $name;
      t1 = this.parameterTypes;
      if (t1 != null)
        for (t2 = t1.length, result = "(", needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
          type = H.interceptedTypeCheck(t1[i], "$isRuntimeType");
          if (needsComma)
            result += ", ";
          result = C.JSString_methods.$add(result, J.toString$0(type));
        }
      else {
        result = "(";
        needsComma = false;
      }
      t1 = this.optionalParameterTypes;
      if (t1 != null && t1.length !== 0) {
        result = (needsComma ? result + ", " : result) + "[";
        for (t2 = t1.length, needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
          type = H.interceptedTypeCheck(t1[i], "$isRuntimeType");
          if (needsComma)
            result += ", ";
          result = C.JSString_methods.$add(result, J.toString$0(type));
        }
        result += "]";
      } else {
        t1 = this.namedParameters;
        if (t1 != null) {
          result = (needsComma ? result + ", " : result) + "{";
          keys = H.extractKeys(t1);
          for (t2 = keys.length, needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
            $name = keys[i];
            if (needsComma)
              result += ", ";
            result += H.S(t1[$name].toRti$0()) + " " + $name;
          }
          result += "}";
        }
      }
      return result + (") -> " + J.toString$0(this.returnType));
    },
    static: {RuntimeFunctionType_listToRti: function(list) {
        var result, t1, i;
        list = list;
        result = [];
        for (t1 = list.length, i = 0; i < t1; ++i)
          result.push(list[i].toRti$0());
        return result;
      }}
  },
  DynamicRuntimeType: {
    "^": "RuntimeType;",
    toString$0: function(_) {
      return "dynamic";
    },
    toRti$0: function() {
      return;
    }
  },
  VoidRuntimeType: {
    "^": "RuntimeType;",
    toString$0: function(_) {
      return "void";
    },
    toRti$0: function() {
      return H.throwExpression("internal error");
    }
  },
  RuntimeTypePlain: {
    "^": "RuntimeType;name>",
    toRti$0: function() {
      var t1, rti;
      t1 = this.name;
      rti = init.getTypeFromName(t1);
      if (rti == null)
        throw H.wrapException("no type for '" + H.S(t1) + "'");
      return rti;
    },
    toString$0: function(_) {
      return this.name;
    }
  },
  RuntimeTypeGeneric: {
    "^": "RuntimeType;name>,$arguments,rti",
    toRti$0: function() {
      var t1, result, t2, t3;
      t1 = this.rti;
      if (t1 != null)
        return t1;
      t1 = this.name;
      result = [init.getTypeFromName(t1)];
      if (0 >= result.length)
        return H.ioore(result, 0);
      if (result[0] == null)
        throw H.wrapException("no type for '" + H.S(t1) + "<...>'");
      for (t1 = this.$arguments, t1.toString, t2 = H.getTypeArgumentByIndex(t1, 0), H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3 = t1.length, t1 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"); t1.moveNext$0();)
        result.push(H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0)), "$isRuntimeType").toRti$0());
      this.rti = result;
      return result;
    },
    toString$0: function(_) {
      var t1 = this.$arguments;
      return H.S(this.name) + "<" + (t1 && C.JSArray_methods).join$1(t1, ", ") + ">";
    }
  },
  FunctionTypeInfoDecoderRing: {
    "^": "Object;_typeData,_cachedToString",
    _convert$1: function(type) {
      var result = H.runtimeTypeToString(type, null);
      if (result != null)
        return result;
      if ("func" in type)
        return new H.FunctionTypeInfoDecoderRing(type, null).toString$0(0);
      else
        throw H.wrapException("bad type");
    },
    toString$0: function(_) {
      var t1, t2, t3, t4, s, sep, argument, $name;
      t1 = this._cachedToString;
      if (t1 != null)
        return t1;
      t1 = this._typeData;
      if ("args" in t1)
        for (t2 = t1.args, t3 = H.getTypeArgumentByIndex(t2, 0), H.assertSubtype(t2, "$isJSArray", [t3], "$asJSArray"), t4 = t2.length, t2 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t2, "$isJSArray", [t3], "$asJSArray"), t4, 0, H.assertSubtypeOfRuntimeType(null, t3)), [t3]), "$isIterator", [H.getTypeArgumentByIndex(t2, 0)], "$asIterator"), s = "(", sep = ""; t2.moveNext$0(); sep = ", ") {
          argument = H.assertSubtypeOfRuntimeType(t2._current, H.getTypeArgumentByIndex(t2, 0));
          s = C.JSString_methods.$add(s + sep, this._convert$1(argument));
        }
      else {
        s = "(";
        sep = "";
      }
      if ("opt" in t1) {
        s += sep + "[";
        for (t2 = t1.opt, t3 = H.getTypeArgumentByIndex(t2, 0), H.assertSubtype(t2, "$isJSArray", [t3], "$asJSArray"), t4 = t2.length, t2 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t2, "$isJSArray", [t3], "$asJSArray"), t4, 0, H.assertSubtypeOfRuntimeType(null, t3)), [t3]), "$isIterator", [H.getTypeArgumentByIndex(t2, 0)], "$asIterator"), sep = ""; t2.moveNext$0(); sep = ", ") {
          argument = H.assertSubtypeOfRuntimeType(t2._current, H.getTypeArgumentByIndex(t2, 0));
          s = C.JSString_methods.$add(s + sep, this._convert$1(argument));
        }
        s += "]";
      }
      if ("named" in t1) {
        s += sep + "{";
        for (t2 = H.extractKeys(t1.named), t3 = H.getTypeArgumentByIndex(t2, 0), H.assertSubtype(t2, "$isJSArray", [t3], "$asJSArray"), t2 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t2, "$isJSArray", [t3], "$asJSArray"), t2.length, 0, H.assertSubtypeOfRuntimeType(null, t3)), [t3]), "$isIterator", [H.getTypeArgumentByIndex(t2, 0)], "$asIterator"), sep = ""; t2.moveNext$0(); sep = ", ") {
          $name = H.assertSubtypeOfRuntimeType(t2._current, H.getTypeArgumentByIndex(t2, 0));
          s = C.JSString_methods.$add(s + sep + (H.S($name) + ": "), this._convert$1(t1.named[$name]));
        }
        s += "}";
      }
      s += ") -> ";
      if (!!t1.void)
        s += "void";
      else
        s = "ret" in t1 ? C.JSString_methods.$add(s, this._convert$1(t1.ret)) : s + "dynamic";
      this._cachedToString = s;
      return s;
    }
  },
  TypeImpl: {
    "^": "Object;_typeName,_unmangledName",
    toString$0: function(_) {
      var t1, unmangledName;
      t1 = this._unmangledName;
      if (t1 != null)
        return t1;
      unmangledName = this._typeName.replace(/[^<,> ]+/g, function(m) {
        return init.mangledGlobalNames[m] || m;
      });
      this._unmangledName = unmangledName;
      return unmangledName;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this._typeName);
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (other instanceof H.TypeImpl) {
        t1 = this._typeName;
        t2 = other._typeName;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    $isType: 1
  },
  JsLinkedHashMap: {
    "^": "Object;__js_helper$_length,_strings,_nums,_rest,_first,_last,_modifications",
    get$length: function(_) {
      return this.__js_helper$_length;
    },
    get$isEmpty: function(_) {
      return this.__js_helper$_length === 0;
    },
    get$keys: function(_) {
      return H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.LinkedHashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]), "$isIterable");
    },
    get$values: function(_) {
      return H.listSuperNativeTypeCheck(H.MappedIterable_MappedIterable(H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.LinkedHashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]), "$isIterable"), new H.JsLinkedHashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)), "$isIterable");
    },
    containsKey$1: function(_, key) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return false;
        return H.interceptedTypeCheck(strings[key], "$isLinkedHashMapCell") != null;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return false;
        return H.interceptedTypeCheck(nums[key], "$isLinkedHashMapCell") != null;
      } else
        return this.internalContainsKey$1(key);
    },
    internalContainsKey$1: function(key) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this.internalFindBucketIndex$2(H.listTypeCheck(rest[this.internalComputeHashCode$1(key)]), key) >= 0;
    },
    $index: function(_, key) {
      var strings, cell, t1, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 1));
        cell = H.interceptedTypeCheck(strings[key], "$isLinkedHashMapCell");
        t1 = cell == null ? null : cell.hashMapCellValue;
        return H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(this, 1));
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 1));
        cell = H.interceptedTypeCheck(nums[key], "$isLinkedHashMapCell");
        t1 = cell == null ? null : cell.hashMapCellValue;
        return H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(this, 1));
      } else
        return H.assertSubtypeOfRuntimeType(this.internalGet$1(key), H.getTypeArgumentByIndex(this, 1));
    },
    internalGet$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 1));
      bucket = H.listTypeCheck(rest[this.internalComputeHashCode$1(key)]);
      index = this.internalFindBucketIndex$2(bucket, key);
      if (index < 0)
        return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 1));
      return H.assertSubtypeOfRuntimeType(H.interceptedTypeCheck(bucket[index], "$isLinkedHashMapCell").hashMapCellValue, H.getTypeArgumentByIndex(this, 1));
    },
    $indexSet: function(_, key, value) {
      var strings, nums;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1));
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          strings = H.JsLinkedHashMap__newHashTable();
          this._strings = strings;
        }
        this._addHashTableEntry$3(strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null) {
          nums = H.JsLinkedHashMap__newHashTable();
          this._nums = nums;
        }
        this._addHashTableEntry$3(nums, key, value);
      } else
        this.internalSet$2(key, value);
    },
    internalSet$2: function(key, value) {
      var rest, hash, bucket, t1, index;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1));
      rest = this._rest;
      if (rest == null) {
        rest = H.JsLinkedHashMap__newHashTable();
        this._rest = rest;
      }
      hash = this.internalComputeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null) {
        t1 = [this._newLinkedCell$2(key, value)];
        H.assertHelper(t1 != null);
        rest[hash] = t1;
      } else {
        index = this.internalFindBucketIndex$2(bucket, key);
        if (index >= 0)
          H.interceptedTypeCheck(bucket[index], "$isLinkedHashMapCell").hashMapCellValue = value;
        else
          bucket.push(this._newLinkedCell$2(key, value));
      }
    },
    putIfAbsent$2: function(_, key, ifAbsent) {
      var t1, value;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
      t1 = H.buildFunctionType(this.V())._assertCheck$1(ifAbsent);
      if (this.containsKey$1(0, key))
        return H.assertSubtypeOfRuntimeType(this.$index(0, key), H.getTypeArgumentByIndex(this, 1));
      value = H.assertSubtypeOfRuntimeType(t1.call$0(), H.getTypeArgumentByIndex(this, 1));
      this.$indexSet(0, key, value);
      return H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1));
    },
    remove$1: function(_, key) {
      if (typeof key === "string" && key !== "__proto__")
        return H.assertSubtypeOfRuntimeType(this.__js_helper$_removeHashTableEntry$2(this._strings, key), H.getTypeArgumentByIndex(this, 1));
      else if (typeof key === "number" && (key & 0x3ffffff) === key)
        return H.assertSubtypeOfRuntimeType(this.__js_helper$_removeHashTableEntry$2(this._nums, key), H.getTypeArgumentByIndex(this, 1));
      else
        return H.assertSubtypeOfRuntimeType(this.internalRemove$1(key), H.getTypeArgumentByIndex(this, 1));
    },
    internalRemove$1: function(key) {
      var rest, bucket, index, cell;
      rest = this._rest;
      if (rest == null)
        return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 1));
      bucket = H.listTypeCheck(rest[this.internalComputeHashCode$1(key)]);
      index = this.internalFindBucketIndex$2(bucket, key);
      if (index < 0)
        return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 1));
      cell = H.interceptedTypeCheck(bucket.splice(index, 1)[0], "$isLinkedHashMapCell");
      this.__js_helper$_unlinkCell$1(cell);
      return H.assertSubtypeOfRuntimeType(cell.hashMapCellValue, H.getTypeArgumentByIndex(this, 1));
    },
    clear$0: function(_) {
      if (this.__js_helper$_length > 0) {
        this._last = null;
        this._first = null;
        this._rest = null;
        this._nums = null;
        this._strings = null;
        this.__js_helper$_length = 0;
        this._modifications = this._modifications + 1 & 67108863;
      }
    },
    forEach$1: function(_, action) {
      var t1, cell, modifications;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [this.K(), this.V()])._assertCheck$1(action);
      cell = this._first;
      modifications = this._modifications;
      for (; cell != null;) {
        t1.call$2(cell.hashMapCellKey, cell.hashMapCellValue);
        if (modifications !== this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        cell = cell._next;
      }
    },
    _addHashTableEntry$3: function(table, key, value) {
      var cell, t1;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1));
      cell = H.interceptedTypeCheck(table[key], "$isLinkedHashMapCell");
      if (cell == null) {
        t1 = this._newLinkedCell$2(key, value);
        H.assertHelper(true);
        table[key] = t1;
      } else
        cell.hashMapCellValue = value;
    },
    __js_helper$_removeHashTableEntry$2: function(table, key) {
      var cell;
      if (table == null)
        return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 1));
      cell = H.interceptedTypeCheck(table[key], "$isLinkedHashMapCell");
      if (cell == null)
        return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 1));
      this.__js_helper$_unlinkCell$1(cell);
      delete table[key];
      return H.assertSubtypeOfRuntimeType(cell.hashMapCellValue, H.getTypeArgumentByIndex(this, 1));
    },
    _newLinkedCell$2: function(key, value) {
      var cell, last;
      cell = new H.LinkedHashMapCell(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1)), null, null);
      if (this._first == null) {
        this._last = cell;
        this._first = cell;
      } else {
        last = this._last;
        cell._previous = last;
        last._next = cell;
        this._last = cell;
      }
      ++this.__js_helper$_length;
      this._modifications = this._modifications + 1 & 67108863;
      return cell;
    },
    __js_helper$_unlinkCell$1: function(cell) {
      var previous, next, t1;
      previous = cell._previous;
      next = cell._next;
      if (previous == null) {
        t1 = this._first;
        H.assertHelper(cell == null ? t1 == null : cell === t1);
        this._first = next;
      } else
        previous._next = next;
      if (next == null) {
        t1 = this._last;
        H.assertHelper(cell == null ? t1 == null : cell === t1);
        this._last = previous;
      } else
        next._previous = previous;
      --this.__js_helper$_length;
      this._modifications = this._modifications + 1 & 67108863;
    },
    internalComputeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    internalFindBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(H.interceptedTypeCheck(bucket[i], "$isLinkedHashMapCell").hashMapCellKey, key))
          return i;
      return -1;
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    K: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    V: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[1]);
    },
    $isInternalMap: 1,
    $isLinkedHashMap: 1,
    $isMap: 1,
    $asMap: null,
    static: {JsLinkedHashMap__newHashTable: function() {
        var table = Object.create(null);
        H.assertHelper(table != null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  JsLinkedHashMap_values_closure: {
    "^": "Closure:2;__js_helper$_captured_this_0",
    call$1: function(each) {
      return this.__js_helper$_captured_this_0.$index(0, each);
    }
  },
  LinkedHashMapCell: {
    "^": "Object;hashMapCellKey,hashMapCellValue,_next,_previous"
  },
  LinkedHashMapKeyIterable: {
    "^": "IterableBase;_map",
    get$length: function(_) {
      return this._map.__js_helper$_length;
    },
    get$isEmpty: function(_) {
      return this._map.__js_helper$_length === 0;
    },
    get$iterator: function(_) {
      var t1, t2;
      t1 = this._map;
      t2 = new H.LinkedHashMapKeyIterator(t1, t1._modifications, null, H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 0)));
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      t2.__js_helper$_cell = t1._first;
      return H.assertSubtype(t2, "$isIterator", [H.getTypeArgumentByIndex(this, 0)], "$asIterator");
    },
    forEach$1: function(_, f) {
      var t1, t2, cell, modifications;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [this.E4()])._assertCheck$1(f);
      t2 = this._map;
      cell = t2._first;
      modifications = t2._modifications;
      for (; cell != null;) {
        t1.call$1(cell.hashMapCellKey);
        if (modifications !== t2._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(t2));
        cell = cell._next;
      }
    },
    E4: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    E: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isEfficientLength: 1
  },
  LinkedHashMapKeyIterator: {
    "^": "Object;_map,_modifications,__js_helper$_cell,__js_helper$_current",
    set$__js_helper$_current: function(_current) {
      this.__js_helper$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    get$current: function() {
      return H.assertSubtypeOfRuntimeType(this.__js_helper$_current, H.getTypeArgumentByIndex(this, 0));
    },
    moveNext$0: function() {
      var t1 = this._map;
      if (this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = this.__js_helper$_cell;
        if (t1 == null) {
          this.set$__js_helper$_current(null);
          return false;
        } else {
          this.set$__js_helper$_current(t1.hashMapCellKey);
          this.__js_helper$_cell = this.__js_helper$_cell._next;
          return true;
        }
      }
    },
    $isIterator: 1
  },
  initHooks_closure: {
    "^": "Closure:2;_captured_getTag_0",
    call$1: function(o) {
      return this._captured_getTag_0(o);
    }
  },
  initHooks_closure0: {
    "^": "Closure:4;_captured_getUnknownTag_1",
    call$2: function(o, tag) {
      return this._captured_getUnknownTag_1(o, tag);
    }
  },
  initHooks_closure1: {
    "^": "Closure:3;_captured_prototypeForTag_2",
    call$1: function(tag) {
      return this._captured_prototypeForTag_2(H.stringTypeCheck(tag));
    }
  },
  JSSyntaxRegExp: {
    "^": "Object;pattern,_nativeRegExp,_nativeGlobalRegExp,_nativeAnchoredRegExp",
    toString$0: function(_) {
      return "RegExp/" + this.pattern + "/";
    },
    get$_nativeGlobalVersion: function() {
      var t1 = this._nativeGlobalRegExp;
      if (t1 != null)
        return t1;
      t1 = this._nativeRegExp;
      t1 = H.JSSyntaxRegExp_makeNative(this.pattern, t1.multiline, !t1.ignoreCase, true);
      this._nativeGlobalRegExp = t1;
      return t1;
    },
    get$_nativeAnchoredVersion: function() {
      var t1 = this._nativeAnchoredRegExp;
      if (t1 != null)
        return t1;
      t1 = this._nativeRegExp;
      t1 = H.JSSyntaxRegExp_makeNative(this.pattern + "|()", t1.multiline, !t1.ignoreCase, true);
      this._nativeAnchoredRegExp = t1;
      return t1;
    },
    firstMatch$1: function(string) {
      var m = H.assertSubtype(this._nativeRegExp.exec(H.checkString(H.stringTypeCheck(string))), "$isList", [P.String], "$asList");
      if (m == null)
        return;
      return H._MatchImplementation$(this, m);
    },
    allMatches$2: function(_, string, start) {
      H.checkString(string);
      H.checkInt(start);
      if (start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      return H.listSuperNativeTypeCheck(new H._AllMatchesIterable(this, string, start), "$isIterable");
    },
    allMatches$1: function($receiver, string) {
      return this.allMatches$2($receiver, string, 0);
    },
    _execGlobal$2: function(string, start) {
      var regexp, match;
      regexp = this.get$_nativeGlobalVersion();
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return;
      return H._MatchImplementation$(this, match);
    },
    _execAnchored$2: function(string, start) {
      var regexp, match, t1, t2;
      regexp = this.get$_nativeAnchoredVersion();
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return;
      t1 = match.length;
      t2 = t1 - 1;
      if (t2 < 0)
        return H.ioore(match, t2);
      if (match[t2] != null)
        return;
      C.JSArray_methods.set$length(match, t2);
      return H._MatchImplementation$(this, match);
    },
    matchAsPrefix$2: function(_, string, start) {
      if (start < 0 || start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      return this._execAnchored$2(string, start);
    },
    $isRegExp: 1,
    $isPattern: 1,
    static: {JSSyntaxRegExp_makeNative: function(source, multiLine, caseSensitive, global) {
        var m, i, g, regexp;
        H.checkString(source);
        m = multiLine ? "m" : "";
        i = caseSensitive ? "" : "i";
        g = global ? "g" : "";
        regexp = function() {
          try {
            return new RegExp(source, m + i + g);
          } catch (e) {
            return e;
          }
        }();
        if (regexp instanceof RegExp)
          return regexp;
        throw H.wrapException(P.FormatException$("Illegal RegExp pattern (" + String(regexp) + ")", source, null));
      }}
  },
  _MatchImplementation: {
    "^": "Object;pattern,_match",
    $index: function(_, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = this._match;
      if (index >= t1.length)
        return H.ioore(t1, index);
      return H.stringTypeCheck(t1[index]);
    },
    _MatchImplementation$2: function(pattern, _match) {
      var t1, t2;
      H.assertSubtype(_match, "$isList", [P.String], "$asList");
      t1 = this._match;
      t2 = t1.input;
      H.assertHelper(typeof t2 === "string");
      t1 = t1.index;
      H.assertHelper(typeof t1 === "number" && Math.floor(t1) === t1);
    },
    $isMatch: 1,
    static: {_MatchImplementation$: function(pattern, _match) {
        var t1;
        H.assertSubtype(_match, "$isList", [P.String], "$asList");
        t1 = new H._MatchImplementation(pattern, H.assertSubtype(_match, "$isList", [P.String], "$asList"));
        t1._MatchImplementation$2(pattern, _match);
        return t1;
      }}
  },
  _AllMatchesIterable: {
    "^": "IterableBase;_re,_string,_start",
    get$iterator: function(_) {
      return H.assertSubtype(new H._AllMatchesIterator(this._re, this._string, this._start, null), "$isIterator", [P.Match], "$asIterator");
    },
    E: function() {
      return H.convertRtiToRuntimeType(function() {
        return P.Match;
      }.apply(null, this.$builtinTypeInfo));
    },
    $asIterableBase: function() {
      return [P.Match];
    },
    $asIterable: function() {
      return [P.Match];
    }
  },
  _AllMatchesIterator: {
    "^": "Object;_regExp,_string,_nextIndex,__js_helper$_current",
    get$current: function() {
      return this.__js_helper$_current;
    },
    moveNext$0: function() {
      var t1, t2, match, nextIndex;
      t1 = this._string;
      if (t1 == null)
        return false;
      t2 = this._nextIndex;
      if (t2 <= t1.length) {
        match = this._regExp._execGlobal$2(t1, t2);
        if (match != null) {
          this.__js_helper$_current = match;
          t1 = match._match;
          t2 = t1.index;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          nextIndex = H.intTypeCheck(C.JSInt_methods.$add(t2, J.get$length$asx(t1[0])));
          this._nextIndex = t1.index === nextIndex ? nextIndex + 1 : nextIndex;
          return true;
        }
      }
      this.__js_helper$_current = null;
      this._string = null;
      return false;
    },
    $isIterator: 1,
    $asIterator: function() {
      return [P.Match];
    }
  },
  StringMatch: {
    "^": "Object;start,input,pattern",
    $index: function(_, g) {
      H.intTypeCheck(g);
      if (g !== 0)
        H.throwExpression(P.RangeError$value(g, null, null));
      return this.pattern;
    },
    $isMatch: 1
  }
}],
["", "bodega.html.dart", , M, {
  "^": "",
  main: [function() {
    var t1, t2, t3, presenter, storage;
    t1 = P.Stream_Stream$periodic(C.Duration_1000000, null, null);
    t2 = H.setRuntimeTypeInfo([], [G.EgbMetaElement]);
    t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
    presenter = new G.HtmlPresenter(null, null, null, null, null, null, 1, new P.StringBuffer(""), null, null, t1, null, H.assertSubtype(t2, "$isList", [G.EgbMetaElement], "$asList"), null, H.assertSubtype(null, "$isList", [Z.UIStat], "$asList"), H.assertSubtype(t3, "$isMap", [P.String, W.Element], "$asMap"), null, null, null, null);
    storage = new G.LocalStorage();
    t3 = new V.EgbPlayerProfile("default", null, H.assertSubtype(null, "$isMap", [P.String, null], "$asMap"), H.assertSubtype(null, "$isQueue", [P.String], "$asQueue"), storage, 10);
    t3._loadPreferences$0();
    presenter._playerProfile = t3;
    M.runFromIsolate("bodega.dart", presenter, storage);
  }, "call$0", "main$closure", 0, 0, 1]
},
1],
["choice_with_infochips", "package:egamebook/src/presenter/choice_with_infochips.dart", , K, {
  "^": "",
  ChoiceWithInfochips: {
    "^": "Object;text>,infochips",
    set$text: function(_, text) {
      this.text = H.stringTypeCheck(text);
    },
    set$infochips: function(infochips) {
      this.infochips = H.assertSubtype(infochips, "$isList", [P.String], "$asList");
    },
    ChoiceWithInfochips$1: function(raw) {
      var t1, level, lastOpenBracketIndex, encounteredFirstChip, i, t2, chipText;
      if (raw == null)
        throw H.wrapException(P.ArgumentError$("Cannot create ChoiceWithInfochips from a null string."));
      this.text = raw;
      this.set$infochips(H.setRuntimeTypeInfo([], [P.String]));
      for (t1 = raw.length, level = 0, lastOpenBracketIndex = null, encounteredFirstChip = false, i = 0; i < t1; ++i) {
        t2 = raw[i];
        if (t2 === "[") {
          if (!encounteredFirstChip) {
            this.text = C.JSString_methods.substring$2(raw, 0, i);
            encounteredFirstChip = true;
          }
          ++level;
          lastOpenBracketIndex = i;
          continue;
        }
        if (t2 === "]") {
          if (level === 1)
            if (C.JSInt_methods.$sub(i, lastOpenBracketIndex) > 1) {
              if (typeof lastOpenBracketIndex !== "number")
                return lastOpenBracketIndex.$add();
              chipText = C.JSString_methods.substring$2(raw, lastOpenBracketIndex + 1, i);
              t2 = this.infochips;
              (t2 && C.JSArray_methods).add$1(t2, chipText);
            } else if (this.infochips.length === 0)
              this.text = raw;
          --level;
          continue;
        }
      }
      if (level !== 0) {
        this.set$infochips(C.List_empty);
        this.text = raw;
      }
    },
    static: {ChoiceWithInfochips$: function(raw) {
        var t1 = new K.ChoiceWithInfochips(null, H.assertSubtype(null, "$isList", [P.String], "$asList"));
        t1.ChoiceWithInfochips$1(raw);
        return t1;
      }}
  }
}],
["constants", "package:html5lib/src/constants.dart", , F, {
  "^": "",
  Namespaces_getPrefix: function(url) {
    switch (url) {
      case "http://www.w3.org/1999/xhtml":
        return "html";
      case "http://www.w3.org/1998/Math/MathML":
        return "math";
      case "http://www.w3.org/2000/svg":
        return "svg";
      case "http://www.w3.org/1999/xlink":
        return "xlink";
      case "http://www.w3.org/XML/1998/namespace":
        return "xml";
      case "http://www.w3.org/2000/xmlns/":
        return "xmlns";
      default:
        throw H.wrapException(P.ArgumentError$(url));
    }
  }
}],
["dart._internal", "dart:_internal", , H, {
  "^": "",
  IterableElementError_noElement: function() {
    return new P.StateError("No element");
  },
  IterableElementError_tooMany: function() {
    return new P.StateError("Too many elements");
  },
  IterableElementError_tooFew: function() {
    return new P.StateError("Too few elements");
  },
  Sort__doSort: function(a, left, right, compare) {
    var t1 = H.getDynamicRuntimeType();
    t1 = H.buildFunctionType(H.buildInterfaceType(P.$int), [t1, t1])._assertCheck$1(compare);
    if (right - left <= 32)
      H.Sort__insertionSort(a, left, right, t1);
    else
      H.Sort__dualPivotQuicksort(a, left, right, t1);
  },
  Sort__insertionSort: function(a, left, right, compare) {
    var t1, i, t2, el, j, j0;
    t1 = H.getDynamicRuntimeType();
    t1 = H.buildFunctionType(H.buildInterfaceType(P.$int), [t1, t1])._assertCheck$1(compare);
    for (i = left + 1, t2 = J.getInterceptor$asx(a); i <= right; ++i) {
      el = t2.$index(a, i);
      j = i;
      while (true) {
        if (!(j > left && J.$gt$n(t1.call$2(t2.$index(a, j - 1), el), 0)))
          break;
        j0 = j - 1;
        t2.$indexSet(a, j, t2.$index(a, j0));
        j = j0;
      }
      t2.$indexSet(a, j, el);
    }
  },
  Sort__dualPivotQuicksort: function(a, left, right, compare) {
    var t1, t2, sixth, index1, index5, index3, index2, index4, el1, el2, el3, el4, el5, t0, less, great, k, ak, comp, great0, less0, pivots_are_equal, comp_pivot1, comp_pivot2, t3;
    t1 = H.getDynamicRuntimeType();
    t1 = H.buildFunctionType(H.buildInterfaceType(P.$int), [t1, t1])._assertCheck$1(compare);
    t2 = right - left;
    H.assertHelper(t2 > 32);
    sixth = C.JSInt_methods._tdivFast$1(t2 + 1, 6);
    index1 = left + sixth;
    index5 = right - sixth;
    index3 = C.JSInt_methods._tdivFast$1(left + right, 2);
    index2 = index3 - sixth;
    index4 = index3 + sixth;
    t2 = J.getInterceptor$asx(a);
    el1 = t2.$index(a, index1);
    el2 = t2.$index(a, index2);
    el3 = t2.$index(a, index3);
    el4 = t2.$index(a, index4);
    el5 = t2.$index(a, index5);
    if (J.$gt$n(t1.call$2(el1, el2), 0)) {
      t0 = el2;
      el2 = el1;
      el1 = t0;
    }
    if (J.$gt$n(t1.call$2(el4, el5), 0)) {
      t0 = el5;
      el5 = el4;
      el4 = t0;
    }
    if (J.$gt$n(t1.call$2(el1, el3), 0)) {
      t0 = el3;
      el3 = el1;
      el1 = t0;
    }
    if (J.$gt$n(t1.call$2(el2, el3), 0)) {
      t0 = el3;
      el3 = el2;
      el2 = t0;
    }
    if (J.$gt$n(t1.call$2(el1, el4), 0)) {
      t0 = el4;
      el4 = el1;
      el1 = t0;
    }
    if (J.$gt$n(t1.call$2(el3, el4), 0)) {
      t0 = el4;
      el4 = el3;
      el3 = t0;
    }
    if (J.$gt$n(t1.call$2(el2, el5), 0)) {
      t0 = el5;
      el5 = el2;
      el2 = t0;
    }
    if (J.$gt$n(t1.call$2(el2, el3), 0)) {
      t0 = el3;
      el3 = el2;
      el2 = t0;
    }
    if (J.$gt$n(t1.call$2(el4, el5), 0)) {
      t0 = el5;
      el5 = el4;
      el4 = t0;
    }
    t2.$indexSet(a, index1, el1);
    t2.$indexSet(a, index3, el3);
    t2.$indexSet(a, index5, el5);
    t2.$indexSet(a, index2, t2.$index(a, left));
    t2.$indexSet(a, index4, t2.$index(a, right));
    less = left + 1;
    great = right - 1;
    if (J.$eq(t1.call$2(el2, el4), 0)) {
      for (k = less; k <= great; ++k) {
        ak = t2.$index(a, k);
        comp = H.intTypeCheck(t1.call$2(ak, el2));
        if (comp === 0)
          continue;
        if (typeof comp !== "number")
          return comp.$lt();
        if (comp < 0) {
          if (k !== less) {
            t2.$indexSet(a, k, t2.$index(a, less));
            t2.$indexSet(a, less, ak);
          }
          ++less;
        } else
          for (; true;) {
            comp = H.intTypeCheck(t1.call$2(t2.$index(a, great), el2));
            if (typeof comp !== "number")
              return comp.$gt();
            if (comp > 0) {
              --great;
              continue;
            } else {
              great0 = great - 1;
              if (comp < 0) {
                t2.$indexSet(a, k, t2.$index(a, less));
                less0 = less + 1;
                t2.$indexSet(a, less, t2.$index(a, great));
                t2.$indexSet(a, great, ak);
                great = great0;
                less = less0;
                break;
              } else {
                t2.$indexSet(a, k, t2.$index(a, great));
                t2.$indexSet(a, great, ak);
                great = great0;
                break;
              }
            }
          }
      }
      pivots_are_equal = true;
    } else {
      for (k = less; k <= great; ++k) {
        ak = t2.$index(a, k);
        comp_pivot1 = H.intTypeCheck(t1.call$2(ak, el2));
        if (typeof comp_pivot1 !== "number")
          return comp_pivot1.$lt();
        if (comp_pivot1 < 0) {
          if (k !== less) {
            t2.$indexSet(a, k, t2.$index(a, less));
            t2.$indexSet(a, less, ak);
          }
          ++less;
        } else {
          comp_pivot2 = H.intTypeCheck(t1.call$2(ak, el4));
          if (typeof comp_pivot2 !== "number")
            return comp_pivot2.$gt();
          if (comp_pivot2 > 0)
            for (; true;) {
              comp = H.intTypeCheck(t1.call$2(t2.$index(a, great), el4));
              if (typeof comp !== "number")
                return comp.$gt();
              if (comp > 0) {
                --great;
                if (great < k)
                  break;
                continue;
              } else {
                comp = H.intTypeCheck(t1.call$2(t2.$index(a, great), el2));
                if (typeof comp !== "number")
                  return comp.$lt();
                great0 = great - 1;
                if (comp < 0) {
                  t2.$indexSet(a, k, t2.$index(a, less));
                  less0 = less + 1;
                  t2.$indexSet(a, less, t2.$index(a, great));
                  t2.$indexSet(a, great, ak);
                  great = great0;
                  less = less0;
                } else {
                  t2.$indexSet(a, k, t2.$index(a, great));
                  t2.$indexSet(a, great, ak);
                  great = great0;
                }
                break;
              }
            }
        }
      }
      pivots_are_equal = false;
    }
    t3 = less - 1;
    t2.$indexSet(a, left, t2.$index(a, t3));
    t2.$indexSet(a, t3, el2);
    t3 = great + 1;
    t2.$indexSet(a, right, t2.$index(a, t3));
    t2.$indexSet(a, t3, el4);
    H.Sort__doSort(a, left, less - 2, t1);
    H.Sort__doSort(a, great + 2, right, t1);
    if (pivots_are_equal)
      return;
    if (less < index1 && great > index5) {
      for (; J.$eq(t1.call$2(t2.$index(a, less), el2), 0);)
        ++less;
      for (; J.$eq(t1.call$2(t2.$index(a, great), el4), 0);)
        --great;
      for (k = less; k <= great; ++k) {
        ak = t2.$index(a, k);
        if (H.intTypeCheck(t1.call$2(ak, el2)) === 0) {
          if (k !== less) {
            t2.$indexSet(a, k, t2.$index(a, less));
            t2.$indexSet(a, less, ak);
          }
          ++less;
        } else if (H.intTypeCheck(t1.call$2(ak, el4)) === 0)
          for (; true;)
            if (H.intTypeCheck(t1.call$2(t2.$index(a, great), el4)) === 0) {
              --great;
              if (great < k)
                break;
              continue;
            } else {
              comp = H.intTypeCheck(t1.call$2(t2.$index(a, great), el2));
              if (typeof comp !== "number")
                return comp.$lt();
              great0 = great - 1;
              if (comp < 0) {
                t2.$indexSet(a, k, t2.$index(a, less));
                less0 = less + 1;
                t2.$indexSet(a, less, t2.$index(a, great));
                t2.$indexSet(a, great, ak);
                great = great0;
                less = less0;
              } else {
                t2.$indexSet(a, k, t2.$index(a, great));
                t2.$indexSet(a, great, ak);
                great = great0;
              }
              break;
            }
      }
      H.Sort__doSort(a, less, great, t1);
    } else
      H.Sort__doSort(a, less, great, t1);
  },
  Symbol_getName: function(symbol) {
    return symbol.get$_name();
  },
  ListIterable: {
    "^": "IterableBase;",
    get$iterator: function(_) {
      var t1, t2;
      t1 = H.getRuntimeTypeArgument(this, "ListIterable", 0);
      H.listSuperNativeTypeCheck(this, "$isIterable");
      t2 = this.get$length(this);
      return H.assertSubtype(H.setRuntimeTypeInfo(new H.ListIterator(H.listSuperNativeTypeCheck(this, "$isIterable"), t2, 0, H.assertSubtypeOfRuntimeType(null, t1)), [t1]), "$isIterator", [H.getRuntimeTypeArgument(this, "ListIterable", 0)], "$asIterator");
    },
    forEach$1: function(_, action) {
      var t1, $length, i;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [this.E3()])._assertCheck$1(action);
      $length = this.get$length(this);
      for (i = 0; i < $length; ++i) {
        t1.call$1(this.elementAt$1(0, i));
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    get$last: function(_) {
      if (this.get$length(this) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      return H.assertSubtypeOfRuntimeType(this.elementAt$1(0, this.get$length(this) - 1), H.getRuntimeTypeArgument(this, "ListIterable", 0));
    },
    join$1: function(_, separator) {
      var $length, first, buffer, i, t1;
      $length = this.get$length(this);
      if (separator.length !== 0) {
        if ($length === 0)
          return "";
        first = H.S(this.elementAt$1(0, 0));
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
        buffer = new P.StringBuffer(first);
        for (i = 1; i < $length; ++i) {
          buffer._contents += separator;
          buffer._contents += H.S(this.elementAt$1(0, i));
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        t1 = buffer._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      } else {
        buffer = new P.StringBuffer("");
        for (i = 0; i < $length; ++i) {
          buffer._contents += H.S(this.elementAt$1(0, i));
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        t1 = buffer._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
    },
    toList$1$growable: function(_, growable) {
      var result, t1, i;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
        C.JSArray_methods.set$length(result, this.get$length(this));
        H.assertSubtype(result, "$isList", [H.getRuntimeTypeArgument(this, "ListIterable", 0)], "$asList");
      } else {
        t1 = Array(this.get$length(this));
        t1.fixed$length = Array;
        result = H.assertSubtype(H.setRuntimeTypeInfo(t1, [H.getRuntimeTypeArgument(this, "ListIterable", 0)]), "$isList", [H.getRuntimeTypeArgument(this, "ListIterable", 0)], "$asList");
      }
      for (i = 0; i < this.get$length(this); ++i) {
        t1 = this.elementAt$1(0, i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
      }
      return H.assertSubtype(result, "$isList", [H.getRuntimeTypeArgument(this, "ListIterable", 0)], "$asList");
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    E3: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    E: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isEfficientLength: 1
  },
  ListIterator: {
    "^": "Object;__internal$_iterable,__internal$_length,__internal$_index,__internal$_current",
    set$__internal$_current: function(_current) {
      this.__internal$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    get$current: function() {
      return H.assertSubtypeOfRuntimeType(this.__internal$_current, H.getTypeArgumentByIndex(this, 0));
    },
    moveNext$0: function() {
      var t1, t2, $length, t3;
      t1 = this.__internal$_iterable;
      t2 = J.getInterceptor$asx(t1);
      $length = t2.get$length(t1);
      if (this.__internal$_length !== $length)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t3 = this.__internal$_index;
      if (t3 >= $length) {
        this.set$__internal$_current(null);
        return false;
      }
      this.set$__internal$_current(t2.elementAt$1(t1, t3));
      ++this.__internal$_index;
      return true;
    },
    $isIterator: 1
  },
  MappedIterable: {
    "^": "IterableBase;__internal$_iterable,_f",
    get$iterator: function(_) {
      var t1, t2, t3, t4, t5;
      t1 = J.get$iterator$ax(this.__internal$_iterable);
      t2 = this._f;
      t3 = H.getTypeArgumentByIndex(this, 0);
      t4 = H.getTypeArgumentByIndex(this, 1);
      H.assertSubtype(t1, "$isIterator", [t3], "$asIterator");
      t5 = H.buildFunctionType(H.convertRtiToRuntimeType(t4), [H.convertRtiToRuntimeType(t3)]);
      t5._assertCheck$1(t2);
      t2 = new H.MappedIterator(H.assertSubtypeOfRuntimeType(null, t4), H.assertSubtype(t1, "$isIterator", [t3], "$asIterator"), t5._assertCheck$1(t2));
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      return H.assertSubtype(t2, "$isIterator", [H.getTypeArgumentByIndex(this, 1)], "$asIterator");
    },
    get$length: function(_) {
      return J.get$length$asx(this.__internal$_iterable);
    },
    get$isEmpty: function(_) {
      return J.get$isEmpty$asx(this.__internal$_iterable);
    },
    get$last: function(_) {
      return H.assertSubtypeOfRuntimeType(this._f$1(J.get$last$ax(this.__internal$_iterable)), H.getTypeArgumentByIndex(this, 1));
    },
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    S1: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T9: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[1]);
    },
    E: function() {
      return H.convertRtiToRuntimeType(function($S, $T) {
        return $T;
      }.apply(null, this.$builtinTypeInfo));
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    $asIterable: function($S, $T) {
      return [$T];
    },
    static: {MappedIterable_MappedIterable: function(iterable, $function, $S, $T) {
        var t1, t2;
        t1 = H.buildFunctionType(H.convertRtiToRuntimeType($T), [H.convertRtiToRuntimeType($S)]);
        t2 = t1._assertCheck$1($function);
        if (!!J.getInterceptor(iterable).$isEfficientLength) {
          t1 = H.buildFunctionType(H.convertRtiToRuntimeType($T), [H.convertRtiToRuntimeType($S)]);
          t1._assertCheck$1(t2);
          return H.assertSubtype(H.setRuntimeTypeInfo(new H.EfficientLengthMappedIterable(H.listSuperNativeTypeCheck(iterable, "$isIterable"), t1._assertCheck$1(t2)), [$S, $T]), "$isMappedIterable", [$S, $T], "$asMappedIterable");
        }
        H.listSuperNativeTypeCheck(iterable, "$isIterable");
        t1._assertCheck$1(t2);
        return H.assertSubtype(H.setRuntimeTypeInfo(new H.MappedIterable(H.listSuperNativeTypeCheck(iterable, "$isIterable"), t1._assertCheck$1(t2)), [$S, $T]), "$isMappedIterable", [$S, $T], "$asMappedIterable");
      }}
  },
  EfficientLengthMappedIterable: {
    "^": "MappedIterable;__internal$_iterable,_f",
    S1: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T9: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[1]);
    },
    E: function() {
      return H.convertRtiToRuntimeType(function($S, $T) {
        return $T;
      }.apply(null, this.$builtinTypeInfo));
    },
    $isEfficientLength: 1
  },
  MappedIterator: {
    "^": "Iterator;__internal$_current,_iterator,_f",
    set$__internal$_current: function(_current) {
      this.__internal$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 1));
    },
    moveNext$0: function() {
      var t1 = this._iterator;
      if (t1.moveNext$0()) {
        this.set$__internal$_current(this._f$1(t1.get$current()));
        return true;
      }
      this.set$__internal$_current(null);
      return false;
    },
    get$current: function() {
      return H.assertSubtypeOfRuntimeType(this.__internal$_current, H.getTypeArgumentByIndex(this, 1));
    },
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    S0: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T8: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[1]);
    },
    $asIterator: function($S, $T) {
      return [$T];
    }
  },
  MappedListIterable: {
    "^": "ListIterable;_source,_f",
    get$length: function(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1: function(_, index) {
      return H.assertSubtypeOfRuntimeType(this._f$1(J.elementAt$1$ax(this._source, index)), H.getTypeArgumentByIndex(this, 1));
    },
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    S: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T2: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[1]);
    },
    E3: function() {
      return H.convertRtiToRuntimeType(function($S, $T) {
        return $T;
      }.apply(null, this.$builtinTypeInfo));
    },
    E: function() {
      return H.convertRtiToRuntimeType(function($S, $T) {
        return $T;
      }.apply(null, this.$builtinTypeInfo));
    },
    $asListIterable: function($S, $T) {
      return [$T];
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    $asIterable: function($S, $T) {
      return [$T];
    },
    $isEfficientLength: 1
  },
  WhereIterable: {
    "^": "IterableBase;__internal$_iterable,_f",
    get$iterator: function(_) {
      var t1, t2, t3, t4;
      t1 = J.get$iterator$ax(this.__internal$_iterable);
      t2 = this._f;
      t3 = H.getTypeArgumentByIndex(this, 0);
      H.assertSubtype(t1, "$isIterator", [t3], "$asIterator");
      t4 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t4, [H.convertRtiToRuntimeType(t3)])._assertCheck$1(t2);
      t2 = new H.WhereIterator(H.assertSubtype(t1, "$isIterator", [t3], "$asIterator"), H.buildFunctionType(t4, [H.getDynamicRuntimeType()])._assertCheck$1(t2));
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      return H.assertSubtype(t2, "$isIterator", [H.getTypeArgumentByIndex(this, 0)], "$asIterator");
    },
    E: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  WhereIterator: {
    "^": "Iterator;_iterator,_f",
    moveNext$0: function() {
      for (var t1 = this._iterator; t1.moveNext$0();)
        if (H.boolConversionCheck(this._f$1(t1.get$current())))
          return true;
      return false;
    },
    get$current: function() {
      return H.assertSubtypeOfRuntimeType(this._iterator.get$current(), H.getTypeArgumentByIndex(this, 0));
    },
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    }
  },
  FixedLengthListMixin: {
    "^": "Object;",
    set$length: function(receiver, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot change the length of a fixed-length list"));
    },
    add$1: function(receiver, value) {
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(receiver, "FixedLengthListMixin", 0));
      throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
    }
  },
  ReversedListIterable: {
    "^": "ListIterable;_source",
    get$length: function(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1: function(_, index) {
      var t1, t2;
      t1 = this._source;
      t2 = J.getInterceptor$asx(t1);
      return H.assertSubtypeOfRuntimeType(t2.elementAt$1(t1, t2.get$length(t1) - 1 - index), H.getTypeArgumentByIndex(this, 0));
    },
    E3: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    E: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  }
}],
["dart._js_names", "dart:_js_names", , H, {
  "^": "",
  extractKeys: function(victim) {
    var t1 = H.setRuntimeTypeInfo(H.assertSubtype(victim ? Object.keys(victim) : [], "$isJSArray", [null], "$asJSArray"), [null]);
    t1.fixed$length = Array;
    return H.assertSubtype(t1, "$isJSArray", [null], "$asJSArray");
  }
}],
["dart.async", "dart:async", , P, {
  "^": "",
  _AsyncRun__initializeScheduleImmediate: function() {
    var t1, div, span;
    t1 = {};
    if (self.scheduleImmediate != null)
      return H.interceptedTypeCheck(P._AsyncRun__scheduleImmediateJsOverride$closure(), "$isFunction");
    if (self.MutationObserver != null && self.document != null) {
      div = self.document.createElement("div");
      span = self.document.createElement("span");
      t1._captured_storedCallback_0 = null;
      new self.MutationObserver(H.convertDartClosureToJS(new P._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
      return new P._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
    } else if (self.setImmediate != null)
      return H.interceptedTypeCheck(P._AsyncRun__scheduleImmediateWithSetImmediate$closure(), "$isFunction");
    return H.interceptedTypeCheck(P._AsyncRun__scheduleImmediateWithTimer$closure(), "$isFunction");
  },
  _AsyncRun__scheduleImmediateJsOverride: [function(callback) {
    var t1 = H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(callback);
    ++init.globalState.topEventLoop._activeJsAsyncCount;
    self.scheduleImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateJsOverride_internalCallback(t1), 0));
  }, "call$1", "_AsyncRun__scheduleImmediateJsOverride$closure", 2, 0, 43],
  _AsyncRun__scheduleImmediateWithSetImmediate: [function(callback) {
    var t1 = H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(callback);
    ++init.globalState.topEventLoop._activeJsAsyncCount;
    self.setImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(t1), 0));
  }, "call$1", "_AsyncRun__scheduleImmediateWithSetImmediate$closure", 2, 0, 43],
  _AsyncRun__scheduleImmediateWithTimer: [function(callback) {
    P.Timer__createTimer(C.Duration_0, H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(callback));
  }, "call$1", "_AsyncRun__scheduleImmediateWithTimer$closure", 2, 0, 43],
  _registerErrorHandler: function(errorHandler, zone) {
    var t1, t2, t3;
    t1 = H.getDynamicRuntimeType();
    t2 = H.buildFunctionType(t1, [t1, t1]);
    t3 = t2._isTest$1(errorHandler);
    if (t3) {
      zone.toString;
      t2._assertCheck$1(errorHandler);
      return t2._assertCheck$1(errorHandler);
    } else {
      zone.toString;
      t1 = H.buildFunctionType(t1, [t1]);
      t1._assertCheck$1(errorHandler);
      return t1._assertCheck$1(errorHandler);
    }
  },
  Future_Future: function(computation, $T) {
    var t1, result;
    t1 = H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(computation);
    result = new P._Future(0, $.Zone__current, null);
    H.assertHelper(true);
    result.$builtinTypeInfo = [$T];
    t1 = new P.Future_Future_closure(t1, result);
    H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(t1);
    P.Timer_Timer(C.Duration_0, t1);
    return H.assertSubtype(result, "$isFuture", [$T], "$asFuture");
  },
  Future_Future$value: function(value, $T) {
    var t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [$T]);
    t1._asyncComplete$1(value);
    return H.assertSubtype(t1, "$isFuture", [$T], "$asFuture");
  },
  Future_Future$delayed: function(duration, computation, $T) {
    var t1, result;
    t1 = H.buildFunctionType(H.convertRtiToRuntimeType($T))._assertCheck$1(computation);
    result = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [$T]);
    P.Timer_Timer(duration, new P.Future_Future$delayed_closure(t1, result));
    return H.assertSubtype(result, "$isFuture", [$T], "$asFuture");
  },
  _completeWithErrorCallback: function(result, error, stackTrace) {
    $.Zone__current.toString;
    result._completeError$2(error, stackTrace);
  },
  _asyncRunCallbackLoop: function() {
    var t1, t2;
    for (; t1 = $._nextCallback, t1 != null;) {
      $._lastPriorityCallback = null;
      t2 = t1.next;
      $._nextCallback = t2;
      if (t2 == null)
        $._lastCallback = null;
      t1.callback$0();
    }
  },
  _asyncRunCallback: [function() {
    $._isInCallbackLoop = true;
    try {
      P._asyncRunCallbackLoop();
    } finally {
      $._lastPriorityCallback = null;
      $._isInCallbackLoop = false;
      if ($._nextCallback != null) {
        H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(P._asyncRunCallback$closure());
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
      }
    }
  }, "call$0", "_asyncRunCallback$closure", 0, 0, 1],
  _scheduleAsyncCallback: function(callback) {
    var t1, t2, newEntry;
    t1 = H.getVoidRuntimeType();
    if ($._nextCallback == null) {
      t1 = H.buildFunctionType(t1);
      t1._assertCheck$1(callback);
      t2 = new P._AsyncCallbackEntry(t1._assertCheck$1(callback), null);
      $._lastCallback = t2;
      $._nextCallback = t2;
      if (!$._isInCallbackLoop) {
        t1._assertCheck$1(P._asyncRunCallback$closure());
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
      }
    } else {
      t1 = H.buildFunctionType(t1);
      t1._assertCheck$1(callback);
      newEntry = new P._AsyncCallbackEntry(t1._assertCheck$1(callback), null);
      $._lastCallback.next = newEntry;
      $._lastCallback = newEntry;
    }
  },
  scheduleMicrotask: function(callback) {
    var t1, t2, t3;
    t1 = H.buildFunctionType(H.getVoidRuntimeType());
    t2 = t1._assertCheck$1(callback);
    t3 = $.Zone__current;
    if (C.C__RootZone === t3) {
      P._rootScheduleMicrotask(null, null, C.C__RootZone, t2);
      return;
    }
    t2 = t3.bindCallback$2$runGuarded(t2, true);
    t1._assertCheck$1(t2);
    P._rootScheduleMicrotask(null, null, t3, t2);
  },
  Stream_Stream$periodic: function(period, computation, $T) {
    var t1, t2, watch, t3, controller;
    t1 = {};
    t1._captured_computation_0 = computation;
    t2 = H.buildFunctionType(H.convertRtiToRuntimeType($T), [H.buildInterfaceType(P.$int)]);
    t2._assertCheck$1(computation);
    if (t1._captured_computation_0 == null)
      t1._captured_computation_0 = t2._assertCheck$1(new P.Stream_Stream$periodic_closure());
    t1._captured_timer_1 = null;
    t1._captured_computationCount_2 = 0;
    t1._captured_controller_3 = null;
    watch = new P.Stopwatch(null, null);
    H.Primitives_initTicker();
    $.Stopwatch__frequency = $.Primitives_timerFrequency;
    t2 = new P.Stream_Stream$periodic_sendEvent(t1, $T, watch);
    t3 = new P.Stream_Stream$periodic_startPeriodicTimer(t1, period, t2);
    controller = H.assertSubtype(P.StreamController_StreamController(new P.Stream_Stream$periodic_closure0(t1), new P.Stream_Stream$periodic_closure1(watch, t3), new P.Stream_Stream$periodic_closure2(t1, watch), new P.Stream_Stream$periodic_closure3(t1, period, watch, t2, t3), true, $T), "$isStreamController", [$T], "$asStreamController");
    t1._captured_controller_3 = controller;
    H.assertSubtype(controller, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle");
    return H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new P._ControllerStream(H.assertSubtype(controller, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle")), [null]), "$isStream", [H.getRuntimeTypeArgument(controller, "_StreamController", 0)], "$asStream"), "$isStream", [$T], "$asStream");
  },
  StreamController_StreamController: function(onCancel, onListen, onPause, onResume, sync, $T) {
    var t1, t2, t3, t4, t5, t6;
    t1 = H.buildFunctionType(H.getDynamicRuntimeType());
    t2 = t1._assertCheck$1(onCancel);
    t3 = H.buildFunctionType(H.getVoidRuntimeType());
    t4 = t3._assertCheck$1(onListen);
    t5 = t3._assertCheck$1(onPause);
    t6 = t3._assertCheck$1(onResume);
    if (t4 == null && t5 == null && t6 == null && t2 == null) {
      t1 = sync ? new P._NoCallbackSyncStreamController(null, 0, null) : new P._NoCallbackAsyncStreamController(null, 0, null);
      return H.assertSubtype(t1, "$isStreamController", [$T], "$asStreamController");
    }
    if (sync) {
      t3._assertCheck$1(t4);
      t3._assertCheck$1(t5);
      t3._assertCheck$1(t6);
      t1._assertCheck$1(t2);
      t1 = H.setRuntimeTypeInfo(new P._SyncStreamController(t1._assertCheck$1(t4), t1._assertCheck$1(t5), t1._assertCheck$1(t6), t1._assertCheck$1(t2), null, 0, null), [$T]);
    } else {
      t3._assertCheck$1(t4);
      t3._assertCheck$1(t5);
      t3._assertCheck$1(t6);
      t1._assertCheck$1(t2);
      t1 = H.setRuntimeTypeInfo(new P._AsyncStreamController(t1._assertCheck$1(t4), t1._assertCheck$1(t5), t1._assertCheck$1(t6), t1._assertCheck$1(t2), null, 0, null), [$T]);
    }
    return H.assertSubtype(t1, "$isStreamController", [$T], "$asStreamController");
  },
  _runGuarded: function(notificationHandler) {
    var result, e, s, t1, exception;
    H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(notificationHandler);
    if (notificationHandler == null)
      return;
    try {
      result = notificationHandler.call$0();
      if (!!J.getInterceptor(result).$isFuture) {
        t1 = H.interceptedTypeCheck(result, "$isFuture");
        return t1;
      }
      return;
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      s = H.getTraceFromException(exception);
      t1 = $.Zone__current;
      t1.toString;
      P._rootHandleUncaughtError(null, null, t1, e, H.interceptedTypeCheck(s, "$isStackTrace"));
    }
  },
  _nullDataHandler: [function(value) {
  }, "call$1", "_nullDataHandler$closure", 2, 0, 44],
  _nullErrorHandler: [function(error, stackTrace) {
    var t1;
    H.interceptedTypeCheck(stackTrace, "$isStackTrace");
    t1 = $.Zone__current;
    t1.toString;
    P._rootHandleUncaughtError(null, null, t1, error, stackTrace);
  }, function(error) {
    return P._nullErrorHandler(error, null);
  }, null, "call$2", "call$1", "_nullErrorHandler$closure", 2, 2, 6, 0],
  _nullDoneHandler: [function() {
  }, "call$0", "_nullDoneHandler$closure", 0, 0, 1],
  _runUserCode: function(userCode, onSuccess, onError) {
    var e, s, replacement, error, stackTrace, t1, exception;
    t1 = H.getDynamicRuntimeType();
    H.buildFunctionType(t1)._assertCheck$1(userCode);
    H.buildFunctionType(t1, [t1])._assertCheck$1(onSuccess);
    H.buildFunctionType(t1, [t1, H.buildInterfaceType(P.StackTrace)])._assertCheck$1(onError);
    try {
      onSuccess.call$1(userCode.call$0());
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      s = H.getTraceFromException(exception);
      $.Zone__current.toString;
      H.interceptedTypeCheck(s, "$isStackTrace");
      replacement = null;
      if (replacement == null)
        onError.call$2(e, s);
      else {
        t1 = J.get$error$x(replacement);
        error = t1;
        stackTrace = replacement.get$stackTrace();
        onError.call$2(error, stackTrace);
      }
    }
  },
  _cancelAndError: function(subscription, future, error, stackTrace) {
    var cancelFuture = subscription.cancel$0();
    if (!!J.getInterceptor(cancelFuture).$isFuture)
      cancelFuture.whenComplete$1(new P._cancelAndError_closure(future, error, stackTrace));
    else
      future._completeError$2(error, stackTrace);
  },
  _cancelAndErrorClosure: function(subscription, future) {
    return new P._cancelAndErrorClosure_closure(subscription, future);
  },
  _cancelAndValue: function(subscription, future, value) {
    var cancelFuture = subscription.cancel$0();
    if (!!J.getInterceptor(cancelFuture).$isFuture)
      cancelFuture.whenComplete$1(new P._cancelAndValue_closure(future, value));
    else
      future._complete$1(value);
  },
  Timer_Timer: function(duration, callback) {
    var t1, t2, t3;
    t1 = H.buildFunctionType(H.getVoidRuntimeType());
    t2 = t1._assertCheck$1(callback);
    t3 = $.Zone__current;
    if (t3 === C.C__RootZone) {
      t3.toString;
      t1._assertCheck$1(t2);
      return P.Timer__createTimer(duration, t2);
    }
    t2 = t3.bindCallback$2$runGuarded(t2, true);
    t1._assertCheck$1(t2);
    return P.Timer__createTimer(duration, t2);
  },
  Timer_Timer$periodic: function(duration, callback) {
    var t1, t2, t3;
    t1 = H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P.Timer)]);
    t2 = t1._assertCheck$1(callback);
    t3 = $.Zone__current;
    if (t3 === C.C__RootZone) {
      t3.toString;
      t1._assertCheck$1(t2);
      return P.Timer__createPeriodicTimer(duration, t2);
    }
    t2 = t3.bindUnaryCallback$2$runGuarded(t2, true);
    t1._assertCheck$1(t2);
    return P.Timer__createPeriodicTimer(duration, t2);
  },
  Timer__createTimer: function(duration, callback) {
    var t1, milliseconds;
    t1 = H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(callback);
    milliseconds = C.JSInt_methods._tdivFast$1(duration._duration, 1000);
    return H.TimerImpl$(milliseconds < 0 ? 0 : milliseconds, t1);
  },
  Timer__createPeriodicTimer: function(duration, callback) {
    var t1, milliseconds;
    t1 = H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P.Timer)])._assertCheck$1(callback);
    milliseconds = C.JSInt_methods._tdivFast$1(duration._duration, 1000);
    return H.TimerImpl$periodic(milliseconds < 0 ? 0 : milliseconds, t1);
  },
  Zone__enter: function(zone) {
    var t1, previous;
    H.assertHelper(zone != null);
    t1 = $.Zone__current;
    H.assertHelper(zone == null ? t1 != null : zone !== t1);
    previous = $.Zone__current;
    $.Zone__current = zone;
    return previous;
  },
  _rootHandleUncaughtError: function($self, $parent, zone, error, stackTrace) {
    var t1, t2, entry;
    t1 = new P._rootHandleUncaughtError_closure(error, stackTrace);
    t2 = H.buildFunctionType(H.getVoidRuntimeType());
    t2._assertCheck$1(t1);
    entry = new P._AsyncCallbackEntry(t2._assertCheck$1(t1), null);
    t2 = $._nextCallback;
    if (t2 == null) {
      P._scheduleAsyncCallback(t1);
      $._lastPriorityCallback = $._lastCallback;
    } else {
      t1 = $._lastPriorityCallback;
      if (t1 == null) {
        entry.next = t2;
        $._lastPriorityCallback = entry;
        $._nextCallback = entry;
      } else {
        entry.next = t1.next;
        t1.next = entry;
        $._lastPriorityCallback = entry;
        if (entry.next == null)
          $._lastCallback = entry;
      }
    }
  },
  _rootRun: function($self, $parent, zone, f) {
    var old, t1;
    H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(f);
    if ($.Zone__current === zone)
      return f.call$0();
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$0();
      return t1;
    } finally {
      t1 = H.interceptedTypeCheck(old, "$isZone");
      H.assertHelper(t1 != null);
      $.Zone__current = t1;
    }
  },
  _rootRunUnary: function($self, $parent, zone, f, arg) {
    var old, t1;
    t1 = H.getDynamicRuntimeType();
    H.buildFunctionType(t1, [t1])._assertCheck$1(f);
    if ($.Zone__current === zone)
      return f.call$1(arg);
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$1(arg);
      return t1;
    } finally {
      t1 = H.interceptedTypeCheck(old, "$isZone");
      H.assertHelper(t1 != null);
      $.Zone__current = t1;
    }
  },
  _rootRunBinary: function($self, $parent, zone, f, arg1, arg2) {
    var old, t1;
    t1 = H.getDynamicRuntimeType();
    H.buildFunctionType(t1, [t1, t1])._assertCheck$1(f);
    if ($.Zone__current === zone)
      return f.call$2(arg1, arg2);
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$2(arg1, arg2);
      return t1;
    } finally {
      t1 = H.interceptedTypeCheck(old, "$isZone");
      H.assertHelper(t1 != null);
      $.Zone__current = t1;
    }
  },
  _rootScheduleMicrotask: function($self, $parent, zone, f) {
    var t1, t2;
    t1 = H.buildFunctionType(H.getDynamicRuntimeType());
    f = t1._assertCheck$1(f);
    t2 = C.C__RootZone !== zone;
    if (t2)
      f = t1._assertCheck$1(zone.bindCallback$2$runGuarded(f, !(!t2 || C.C__RootZone.get$errorZone() === zone)));
    P._scheduleAsyncCallback(f);
  },
  _AsyncRun__initializeScheduleImmediate_internalCallback: {
    "^": "Closure:2;_box_0",
    call$1: function(_) {
      var t1, f;
      H.leaveJsAsync();
      t1 = this._box_0;
      f = t1._captured_storedCallback_0;
      t1._captured_storedCallback_0 = null;
      f.call$0();
    }
  },
  _AsyncRun__initializeScheduleImmediate_closure: {
    "^": "Closure:5;_box_0,_captured_div_1,_captured_span_2",
    call$1: function(callback) {
      var storedCallback, t1, t2;
      storedCallback = H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(callback);
      t1 = this._box_0;
      H.assertHelper(t1._captured_storedCallback_0 == null);
      ++init.globalState.topEventLoop._activeJsAsyncCount;
      t1._captured_storedCallback_0 = storedCallback;
      t1 = this._captured_div_1;
      t2 = this._captured_span_2;
      t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
    }
  },
  _AsyncRun__scheduleImmediateJsOverride_internalCallback: {
    "^": "Closure:0;_captured_callback_0",
    call$0: function() {
      H.leaveJsAsync();
      this._captured_callback_0.call$0();
    }
  },
  _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback: {
    "^": "Closure:0;_captured_callback_0",
    call$0: function() {
      H.leaveJsAsync();
      this._captured_callback_0.call$0();
    }
  },
  _UncaughtAsyncError: {
    "^": "AsyncError;error,stackTrace",
    toString$0: function(_) {
      var result, t1;
      result = "Uncaught Error: " + H.S(this.error);
      t1 = this.stackTrace;
      return t1 != null ? result + ("\nStack Trace:\n" + J.toString$0(t1)) : result;
    },
    static: {_UncaughtAsyncError__getBestStackTrace: function(error, stackTrace) {
        if (stackTrace != null)
          return stackTrace;
        if (!!J.getInterceptor(error).$isError)
          return error.get$stackTrace();
        return;
      }}
  },
  Future: {
    "^": "Object;"
  },
  Future_Future_closure: {
    "^": "Closure:0;_captured_computation_0,_async$_captured_result_1",
    call$0: function() {
      var e, s, exception, t1;
      try {
        this._async$_captured_result_1._complete$1(this._captured_computation_0.call$0());
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        P._completeWithErrorCallback(this._async$_captured_result_1, e, s);
      }
    }
  },
  Future_Future$delayed_closure: {
    "^": "Closure:0;_captured_computation_0,_async$_captured_result_1",
    call$0: function() {
      var e, s, t1, exception;
      try {
        t1 = this._captured_computation_0.call$0();
        this._async$_captured_result_1._complete$1(t1);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        P._completeWithErrorCallback(this._async$_captured_result_1, e, s);
      }
    }
  },
  _Completer: {
    "^": "Object;",
    completeError$2: function(error, stackTrace) {
      error = error != null ? error : new P.NullThrownError();
      if (this.future._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      $.Zone__current.toString;
      this._completeError$2(error, stackTrace);
    },
    completeError$1: function(error) {
      return this.completeError$2(error, null);
    },
    $isCompleter: 1
  },
  _AsyncCompleter: {
    "^": "_Completer;future",
    complete$1: function(_, value) {
      var t1 = this.future;
      if (t1._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      t1._asyncComplete$1(value);
    },
    complete$0: function($receiver) {
      return this.complete$1($receiver, null);
    },
    _completeError$2: function(error, stackTrace) {
      this.future._asyncCompleteError$2(error, stackTrace);
    }
  },
  _FutureListener: {
    "^": "Object;_nextListener,result,state,callback,errorCallback"
  },
  _Future: {
    "^": "Object;_state<,_zone,_resultOrListeners",
    set$_state: function(_state) {
      this._state = H.intTypeCheck(_state);
    },
    set$_isChained: function(value) {
      var t1 = this._state;
      if (value) {
        H.assertHelper(t1 < 4);
        this._state = 2;
      } else {
        H.assertHelper(t1 === 2);
        this._state = 0;
      }
    },
    then$2$onError: function(f, onError) {
      var t1, t2, result, t3, t4;
      t1 = H.getDynamicRuntimeType();
      t2 = H.buildFunctionType(t1, [this.T0()]);
      f = t2._assertCheck$1(f);
      result = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
      t3 = result._zone;
      if (t3 !== C.C__RootZone) {
        t3.toString;
        t4 = H.buildFunctionType(t1, [t1]);
        t4._assertCheck$1(f);
        f = t2._assertCheck$1(t4._assertCheck$1(f));
        if (onError != null)
          onError = P._registerErrorHandler(onError, t3);
      }
      H.buildFunctionType(t1, [t1])._assertCheck$1(f);
      this._addListener$1(new P._FutureListener(null, result, onError == null ? 1 : 3, f, onError));
      return result;
    },
    then$1: function(f) {
      return this.then$2$onError(f, null);
    },
    whenComplete$1: function(action) {
      var t1, t2, result;
      t1 = H.buildFunctionType(H.getDynamicRuntimeType());
      action = t1._assertCheck$1(action);
      t2 = $.Zone__current;
      result = new P._Future(0, t2, null);
      result.$builtinTypeInfo = this.$builtinTypeInfo;
      if (t2 !== C.C__RootZone) {
        t2.toString;
        t1._assertCheck$1(action);
        action = t1._assertCheck$1(t1._assertCheck$1(action));
      }
      t1._assertCheck$1(action);
      this._addListener$1(new P._FutureListener(null, result, 8, action, null));
      return H.assertSubtype(result, "$isFuture", [H.getTypeArgumentByIndex(this, 0)], "$asFuture");
    },
    _markPendingCompletion$0: function() {
      if (this._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      this._state = 1;
    },
    _setValue$1: function(value) {
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0));
      H.assertHelper(this._state < 4);
      this._state = 4;
      this._resultOrListeners = value;
    },
    _setErrorObject$1: function(error) {
      H.assertHelper(this._state < 4);
      this._state = 8;
      this._resultOrListeners = error;
    },
    _setError$2: function(error, stackTrace) {
      this._setErrorObject$1(new P.AsyncError(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace")));
    },
    _addListener$1: function(listener) {
      var t1, t2;
      H.assertHelper(listener._nextListener == null);
      if (this._state >= 4) {
        t1 = this._zone;
        t2 = new P._Future__addListener_closure(this, listener);
        t1.toString;
        H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(t2);
        P._rootScheduleMicrotask(null, null, t1, t2);
      } else {
        listener._nextListener = H.interceptedTypeCheck(this._resultOrListeners, "$is_FutureListener");
        this._resultOrListeners = listener;
      }
    },
    _removeListeners$0: function() {
      var current, prev, next;
      H.assertHelper(this._state < 4);
      current = H.interceptedTypeCheck(this._resultOrListeners, "$is_FutureListener");
      this._resultOrListeners = null;
      for (prev = null; current != null; prev = current, current = next) {
        next = current._nextListener;
        current._nextListener = prev;
      }
      return prev;
    },
    _complete$1: function(value) {
      var t1, listeners;
      H.assertHelper(this._state < 4);
      t1 = J.getInterceptor(value);
      if (!!t1.$isFuture)
        if (!!t1.$is_Future)
          P._Future__chainCoreFuture(value, this);
        else
          P._Future__chainForeignFuture(value, this);
      else {
        listeners = this._removeListeners$0();
        this._setValue$1(value);
        P._Future__propagateToListeners(this, listeners);
      }
    },
    _completeWithValue$1: function(value) {
      var listeners;
      H.assertHelper(this._state < 4);
      H.assertHelper(!J.getInterceptor(value).$isFuture);
      listeners = this._removeListeners$0();
      this._setValue$1(value);
      P._Future__propagateToListeners(this, listeners);
    },
    _completeError$2: [function(error, stackTrace) {
      var listeners;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      H.assertHelper(this._state < 4);
      listeners = this._removeListeners$0();
      this._setErrorObject$1(new P.AsyncError(error, stackTrace));
      P._Future__propagateToListeners(this, listeners);
    }, function(error) {
      return this._completeError$2(error, null);
    }, "_completeError$1", "call$2", "call$1", "get$_completeError", 2, 2, 6, 0],
    _asyncComplete$1: function(value) {
      var t1, t2;
      H.assertHelper(this._state < 4);
      if (value == null)
        ;
      else {
        t1 = J.getInterceptor(value);
        if (!!t1.$isFuture) {
          H.assertSubtype(value, "$isFuture", [H.getTypeArgumentByIndex(this, 0)], "$asFuture");
          if (!!t1.$is_Future) {
            H.assertSubtype(value, "$is_Future", [H.getTypeArgumentByIndex(this, 0)], "$as_Future");
            t1 = value._state;
            if (t1 >= 4 && t1 === 8) {
              this._markPendingCompletion$0();
              t1 = this._zone;
              t2 = new P._Future__asyncComplete_closure(this, value);
              t1.toString;
              H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(t2);
              P._rootScheduleMicrotask(null, null, t1, t2);
            } else
              P._Future__chainCoreFuture(value, this);
          } else
            P._Future__chainForeignFuture(value, this);
          return;
        } else
          H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0));
      }
      this._markPendingCompletion$0();
      t1 = this._zone;
      t2 = new P._Future__asyncComplete_closure0(this, value);
      t1.toString;
      H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(t2);
      P._rootScheduleMicrotask(null, null, t1, t2);
    },
    _asyncCompleteError$2: function(error, stackTrace) {
      var t1, t2;
      H.assertHelper(this._state < 4);
      this._markPendingCompletion$0();
      t1 = this._zone;
      t2 = new P._Future__asyncCompleteError_closure(this, error, stackTrace);
      t1.toString;
      H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(t2);
      P._rootScheduleMicrotask(null, null, t1, t2);
    },
    T0: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isFuture: 1,
    static: {_Future__chainForeignFuture: function(source, target) {
        var e, s, t1, exception;
        H.assertHelper(target.get$_state() < 4);
        H.assertHelper(!(source instanceof P._Future));
        t1 = target;
        H.assertHelper(t1.get$_state() < 4);
        t1.set$_state(2);
        try {
          source.then$2$onError(new P._Future__chainForeignFuture_closure(target), new P._Future__chainForeignFuture_closure0(target));
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          P.scheduleMicrotask(new P._Future__chainForeignFuture_closure1(target, e, s));
        }
      }, _Future__chainCoreFuture: function(source, target) {
        var listener;
        H.assertHelper(target._state < 4);
        H.assertHelper(true);
        H.assertHelper(target._state < 4);
        target._state = 2;
        listener = new P._FutureListener(null, target, 0, null, null);
        if (source._state >= 4)
          P._Future__propagateToListeners(source, listener);
        else
          source._addListener$1(listener);
      }, _Future__propagateToListeners: function(source, listeners) {
        var t1, t2, t3, t4, hasError, asyncError, t5, listeners0, sourceValue, zone, previous, oldZone, chainSource, result;
        t1 = {};
        t1._captured_source_4 = source;
        H.interceptedTypeCheck(source, "$is_Future");
        for (t2 = source; true;) {
          t3 = {};
          H.assertHelper(t2._state >= 4);
          t2 = t1._captured_source_4;
          t4 = t2._state;
          hasError = t4 === 8;
          if (listeners == null) {
            if (hasError) {
              H.assertHelper(t4 >= 4 && true);
              asyncError = H.interceptedTypeCheck(t2._resultOrListeners, "$isAsyncError");
              t2 = t1._captured_source_4._zone;
              t3 = asyncError.error;
              t5 = asyncError.stackTrace;
              t2.toString;
              P._rootHandleUncaughtError(null, null, t2, t3, t5);
            }
            return;
          }
          for (; listeners0 = listeners._nextListener, listeners0 != null; listeners = listeners0) {
            listeners._nextListener = null;
            P._Future__propagateToListeners(t1._captured_source_4, listeners);
          }
          t3._captured_listenerHasValue_1 = true;
          if (hasError)
            sourceValue = null;
          else {
            t2 = t1._captured_source_4;
            t4 = t2._state;
            H.assertHelper(t4 >= 4 && t4 === 4);
            sourceValue = H.assertSubtypeOfRuntimeType(t2._resultOrListeners, H.getTypeArgumentByIndex(t2, 0));
          }
          t3._captured_listenerValueOrError_2 = sourceValue;
          t3._captured_isPropagationAborted_3 = false;
          t2 = !hasError;
          if (t2) {
            t4 = listeners.state;
            t4 = (t4 & 1) !== 0 || t4 === 8;
          } else
            t4 = true;
          if (t4) {
            t4 = listeners.result;
            zone = t4._zone;
            if (hasError) {
              t5 = t1._captured_source_4._zone;
              t5.toString;
              if (t5 == null ? zone != null : t5 !== zone) {
                t5 = t5.get$errorZone();
                zone.toString;
                t5 = t5 === zone;
              } else
                t5 = true;
              t5 = !t5;
            } else
              t5 = false;
            if (t5) {
              t2 = t1._captured_source_4;
              t3 = t2._state;
              H.assertHelper(t3 >= 4 && t3 === 8);
              asyncError = H.interceptedTypeCheck(t2._resultOrListeners, "$isAsyncError");
              t2 = t1._captured_source_4._zone;
              t3 = asyncError.error;
              t4 = asyncError.stackTrace;
              t2.toString;
              P._rootHandleUncaughtError(null, null, t2, t3, t4);
              return;
            }
            t5 = $.Zone__current;
            if (t5 == null ? zone != null : t5 !== zone) {
              H.assertHelper(zone != null);
              t5 = $.Zone__current;
              H.assertHelper(zone == null ? t5 != null : zone !== t5);
              previous = $.Zone__current;
              $.Zone__current = zone;
              oldZone = previous;
            } else
              oldZone = null;
            if (t2) {
              if ((listeners.state & 1) !== 0)
                t3._captured_listenerHasValue_1 = H.boolTypeCheck(new P._Future__propagateToListeners_handleValueCallback(t3, listeners, sourceValue, zone).call$0());
            } else
              new P._Future__propagateToListeners_handleError(t1, t3, listeners, zone).call$0();
            if (listeners.state === 8)
              new P._Future__propagateToListeners_handleWhenCompleteCallback(t1, t3, hasError, listeners, zone).call$0();
            if (oldZone != null) {
              H.assertHelper(true);
              $.Zone__current = oldZone;
            }
            if (t3._captured_isPropagationAborted_3)
              return;
            if (H.boolConversionCheck(t3._captured_listenerHasValue_1)) {
              t2 = t3._captured_listenerValueOrError_2;
              t2 = (sourceValue == null ? t2 != null : sourceValue !== t2) && !!J.getInterceptor(t2).$isFuture;
            } else
              t2 = false;
            if (t2) {
              chainSource = H.interceptedTypeCheck(t3._captured_listenerValueOrError_2, "$isFuture");
              if (chainSource instanceof P._Future)
                if (chainSource._state >= 4) {
                  H.assertHelper(t4._state < 4);
                  t4._state = 2;
                  t1._captured_source_4 = chainSource;
                  listeners = new P._FutureListener(null, t4, 0, null, null);
                  t2 = chainSource;
                  continue;
                } else
                  P._Future__chainCoreFuture(chainSource, t4);
              else
                P._Future__chainForeignFuture(chainSource, t4);
              return;
            }
          }
          result = listeners.result;
          listeners = result._removeListeners$0();
          t2 = H.boolConversionCheck(t3._captured_listenerHasValue_1);
          t3 = t3._captured_listenerValueOrError_2;
          t4 = result._state;
          if (t2) {
            H.assertSubtypeOfRuntimeType(t3, H.getTypeArgumentByIndex(result, 0));
            H.assertHelper(t4 < 4);
            result._state = 4;
            result._resultOrListeners = t3;
          } else {
            H.interceptedTypeCheck(t3, "$isAsyncError");
            H.assertHelper(t4 < 4);
            result._state = 8;
            result._resultOrListeners = t3;
          }
          t1._captured_source_4 = result;
          t2 = result;
        }
      }}
  },
  _Future__addListener_closure: {
    "^": "Closure:0;_async$_captured_this_0,_captured_listener_1",
    call$0: function() {
      P._Future__propagateToListeners(this._async$_captured_this_0, this._captured_listener_1);
    }
  },
  _Future__chainForeignFuture_closure: {
    "^": "Closure:2;_captured_target_0",
    call$1: function(value) {
      var t1 = this._captured_target_0;
      H.assertHelper(t1._state === 2);
      t1._completeWithValue$1(value);
    }
  },
  _Future__chainForeignFuture_closure0: {
    "^": "Closure:7;_captured_target_1",
    call$2: function(error, stackTrace) {
      var t1 = this._captured_target_1;
      H.assertHelper(t1._state === 2);
      t1._completeError$2(error, stackTrace);
    },
    call$1: function(error) {
      return this.call$2(error, null);
    }
  },
  _Future__chainForeignFuture_closure1: {
    "^": "Closure:0;_captured_target_2,_captured_e_3,_captured_s_4",
    call$0: function() {
      this._captured_target_2._completeError$2(this._captured_e_3, this._captured_s_4);
    }
  },
  _Future__asyncComplete_closure: {
    "^": "Closure:0;_async$_captured_this_0,_captured_coreFuture_1",
    call$0: function() {
      P._Future__chainCoreFuture(this._captured_coreFuture_1, this._async$_captured_this_0);
    }
  },
  _Future__asyncComplete_closure0: {
    "^": "Closure:0;_async$_captured_this_2,_captured_value_3",
    call$0: function() {
      this._async$_captured_this_2._completeWithValue$1(this._captured_value_3);
    }
  },
  _Future__asyncCompleteError_closure: {
    "^": "Closure:0;_async$_captured_this_0,_captured_error_1,_captured_stackTrace_2",
    call$0: function() {
      this._async$_captured_this_0._completeError$2(this._captured_error_1, this._captured_stackTrace_2);
    }
  },
  _Future__propagateToListeners_handleValueCallback: {
    "^": "Closure:8;_box_1,_captured_listener_3,_captured_sourceValue_4,_captured_zone_5",
    call$0: function() {
      var e, s, t1, t2, exception;
      try {
        t1 = this._captured_listener_3;
        H.assertHelper((t1.state & 1) !== 0);
        t2 = H.getDynamicRuntimeType();
        this._box_1._captured_listenerValueOrError_2 = this._captured_zone_5.runUnary$2(H.buildFunctionType(t2, [t2])._assertCheck$1(t1.callback), this._captured_sourceValue_4);
        return true;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        this._box_1._captured_listenerValueOrError_2 = new P.AsyncError(e, H.interceptedTypeCheck(s, "$isStackTrace"));
        return false;
      }
    }
  },
  _Future__propagateToListeners_handleError: {
    "^": "Closure:1;_box_2,_box_1,_captured_listener_6,_captured_zone_7",
    call$0: function() {
      var asyncError, matchesTest, test, e, s, errorCallback, e0, s0, t1, t2, exception, listenerValueOrError, t3, t4;
      t1 = this._box_2._captured_source_4;
      t2 = t1._state;
      H.assertHelper(t2 >= 4 && t2 === 8);
      asyncError = H.interceptedTypeCheck(t1._resultOrListeners, "$isAsyncError");
      matchesTest = true;
      t1 = this._captured_listener_6;
      if (t1.state === 6) {
        H.assertHelper(true);
        t2 = H.buildFunctionType(H.buildInterfaceType(P.bool), [H.getDynamicRuntimeType()]);
        test = t2._assertCheck$1(t2._assertCheck$1(t1.callback));
        try {
          matchesTest = H.boolTypeCheck(this._captured_zone_7.runUnary$2(test, J.get$error$x(asyncError)));
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          t1 = J.get$error$x(asyncError);
          t2 = e;
          listenerValueOrError = (t1 == null ? t2 == null : t1 === t2) ? asyncError : new P.AsyncError(e, H.interceptedTypeCheck(s, "$isStackTrace"));
          t1 = this._box_1;
          t1._captured_listenerValueOrError_2 = listenerValueOrError;
          t1._captured_listenerHasValue_1 = false;
          return;
        }
      }
      errorCallback = t1.errorCallback;
      if (H.boolConversionCheck(matchesTest) && errorCallback != null) {
        try {
          t1 = errorCallback;
          t2 = H.getDynamicRuntimeType();
          t2 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
          t3 = this._captured_zone_7;
          t4 = this._box_1;
          if (t2)
            t4._captured_listenerValueOrError_2 = t3.runBinary$3(errorCallback, J.get$error$x(asyncError), asyncError.get$stackTrace());
          else
            t4._captured_listenerValueOrError_2 = t3.runUnary$2(errorCallback, J.get$error$x(asyncError));
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e0 = t1;
          s0 = H.getTraceFromException(exception);
          t1 = J.get$error$x(asyncError);
          t2 = e0;
          listenerValueOrError = (t1 == null ? t2 == null : t1 === t2) ? asyncError : new P.AsyncError(e0, H.interceptedTypeCheck(s0, "$isStackTrace"));
          t1 = this._box_1;
          t1._captured_listenerValueOrError_2 = listenerValueOrError;
          t1._captured_listenerHasValue_1 = false;
          return;
        }
        this._box_1._captured_listenerHasValue_1 = true;
      } else {
        t1 = this._box_1;
        t1._captured_listenerValueOrError_2 = asyncError;
        t1._captured_listenerHasValue_1 = false;
      }
    }
  },
  _Future__propagateToListeners_handleWhenCompleteCallback: {
    "^": "Closure:1;_box_2,_box_1,_captured_hasError_8,_captured_listener_9,_captured_zone_10",
    call$0: function() {
      var t1, e, s, t2, completeResult, exception, result;
      t1 = {};
      t1._captured_completeResult_0 = null;
      try {
        t2 = this._captured_listener_9;
        H.assertHelper(t2.state === 8);
        completeResult = this._captured_zone_10.run$1(H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(t2.callback));
        t1._captured_completeResult_0 = completeResult;
        t2 = completeResult;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        if (this._captured_hasError_8) {
          t1 = this._box_2._captured_source_4;
          t2 = t1._state;
          H.assertHelper(t2 >= 4 && t2 === 8);
          t1 = H.interceptedTypeCheck(t1._resultOrListeners, "$isAsyncError").error;
          t2 = e;
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = false;
        if (t1) {
          t1 = this._box_2._captured_source_4;
          t2 = t1._state;
          H.assertHelper(t2 >= 4 && t2 === 8);
          t2 = this._box_1;
          t2._captured_listenerValueOrError_2 = H.interceptedTypeCheck(t1._resultOrListeners, "$isAsyncError");
          t1 = t2;
        } else {
          t1 = this._box_1;
          t1._captured_listenerValueOrError_2 = new P.AsyncError(e, H.interceptedTypeCheck(s, "$isStackTrace"));
        }
        t1._captured_listenerHasValue_1 = false;
        return;
      }
      if (!!J.getInterceptor(t2).$isFuture) {
        result = this._captured_listener_9.result;
        result.set$_isChained(true);
        this._box_1._captured_isPropagationAborted_3 = true;
        t1._captured_completeResult_0.then$2$onError(new P._Future__propagateToListeners_handleWhenCompleteCallback_closure(this._box_2, result), new P._Future__propagateToListeners_handleWhenCompleteCallback_closure0(t1, result));
      }
    }
  },
  _Future__propagateToListeners_handleWhenCompleteCallback_closure: {
    "^": "Closure:2;_box_2,_captured_result_11",
    call$1: function(ignored) {
      P._Future__propagateToListeners(this._box_2._captured_source_4, new P._FutureListener(null, this._captured_result_11, 0, null, null));
    }
  },
  _Future__propagateToListeners_handleWhenCompleteCallback_closure0: {
    "^": "Closure:7;_box_0,_captured_result_12",
    call$2: function(error, stackTrace) {
      var t1, completeResult;
      t1 = this._box_0;
      if (!(t1._captured_completeResult_0 instanceof P._Future)) {
        completeResult = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
        t1._captured_completeResult_0 = completeResult;
        completeResult._setError$2(error, stackTrace);
      }
      P._Future__propagateToListeners(t1._captured_completeResult_0, new P._FutureListener(null, this._captured_result_12, 0, null, null));
    },
    call$1: function(error) {
      return this.call$2(error, null);
    }
  },
  _AsyncCallbackEntry: {
    "^": "Object;callback,next",
    callback$0: function() {
      return this.callback.call$0();
    }
  },
  Stream: {
    "^": "Object;",
    forEach$1: function(_, action) {
      var t1, t2, future;
      t1 = {};
      t2 = H.buildFunctionType(H.getVoidRuntimeType(), [this.T()])._assertCheck$1(action);
      future = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
      t1._captured_subscription_0 = null;
      t1._captured_subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_forEach_closure(t1, this, t2, future), true, new P.Stream_forEach_closure0(future), future.get$_completeError());
      return future;
    },
    get$length: function(_) {
      var t1, future;
      t1 = {};
      future = H.assertSubtype(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [P.$int]), "$is_Future", [P.$int], "$as_Future");
      t1._captured_count_0 = 0;
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_length_closure(t1), true, new P.Stream_length_closure0(t1, future), future.get$_completeError());
      return H.assertSubtype(future, "$isFuture", [P.$int], "$asFuture");
    },
    get$first: function(_) {
      var t1, future;
      t1 = {};
      future = H.assertSubtype(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [H.getRuntimeTypeArgument(this, "Stream", 0)]), "$is_Future", [H.getRuntimeTypeArgument(this, "Stream", 0)], "$as_Future");
      t1._captured_subscription_0 = null;
      t1._captured_subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_first_closure(t1, this, future), true, new P.Stream_first_closure0(future), future.get$_completeError());
      return H.assertSubtype(future, "$isFuture", [H.getRuntimeTypeArgument(this, "Stream", 0)], "$asFuture");
    },
    get$last: function(_) {
      var t1, future;
      t1 = {};
      future = H.assertSubtype(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [H.getRuntimeTypeArgument(this, "Stream", 0)]), "$is_Future", [H.getRuntimeTypeArgument(this, "Stream", 0)], "$as_Future");
      t1._captured_result_0 = H.assertSubtypeOfRuntimeType(null, H.getRuntimeTypeArgument(this, "Stream", 0));
      t1._captured_foundResult_1 = false;
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_last_closure(t1, this), true, new P.Stream_last_closure0(t1, future), future.get$_completeError());
      return H.assertSubtype(future, "$isFuture", [H.getRuntimeTypeArgument(this, "Stream", 0)], "$asFuture");
    },
    T: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  Stream_Stream$periodic_closure: {
    "^": "Closure:2;",
    call$1: function(i) {
      return;
    }
  },
  Stream_Stream$periodic_sendEvent: {
    "^": "Closure:1;_box_0,_captured_T_1,_captured_watch_2",
    call$0: function() {
      var t1, data;
      this._captured_watch_2.reset$0(0);
      t1 = this._box_0;
      data = H.assertSubtypeOfRuntimeType(t1._captured_computation_0.call$1(t1._captured_computationCount_2++), this._captured_T_1);
      t1 = t1._captured_controller_3;
      t1.toString;
      H.assertSubtypeOfRuntimeType(data, H.getRuntimeTypeArgument(t1, "_StreamController", 0));
      if (t1._state >= 4)
        H.throwExpression(t1._badEventState$0());
      t1._async$_add$1(data);
    }
  },
  Stream_Stream$periodic_startPeriodicTimer: {
    "^": "Closure:1;_box_0,_captured_period_3,_captured_sendEvent_4",
    call$0: function() {
      var t1 = this._box_0;
      H.assertHelper(t1._captured_timer_1 == null);
      t1._captured_timer_1 = P.Timer_Timer$periodic(this._captured_period_3, new P.Stream_Stream$periodic_startPeriodicTimer_closure(this._captured_sendEvent_4));
    }
  },
  Stream_Stream$periodic_startPeriodicTimer_closure: {
    "^": "Closure:9;_captured_sendEvent_5",
    call$1: function(timer) {
      H.interceptedTypeCheck(timer, "$isTimer");
      this._captured_sendEvent_5.call$0();
    }
  },
  Stream_Stream$periodic_closure1: {
    "^": "Closure:0;_captured_watch_6,_captured_startPeriodicTimer_7",
    call$0: function() {
      this._captured_watch_6.start$0(0);
      this._captured_startPeriodicTimer_7.call$0();
    }
  },
  Stream_Stream$periodic_closure2: {
    "^": "Closure:0;_box_0,_captured_watch_8",
    call$0: function() {
      var t1 = this._box_0;
      t1._captured_timer_1.cancel$0();
      t1._captured_timer_1 = null;
      this._captured_watch_8.stop$0(0);
    }
  },
  Stream_Stream$periodic_closure3: {
    "^": "Closure:0;_box_0,_captured_period_9,_captured_watch_10,_captured_sendEvent_11,_captured_startPeriodicTimer_12",
    call$0: function() {
      var t1, t2, elapsed;
      t1 = this._box_0;
      H.assertHelper(t1._captured_timer_1 == null);
      t2 = this._captured_watch_10;
      elapsed = P.Duration$(0, 0, C.JSInt_methods.$tdiv(t2.get$elapsedTicks() * 1000000, $.Stopwatch__frequency), 0, 0, 0);
      t2.start$0(0);
      t1._captured_timer_1 = P.Timer_Timer(new P.Duration(this._captured_period_9._duration - elapsed._duration), new P.Stream_Stream$periodic__closure(t1, this._captured_sendEvent_11, this._captured_startPeriodicTimer_12));
    }
  },
  Stream_Stream$periodic__closure: {
    "^": "Closure:0;_box_0,_captured_sendEvent_13,_captured_startPeriodicTimer_14",
    call$0: function() {
      this._box_0._captured_timer_1 = null;
      this._captured_startPeriodicTimer_14.call$0();
      this._captured_sendEvent_13.call$0();
    }
  },
  Stream_Stream$periodic_closure0: {
    "^": "Closure:0;_box_0",
    call$0: function() {
      var t1, t2;
      t1 = this._box_0;
      t2 = t1._captured_timer_1;
      if (t2 != null)
        t2.cancel$0();
      t1._captured_timer_1 = null;
    }
  },
  Stream_forEach_closure: {
    "^": "Closure;_box_0,_async$_captured_this_1,_captured_action_2,_captured_future_3",
    call$1: function(element) {
      P._runUserCode(new P.Stream_forEach__closure(this._captured_action_2, H.assertSubtypeOfRuntimeType(element, H.getRuntimeTypeArgument(this._async$_captured_this_1, "Stream", 0))), new P.Stream_forEach__closure0(), P._cancelAndErrorClosure(this._box_0._captured_subscription_0, this._captured_future_3));
    },
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "", args: [T]};
      }, this._async$_captured_this_1, "Stream");
    }
  },
  Stream_forEach__closure: {
    "^": "Closure:0;_captured_action_4,_captured_element_5",
    call$0: function() {
      return this._captured_action_4.call$1(this._captured_element_5);
    }
  },
  Stream_forEach__closure0: {
    "^": "Closure:2;",
    call$1: function(_) {
    }
  },
  Stream_forEach_closure0: {
    "^": "Closure:0;_captured_future_6",
    call$0: function() {
      this._captured_future_6._complete$1(null);
    }
  },
  Stream_length_closure: {
    "^": "Closure:2;_box_0",
    call$1: function(_) {
      ++this._box_0._captured_count_0;
    }
  },
  Stream_length_closure0: {
    "^": "Closure:0;_box_0,_captured_future_1",
    call$0: function() {
      this._captured_future_1._complete$1(this._box_0._captured_count_0);
    }
  },
  Stream_first_closure: {
    "^": "Closure;_box_0,_async$_captured_this_1,_captured_future_2",
    call$1: function(value) {
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(this._async$_captured_this_1, "Stream", 0));
      P._cancelAndValue(this._box_0._captured_subscription_0, this._captured_future_2, value);
    },
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "", args: [T]};
      }, this._async$_captured_this_1, "Stream");
    }
  },
  Stream_first_closure0: {
    "^": "Closure:0;_captured_future_3",
    call$0: function() {
      var e, s, t1, exception;
      try {
        t1 = H.IterableElementError_noElement();
        throw H.wrapException(t1);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        P._completeWithErrorCallback(this._captured_future_3, e, s);
      }
    }
  },
  Stream_last_closure: {
    "^": "Closure;_box_0,_async$_captured_this_1",
    call$1: function(value) {
      var t1, t2;
      t1 = this._async$_captured_this_1;
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(t1, "Stream", 0));
      t2 = this._box_0;
      t2._captured_foundResult_1 = true;
      t2._captured_result_0 = H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(t1, "Stream", 0));
    },
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "", args: [T]};
      }, this._async$_captured_this_1, "Stream");
    }
  },
  Stream_last_closure0: {
    "^": "Closure:0;_box_0,_captured_future_2",
    call$0: function() {
      var e, s, t1, exception;
      t1 = this._box_0;
      if (t1._captured_foundResult_1) {
        this._captured_future_2._complete$1(t1._captured_result_0);
        return;
      }
      try {
        t1 = H.IterableElementError_noElement();
        throw H.wrapException(t1);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        P._completeWithErrorCallback(this._captured_future_2, e, s);
      }
    }
  },
  StreamSubscription: {
    "^": "Object;"
  },
  _StreamController: {
    "^": "Object;_state<",
    set$_state: function(_state) {
      this._state = H.intTypeCheck(_state);
    },
    get$_pendingEvents: function() {
      H.assertHelper((this._state & 3) === 0);
      if ((this._state & 8) === 0)
        return H.interceptedTypeCheck(this._varData, "$is_PendingEvents");
      return H.interceptedTypeCheck(this._varData, "$is_StreamControllerAddStreamState").get$varData();
    },
    _ensurePendingEvents$0: function() {
      var t1, state;
      H.assertHelper((this._state & 3) === 0);
      if ((this._state & 8) === 0) {
        t1 = this._varData;
        if (t1 == null) {
          t1 = new P._StreamImplEvents(null, null, 0);
          this._varData = t1;
        }
        return H.interceptedTypeCheck(t1, "$is_StreamImplEvents");
      }
      state = H.interceptedTypeCheck(this._varData, "$is_StreamControllerAddStreamState");
      state.get$varData();
      return state.get$varData();
    },
    get$_subscription: function() {
      H.assertHelper((this._state & 1) !== 0);
      if ((this._state & 8) !== 0)
        return H.interceptedTypeCheck(this._varData, "$is_StreamControllerAddStreamState").get$varData();
      return H.interceptedTypeCheck(this._varData, "$is_ControllerSubscription");
    },
    _badEventState$0: function() {
      var t1 = this._state;
      if ((t1 & 4) !== 0)
        return new P.StateError("Cannot add event after closing");
      H.assertHelper((t1 & 8) !== 0);
      return new P.StateError("Cannot add event while adding a stream");
    },
    get$done: function() {
      return this._ensureDoneFuture$0();
    },
    _ensureDoneFuture$0: function() {
      var t1 = this._doneFuture;
      if (t1 == null) {
        t1 = (this._state & 2) !== 0 ? $.get$Future__nullFuture() : H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
        this._doneFuture = t1;
      }
      return t1;
    },
    add$1: [function(_, value) {
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(this, "_StreamController", 0));
      if (this._state >= 4)
        throw H.wrapException(this._badEventState$0());
      this._async$_add$1(value);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "", void: true, args: [T]};
      }, this.$receiver, "_StreamController");
    }],
    close$0: function(_) {
      var t1 = this._state;
      if ((t1 & 4) !== 0)
        return this._ensureDoneFuture$0();
      if (t1 >= 4)
        throw H.wrapException(this._badEventState$0());
      t1 |= 4;
      this._state = t1;
      if ((t1 & 1) !== 0)
        this._sendDone$0();
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, C.C__DelayedDone);
      return this._ensureDoneFuture$0();
    },
    _async$_add$1: function(value) {
      var t1;
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(this, "_StreamController", 0));
      t1 = this._state;
      if ((t1 & 1) !== 0)
        this._sendData$1(value);
      else if ((t1 & 3) === 0) {
        t1 = H.getRuntimeTypeArgument(this, "_StreamController", 0);
        this._ensurePendingEvents$0().add$1(0, H.setRuntimeTypeInfo(new P._DelayedData(H.assertSubtypeOfRuntimeType(value, t1), null), [t1]));
      }
    },
    _subscribe$4: function(onData, onError, onDone, cancelOnError) {
      var t1, t2, t3, t4, t5, t6, subscription, pendingEvents, addState;
      t1 = H.getVoidRuntimeType();
      t2 = H.buildFunctionType(t1, [this.T7()])._assertCheck$1(onData);
      t3 = H.buildFunctionType(t1);
      t4 = t3._assertCheck$1(onDone);
      if ((this._state & 3) !== 0)
        throw H.wrapException(P.StateError$("Stream has already been listened to."));
      H.assertSubtype(this, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle");
      t1 = H.buildFunctionType(t1, [H.convertRtiToRuntimeType(null)]);
      t1._assertCheck$1(t2);
      t3._assertCheck$1(t4);
      t5 = $.Zone__current;
      t6 = cancelOnError ? 1 : 0;
      subscription = H.setRuntimeTypeInfo(new P._ControllerSubscription(H.assertSubtype(this, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle"), t1._assertCheck$1(null), null, t3._assertCheck$1(null), t5, t6, null, null), [null]);
      subscription._BufferingStreamSubscription$4(t2, onError, t4, cancelOnError, null);
      pendingEvents = this.get$_pendingEvents();
      t4 = this._state |= 1;
      if ((t4 & 8) !== 0) {
        addState = H.interceptedTypeCheck(this._varData, "$is_StreamControllerAddStreamState");
        addState.set$varData(subscription);
        addState.resume$0();
      } else
        this._varData = subscription;
      subscription._setPendingEvents$1(pendingEvents);
      subscription._guardCallback$1(new P._StreamController__subscribe_closure(this));
      return H.assertSubtype(subscription, "$isStreamSubscription", [H.getRuntimeTypeArgument(this, "_StreamController", 0)], "$asStreamSubscription");
    },
    _recordCancel$1: function(subscription) {
      var result, e, s, exception, t1, result0;
      H.assertSubtype(subscription, "$isStreamSubscription", [H.getRuntimeTypeArgument(this, "_StreamController", 0)], "$asStreamSubscription");
      result = null;
      if ((this._state & 8) !== 0)
        result = H.interceptedTypeCheck(this._varData, "$is_StreamControllerAddStreamState").cancel$0();
      this._varData = null;
      this._state = this._state & 4294967286 | 2;
      if (this.get$_onCancel() != null)
        if (result == null)
          try {
            result = H.interceptedTypeCheck(this._onCancel$0(), "$isFuture");
          } catch (exception) {
            t1 = H.unwrapException(exception);
            e = t1;
            s = H.getTraceFromException(exception);
            result0 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
            result0._asyncCompleteError$2(e, s);
            result = result0;
          }
        else
          result = result.whenComplete$1(this.get$_onCancel());
      t1 = new P._StreamController__recordCancel_complete(this);
      if (result != null)
        result = result.whenComplete$1(t1);
      else
        t1.call$0();
      return H.interceptedTypeCheck(result, "$isFuture");
    },
    _recordPause$1: function(subscription) {
      H.assertSubtype(subscription, "$isStreamSubscription", [H.getRuntimeTypeArgument(this, "_StreamController", 0)], "$asStreamSubscription");
      if ((this._state & 8) !== 0)
        C.JSNull_methods.pause$0(H.interceptedTypeCheck(this._varData, "$is_StreamControllerAddStreamState"));
      P._runGuarded(this.get$_onPause());
    },
    _recordResume$1: function(subscription) {
      H.assertSubtype(subscription, "$isStreamSubscription", [H.getRuntimeTypeArgument(this, "_StreamController", 0)], "$asStreamSubscription");
      if ((this._state & 8) !== 0)
        H.interceptedTypeCheck(this._varData, "$is_StreamControllerAddStreamState").resume$0();
      P._runGuarded(this.get$_onResume());
    },
    T7: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $is_EventDispatch: 1,
    $is_StreamControllerLifecycle: 1,
    $isStreamController: 1
  },
  _StreamController__subscribe_closure: {
    "^": "Closure:0;_async$_captured_this_0",
    call$0: function() {
      P._runGuarded(this._async$_captured_this_0.get$_onListen());
    }
  },
  _StreamController__recordCancel_complete: {
    "^": "Closure:1;_async$_captured_this_0",
    call$0: function() {
      var t1 = this._async$_captured_this_0._doneFuture;
      if (t1 != null && t1._state === 0)
        t1._asyncComplete$1(null);
    }
  },
  _SyncStreamControllerDispatch: {
    "^": "Object;",
    _sendData$1: function(data) {
      H.assertSubtypeOfRuntimeType(data, H.getRuntimeTypeArgument(this, "_SyncStreamControllerDispatch", 0));
      this.get$_subscription()._async$_add$1(data);
    },
    _sendDone$0: function() {
      this.get$_subscription()._close$0();
    },
    $isStreamController: 1,
    $is_EventDispatch: 1,
    $is_StreamControllerLifecycle: 1
  },
  _AsyncStreamControllerDispatch: {
    "^": "Object;",
    _sendData$1: function(data) {
      H.assertSubtypeOfRuntimeType(data, H.getRuntimeTypeArgument(this, "_AsyncStreamControllerDispatch", 0));
      this.get$_subscription()._addPending$1(H.setRuntimeTypeInfo(new P._DelayedData(H.assertSubtypeOfRuntimeType(data, null), null), [null]));
    },
    _sendDone$0: function() {
      this.get$_subscription()._addPending$1(C.C__DelayedDone);
    },
    $is_EventDispatch: 1,
    $is_StreamControllerLifecycle: 1,
    $isStreamController: 1
  },
  _AsyncStreamController: {
    "^": "_StreamController__AsyncStreamControllerDispatch;_onListen<,_onPause<,_onResume<,_onCancel<,_varData,_state,_doneFuture",
    _onCancel$0: function() {
      return this._onCancel.call$0();
    },
    T7: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  _StreamController__AsyncStreamControllerDispatch: {
    "^": "_StreamController+_AsyncStreamControllerDispatch;",
    T7: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $is_EventDispatch: 1,
    $is_StreamControllerLifecycle: 1,
    $isStreamController: 1
  },
  _SyncStreamController: {
    "^": "_StreamController__SyncStreamControllerDispatch;_onListen<,_onPause<,_onResume<,_onCancel<,_varData,_state,_doneFuture",
    _onCancel$0: function() {
      return this._onCancel.call$0();
    },
    T7: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  _StreamController__SyncStreamControllerDispatch: {
    "^": "_StreamController+_SyncStreamControllerDispatch;",
    T7: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isStreamController: 1,
    $is_EventDispatch: 1,
    $is_StreamControllerLifecycle: 1
  },
  _NoCallbacks: {
    "^": "Object;",
    get$_onListen: function() {
      return H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(null);
    },
    get$_onPause: function() {
      return H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(null);
    },
    get$_onResume: function() {
      return H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(null);
    },
    get$_onCancel: function() {
      return H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(null);
    },
    _onCancel$0: function() {
      return this.get$_onCancel().call$0();
    }
  },
  _NoCallbackAsyncStreamController: {
    "^": "_StreamController__AsyncStreamControllerDispatch0+_NoCallbacks;_varData,_state,_doneFuture",
    T7: function() {
      return H.convertRtiToRuntimeType($.functionThatReturnsNull.apply(null, this.$builtinTypeInfo));
    }
  },
  _StreamController__AsyncStreamControllerDispatch0: {
    "^": "_StreamController+_AsyncStreamControllerDispatch;",
    T7: function() {
      return H.convertRtiToRuntimeType($.functionThatReturnsNull.apply(null, this.$builtinTypeInfo));
    },
    $as_StreamController: $.functionThatReturnsNull,
    $as_AsyncStreamControllerDispatch: $.functionThatReturnsNull,
    $as_EventDispatch: $.functionThatReturnsNull,
    $as_StreamControllerLifecycle: $.functionThatReturnsNull,
    $asStreamController: $.functionThatReturnsNull,
    $is_EventDispatch: 1,
    $is_StreamControllerLifecycle: 1,
    $isStreamController: 1
  },
  _NoCallbackSyncStreamController: {
    "^": "_StreamController__SyncStreamControllerDispatch0+_NoCallbacks;_varData,_state,_doneFuture",
    T7: function() {
      return H.convertRtiToRuntimeType($.functionThatReturnsNull.apply(null, this.$builtinTypeInfo));
    }
  },
  _StreamController__SyncStreamControllerDispatch0: {
    "^": "_StreamController+_SyncStreamControllerDispatch;",
    T7: function() {
      return H.convertRtiToRuntimeType($.functionThatReturnsNull.apply(null, this.$builtinTypeInfo));
    },
    $as_StreamController: $.functionThatReturnsNull,
    $as_SyncStreamControllerDispatch: $.functionThatReturnsNull,
    $as_EventDispatch: $.functionThatReturnsNull,
    $as_StreamControllerLifecycle: $.functionThatReturnsNull,
    $asStreamController: $.functionThatReturnsNull,
    $isStreamController: 1,
    $is_EventDispatch: 1,
    $is_StreamControllerLifecycle: 1
  },
  _ControllerStream: {
    "^": "_StreamImpl;_async$_controller",
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      var t1 = H.getVoidRuntimeType();
      return H.assertSubtype(this._async$_controller._subscribe$4(H.buildFunctionType(t1, [this.T6()])._assertCheck$1(onData), onError, H.buildFunctionType(t1)._assertCheck$1(onDone), cancelOnError), "$isStreamSubscription", [H.getTypeArgumentByIndex(this, 0)], "$asStreamSubscription");
    },
    get$hashCode: function(_) {
      return (H.Primitives_objectHashCode(this._async$_controller) ^ 892482866) >>> 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!(other instanceof P._ControllerStream))
        return false;
      return other._async$_controller === this._async$_controller;
    },
    T6: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T4: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  _ControllerSubscription: {
    "^": "_BufferingStreamSubscription;_async$_controller<,_async$_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending",
    _onCancel$0: function() {
      return this.get$_async$_controller()._recordCancel$1(this);
    },
    _onPause$0: [function() {
      this.get$_async$_controller()._recordPause$1(this);
    }, "call$0", "get$_onPause", 0, 0, 1],
    _onResume$0: [function() {
      this.get$_async$_controller()._recordResume$1(this);
    }, "call$0", "get$_onResume", 0, 0, 1],
    T5: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  _EventSink: {
    "^": "Object;"
  },
  _BufferingStreamSubscription: {
    "^": "Object;_async$_onData,_onError,_onDone,_zone,_state<,_cancelFuture,_pending",
    set$_async$_onData: function(_onData) {
      this._async$_onData = H.buildFunctionType(H.getVoidRuntimeType(), [this.T5()])._assertCheck$1(_onData);
    },
    set$_state: function(_state) {
      this._state = H.intTypeCheck(_state);
    },
    _setPendingEvents$1: function(pendingEvents) {
      H.assertHelper(this._pending == null);
      if (pendingEvents == null)
        return;
      this._pending = pendingEvents;
      if (pendingEvents.lastPendingEvent != null) {
        this._state = (this._state | 64) >>> 0;
        pendingEvents.schedule$1(this);
      }
    },
    pause$1: function(_, resumeSignal) {
      var t1, t2, t3;
      t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      t2 = (t1 + 128 | 4) >>> 0;
      this._state = t2;
      if (t1 < 128 && this._pending != null) {
        t3 = this._pending;
        if (t3._state === 1)
          t3._state = 3;
      }
      if ((t1 & 4) === 0 && (t2 & 32) === 0)
        this._guardCallback$1(this.get$_onPause());
    },
    pause$0: function($receiver) {
      return this.pause$1($receiver, null);
    },
    resume$0: function() {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 >= 128) {
        H.assertHelper(true);
        t1 = this._state -= 128;
        if (t1 < 128)
          if ((t1 & 64) !== 0 && this._pending.lastPendingEvent != null)
            this._pending.schedule$1(this);
          else {
            H.assertHelper(this.get$_mayResumeInput());
            t1 = (this._state & 4294967291) >>> 0;
            this._state = t1;
            if ((t1 & 32) === 0)
              this._guardCallback$1(this.get$_onResume());
          }
      }
    },
    cancel$0: function() {
      var t1 = (this._state & 4294967279) >>> 0;
      this._state = t1;
      if ((t1 & 8) !== 0)
        return this._cancelFuture;
      this._cancel$0();
      return this._cancelFuture;
    },
    get$_mayResumeInput: function() {
      if (this._state < 128) {
        var t1 = this._pending;
        t1 = t1 == null || t1.lastPendingEvent == null;
      } else
        t1 = false;
      return t1;
    },
    get$isPaused: function() {
      return this._state >= 128;
    },
    _cancel$0: function() {
      var t1, t2;
      t1 = (this._state | 8) >>> 0;
      this._state = t1;
      if ((t1 & 64) !== 0) {
        t2 = this._pending;
        if (t2._state === 1)
          t2._state = 3;
      }
      if ((t1 & 32) === 0)
        this._pending = null;
      this._cancelFuture = this._onCancel$0();
    },
    _async$_add$1: function(data) {
      var t1;
      H.assertSubtypeOfRuntimeType(data, H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0));
      H.assertHelper((this._state & 2) === 0);
      t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 32)
        this._sendData$1(data);
      else
        this._addPending$1(H.setRuntimeTypeInfo(new P._DelayedData(H.assertSubtypeOfRuntimeType(data, null), null), [null]));
    },
    _close$0: function() {
      H.assertHelper((this._state & 2) === 0);
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      t1 = (t1 | 2) >>> 0;
      this._state = t1;
      if (t1 < 32)
        this._sendDone$0();
      else
        this._addPending$1(C.C__DelayedDone);
    },
    _onPause$0: [function() {
      H.assertHelper((this._state & 4) !== 0);
    }, "call$0", "get$_onPause", 0, 0, 1],
    _onResume$0: [function() {
      H.assertHelper((this._state & 4) === 0);
    }, "call$0", "get$_onResume", 0, 0, 1],
    _onCancel$0: function() {
      H.assertHelper((this._state & 8) !== 0);
      return;
    },
    _addPending$1: function($event) {
      var pending, t1;
      pending = this._pending;
      if (pending == null) {
        pending = new P._StreamImplEvents(null, null, 0);
        this._pending = pending;
      }
      pending.add$1(0, $event);
      t1 = this._state;
      if ((t1 & 64) === 0) {
        t1 = (t1 | 64) >>> 0;
        this._state = t1;
        if (t1 < 128)
          this._pending.schedule$1(this);
      }
    },
    _sendData$1: function(data) {
      var t1;
      H.assertSubtypeOfRuntimeType(data, H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0));
      H.assertHelper((this._state & 8) === 0);
      H.assertHelper(this._state < 128);
      H.assertHelper((this._state & 32) === 0);
      t1 = this._state;
      this._state = (t1 | 32) >>> 0;
      this._zone.runUnaryGuarded$2(this._async$_onData, data);
      this._state = (this._state & 4294967263) >>> 0;
      this._checkState$1((t1 & 4) !== 0);
    },
    _sendDone$0: function() {
      var t1, t2;
      H.assertHelper((this._state & 8) === 0);
      H.assertHelper(this._state < 128);
      H.assertHelper((this._state & 32) === 0);
      t1 = new P._BufferingStreamSubscription__sendDone_sendDone(this);
      this._cancel$0();
      this._state = (this._state | 16) >>> 0;
      t2 = this._cancelFuture;
      if (!!J.getInterceptor(t2).$isFuture)
        t2.whenComplete$1(t1);
      else
        t1.call$0();
    },
    _guardCallback$1: function(callback) {
      var t1;
      H.assertHelper((this._state & 32) === 0);
      t1 = this._state;
      this._state = (t1 | 32) >>> 0;
      callback.call$0();
      this._state = (this._state & 4294967263) >>> 0;
      this._checkState$1((t1 & 4) !== 0);
    },
    _checkState$1: function(wasInputPaused) {
      var t1, isInputPaused;
      H.assertHelper((this._state & 32) === 0);
      t1 = this._state;
      if ((t1 & 64) !== 0 && this._pending.lastPendingEvent == null) {
        t1 = (t1 & 4294967231) >>> 0;
        this._state = t1;
        if ((t1 & 4) !== 0 && this.get$_mayResumeInput())
          this._state = (this._state & 4294967291) >>> 0;
      }
      for (; true; wasInputPaused = isInputPaused) {
        t1 = this._state;
        if ((t1 & 8) !== 0) {
          this._pending = null;
          return;
        }
        isInputPaused = (t1 & 4) !== 0;
        if (wasInputPaused === isInputPaused)
          break;
        this._state = (t1 ^ 32) >>> 0;
        if (isInputPaused)
          this._onPause$0();
        else
          this._onResume$0();
        this._state = (this._state & 4294967263) >>> 0;
      }
      t1 = this._state;
      if ((t1 & 64) !== 0 && t1 < 128)
        this._pending.schedule$1(this);
    },
    _BufferingStreamSubscription$4: function(onData, onError, onDone, cancelOnError, $T) {
      var t1, t2, t3, handleDone, t4, t5;
      t1 = H.getVoidRuntimeType();
      t2 = H.buildFunctionType(t1, [this.T5()]);
      t3 = t2._assertCheck$1(onData);
      t1 = H.buildFunctionType(t1);
      handleDone = t1._assertCheck$1(onDone);
      t2._assertCheck$1(t3);
      t2 = this._zone;
      t2.toString;
      t4 = H.getDynamicRuntimeType();
      t5 = H.buildFunctionType(t4, [t4]);
      t5._assertCheck$1(t3);
      this.set$_async$_onData(t5._assertCheck$1(t3));
      this._onError = P._registerErrorHandler(onError == null ? H.interceptedTypeCheck(P._nullErrorHandler$closure(), "$isFunction") : onError, t2);
      t1._assertCheck$1(handleDone);
      if (handleDone == null)
        handleDone = t1._assertCheck$1(P._nullDoneHandler$closure());
      t1 = H.buildFunctionType(t4);
      t1._assertCheck$1(handleDone);
      this._onDone = t1._assertCheck$1(handleDone);
    },
    T5: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $is_EventDispatch: 1,
    $isStreamSubscription: 1,
    static: {_BufferingStreamSubscription$: function(onData, onError, onDone, cancelOnError, $T) {
        var t1, t2, t3, t4, t5, t6;
        t1 = H.getVoidRuntimeType();
        t2 = H.buildFunctionType(t1, [H.convertRtiToRuntimeType($T)]);
        t3 = t2._assertCheck$1(onData);
        t1 = H.buildFunctionType(t1);
        t4 = t1._assertCheck$1(onDone);
        t5 = $.Zone__current;
        t6 = cancelOnError ? 1 : 0;
        t6 = H.setRuntimeTypeInfo(new P._BufferingStreamSubscription(t2._assertCheck$1(null), null, t1._assertCheck$1(null), t5, t6, null, null), [$T]);
        t6._BufferingStreamSubscription$4(t3, onError, t4, cancelOnError, $T);
        return t6;
      }}
  },
  _BufferingStreamSubscription__sendDone_sendDone: {
    "^": "Closure:1;_async$_captured_this_0",
    call$0: function() {
      var t1, t2;
      t1 = this._async$_captured_this_0;
      t2 = t1._state;
      if ((t2 & 16) === 0)
        return;
      t1._state = (t2 | 42) >>> 0;
      t1._zone.runGuarded$1(t1._onDone);
      t1._state = (t1._state & 4294967263) >>> 0;
    }
  },
  _StreamImpl: {
    "^": "Stream;",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1 = H.getVoidRuntimeType();
      return H.assertSubtype(this._createSubscription$4(H.buildFunctionType(t1, [this.T4()])._assertCheck$1(onData), onError, H.buildFunctionType(t1)._assertCheck$1(onDone), true === cancelOnError), "$isStreamSubscription", [H.getTypeArgumentByIndex(this, 0)], "$asStreamSubscription");
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      var t1 = H.getVoidRuntimeType();
      return H.assertSubtype(P._BufferingStreamSubscription$(H.buildFunctionType(t1, [this.T4()])._assertCheck$1(onData), onError, H.buildFunctionType(t1)._assertCheck$1(onDone), cancelOnError, H.getTypeArgumentByIndex(this, 0)), "$is_BufferingStreamSubscription", [H.getTypeArgumentByIndex(this, 0)], "$as_BufferingStreamSubscription");
    },
    T4: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  _DelayedEvent: {
    "^": "Object;next<",
    set$next: function(next) {
      this.next = H.interceptedTypeCheck(next, "$is_DelayedEvent");
    }
  },
  _DelayedData: {
    "^": "_DelayedEvent;value,next",
    perform$1: function(dispatch) {
      H.assertSubtype(dispatch, "$is_EventDispatch", [H.getTypeArgumentByIndex(this, 0)], "$as_EventDispatch")._sendData$1(this.value);
    }
  },
  _DelayedDone: {
    "^": "Object;",
    perform$1: function(dispatch) {
      dispatch._sendDone$0();
    },
    get$next: function() {
      return;
    },
    set$next: function(_) {
      throw H.wrapException(P.StateError$("No events after a done."));
    },
    $is_DelayedEvent: 1
  },
  _PendingEvents: {
    "^": "Object;_state<",
    set$_state: function(_state) {
      this._state = H.intTypeCheck(_state);
    },
    schedule$1: function(dispatch) {
      var t1;
      if (this._state === 1)
        return;
      H.assertHelper(!this.get$isEmpty(this));
      t1 = this._state;
      if (t1 >= 1) {
        H.assertHelper(t1 === 3);
        this._state = 1;
        return;
      }
      P.scheduleMicrotask(new P._PendingEvents_schedule_closure(this, dispatch));
      this._state = 1;
    }
  },
  _PendingEvents_schedule_closure: {
    "^": "Closure:0;_async$_captured_this_0,_captured_dispatch_1",
    call$0: function() {
      var t1, oldState;
      t1 = this._async$_captured_this_0;
      oldState = t1._state;
      t1._state = 0;
      if (oldState === 3)
        return;
      t1.handleNext$1(this._captured_dispatch_1);
    }
  },
  _StreamImplEvents: {
    "^": "_PendingEvents;firstPendingEvent,lastPendingEvent,_state",
    get$isEmpty: function(_) {
      return this.lastPendingEvent == null;
    },
    add$1: function(_, $event) {
      var t1;
      H.interceptedTypeCheck($event, "$is_DelayedEvent");
      t1 = this.lastPendingEvent;
      if (t1 == null) {
        this.lastPendingEvent = $event;
        this.firstPendingEvent = $event;
      } else {
        t1.set$next($event);
        this.lastPendingEvent = $event;
      }
    },
    handleNext$1: function(dispatch) {
      var $event, t1;
      H.assertHelper(this._state !== 1);
      $event = this.firstPendingEvent;
      t1 = $event.get$next();
      this.firstPendingEvent = t1;
      if (t1 == null)
        this.lastPendingEvent = null;
      $event.perform$1(dispatch);
    }
  },
  _cancelAndError_closure: {
    "^": "Closure:0;_captured_future_0,_captured_error_1,_captured_stackTrace_2",
    call$0: function() {
      return this._captured_future_0._completeError$2(this._captured_error_1, this._captured_stackTrace_2);
    }
  },
  _cancelAndErrorClosure_closure: {
    "^": "Closure:10;_captured_subscription_0,_captured_future_1",
    call$2: function(error, stackTrace) {
      return P._cancelAndError(this._captured_subscription_0, this._captured_future_1, error, stackTrace);
    }
  },
  _cancelAndValue_closure: {
    "^": "Closure:0;_captured_future_0,_captured_value_1",
    call$0: function() {
      return this._captured_future_0._complete$1(this._captured_value_1);
    }
  },
  Timer: {
    "^": "Object;"
  },
  AsyncError: {
    "^": "Object;error>,stackTrace<",
    toString$0: function(_) {
      return H.S(this.error);
    },
    $isError: 1
  },
  _Zone: {
    "^": "Object;",
    $isZone: 1
  },
  _rootHandleUncaughtError_closure: {
    "^": "Closure:0;_captured_error_0,_captured_stackTrace_1",
    call$0: function() {
      var t1 = this._captured_error_0;
      throw H.wrapException(new P._UncaughtAsyncError(t1, P._UncaughtAsyncError__getBestStackTrace(t1, this._captured_stackTrace_1)));
    }
  },
  _RootZone: {
    "^": "_Zone;",
    get$errorZone: function() {
      return this;
    },
    runGuarded$1: function(f) {
      var e, s, t1, exception;
      H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(f);
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$0();
          return t1;
        }
        t1 = P._rootRun(null, null, this, f);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        return P._rootHandleUncaughtError(null, null, this, e, H.interceptedTypeCheck(s, "$isStackTrace"));
      }
    },
    runUnaryGuarded$2: function(f, arg) {
      var e, s, t1, exception;
      t1 = H.getDynamicRuntimeType();
      H.buildFunctionType(t1, [t1])._assertCheck$1(f);
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$1(arg);
          return t1;
        }
        t1 = P._rootRunUnary(null, null, this, f, arg);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        return P._rootHandleUncaughtError(null, null, this, e, H.interceptedTypeCheck(s, "$isStackTrace"));
      }
    },
    bindCallback$2$runGuarded: function(f, runGuarded) {
      var t1, t2;
      t1 = H.buildFunctionType(H.getDynamicRuntimeType());
      t2 = t1._assertCheck$1(f);
      if (runGuarded)
        return t1._assertCheck$1(new P._RootZone_bindCallback_closure(this, t2));
      else
        return t1._assertCheck$1(new P._RootZone_bindCallback_closure0(this, t2));
    },
    bindUnaryCallback$2$runGuarded: function(f, runGuarded) {
      var t1, t2;
      t1 = H.getDynamicRuntimeType();
      t1 = H.buildFunctionType(t1, [t1]);
      t2 = t1._assertCheck$1(f);
      if (runGuarded)
        return t1._assertCheck$1(new P._RootZone_bindUnaryCallback_closure(this, t2));
      else
        return t1._assertCheck$1(new P._RootZone_bindUnaryCallback_closure0(this, t2));
    },
    $index: function(_, key) {
      return;
    },
    run$1: function(f) {
      var t1 = H.buildFunctionType(H.getDynamicRuntimeType())._assertCheck$1(f);
      if ($.Zone__current === C.C__RootZone)
        return t1.call$0();
      return P._rootRun(null, null, this, t1);
    },
    runUnary$2: function(f, arg) {
      var t1 = H.getDynamicRuntimeType();
      t1 = H.buildFunctionType(t1, [t1])._assertCheck$1(f);
      if ($.Zone__current === C.C__RootZone)
        return t1.call$1(arg);
      return P._rootRunUnary(null, null, this, t1, arg);
    },
    runBinary$3: function(f, arg1, arg2) {
      var t1 = H.getDynamicRuntimeType();
      t1 = H.buildFunctionType(t1, [t1, t1])._assertCheck$1(f);
      if ($.Zone__current === C.C__RootZone)
        return t1.call$2(arg1, arg2);
      return P._rootRunBinary(null, null, this, t1, arg1, arg2);
    }
  },
  _RootZone_bindCallback_closure: {
    "^": "Closure:0;_async$_captured_this_0,_captured_f_1",
    call$0: function() {
      return this._async$_captured_this_0.runGuarded$1(this._captured_f_1);
    }
  },
  _RootZone_bindCallback_closure0: {
    "^": "Closure:0;_async$_captured_this_2,_captured_f_3",
    call$0: function() {
      return this._async$_captured_this_2.run$1(this._captured_f_3);
    }
  },
  _RootZone_bindUnaryCallback_closure: {
    "^": "Closure:2;_async$_captured_this_0,_captured_f_1",
    call$1: function(arg) {
      return this._async$_captured_this_0.runUnaryGuarded$2(this._captured_f_1, arg);
    }
  },
  _RootZone_bindUnaryCallback_closure0: {
    "^": "Closure:2;_async$_captured_this_2,_captured_f_3",
    call$1: function(arg) {
      return this._async$_captured_this_2.runUnary$2(this._captured_f_3, arg);
    }
  }
}],
["dart.collection", "dart:collection", , P, {
  "^": "",
  LinkedHashMap_LinkedHashMap$_literal: function(keyValuePairs, $K, $V) {
    return H.assertSubtype(H.fillLiteralMap(H.listTypeCheck(keyValuePairs), H.setRuntimeTypeInfo(new H.JsLinkedHashMap(0, null, null, null, null, null, 0), [$K, $V])), "$isLinkedHashMap", [$K, $V], "$asLinkedHashMap");
  },
  LinkedHashMap_LinkedHashMap$_empty: function($K, $V) {
    return H.assertSubtype(H.setRuntimeTypeInfo(new H.JsLinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]), "$isLinkedHashMap", [$K, $V], "$asLinkedHashMap");
  },
  _defaultEquals: [function(a, b) {
    return J.$eq(a, b);
  }, "call$2", "_defaultEquals$closure", 4, 0, 45],
  _defaultHashCode: [function(a) {
    return J.get$hashCode$(a);
  }, "call$1", "_defaultHashCode$closure", 2, 0, 46],
  IterableBase_iterableToShortString: function(iterable, leftDelimiter, rightDelimiter) {
    var parts, t1, t2, t3;
    if (P.IterableBase__isToStringVisiting(iterable)) {
      if (leftDelimiter === "(" && rightDelimiter === ")")
        return "(...)";
      return leftDelimiter + "..." + rightDelimiter;
    }
    parts = [];
    t1 = $.get$IterableBase__toStringVisiting();
    C.JSArray_methods.add$1(t1, iterable);
    try {
      P.IterableBase__iterablePartsToStrings(iterable, parts);
    } finally {
      t2 = C.JSArray_methods.get$last(t1);
      t3 = iterable;
      H.assertHelper(t2 == null ? t3 == null : t2 === t3);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    t1 = new P.StringBuffer(leftDelimiter);
    t1.writeAll$2(parts, ", ");
    t1 = t1._contents += rightDelimiter;
    return t1.charCodeAt(0) == 0 ? t1 : t1;
  },
  IterableBase_iterableToFullString: function(iterable, leftDelimiter, rightDelimiter) {
    var buffer, t1, t2, t3;
    if (P.IterableBase__isToStringVisiting(iterable))
      return leftDelimiter + "..." + rightDelimiter;
    buffer = new P.StringBuffer(leftDelimiter);
    t1 = $.get$IterableBase__toStringVisiting();
    C.JSArray_methods.add$1(t1, iterable);
    try {
      buffer.writeAll$2(iterable, ", ");
    } finally {
      t2 = C.JSArray_methods.get$last(t1);
      t3 = iterable;
      H.assertHelper(t2 == null ? t3 == null : t2 === t3);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    t1 = buffer;
    t1._contents = t1.get$_contents() + rightDelimiter;
    t1 = buffer.get$_contents();
    return t1.charCodeAt(0) == 0 ? t1 : t1;
  },
  IterableBase__isToStringVisiting: function(o) {
    var i, t1;
    for (i = 0; t1 = $.get$IterableBase__toStringVisiting(), i < t1.length; ++i) {
      t1 = t1[i];
      if (o == null ? t1 == null : o === t1)
        return true;
    }
    return false;
  },
  IterableBase__iterablePartsToStrings: function(iterable, parts) {
    var it, $length, count, next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, elision;
    it = iterable.get$iterator(iterable);
    $length = 0;
    count = 0;
    while (true) {
      if (!($length < 80 || count < 3))
        break;
      if (!it.moveNext$0())
        return;
      next = H.S(it.get$current());
      C.JSArray_methods.add$1(parts, next);
      $length += next.length + 2;
      ++count;
    }
    if (!it.moveNext$0()) {
      if (count <= 5)
        return;
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      ultimateString = parts.pop();
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      penultimateString = parts.pop();
    } else {
      penultimate = it.get$current();
      ++count;
      if (!it.moveNext$0()) {
        if (count <= 4) {
          C.JSArray_methods.add$1(parts, H.S(penultimate));
          return;
        }
        ultimateString = H.S(penultimate);
        if (0 >= parts.length)
          return H.ioore(parts, 0);
        penultimateString = parts.pop();
        $length += ultimateString.length + 2;
      } else {
        ultimate = it.get$current();
        ++count;
        H.assertHelper(count < 100);
        for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
          ultimate0 = it.get$current();
          ++count;
          if (count > 100) {
            while (true) {
              if (!($length > 75 && count > 3))
                break;
              if (0 >= parts.length)
                return H.ioore(parts, 0);
              $length -= parts.pop().length + 2;
              --count;
            }
            C.JSArray_methods.add$1(parts, "...");
            return;
          }
        }
        penultimateString = H.S(penultimate);
        ultimateString = H.S(ultimate);
        $length += ultimateString.length + penultimateString.length + 4;
      }
    }
    if (count > parts.length + 2) {
      $length += 5;
      elision = "...";
    } else
      elision = null;
    while (true) {
      if (!($length > 80 && parts.length > 3))
        break;
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      $length -= parts.pop().length + 2;
      if (elision == null) {
        $length += 5;
        elision = "...";
      }
    }
    if (elision != null)
      C.JSArray_methods.add$1(parts, elision);
    C.JSArray_methods.add$1(parts, penultimateString);
    C.JSArray_methods.add$1(parts, ultimateString);
  },
  LinkedHashMap_LinkedHashMap: function(equals, hashCode, isValidKey, $K, $V) {
    var t1, t2;
    t1 = H.buildInterfaceType(P.bool);
    t2 = H.convertRtiToRuntimeType($K);
    H.buildFunctionType(t1, [t2, t2])._assertCheck$1(equals);
    H.buildFunctionType(H.buildInterfaceType(P.$int), [t2])._assertCheck$1(hashCode);
    H.buildFunctionType(t1, [H.getDynamicRuntimeType()])._assertCheck$1(isValidKey);
    return H.assertSubtype(H.setRuntimeTypeInfo(new H.JsLinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]), "$isLinkedHashMap", [$K, $V], "$asLinkedHashMap");
  },
  LinkedHashMap_LinkedHashMap$identity: function($K, $V) {
    return H.setRuntimeTypeInfo(new P._LinkedIdentityHashMap(0, null, null, null, null, null, 0), [$K, $V]);
  },
  LinkedHashMap_LinkedHashMap$from: function(other, $K, $V) {
    var result = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, $K, $V), "$isLinkedHashMap", [$K, $V], "$asLinkedHashMap");
    J.forEach$1$ax(other, new P.LinkedHashMap_LinkedHashMap$from_closure(result));
    return H.assertSubtype(result, "$isLinkedHashMap", [$K, $V], "$asLinkedHashMap");
  },
  LinkedHashSet_LinkedHashSet: function(equals, hashCode, isValidKey, $E) {
    var t1, t2;
    t1 = H.buildInterfaceType(P.bool);
    t2 = H.convertRtiToRuntimeType($E);
    H.buildFunctionType(t1, [t2, t2])._assertCheck$1(equals);
    H.buildFunctionType(H.buildInterfaceType(P.$int), [t2])._assertCheck$1(hashCode);
    H.buildFunctionType(t1, [H.getDynamicRuntimeType()])._assertCheck$1(isValidKey);
    return H.assertSubtype(H.setRuntimeTypeInfo(new P._LinkedHashSet(0, null, null, null, null, null, 0), [$E]), "$isLinkedHashSet", [$E], "$asLinkedHashSet");
  },
  LinkedHashSet_LinkedHashSet$from: function(elements, $E) {
    var result, t1;
    H.listSuperNativeTypeCheck(elements, "$isIterable");
    result = H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, $E), "$isLinkedHashSet", [$E], "$asLinkedHashSet");
    for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
      result.add$1(0, H.assertSubtypeOfRuntimeType(t1.get$current(), $E));
    return H.assertSubtype(result, "$isLinkedHashSet", [$E], "$asLinkedHashSet");
  },
  Maps_mapToString: function(m) {
    var t1, result, t2, t3;
    t1 = {};
    if (P.IterableBase__isToStringVisiting(m))
      return "{...}";
    result = new P.StringBuffer("");
    try {
      C.JSArray_methods.add$1($.get$IterableBase__toStringVisiting(), m);
      t2 = result;
      t2._contents = t2.get$_contents() + "{";
      t1._captured_first_0 = true;
      J.forEach$1$ax(m, new P.Maps_mapToString_closure(t1, result));
      t1 = result;
      t1._contents = t1.get$_contents() + "}";
    } finally {
      t1 = $.get$IterableBase__toStringVisiting();
      t2 = C.JSArray_methods.get$last(t1);
      t3 = m;
      H.assertHelper(t2 == null ? t3 == null : t2 === t3);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    t1 = result.get$_contents();
    return t1.charCodeAt(0) == 0 ? t1 : t1;
  },
  _LinkedIdentityHashMap: {
    "^": "JsLinkedHashMap;__js_helper$_length,_strings,_nums,_rest,_first,_last,_modifications",
    internalComputeHashCode$1: function(key) {
      return H.objectHashCode(key) & 0x3ffffff;
    },
    internalFindBucketIndex$2: function(bucket, key) {
      var $length, i, t1;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i) {
        t1 = H.interceptedTypeCheck(bucket[i], "$isLinkedHashMapCell").hashMapCellKey;
        if (t1 == null ? key == null : t1 === key)
          return i;
      }
      return -1;
    },
    K: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    V: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[1]);
    }
  },
  _LinkedHashSet: {
    "^": "_HashSetBase;_collection$_length,_collection$_strings,_collection$_nums,_collection$_rest,_collection$_first,_collection$_last,_collection$_modifications",
    get$iterator: function(_) {
      var t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(this, this._collection$_modifications, null, H.assertSubtypeOfRuntimeType(null, null)), [null]);
      t1._cell = t1._set._collection$_first;
      return H.assertSubtype(t1, "$isIterator", [H.getTypeArgumentByIndex(this, 0)], "$asIterator");
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    contains$1: function(_, object) {
      var strings, nums;
      if (typeof object === "string" && object !== "__proto__") {
        strings = this._collection$_strings;
        if (strings == null)
          return false;
        return H.interceptedTypeCheck(strings[object], "$isLinkedHashSetCell") != null;
      } else if (typeof object === "number" && (object & 0x3ffffff) === object) {
        nums = this._collection$_nums;
        if (nums == null)
          return false;
        return H.interceptedTypeCheck(nums[object], "$isLinkedHashSetCell") != null;
      } else
        return this._contains$1(object);
    },
    _contains$1: function(object) {
      var rest = this._collection$_rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(H.listTypeCheck(rest[this._computeHashCode$1(object)]), object) >= 0;
    },
    lookup$1: function(object) {
      var t1 = typeof object === "number" && (object & 0x3ffffff) === object;
      if (t1) {
        t1 = this.contains$1(0, object) ? object : null;
        return H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(this, 0));
      } else
        return H.assertSubtypeOfRuntimeType(this._lookup$1(object), H.getTypeArgumentByIndex(this, 0));
    },
    _lookup$1: function(object) {
      var rest, bucket, index;
      rest = this._collection$_rest;
      if (rest == null)
        return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 0));
      bucket = H.listTypeCheck(rest[this._computeHashCode$1(object)]);
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 0));
      return H.assertSubtypeOfRuntimeType(J.$index$asx(bucket, index).get$_element(), H.getTypeArgumentByIndex(this, 0));
    },
    forEach$1: function(_, action) {
      var t1, cell, modifications;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [this.E2()])._assertCheck$1(action);
      cell = this._collection$_first;
      modifications = this._collection$_modifications;
      for (; cell != null;) {
        t1.call$1(cell._element);
        if (modifications !== this._collection$_modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        cell = cell._collection$_next;
      }
    },
    get$last: function(_) {
      var t1 = this._collection$_last;
      if (t1 == null)
        throw H.wrapException(P.StateError$("No elements"));
      return H.assertSubtypeOfRuntimeType(t1._element, H.getTypeArgumentByIndex(this, 0));
    },
    add$1: function(_, element) {
      var strings, table, nums;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
      if (typeof element === "string" && element !== "__proto__") {
        strings = this._collection$_strings;
        if (strings == null) {
          table = Object.create(null);
          H.assertHelper(table != null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._collection$_strings = table;
          strings = table;
        }
        return this._collection$_addHashTableEntry$2(strings, element);
      } else if (typeof element === "number" && (element & 0x3ffffff) === element) {
        nums = this._collection$_nums;
        if (nums == null) {
          table = Object.create(null);
          H.assertHelper(table != null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._collection$_nums = table;
          nums = table;
        }
        return this._collection$_addHashTableEntry$2(nums, element);
      } else
        return this._add$1(element);
    },
    _add$1: function(element) {
      var rest, hash, bucket, t1;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
      rest = this._collection$_rest;
      if (rest == null) {
        rest = P._LinkedHashSet__newHashTable();
        this._collection$_rest = rest;
      }
      hash = this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null) {
        t1 = [this._collection$_newLinkedCell$1(element)];
        H.assertHelper(t1 != null);
        rest[hash] = t1;
      } else {
        if (this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(this._collection$_newLinkedCell$1(element));
      }
      return true;
    },
    remove$1: function(_, object) {
      if (typeof object === "string" && object !== "__proto__")
        return this._removeHashTableEntry$2(this._collection$_strings, object);
      else if (typeof object === "number" && (object & 0x3ffffff) === object)
        return this._removeHashTableEntry$2(this._collection$_nums, object);
      else
        return this._remove$1(object);
    },
    _remove$1: function(object) {
      var rest, bucket, index;
      rest = this._collection$_rest;
      if (rest == null)
        return false;
      bucket = H.listTypeCheck(rest[this._computeHashCode$1(object)]);
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      this._unlinkCell$1(H.interceptedTypeCheck(bucket.splice(index, 1)[0], "$isLinkedHashSetCell"));
      return true;
    },
    clear$0: function(_) {
      if (this._collection$_length > 0) {
        this._collection$_last = null;
        this._collection$_first = null;
        this._collection$_rest = null;
        this._collection$_nums = null;
        this._collection$_strings = null;
        this._collection$_length = 0;
        this._collection$_modifications = this._collection$_modifications + 1 & 67108863;
      }
    },
    _collection$_addHashTableEntry$2: function(table, element) {
      var t1;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
      if (H.interceptedTypeCheck(table[element], "$isLinkedHashSetCell") != null)
        return false;
      t1 = this._collection$_newLinkedCell$1(element);
      H.assertHelper(true);
      table[element] = t1;
      return true;
    },
    _removeHashTableEntry$2: function(table, element) {
      var cell;
      if (table == null)
        return false;
      cell = H.interceptedTypeCheck(table[element], "$isLinkedHashSetCell");
      if (cell == null)
        return false;
      this._unlinkCell$1(cell);
      delete table[element];
      return true;
    },
    _collection$_newLinkedCell$1: function(element) {
      var cell, last;
      cell = new P.LinkedHashSetCell(H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0)), null, null);
      if (this._collection$_first == null) {
        this._collection$_last = cell;
        this._collection$_first = cell;
      } else {
        last = this._collection$_last;
        cell._collection$_previous = last;
        last._collection$_next = cell;
        this._collection$_last = cell;
      }
      ++this._collection$_length;
      this._collection$_modifications = this._collection$_modifications + 1 & 67108863;
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var previous, next, t1;
      previous = cell._collection$_previous;
      next = cell._collection$_next;
      if (previous == null) {
        t1 = this._collection$_first;
        H.assertHelper(cell == null ? t1 == null : cell === t1);
        this._collection$_first = next;
      } else
        previous._collection$_next = next;
      if (next == null) {
        t1 = this._collection$_last;
        H.assertHelper(cell == null ? t1 == null : cell === t1);
        this._collection$_last = previous;
      } else
        next._collection$_previous = previous;
      --this._collection$_length;
      this._collection$_modifications = this._collection$_modifications + 1 & 67108863;
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(H.interceptedTypeCheck(bucket[i], "$isLinkedHashSetCell")._element, element))
          return i;
      return -1;
    },
    E2: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    E1: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isLinkedHashSet: 1,
    $isSet: 1,
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: null,
    static: {_LinkedHashSet__newHashTable: function() {
        var table = Object.create(null);
        H.assertHelper(table != null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  LinkedHashSetCell: {
    "^": "Object;_element<,_collection$_next,_collection$_previous"
  },
  LinkedHashSetIterator: {
    "^": "Object;_set,_collection$_modifications,_cell,_collection$_current",
    set$_collection$_current: function(_current) {
      this._collection$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    get$current: function() {
      return H.assertSubtypeOfRuntimeType(this._collection$_current, H.getTypeArgumentByIndex(this, 0));
    },
    moveNext$0: function() {
      var t1 = this._set;
      if (this._collection$_modifications !== t1._collection$_modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = this._cell;
        if (t1 == null) {
          this.set$_collection$_current(null);
          return false;
        } else {
          this.set$_collection$_current(t1._element);
          this._cell = this._cell._collection$_next;
          return true;
        }
      }
    },
    $isIterator: 1
  },
  _HashSetBase: {
    "^": "SetBase;",
    E1: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  IterableBase: {
    "^": "Object;",
    map$1: function(_, f) {
      return H.MappedIterable_MappedIterable(this, H.buildFunctionType(H.getDynamicRuntimeType(), [this.E()])._assertCheck$1(f), H.getRuntimeTypeArgument(this, "IterableBase", 0), null);
    },
    forEach$1: function(_, f) {
      var t1, t2;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [this.E()])._assertCheck$1(f);
      for (t2 = this.get$iterator(this); t2.moveNext$0();)
        t1.call$1(H.assertSubtypeOfRuntimeType(t2.get$current(), H.getRuntimeTypeArgument(this, "IterableBase", 0)));
    },
    join$1: function(_, separator) {
      var iterator, buffer, t1;
      iterator = H.assertSubtype(this.get$iterator(this), "$isIterator", [H.getRuntimeTypeArgument(this, "IterableBase", 0)], "$asIterator");
      if (!iterator.moveNext$0())
        return "";
      buffer = new P.StringBuffer("");
      if (separator === "") {
        do
          buffer._contents += H.S(iterator.get$current());
        while (iterator.moveNext$0());
      } else {
        buffer._contents = H.S(iterator.get$current());
        for (; iterator.moveNext$0();) {
          buffer._contents += separator;
          buffer._contents += H.S(iterator.get$current());
        }
      }
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    toList$1$growable: function(_, growable) {
      return H.assertSubtype(P.List_List$from(this, growable, H.getRuntimeTypeArgument(this, "IterableBase", 0)), "$isList", [H.getRuntimeTypeArgument(this, "IterableBase", 0)], "$asList");
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    toSet$0: function(_) {
      return H.assertSubtype(H.assertSubtype(P.LinkedHashSet_LinkedHashSet$from(this, H.getRuntimeTypeArgument(this, "IterableBase", 0)), "$isSet", [H.getRuntimeTypeArgument(this, "IterableBase", 0)], "$asSet"), "$isSet", [H.getRuntimeTypeArgument(this, "IterableBase", 0)], "$asSet");
    },
    get$length: function(_) {
      var it, count;
      H.assertHelper(!this.$isEfficientLength);
      it = this.get$iterator(this);
      for (count = 0; it.moveNext$0();)
        ++count;
      return count;
    },
    get$isEmpty: function(_) {
      return !this.get$iterator(this).moveNext$0();
    },
    get$isNotEmpty: function(_) {
      return !this.get$isEmpty(this);
    },
    get$last: function(_) {
      var it, result;
      it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      do
        result = H.assertSubtypeOfRuntimeType(it.get$current(), H.getRuntimeTypeArgument(this, "IterableBase", 0));
      while (it.moveNext$0());
      return H.assertSubtypeOfRuntimeType(result, H.getRuntimeTypeArgument(this, "IterableBase", 0));
    },
    get$single: function(_) {
      var it, result;
      it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      result = H.assertSubtypeOfRuntimeType(it.get$current(), H.getRuntimeTypeArgument(this, "IterableBase", 0));
      if (it.moveNext$0())
        throw H.wrapException(H.IterableElementError_tooMany());
      return H.assertSubtypeOfRuntimeType(result, H.getRuntimeTypeArgument(this, "IterableBase", 0));
    },
    elementAt$1: function(_, index) {
      var t1, elementIndex, element;
      if (index < 0)
        H.throwExpression(P.RangeError$range(index, 0, null, "index", null));
      for (t1 = this.get$iterator(this), elementIndex = 0; t1.moveNext$0();) {
        element = H.assertSubtypeOfRuntimeType(t1.get$current(), H.getRuntimeTypeArgument(this, "IterableBase", 0));
        if (index === elementIndex)
          return H.assertSubtypeOfRuntimeType(element, H.getRuntimeTypeArgument(this, "IterableBase", 0));
        ++elementIndex;
      }
      throw H.wrapException(P.IndexError$(index, this, "index", null, elementIndex));
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToShortString(this, "(", ")");
    },
    E: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isIterable: 1,
    $asIterable: null
  },
  LinkedHashMap: {
    "^": "Object;",
    $isMap: 1,
    $asMap: null
  },
  LinkedHashMap_LinkedHashMap$from_closure: {
    "^": "Closure:11;_captured_result_0",
    call$2: function(k, v) {
      this._captured_result_0.$indexSet(0, k, v);
    }
  },
  LinkedHashSet: {
    "^": "Object;",
    $isSet: 1,
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: null
  },
  ListBase: {
    "^": "Object_ListMixin;"
  },
  Object_ListMixin: {
    "^": "Object+ListMixin;",
    $isList: 1,
    $asList: null,
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: null
  },
  ListMixin: {
    "^": "Object;",
    get$iterator: function(receiver) {
      var t1, t2;
      t1 = H.getRuntimeTypeArgument(receiver, "ListMixin", 0);
      H.listSuperNativeTypeCheck(receiver, "$isIterable");
      t2 = this.get$length(receiver);
      return H.assertSubtype(H.setRuntimeTypeInfo(new H.ListIterator(H.listSuperNativeTypeCheck(receiver, "$isIterable"), t2, 0, H.assertSubtypeOfRuntimeType(null, t1)), [t1]), "$isIterator", [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)], "$asIterator");
    },
    elementAt$1: function(receiver, index) {
      return H.assertSubtypeOfRuntimeType(this.$index(receiver, index), H.getRuntimeTypeArgument(receiver, "ListMixin", 0));
    },
    forEach$1: function(receiver, action) {
      var t1, $length, i;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [H.convertRtiToRuntimeType(receiver.$builtinTypeInfo && receiver.$builtinTypeInfo[0])])._assertCheck$1(action);
      $length = this.get$length(receiver);
      for (i = 0; i < $length; ++i) {
        t1.call$1(this.$index(receiver, i));
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
    },
    get$isEmpty: function(receiver) {
      return this.get$length(receiver) === 0;
    },
    get$last: function(receiver) {
      if (this.get$length(receiver) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      return H.assertSubtypeOfRuntimeType(this.$index(receiver, this.get$length(receiver) - 1), H.getRuntimeTypeArgument(receiver, "ListMixin", 0));
    },
    get$single: function(receiver) {
      if (this.get$length(receiver) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      if (this.get$length(receiver) > 1)
        throw H.wrapException(H.IterableElementError_tooMany());
      return H.assertSubtypeOfRuntimeType(this.$index(receiver, 0), H.getRuntimeTypeArgument(receiver, "ListMixin", 0));
    },
    where$1: function(receiver, test) {
      var t1, t2, t3;
      t1 = H.buildInterfaceType(P.bool);
      t2 = H.buildFunctionType(t1, [H.convertRtiToRuntimeType(receiver.$builtinTypeInfo && receiver.$builtinTypeInfo[0])])._assertCheck$1(test);
      t3 = H.getRuntimeTypeArgument(receiver, "ListMixin", 0);
      H.listSuperNativeTypeCheck(receiver, "$isIterable");
      H.buildFunctionType(t1, [H.convertRtiToRuntimeType(t3)])._assertCheck$1(t2);
      return H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(receiver, "$isIterable"), H.buildFunctionType(t1, [H.getDynamicRuntimeType()])._assertCheck$1(t2)), [t3]), "$isIterable");
    },
    map$1: function(receiver, f) {
      var t1, t2;
      t1 = H.buildFunctionType(H.getDynamicRuntimeType(), [H.convertRtiToRuntimeType(receiver.$builtinTypeInfo && receiver.$builtinTypeInfo[0])])._assertCheck$1(f);
      H.listSuperNativeTypeCheck(receiver, "$isIterable");
      t2 = H.buildFunctionType(H.convertRtiToRuntimeType(null), [H.convertRtiToRuntimeType(null)]);
      t2._assertCheck$1(t1);
      return H.setRuntimeTypeInfo(new H.MappedListIterable(H.listSuperNativeTypeCheck(receiver, "$isIterable"), t2._assertCheck$1(t1)), [null, null]);
    },
    toList$1$growable: function(receiver, growable) {
      var result, i, t1;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
        C.JSArray_methods.set$length(result, this.get$length(receiver));
        H.assertSubtype(result, "$isList", [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)], "$asList");
      } else
        result = H.assertSubtype(H.setRuntimeTypeInfo(Array(this.get$length(receiver)), [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]), "$isList", [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)], "$asList");
      for (i = 0; i < this.get$length(receiver); ++i) {
        t1 = this.$index(receiver, i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
      }
      return H.assertSubtype(result, "$isList", [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)], "$asList");
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    toSet$0: function(receiver) {
      var result, i;
      result = H.assertSubtype(H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, H.getRuntimeTypeArgument(receiver, "ListMixin", 0)), "$isSet", [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)], "$asSet"), "$isSet", [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)], "$asSet");
      for (i = 0; i < this.get$length(receiver); ++i)
        result.add$1(0, this.$index(receiver, i));
      return H.assertSubtype(result, "$isSet", [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)], "$asSet");
    },
    add$1: function(receiver, element) {
      var t1;
      H.assertSubtypeOfRuntimeType(element, H.getRuntimeTypeArgument(receiver, "ListMixin", 0));
      t1 = this.get$length(receiver);
      this.set$length(receiver, t1 + 1);
      this.$indexSet(receiver, t1, element);
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    $isList: 1,
    $asList: null,
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: null
  },
  Maps_mapToString_closure: {
    "^": "Closure:11;_collection$_box_0,_captured_result_1",
    call$2: function(k, v) {
      var t1, t2;
      t1 = this._collection$_box_0;
      if (!t1._captured_first_0)
        this._captured_result_1._contents += ", ";
      t1._captured_first_0 = false;
      t1 = this._captured_result_1;
      t2 = t1._contents += H.S(k);
      t1._contents = t2 + ": ";
      t1._contents += H.S(v);
    }
  },
  ListQueue: {
    "^": "IterableBase;_table,_head,_tail,_modificationCount",
    set$_table: function(_table) {
      this._table = H.assertSubtype(_table, "$isList", [H.getTypeArgumentByIndex(this, 0)], "$asList");
    },
    get$iterator: function(_) {
      var t1 = new P._ListQueueIterator(this, this._tail, this._modificationCount, this._head, H.assertSubtypeOfRuntimeType(null, H.getTypeArgumentByIndex(this, 0)));
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return H.assertSubtype(t1, "$isIterator", [H.getTypeArgumentByIndex(this, 0)], "$asIterator");
    },
    forEach$1: function(_, action) {
      var t1, modificationCount, i, t2;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [this.E0()])._assertCheck$1(action);
      modificationCount = this._modificationCount;
      for (i = this._head; i !== this._tail; i = (i + 1 & this._table.length - 1) >>> 0) {
        t2 = this._table;
        if (i < 0 || i >= t2.length)
          return H.ioore(t2, i);
        t1.call$1(t2[i]);
        if (modificationCount !== this._modificationCount)
          H.throwExpression(P.ConcurrentModificationError$(this));
      }
    },
    get$isEmpty: function(_) {
      return this._head === this._tail;
    },
    get$length: function(_) {
      return (this._tail - this._head & this._table.length - 1) >>> 0;
    },
    get$last: function(_) {
      var t1, t2, t3;
      t1 = this._head;
      t2 = this._tail;
      if (t1 === t2)
        throw H.wrapException(H.IterableElementError_noElement());
      t1 = this._table;
      t3 = t1.length;
      t2 = (t2 - 1 & t3 - 1) >>> 0;
      if (t2 < 0 || t2 >= t3)
        return H.ioore(t1, t2);
      return H.assertSubtypeOfRuntimeType(t1[t2], H.getTypeArgumentByIndex(this, 0));
    },
    toList$1$growable: function(_, growable) {
      var list, t1;
      if (growable) {
        list = H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(this, 0)]);
        C.JSArray_methods.set$length(list, this.get$length(this));
        H.assertSubtype(list, "$isList", [H.getTypeArgumentByIndex(this, 0)], "$asList");
      } else {
        t1 = Array(this.get$length(this));
        t1.fixed$length = Array;
        list = H.assertSubtype(H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]), "$isList", [H.getTypeArgumentByIndex(this, 0)], "$asList");
      }
      this._writeToList$1(list);
      return H.assertSubtype(list, "$isList", [H.getTypeArgumentByIndex(this, 0)], "$asList");
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    add$1: function(_, element) {
      this._add$1(H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0)));
    },
    clear$0: function(_) {
      var i, t1, t2, t3, t4;
      i = this._head;
      t1 = this._tail;
      if (i !== t1) {
        for (t2 = this._table, t3 = t2.length, t4 = t3 - 1; i !== t1; i = (i + 1 & t4) >>> 0) {
          if (i < 0 || i >= t3)
            return H.ioore(t2, i);
          t2[i] = null;
        }
        this._tail = 0;
        this._head = 0;
        ++this._modificationCount;
      }
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    removeFirst$0: function() {
      var t1, t2, t3, result;
      t1 = this._head;
      if (t1 === this._tail)
        throw H.wrapException(H.IterableElementError_noElement());
      ++this._modificationCount;
      t2 = this._table;
      t3 = t2.length;
      if (t1 >= t3)
        return H.ioore(t2, t1);
      result = H.assertSubtypeOfRuntimeType(t2[t1], H.getTypeArgumentByIndex(this, 0));
      t2[t1] = null;
      this._head = (t1 + 1 & t3 - 1) >>> 0;
      return H.assertSubtypeOfRuntimeType(result, H.getTypeArgumentByIndex(this, 0));
    },
    _add$1: function(element) {
      var t1, t2, t3;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
      t1 = this._table;
      t2 = this._tail;
      t3 = t1.length;
      if (t2 < 0 || t2 >= t3)
        return H.ioore(t1, t2);
      t1[t2] = element;
      t3 = (t2 + 1 & t3 - 1) >>> 0;
      this._tail = t3;
      if (this._head === t3)
        this._grow$0();
      ++this._modificationCount;
    },
    _grow$0: function() {
      var t1, newTable, t2, split;
      t1 = Array(this._table.length * 2);
      t1.fixed$length = Array;
      newTable = H.assertSubtype(H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]), "$isList", [H.getTypeArgumentByIndex(this, 0)], "$asList");
      t1 = this._table;
      t2 = this._head;
      split = t1.length - t2;
      C.JSArray_methods.setRange$4(newTable, 0, split, t1, t2);
      C.JSArray_methods.setRange$4(newTable, split, split + this._head, this._table, 0);
      this._head = 0;
      this._tail = this._table.length;
      this.set$_table(newTable);
    },
    _writeToList$1: function(target) {
      var t1, t2, t3, $length, firstPartSize;
      H.assertSubtype(target, "$isList", [H.getTypeArgumentByIndex(this, 0)], "$asList");
      H.assertHelper(target.length >= this.get$length(this));
      t1 = this._head;
      t2 = this._tail;
      t3 = this._table;
      if (t1 <= t2) {
        $length = t2 - t1;
        C.JSArray_methods.setRange$4(target, 0, $length, t3, t1);
        return $length;
      } else {
        firstPartSize = t3.length - t1;
        C.JSArray_methods.setRange$4(target, 0, firstPartSize, t3, t1);
        C.JSArray_methods.setRange$4(target, firstPartSize, firstPartSize + this._tail, this._table, 0);
        return this._tail + firstPartSize;
      }
    },
    ListQueue$1: function(initialCapacity, $E) {
      var t1;
      if (initialCapacity == null || initialCapacity < 8)
        initialCapacity = 8;
      else {
        if (typeof initialCapacity !== "number")
          return initialCapacity.$sub();
        if ((initialCapacity & initialCapacity - 1) >>> 0 !== 0)
          initialCapacity = P.ListQueue__nextPowerOf2(initialCapacity);
      }
      if (typeof initialCapacity !== "number")
        return initialCapacity.$sub();
      H.assertHelper((initialCapacity & initialCapacity - 1) >>> 0 === 0);
      t1 = Array(initialCapacity);
      t1.fixed$length = Array;
      this.set$_table(H.setRuntimeTypeInfo(t1, [$E]));
    },
    E0: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    E: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isQueue: 1,
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: null,
    static: {ListQueue$: function(initialCapacity, $E) {
        var t1 = H.setRuntimeTypeInfo(new P.ListQueue(H.assertSubtype(null, "$isList", [$E], "$asList"), 0, 0, 0), [$E]);
        t1.ListQueue$1(initialCapacity, $E);
        return t1;
      }, ListQueue_ListQueue$from: function(elements, $E) {
        var t1, $length, queue, result, element;
        t1 = J.getInterceptor(elements);
        if (!!t1.$isList) {
          $length = t1.get$length(elements);
          queue = H.assertSubtype(P.ListQueue$($length + 1, null), "$isListQueue", [$E], "$asListQueue");
          H.assertHelper(queue._table.length > $length);
          C.JSArray_methods.setRange$4(queue._table, 0, $length, elements, 0);
          queue._tail = $length;
          return H.assertSubtype(queue, "$isListQueue", [$E], "$asListQueue");
        } else {
          result = H.assertSubtype(P.ListQueue$(!!t1.$isEfficientLength ? t1.get$length(elements) : 8, $E), "$isListQueue", [$E], "$asListQueue");
          for (t1 = t1.get$iterator(elements); t1.moveNext$0();) {
            element = H.assertSubtypeOfRuntimeType(t1.get$current(), $E);
            H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(result, 0));
            result._add$1(element);
          }
          return H.assertSubtype(result, "$isListQueue", [$E], "$asListQueue");
        }
      }, ListQueue__nextPowerOf2: function(number) {
        var nextNumber;
        if (typeof number !== "number")
          return number.$gt();
        H.assertHelper(number > 0);
        number = (number << 1 >>> 0) - 1;
        for (; true; number = nextNumber) {
          nextNumber = (number & number - 1) >>> 0;
          if (nextNumber === 0)
            return number;
        }
      }}
  },
  _ListQueueIterator: {
    "^": "Object;_queue,_end,_modificationCount,_collection$_position,_collection$_current",
    set$_collection$_current: function(_current) {
      this._collection$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    get$current: function() {
      return H.assertSubtypeOfRuntimeType(this._collection$_current, H.getTypeArgumentByIndex(this, 0));
    },
    moveNext$0: function() {
      var t1, t2, t3;
      t1 = this._queue;
      if (this._modificationCount !== t1._modificationCount)
        H.throwExpression(P.ConcurrentModificationError$(t1));
      t2 = this._collection$_position;
      if (t2 === this._end) {
        this.set$_collection$_current(null);
        return false;
      }
      t3 = t1._table;
      if (t2 >= t3.length)
        return H.ioore(t3, t2);
      this.set$_collection$_current(t3[t2]);
      this._collection$_position = (this._collection$_position + 1 & t1._table.length - 1) >>> 0;
      return true;
    },
    $isIterator: 1
  },
  SetMixin: {
    "^": "Object;",
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    addAll$1: function(_, elements) {
      var t1;
      H.listSuperNativeTypeCheck(elements, "$isIterable");
      for (t1 = elements.get$iterator(elements); t1.moveNext$0();)
        this.add$1(0, H.assertSubtypeOfRuntimeType(H.assertSubtypeOfRuntimeType(t1._collection$_current, H.getTypeArgumentByIndex(t1, 0)), H.getTypeArgumentByIndex(this, 0)));
    },
    toList$1$growable: function(_, growable) {
      var result, t1, i, element, i0;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(this, 0)]);
        C.JSArray_methods.set$length(result, this.get$length(this));
      } else {
        t1 = Array(this.get$length(this));
        t1.fixed$length = Array;
        result = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      }
      H.assertSubtype(result, "$isList", [H.getTypeArgumentByIndex(this, 0)], "$asList");
      for (t1 = this.get$iterator(this), i = 0; t1.moveNext$0(); i = i0) {
        element = H.assertSubtypeOfRuntimeType(H.assertSubtypeOfRuntimeType(t1._collection$_current, H.getTypeArgumentByIndex(t1, 0)), H.getTypeArgumentByIndex(this, 0));
        i0 = i + 1;
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = element;
      }
      return H.assertSubtype(result, "$isList", [H.getTypeArgumentByIndex(this, 0)], "$asList");
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    forEach$1: function(_, f) {
      var t1, t2;
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [this.E1()])._assertCheck$1(f);
      for (t2 = this.get$iterator(this); t2.moveNext$0();)
        t1.call$1(H.assertSubtypeOfRuntimeType(H.assertSubtypeOfRuntimeType(t2._collection$_current, H.getTypeArgumentByIndex(t2, 0)), H.getTypeArgumentByIndex(this, 0)));
    },
    join$1: function(_, separator) {
      var iterator, buffer, t1;
      iterator = H.assertSubtype(this.get$iterator(this), "$isIterator", [H.getTypeArgumentByIndex(this, 0)], "$asIterator");
      if (!iterator.moveNext$0())
        return "";
      buffer = new P.StringBuffer("");
      if (separator === "") {
        do
          buffer._contents += H.S(H.assertSubtypeOfRuntimeType(iterator._collection$_current, H.getTypeArgumentByIndex(iterator, 0)));
        while (iterator.moveNext$0());
      } else {
        buffer._contents = H.S(H.assertSubtypeOfRuntimeType(iterator._collection$_current, H.getTypeArgumentByIndex(iterator, 0)));
        for (; iterator.moveNext$0();) {
          buffer._contents += separator;
          buffer._contents += H.S(H.assertSubtypeOfRuntimeType(iterator._collection$_current, H.getTypeArgumentByIndex(iterator, 0)));
        }
      }
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    get$last: function(_) {
      var it, result;
      it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      do
        result = H.assertSubtypeOfRuntimeType(H.assertSubtypeOfRuntimeType(it._collection$_current, H.getTypeArgumentByIndex(it, 0)), H.getTypeArgumentByIndex(this, 0));
      while (it.moveNext$0());
      return H.assertSubtypeOfRuntimeType(result, H.getTypeArgumentByIndex(this, 0));
    },
    E1: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isSet: 1,
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: null
  },
  SetBase: {
    "^": "SetMixin;",
    E1: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  }
}],
["dart.convert", "dart:convert", , P, {
  "^": "",
  _convertJsonToDartLazy: function(object) {
    var i;
    if (object == null)
      return;
    if (typeof object != "object")
      return object;
    if (Object.getPrototypeOf(object) !== Array.prototype)
      return new P._JsonMap(object, Object.create(null), null);
    for (i = 0; i < object.length; ++i)
      object[i] = P._convertJsonToDartLazy(object[i]);
    return object;
  },
  _parseJson: function(source, reviver) {
    var parsed, e, t1, exception;
    t1 = H.getDynamicRuntimeType();
    H.buildFunctionType(t1, [t1, t1])._assertCheck$1(reviver);
    t1 = source;
    if (typeof t1 !== "string")
      throw H.wrapException(P.ArgumentError$(source));
    parsed = null;
    try {
      parsed = JSON.parse(source);
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      throw H.wrapException(P.FormatException$(String(e), null, null));
    }
    return P._convertJsonToDartLazy(parsed);
  },
  _defaultToEncodable: [function(object) {
    return object.toJson$0();
  }, "call$1", "_defaultToEncodable$closure", 2, 0, 47],
  _isLeadSurrogate: function(codeUnit) {
    codeUnit.$and(0, 64512);
    return false;
  },
  _combineSurrogatePair: function(lead, tail) {
    return (C.JSInt_methods.$add(65536, lead.$and(0, 1023).$shl(0, 10)) | tail & 1023) >>> 0;
  },
  _JsonMap: {
    "^": "Object;_original,_processed,_data",
    $index: function(_, key) {
      var t1, result;
      t1 = this._processed;
      if (t1 == null) {
        H.assertHelper(true);
        return this._data.$index(0, key);
      } else if (typeof key !== "string")
        return;
      else {
        result = t1[key];
        return typeof result == "undefined" ? this._process$1(key) : result;
      }
    },
    get$length: function(_) {
      var t1;
      if (this._processed == null) {
        H.assertHelper(true);
        t1 = this._data;
        t1 = t1.get$length(t1);
      } else
        t1 = this._computeKeys$0().length;
      return t1;
    },
    get$isEmpty: function(_) {
      var t1;
      if (this._processed == null) {
        H.assertHelper(true);
        t1 = this._data;
        t1 = t1.get$length(t1);
      } else
        t1 = this._computeKeys$0().length;
      return t1 === 0;
    },
    get$keys: function(_) {
      var t1;
      if (this._processed == null) {
        H.assertHelper(true);
        t1 = this._data;
        return t1.get$keys(t1);
      }
      return new P._JsonMapKeyIterable(this);
    },
    $indexSet: function(_, key, value) {
      var processed, original;
      if (this._processed == null) {
        H.assertHelper(true);
        this._data.$indexSet(0, key, value);
      } else if (this.containsKey$1(0, key)) {
        processed = this._processed;
        H.stringTypeCheck(key);
        processed[key] = value;
        original = this._original;
        if (original == null ? processed != null : original !== processed)
          original[key] = null;
      } else
        this._upgrade$0().$indexSet(0, key, value);
    },
    containsKey$1: function(_, key) {
      if (this._processed == null) {
        H.assertHelper(true);
        return this._data.containsKey$1(0, key);
      }
      if (typeof key !== "string")
        return false;
      return Object.prototype.hasOwnProperty.call(this._original, key);
    },
    remove$1: function(_, key) {
      if (this._processed != null && !this.containsKey$1(0, key))
        return;
      return this._upgrade$0().remove$1(0, key);
    },
    forEach$1: function(_, f) {
      var t1, keys, i, key, value;
      t1 = H.getDynamicRuntimeType();
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [t1, t1])._assertCheck$1(f);
      if (this._processed == null) {
        H.assertHelper(true);
        return H.voidTypeCheck(this._data.forEach$1(0, t1));
      }
      keys = H.assertSubtype(this._computeKeys$0(), "$isList", [P.String], "$asList");
      for (i = 0; i < keys.length; ++i) {
        key = H.stringTypeCheck(keys[i]);
        value = this._processed[key];
        if (typeof value == "undefined") {
          value = P._convertJsonToDartLazy(this._original[key]);
          this._processed[key] = value;
        }
        t1.call$2(key, value);
        if (keys !== this._data)
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    _computeKeys$0: function() {
      H.assertHelper(this._processed != null);
      var keys = H.listTypeCheck(this._data);
      if (keys == null) {
        keys = Object.keys(this._original);
        this._data = keys;
      }
      return H.assertSubtype(keys, "$isList", [P.String], "$asList");
    },
    _upgrade$0: function() {
      var result, keys, i, t1, key;
      if (this._processed == null) {
        H.assertHelper(true);
        return this._data;
      }
      result = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      keys = H.assertSubtype(this._computeKeys$0(), "$isList", [P.String], "$asList");
      for (i = 0; t1 = keys.length, i < t1; ++i) {
        key = H.stringTypeCheck(keys[i]);
        result.$indexSet(0, key, this.$index(0, key));
      }
      if (t1 === 0)
        C.JSArray_methods.add$1(keys, null);
      else
        C.JSArray_methods.set$length(keys, 0);
      this._processed = null;
      this._original = null;
      this._data = result;
      H.assertHelper(true);
      return result;
    },
    _process$1: function(key) {
      var result;
      if (!Object.prototype.hasOwnProperty.call(this._original, key))
        return;
      result = P._convertJsonToDartLazy(this._original[key]);
      return this._processed[key] = result;
    },
    $isLinkedHashMap: 1,
    $asLinkedHashMap: $.functionThatReturnsNull,
    $isMap: 1,
    $asMap: $.functionThatReturnsNull
  },
  _JsonMapKeyIterable: {
    "^": "ListIterable;_parent",
    get$length: function(_) {
      var t1 = this._parent;
      if (t1._processed == null) {
        H.assertHelper(true);
        t1 = t1._data;
        t1 = t1.get$length(t1);
      } else
        t1 = t1._computeKeys$0().length;
      return t1;
    },
    elementAt$1: function(_, index) {
      var t1 = this._parent;
      if (t1._processed == null)
        t1 = t1.get$keys(t1).elementAt$1(0, index);
      else {
        t1 = t1._computeKeys$0();
        if (index < 0 || index >= t1.length)
          return H.ioore(t1, index);
        t1 = t1[index];
      }
      return H.stringTypeCheck(t1);
    },
    get$iterator: function(_) {
      var t1, t2, t3;
      t1 = this._parent;
      if (t1._processed == null) {
        t1 = t1.get$keys(t1);
        t1 = t1.get$iterator(t1);
      } else {
        t1 = t1._computeKeys$0();
        t2 = H.getTypeArgumentByIndex(t1, 0);
        H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray");
        t3 = t1.length;
        t1 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator");
      }
      return t1;
    },
    E3: function() {
      return H.convertRtiToRuntimeType($.functionThatReturnsNull.apply(null, this.$builtinTypeInfo));
    },
    E: function() {
      return H.convertRtiToRuntimeType($.functionThatReturnsNull.apply(null, this.$builtinTypeInfo));
    },
    $asListIterable: $.functionThatReturnsNull,
    $asIterableBase: $.functionThatReturnsNull,
    $asIterable: $.functionThatReturnsNull
  },
  Codec: {
    "^": "Object;"
  },
  Converter: {
    "^": "Object;"
  },
  Encoding: {
    "^": "Codec;",
    $asCodec: function() {
      return [P.String, [P.List, P.$int]];
    }
  },
  JsonUnsupportedObjectError: {
    "^": "Error;unsupportedObject,cause",
    toString$0: function(_) {
      if (this.cause != null)
        return "Converting object to an encodable object failed.";
      else
        return "Converting object did not return an encodable object.";
    },
    static: {JsonUnsupportedObjectError$: function(unsupportedObject, cause) {
        return new P.JsonUnsupportedObjectError(unsupportedObject, cause);
      }}
  },
  JsonCyclicError: {
    "^": "JsonUnsupportedObjectError;unsupportedObject,cause",
    toString$0: function(_) {
      return "Cyclic error in JSON stringify";
    }
  },
  JsonCodec: {
    "^": "Codec;_reviver,_toEncodable",
    decode$2$reviver: function(source, reviver) {
      var t1;
      H.stringTypeCheck(source);
      t1 = H.getDynamicRuntimeType();
      t1 = H.buildFunctionType(t1, [t1, t1]);
      t1._assertCheck$1(reviver);
      t1._assertCheck$1(this._reviver);
      return P._parseJson(source, this.get$decoder()._reviver);
    },
    decode$1: function(source) {
      return this.decode$2$reviver(source, null);
    },
    encode$2$toEncodable: function(value, toEncodable) {
      var t1 = H.getDynamicRuntimeType();
      t1 = H.buildFunctionType(t1, [t1]);
      t1._assertCheck$1(toEncodable);
      t1._assertCheck$1(this._toEncodable);
      t1 = this.get$encoder();
      return P._JsonStringStringifier_stringify(value, t1._toEncodable, t1.indent);
    },
    encode$1: function(value) {
      return this.encode$2$toEncodable(value, null);
    },
    get$encoder: function() {
      return C.JsonEncoder_null_null;
    },
    get$decoder: function() {
      return C.JsonDecoder_null;
    },
    $asCodec: function() {
      return [P.Object, P.String];
    }
  },
  JsonEncoder: {
    "^": "Converter;indent,_toEncodable",
    $asConverter: function() {
      return [P.Object, P.String];
    }
  },
  JsonDecoder: {
    "^": "Converter;_reviver",
    $asConverter: function() {
      return [P.String, P.Object];
    }
  },
  _JsonStringifier: {
    "^": "Object;",
    writeStringContent$1: function(s) {
      var $length, t1, offset, i, charCode, t2;
      $length = s.length;
      for (t1 = J.getInterceptor$s(s), offset = 0, i = 0; i < $length; ++i) {
        charCode = t1.codeUnitAt$1(s, i);
        if (charCode > 92)
          continue;
        if (charCode < 32) {
          if (i > offset)
            this.writeStringSlice$3(s, offset, i);
          offset = i + 1;
          this.writeCharCode$1(92);
          switch (charCode) {
            case 8:
              this.writeCharCode$1(98);
              break;
            case 9:
              this.writeCharCode$1(116);
              break;
            case 10:
              this.writeCharCode$1(110);
              break;
            case 12:
              this.writeCharCode$1(102);
              break;
            case 13:
              this.writeCharCode$1(114);
              break;
            default:
              this.writeCharCode$1(117);
              this.writeCharCode$1(48);
              this.writeCharCode$1(48);
              t2 = charCode >>> 4 & 15;
              this.writeCharCode$1(t2 < 10 ? 48 + t2 : 87 + t2);
              t2 = charCode & 15;
              this.writeCharCode$1(t2 < 10 ? 48 + t2 : 87 + t2);
              break;
          }
        } else if (charCode === 34 || charCode === 92) {
          if (i > offset)
            this.writeStringSlice$3(s, offset, i);
          offset = i + 1;
          this.writeCharCode$1(92);
          this.writeCharCode$1(charCode);
        }
      }
      if (offset === 0)
        this.writeString$1(s);
      else if (offset < $length)
        this.writeStringSlice$3(s, offset, $length);
    },
    _checkCycle$1: function(object) {
      var t1, t2, i, t3;
      for (t1 = this._seen, t2 = t1.length, i = 0; i < t2; ++i) {
        t3 = t1[i];
        if (object == null ? t3 == null : object === t3)
          throw H.wrapException(new P.JsonCyclicError(object, null));
      }
      C.JSArray_methods.add$1(t1, object);
    },
    _removeSeen$1: function(object) {
      var t1, t2;
      t1 = this._seen;
      H.assertHelper(t1.length !== 0);
      t2 = C.JSArray_methods.get$last(t1);
      H.assertHelper(t2 == null ? object == null : t2 === object);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    },
    writeObject$1: function(object) {
      var customJson, e, t1, t2, t3, exception;
      if (this.writeJsonValue$1(object))
        return;
      this._checkCycle$1(object);
      try {
        customJson = this._toEncodable$1(object);
        if (!this.writeJsonValue$1(customJson)) {
          t1 = P.JsonUnsupportedObjectError$(object, null);
          throw H.wrapException(t1);
        }
        t1 = object;
        t2 = this._seen;
        H.assertHelper(t2.length !== 0);
        t3 = C.JSArray_methods.get$last(t2);
        H.assertHelper(t3 == null ? t1 == null : t3 === t1);
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2.pop();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        throw H.wrapException(P.JsonUnsupportedObjectError$(object, e));
      }
    },
    writeJsonValue$1: function(object) {
      var t1;
      if (typeof object === "number") {
        if (!C.JSNumber_methods.get$isFinite(object))
          return false;
        this.writeNumber$1(object);
        return true;
      } else if (object === true) {
        this.writeString$1("true");
        return true;
      } else if (object === false) {
        this.writeString$1("false");
        return true;
      } else if (object == null) {
        this.writeString$1("null");
        return true;
      } else if (typeof object === "string") {
        this.writeString$1("\"");
        this.writeStringContent$1(object);
        this.writeString$1("\"");
        return true;
      } else {
        t1 = J.getInterceptor(object);
        if (!!t1.$isList) {
          this._checkCycle$1(object);
          this.writeList$1(object);
          this._removeSeen$1(object);
          return true;
        } else if (!!t1.$isMap) {
          this._checkCycle$1(object);
          this.writeMap$1(object);
          this._removeSeen$1(object);
          return true;
        } else
          return false;
      }
    },
    writeList$1: function(list) {
      var t1, i;
      this.writeString$1("[");
      t1 = J.getInterceptor$asx(list);
      if (t1.get$length(list) > 0) {
        this.writeObject$1(t1.$index(list, 0));
        for (i = 1; i < t1.get$length(list); ++i) {
          this.writeString$1(",");
          this.writeObject$1(t1.$index(list, i));
        }
      }
      this.writeString$1("]");
    },
    writeMap$1: function(map) {
      var t1 = {};
      H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
      this.writeString$1("{");
      t1._captured_separator_0 = "\"";
      J.forEach$1$ax(map, new P._JsonStringifier_writeMap_closure(t1, this));
      this.writeString$1("}");
    },
    _toEncodable$1: function(arg0) {
      return this._toEncodable.call$1(arg0);
    }
  },
  _JsonStringifier_writeMap_closure: {
    "^": "Closure:12;_convert$_box_0,_captured_this_1",
    call$2: function(key, value) {
      var t1, t2;
      H.stringTypeCheck(key);
      t1 = this._captured_this_1;
      t2 = this._convert$_box_0;
      t1.writeString$1(t2._captured_separator_0);
      t2._captured_separator_0 = ",\"";
      t1.writeStringContent$1(key);
      t1.writeString$1("\":");
      t1.writeObject$1(value);
    }
  },
  _JsonStringStringifier: {
    "^": "_JsonStringifier;_sink,_seen,_toEncodable",
    writeNumber$1: function(number) {
      this._sink._contents += C.JSNumber_methods.toString$0(number);
    },
    writeString$1: function(string) {
      this._sink._contents += string;
    },
    writeStringSlice$3: function(string, start, end) {
      this._sink._contents += C.JSString_methods.substring$2(string, start, end);
    },
    writeCharCode$1: function(charCode) {
      this._sink._contents += H.Primitives_stringFromCharCode(charCode);
    },
    static: {_JsonStringStringifier_stringify: function(object, toEncodable, indent) {
        var t1, output, stringifier;
        t1 = H.getDynamicRuntimeType();
        t1 = H.buildFunctionType(t1, [t1]);
        output = new P.StringBuffer("");
        t1._assertCheck$1(t1._assertCheck$1(toEncodable));
        stringifier = new P._JsonStringStringifier(output, [], H.interceptedTypeCheck(P._defaultToEncodable$closure(), "$isFunction"));
        stringifier.writeObject$1(object);
        t1 = output._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }}
  },
  Utf8Codec: {
    "^": "Encoding;_allowMalformed",
    get$name: function(_) {
      return "utf-8";
    },
    get$encoder: function() {
      return new P.Utf8Encoder();
    }
  },
  Utf8Encoder: {
    "^": "Converter;",
    convert$3: function(string, start, end) {
      var stringLength, $length, t1, encoder;
      stringLength = string.get$length(string);
      P.RangeError_checkValidRange(start, end, stringLength, null, null, null);
      $length = stringLength.$sub(0, start);
      t1 = $length.$mul(0, 3);
      t1 = H.assertSubtype(H.assertSubtype(new Uint8Array(t1), "$isList", [P.$int], "$asList"), "$isList", [P.$int], "$asList");
      encoder = new P._Utf8Encoder(0, 0, t1);
      H.assertHelper(C.JSInt_methods.$ge(encoder._fillBuffer$3(string, start, stringLength), stringLength.$sub(0, 1)));
      H.assertHelper(P._isLeadSurrogate(string.codeUnitAt$1(0, stringLength.$sub(0, 1))));
      return H.assertSubtype(H.assertSubtype(new Uint8Array(t1.subarray(0, C.NativeUint8List_methods._checkSublistArguments$3(t1, 0, encoder._bufferIndex, t1.length))), "$isList", [P.$int], "$asList"), "$isList", [P.$int], "$asList");
    },
    convert$1: function(string) {
      return this.convert$3(string, 0, null);
    },
    $asConverter: function() {
      return [P.String, [P.List, P.$int]];
    }
  },
  _Utf8Encoder: {
    "^": "Object;_carry,_bufferIndex,_buffer",
    _writeSurrogate$2: function(leadingSurrogate, nextCodeUnit) {
      var t1, t2, t3, t4;
      if ((nextCodeUnit & 64512) === 56320)
        P._combineSurrogatePair(leadingSurrogate, nextCodeUnit);
      else {
        t1 = this._buffer;
        t2 = this._bufferIndex++;
        t3 = C.JSInt_methods.$or(224, leadingSurrogate.$shr(0, 12));
        t4 = t1.length;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = t3;
        t3 = this._bufferIndex++;
        t2 = C.JSInt_methods.$or(128, leadingSurrogate.$shr(0, 6).$and(0, 63));
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = t2;
        t2 = this._bufferIndex++;
        t3 = C.JSInt_methods.$or(128, leadingSurrogate.$and(0, 63));
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = t3;
        return false;
      }
    },
    _fillBuffer$3: function(str, start, end) {
      var t1, t2, stringIndex, codeUnit, t3, stringIndex0, t4;
      if (P._isLeadSurrogate(str.codeUnitAt$1(0, end.$sub(0, 1))))
        end = end.$sub(0, 1);
      for (t1 = this._buffer, t2 = t1.length, stringIndex = start; C.JSInt_methods.$lt(stringIndex, end); ++stringIndex) {
        codeUnit = str.codeUnitAt$1(0, stringIndex);
        if (codeUnit.$le(0, 127)) {
          t3 = this._bufferIndex;
          if (t3 >= t2)
            break;
          this._bufferIndex = t3 + 1;
          t1[t3] = codeUnit;
        } else if (P._isLeadSurrogate(codeUnit)) {
          if (this._bufferIndex + 3 >= t2)
            break;
          stringIndex0 = stringIndex + 1;
          if (this._writeSurrogate$2(codeUnit, str.codeUnitAt$1(0, stringIndex0)))
            stringIndex = stringIndex0;
        } else if (codeUnit.$le(0, 2047)) {
          t3 = this._bufferIndex;
          t4 = t3 + 1;
          if (t4 >= t2)
            break;
          this._bufferIndex = t4;
          t4 = C.JSInt_methods.$or(192, codeUnit.$shr(0, 6));
          if (t3 >= t2)
            return H.ioore(t1, t3);
          t1[t3] = t4;
          t4 = this._bufferIndex++;
          t3 = C.JSInt_methods.$or(128, codeUnit.$and(0, 63));
          if (t4 >= t2)
            return H.ioore(t1, t4);
          t1[t4] = t3;
        } else {
          H.assertHelper(codeUnit.$le(0, 65535));
          t3 = this._bufferIndex;
          if (t3 + 2 >= t2)
            break;
          this._bufferIndex = t3 + 1;
          t4 = C.JSInt_methods.$or(224, codeUnit.$shr(0, 12));
          if (t3 >= t2)
            return H.ioore(t1, t3);
          t1[t3] = t4;
          t4 = this._bufferIndex++;
          t3 = C.JSInt_methods.$or(128, codeUnit.$shr(0, 6).$and(0, 63));
          if (t4 >= t2)
            return H.ioore(t1, t4);
          t1[t4] = t3;
          t3 = this._bufferIndex++;
          t4 = C.JSInt_methods.$or(128, codeUnit.$and(0, 63));
          if (t3 >= t2)
            return H.ioore(t1, t3);
          t1[t3] = t4;
        }
      }
      return stringIndex;
    }
  }
}],
["dart.core", "dart:core", , P, {
  "^": "",
  _symbolToString: function(symbol) {
    return H.Symbol_getName(symbol);
  },
  String__checkBounds: function(len, start, end) {
    if (start < 0 || start > len)
      throw H.wrapException(P.RangeError$range(start, 0, len, null, null));
    if (end == null)
      end = len;
    else if (end < start || end > len)
      throw H.wrapException(P.RangeError$range(end, start, len, null, null));
    return end;
  },
  String__stringFromIterable: function(charCodes, start, end) {
    var t1, it, i, list;
    H.listSuperNativeTypeCheck(charCodes, "$isIterable");
    if (start < 0)
      throw H.wrapException(P.RangeError$range(start, 0, J.get$length$asx(charCodes), null, null));
    t1 = end == null;
    if (!t1 && end < start)
      throw H.wrapException(P.RangeError$range(end, start, J.get$length$asx(charCodes), null, null));
    it = J.get$iterator$ax(charCodes);
    for (i = 0; i < start; ++i)
      if (!it.moveNext$0())
        throw H.wrapException(P.RangeError$range(start, 0, i, null, null));
    list = [];
    if (t1)
      for (; it.moveNext$0();)
        C.JSArray_methods.add$1(list, it.get$current());
    else
      for (i = start; i < end; ++i) {
        if (!it.moveNext$0())
          throw H.wrapException(P.RangeError$range(end, start, i, null, null));
        C.JSArray_methods.add$1(list, it.get$current());
      }
    return H.Primitives_stringFromCharCodes(list);
  },
  Comparable_compare: [function(a, b) {
    return J.compareTo$1$ns(H.numberOrStringSuperNativeTypeCheck(a, "$isComparable"), H.numberOrStringSuperNativeTypeCheck(b, "$isComparable"));
  }, "call$2", "Comparable_compare$closure", 4, 0, 48],
  Error_safeToString: function(object) {
    if (typeof object === "number" || typeof object === "boolean" || null == object)
      return J.toString$0(object);
    if (typeof object === "string")
      return JSON.stringify(object);
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Exception_Exception: function(message) {
    return new P._ExceptionImplementation(message);
  },
  identical: [function(a, b) {
    return a == null ? b == null : a === b;
  }, "call$2", "identical$closure", 4, 0, 49],
  identityHashCode: [function(object) {
    return H.objectHashCode(object);
  }, "call$1", "identityHashCode$closure", 2, 0, 50],
  List_List$from: function(elements, growable, $E) {
    var list, t1;
    list = H.assertSubtype(H.setRuntimeTypeInfo([], [$E]), "$isList", [$E], "$asList");
    for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
      C.JSArray_methods.add$1(list, H.assertSubtypeOfRuntimeType(t1.get$current(), $E));
    if (growable)
      return H.assertSubtype(list, "$isList", [$E], "$asList");
    list.fixed$length = Array;
    return H.assertSubtype(list, "$isList", [$E], "$asList");
  },
  print: function(object) {
    var line = H.S(object);
    H.printString(line);
  },
  RegExp_RegExp: function(source, caseSensitive, multiLine) {
    return new H.JSSyntaxRegExp(source, H.JSSyntaxRegExp_makeNative(source, multiLine, caseSensitive, false), null, null);
  },
  String_String$fromCharCodes: function(charCodes, start, end) {
    var len;
    H.listSuperNativeTypeCheck(charCodes, "$isIterable");
    if (charCodes.constructor === Array) {
      len = charCodes.length;
      end = P.String__checkBounds(len, start, end);
      return H.Primitives_stringFromCharCodes(start > 0 || end < len ? C.JSArray_methods.sublist$2(charCodes, start, end) : charCodes);
    }
    return P.String__stringFromIterable(charCodes, start, end);
  },
  NoSuchMethodError_toString_closure: {
    "^": "Closure:13;_core$_box_0",
    call$2: function(key, value) {
      var t1 = this._core$_box_0;
      if (t1._captured_i_1 > 0)
        t1._captured_sb_0._contents += ", ";
      P._symbolToString(key);
    }
  },
  bool: {
    "^": "Object;"
  },
  "+bool": 0,
  Comparable: {
    "^": "Object;"
  },
  DateTime: {
    "^": "Object;",
    $isComparable: 1,
    $asComparable: $.functionThatReturnsNull
  },
  $double: {
    "^": "num;",
    $isComparable: 1,
    $asComparable: function() {
      return [P.num];
    }
  },
  "+double": 0,
  Duration: {
    "^": "Object;_duration",
    $add: function(_, other) {
      return new P.Duration(H.intTypeCheck(C.JSInt_methods.$add(this._duration, other.get$_duration())));
    },
    $lt: function(_, other) {
      return C.JSInt_methods.$lt(this._duration, other.get$_duration());
    },
    $gt: function(_, other) {
      return C.JSInt_methods.$gt(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof P.Duration))
        return false;
      return this._duration === other._duration;
    },
    get$hashCode: function(_) {
      return this._duration & 0x1FFFFFFF;
    },
    compareTo$1: function(_, other) {
      return C.JSInt_methods.compareTo$1(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration);
    },
    toString$0: function(_) {
      var t1, t2, twoDigitMinutes, twoDigitSeconds, sixDigitUs;
      t1 = new P.Duration_toString_twoDigits();
      t2 = this._duration;
      if (t2 < 0)
        return "-" + new P.Duration(-t2).toString$0(0);
      twoDigitMinutes = H.stringTypeCheck(t1.call$1(C.JSInt_methods.remainder$1(C.JSInt_methods._tdivFast$1(t2, 60000000), 60)));
      twoDigitSeconds = H.stringTypeCheck(t1.call$1(C.JSInt_methods.remainder$1(C.JSInt_methods._tdivFast$1(t2, 1000000), 60)));
      sixDigitUs = H.stringTypeCheck(new P.Duration_toString_sixDigits().call$1(C.JSInt_methods.remainder$1(t2, 1000000)));
      return "" + C.JSInt_methods._tdivFast$1(t2, 3600000000) + ":" + H.S(twoDigitMinutes) + ":" + H.S(twoDigitSeconds) + "." + H.S(sixDigitUs);
    },
    $isComparable: 1,
    $asComparable: function() {
      return [P.Duration];
    },
    static: {Duration$: function(days, hours, microseconds, milliseconds, minutes, seconds) {
        return new P.Duration(864e8 * days + 3600000000 * hours + 60000000 * minutes + 1000000 * seconds + 1000 * milliseconds + microseconds);
      }}
  },
  Duration_toString_sixDigits: {
    "^": "Closure:14;",
    call$1: function(n) {
      if (n >= 100000)
        return "" + n;
      if (n >= 10000)
        return "0" + n;
      if (n >= 1000)
        return "00" + n;
      if (n >= 100)
        return "000" + n;
      if (n >= 10)
        return "0000" + n;
      return "00000" + n;
    }
  },
  Duration_toString_twoDigits: {
    "^": "Closure:14;",
    call$1: function(n) {
      if (n >= 10)
        return "" + n;
      return "0" + n;
    }
  },
  Error: {
    "^": "Object;",
    get$stackTrace: function() {
      return H.getTraceFromException(this.$thrownJsError);
    }
  },
  AssertionError: {
    "^": "Error;"
  },
  NullThrownError: {
    "^": "Error;",
    toString$0: function(_) {
      return "Throw of null.";
    }
  },
  ArgumentError: {
    "^": "Error;_hasValue,invalidValue,name>,message",
    get$_errorName: function() {
      return "Invalid argument" + (!this._hasValue ? "(s)" : "");
    },
    get$_errorExplanation: function() {
      return "";
    },
    toString$0: function(_) {
      var t1, nameString, message, prefix, explanation, errorValue;
      t1 = this.name;
      nameString = t1 != null ? " (" + H.S(t1) + ")" : "";
      t1 = this.message;
      message = t1 == null ? "" : ": " + H.S(t1);
      prefix = this.get$_errorName() + nameString + message;
      if (!this._hasValue)
        return prefix;
      explanation = this.get$_errorExplanation();
      errorValue = P.Error_safeToString(this.invalidValue);
      return prefix + explanation + ": " + H.S(errorValue);
    },
    static: {ArgumentError$: function(message) {
        return new P.ArgumentError(false, null, null, message);
      }, ArgumentError$value: function(value, $name, message) {
        return new P.ArgumentError(true, value, $name, message);
      }}
  },
  RangeError: {
    "^": "ArgumentError;start,end,_hasValue,invalidValue,name,message",
    get$_errorName: function() {
      return "RangeError";
    },
    get$_errorExplanation: function() {
      var t1, explanation, t2;
      H.assertHelper(this._hasValue);
      t1 = this.start;
      if (t1 == null) {
        t1 = this.end;
        explanation = t1 != null ? ": Not less than or equal to " + H.S(t1) : "";
      } else {
        t2 = this.end;
        if (t2 == null)
          explanation = ": Not greater than or equal to " + H.S(t1);
        else {
          if (typeof t2 !== "number")
            return t2.$gt();
          if (C.JSInt_methods.$gt(t2, t1))
            explanation = ": Not in range " + H.S(t1) + ".." + t2 + ", inclusive";
          else
            explanation = C.JSInt_methods.$lt(t2, t1) ? ": Valid value range is empty" : ": Only valid value is " + H.S(t1);
        }
      }
      return explanation;
    },
    static: {RangeError$value: function(value, $name, message) {
        H.numTypeCheck(value);
        return new P.RangeError(null, null, true, value, $name, "Value not in range");
      }, RangeError$range: function(invalidValue, minValue, maxValue, $name, message) {
        return new P.RangeError(minValue, maxValue, true, invalidValue, $name, "Invalid value");
      }, RangeError_checkValueInInterval: function(value, minValue, maxValue, $name, message) {
        if (value < minValue || value > maxValue)
          throw H.wrapException(P.RangeError$range(value, minValue, maxValue, $name, message));
      }, RangeError_checkValidRange: function(start, end, $length, startName, endName, message) {
        if (0 > start || start > $length)
          throw H.wrapException(P.RangeError$range(start, 0, $length, "start", message));
        if (end != null) {
          if (start > end || end > $length)
            throw H.wrapException(P.RangeError$range(end, start, $length, "end", message));
          return end;
        }
        return $length;
      }}
  },
  IndexError: {
    "^": "ArgumentError;indexable,length>,_hasValue,invalidValue,name,message",
    get$_errorName: function() {
      return "RangeError";
    },
    get$_errorExplanation: function() {
      var explanation, t1;
      H.assertHelper(this._hasValue);
      P.Error_safeToString(this.indexable);
      explanation = ": index should be less than " + H.S(this.length);
      t1 = this.invalidValue;
      if (typeof t1 !== "number")
        return t1.$lt();
      return t1 < 0 ? ": index must not be negative" : explanation;
    },
    $isRangeError: 1,
    static: {IndexError$: function(invalidValue, indexable, $name, message, $length) {
        var t1 = $length != null ? $length : J.get$length$asx(indexable);
        return new P.IndexError(indexable, H.intTypeCheck(t1), true, invalidValue, $name, "Index out of range");
      }}
  },
  UnsupportedError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Unsupported operation: " + this.message;
    },
    static: {UnsupportedError$: function(message) {
        return new P.UnsupportedError(message);
      }}
  },
  UnimplementedError: {
    "^": "Error;message",
    toString$0: function(_) {
      var t1 = this.message;
      return t1 != null ? "UnimplementedError: " + H.S(t1) : "UnimplementedError";
    },
    static: {UnimplementedError$: function(message) {
        return new P.UnimplementedError(message);
      }}
  },
  StateError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Bad state: " + this.message;
    },
    static: {StateError$: function(message) {
        return new P.StateError(message);
      }}
  },
  ConcurrentModificationError: {
    "^": "Error;modifiedObject",
    toString$0: function(_) {
      return "Concurrent modification during iteration: " + H.S(P.Error_safeToString(this.modifiedObject)) + ".";
    },
    static: {ConcurrentModificationError$: function(modifiedObject) {
        return new P.ConcurrentModificationError(modifiedObject);
      }}
  },
  OutOfMemoryError: {
    "^": "Object;",
    toString$0: function(_) {
      return "Out of Memory";
    },
    get$stackTrace: function() {
      return;
    },
    $isError: 1
  },
  StackOverflowError: {
    "^": "Object;",
    toString$0: function(_) {
      return "Stack Overflow";
    },
    get$stackTrace: function() {
      return;
    },
    $isError: 1
  },
  CyclicInitializationError: {
    "^": "Error;variableName",
    toString$0: function(_) {
      return "Reading static variable '" + this.variableName + "' during its initialization";
    }
  },
  _ExceptionImplementation: {
    "^": "Object;message",
    toString$0: function(_) {
      var t1 = this.message;
      if (t1 == null)
        return "Exception";
      return "Exception: " + H.S(t1);
    },
    $isException: 1
  },
  FormatException: {
    "^": "Object;message,source,offset",
    toString$0: function(_) {
      var t1, report, offset, source, lineNum, lineStart, lastWasCR, i, $char, lineEnd, end, start, prefix, postfix, slice;
      t1 = this.message;
      report = t1 != null && "" !== t1 ? "FormatException: " + H.S(t1) : "FormatException";
      offset = this.offset;
      source = this.source;
      if (typeof source !== "string")
        return offset != null ? report + (" (at offset " + H.S(offset) + ")") : report;
      if (offset != null)
        t1 = offset < 0 || offset > source.length;
      else
        t1 = false;
      if (t1)
        offset = null;
      if (offset == null) {
        if (source.length > 78)
          source = J.substring$2$s(source, 0, 75) + "...";
        return report + "\n" + H.S(source);
      }
      for (t1 = J.getInterceptor$s(source), lineNum = 1, lineStart = 0, lastWasCR = null, i = 0; i < offset; ++i) {
        $char = t1.codeUnitAt$1(source, i);
        if ($char === 10) {
          if (lineStart !== i || !H.boolConversionCheck(lastWasCR))
            ++lineNum;
          lineStart = i + 1;
          lastWasCR = false;
        } else if ($char === 13) {
          ++lineNum;
          lineStart = i + 1;
          lastWasCR = true;
        }
      }
      report = lineNum > 1 ? report + (" (at line " + lineNum + ", character " + (offset - lineStart + 1) + ")\n") : report + (" (at character " + (offset + 1) + ")\n");
      lineEnd = source.length;
      for (i = offset; i < lineEnd; ++i) {
        $char = t1.codeUnitAt$1(source, i);
        if ($char === 10 || $char === 13) {
          lineEnd = i;
          break;
        }
      }
      if (lineEnd - lineStart > 78)
        if (offset - lineStart < 75) {
          end = lineStart + 75;
          start = lineStart;
          prefix = "";
          postfix = "...";
        } else {
          if (lineEnd - offset < 75) {
            start = lineEnd - 75;
            end = lineEnd;
            postfix = "";
          } else {
            start = offset - 36;
            end = offset + 36;
            postfix = "...";
          }
          prefix = "...";
        }
      else {
        end = lineEnd;
        start = lineStart;
        prefix = "";
        postfix = "";
      }
      slice = t1.substring$2(source, start, end);
      return report + prefix + slice + postfix + "\n" + C.JSString_methods.$mul(" ", offset - start + prefix.length) + "^\n";
    },
    $isException: 1,
    static: {FormatException$: function(message, source, offset) {
        return new P.FormatException(message, source, offset);
      }}
  },
  Expando: {
    "^": "Object;name>",
    toString$0: function(_) {
      return "Expando:" + H.S(this.name);
    },
    $index: function(_, object) {
      var values, t1;
      values = H.Primitives_getProperty(object, "expando$values");
      t1 = values == null ? null : H.Primitives_getProperty(values, this._getKey$0());
      return H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(this, 0));
    },
    $indexSet: function(_, object, value) {
      var values;
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0));
      values = H.Primitives_getProperty(object, "expando$values");
      if (values == null) {
        values = new P.Object();
        H.Primitives_setProperty(object, "expando$values", values);
      }
      H.Primitives_setProperty(values, this._getKey$0(), value);
    },
    _getKey$0: function() {
      var key, t1;
      key = H.stringTypeCheck(H.Primitives_getProperty(this, "expando$key"));
      if (key == null) {
        t1 = $.Expando__keyCount;
        $.Expando__keyCount = t1 + 1;
        key = "expando$key$" + t1;
        H.Primitives_setProperty(this, "expando$key", key);
      }
      return key;
    }
  },
  Function: {
    "^": "Object;"
  },
  $int: {
    "^": "num;",
    $isComparable: 1,
    $asComparable: function() {
      return [P.num];
    }
  },
  "+int": 0,
  Iterator: {
    "^": "Object;"
  },
  List: {
    "^": "Object;",
    $asList: null,
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: null
  },
  "+List": 0,
  Map: {
    "^": "Object;",
    $asMap: null
  },
  Null: {
    "^": "Object;",
    toString$0: function(_) {
      return "null";
    }
  },
  "+Null": 0,
  num: {
    "^": "Object;",
    $isComparable: 1,
    $asComparable: function() {
      return [P.num];
    }
  },
  "+num": 0,
  Object: {
    "^": ";",
    $eq: function(_, other) {
      return this === other;
    },
    get$hashCode: function(_) {
      return H.Primitives_objectHashCode(this);
    },
    toString$0: function(_) {
      return H.Primitives_objectToString(this);
    },
    get$runtimeType: function(_) {
      return new H.TypeImpl(H.getRuntimeTypeString(this), null);
    }
  },
  Match: {
    "^": "Object;"
  },
  RegExp: {
    "^": "Object;",
    $isPattern: 1
  },
  Set: {
    "^": "IterableBase;",
    E: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isEfficientLength: 1
  },
  StackTrace: {
    "^": "Object;"
  },
  Stopwatch: {
    "^": "Object;_core$_start,_stop",
    start$0: function(_) {
      var t1, t2, t3;
      t1 = this._core$_start == null;
      if (!t1 && this._stop == null)
        return;
      t2 = $.Primitives_timerTicks;
      if (t1)
        this._core$_start = H.intTypeCheck(t2.call$0());
      else {
        t1 = H.intTypeCheck(t2.call$0());
        t2 = this._stop;
        t3 = this._core$_start;
        if (typeof t2 !== "number")
          return t2.$sub();
        t3 = C.JSInt_methods.$sub(t2, t3);
        if (typeof t1 !== "number")
          return t1.$sub();
        this._core$_start = t1 - t3;
        this._stop = null;
      }
    },
    stop$0: function(_) {
      if (!(this._core$_start != null && this._stop == null))
        return;
      this._stop = H.intTypeCheck($.Primitives_timerTicks.call$0());
    },
    reset$0: function(_) {
      var t1;
      if (this._core$_start == null)
        return;
      t1 = H.intTypeCheck($.Primitives_timerTicks.call$0());
      this._core$_start = t1;
      if (this._stop != null)
        this._stop = t1;
    },
    get$elapsedTicks: function() {
      var t1, t2;
      t1 = this._core$_start;
      if (t1 == null)
        return 0;
      t2 = this._stop;
      if (t2 == null) {
        t1 = H.intTypeCheck($.Primitives_timerTicks.call$0());
        t2 = this._core$_start;
        if (typeof t1 !== "number")
          return t1.$sub();
        t2 = C.JSInt_methods.$sub(t1, t2);
        t1 = t2;
      } else {
        if (typeof t2 !== "number")
          return t2.$sub();
        t1 = C.JSInt_methods.$sub(t2, t1);
      }
      return t1;
    }
  },
  String: {
    "^": "Object;",
    $isComparable: 1,
    $asComparable: function() {
      return [P.String];
    },
    $isPattern: 1
  },
  "+String": 0,
  StringBuffer: {
    "^": "Object;_contents<",
    get$length: function(_) {
      return this._contents.length;
    },
    writeAll$2: function(objects, separator) {
      var iterator = J.get$iterator$ax(objects);
      if (!iterator.moveNext$0())
        return;
      if (separator.length === 0) {
        do
          this._contents += H.S(iterator.get$current());
        while (iterator.moveNext$0());
      } else {
        this._contents += H.S(iterator.get$current());
        for (; iterator.moveNext$0();) {
          this._contents += separator;
          this._contents += H.S(iterator.get$current());
        }
      }
    },
    toString$0: function(_) {
      var t1 = this._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $isStringSink: 1
  },
  Symbol: {
    "^": "Object;"
  },
  Uri: {
    "^": "Object;_host,_port,_path,scheme,_userInfo,_query,_fragment,_pathSegments,_queryParameters",
    get$host: function(_) {
      var t1 = this._host;
      if (t1 == null)
        return "";
      if (J.getInterceptor$s(t1).startsWith$1(t1, "["))
        return C.JSString_methods.substring$2(t1, 1, t1.length - 1);
      return t1;
    },
    get$port: function(_) {
      var t1 = this._port;
      if (t1 == null)
        return P.Uri__defaultPort(this.scheme);
      return t1;
    },
    toString$0: function(_) {
      var t1, t2, t3, t4;
      t1 = this.scheme;
      t2 = "" !== t1 ? t1 + ":" : "";
      t3 = this._host;
      t4 = t3 == null;
      if (!t4 || C.JSString_methods.startsWith$1(this._path, "//") || t1 === "file") {
        t1 = t2 + "//";
        t2 = this._userInfo;
        if (t2.length !== 0)
          t1 = t1 + t2 + "@";
        if (!t4)
          t1 += H.S(t3);
        t2 = this._port;
        if (t2 != null)
          t1 = t1 + ":" + H.S(t2);
      } else
        t1 = t2;
      t1 += this._path;
      t2 = this._query;
      if (t2 != null)
        t1 = t1 + "?" + H.S(t2);
      t2 = this._fragment;
      if (t2 != null)
        t1 = t1 + "#" + H.S(t2);
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $eq: function(_, other) {
      var t1, t2, t3, t4;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isUri)
        return false;
      if (this.scheme === other.scheme)
        if (this._host != null === (other._host != null))
          if (this._userInfo === other._userInfo) {
            t2 = this.get$host(this);
            t3 = t1.get$host(other);
            if (t2 == null ? t3 == null : t2 === t3) {
              t2 = this.get$port(this);
              t1 = t1.get$port(other);
              if (t2 == null ? t1 == null : t2 === t1)
                if (this._path === other._path) {
                  t1 = this._query;
                  t2 = t1 == null;
                  t3 = other._query;
                  t4 = t3 == null;
                  if (!t2 === !t4) {
                    if (t2)
                      t1 = "";
                    if (t1 == null ? (t4 ? "" : t3) == null : t1 === (t4 ? "" : t3)) {
                      t1 = this._fragment;
                      t2 = t1 == null;
                      t3 = other._fragment;
                      t4 = t3 == null;
                      if (!t2 === !t4) {
                        if (t2)
                          t1 = "";
                        t1 = t1 == null ? (t4 ? "" : t3) == null : t1 === (t4 ? "" : t3);
                      } else
                        t1 = false;
                    } else
                      t1 = false;
                  } else
                    t1 = false;
                } else
                  t1 = false;
              else
                t1 = false;
            } else
              t1 = false;
          } else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1, t2, t3, t4, t5;
      t1 = new P.Uri_hashCode_combine();
      t2 = this.get$host(this);
      t3 = this.get$port(this);
      t4 = this._query;
      if (t4 == null)
        t4 = "";
      t5 = this._fragment;
      return H.intTypeCheck(t1.call$2(this.scheme, t1.call$2(this._userInfo, t1.call$2(t2, t1.call$2(t3, t1.call$2(this._path, t1.call$2(t4, t1.call$2(t5 == null ? "" : t5, 1))))))));
    },
    static: {Uri__defaultPort: function(scheme) {
        if (scheme === "http")
          return 80;
        if (scheme === "https")
          return 443;
        return 0;
      }, Uri_parse: function(uri, start, end) {
        var t1, pathStart, state, i, $char, t2, index, t3, path, numberSignIndex, query, fragment;
        t1 = {};
        t1._captured_end_0 = end;
        t1._captured_scheme_1 = "";
        t1._captured_userinfo_2 = "";
        t1._captured_host_3 = null;
        t1._captured_port_4 = null;
        t1._captured_end_0 = uri.length;
        t1._captured_index_5 = start;
        t1._captured_char_6 = -1;
        i = start;
        while (true) {
          if (!C.JSInt_methods.$lt(i, t1._captured_end_0)) {
            pathStart = start;
            state = 0;
            break;
          }
          $char = C.JSString_methods.codeUnitAt$1(uri, i);
          t1._captured_char_6 = $char;
          if ($char === 63 || $char === 35) {
            pathStart = start;
            state = 0;
            break;
          }
          if ($char === 47) {
            state = i === start ? 2 : 1;
            pathStart = start;
            break;
          }
          if ($char === 58) {
            if (i === start)
              P.Uri__fail(uri, start, "Invalid empty scheme");
            t1._captured_scheme_1 = P.Uri__makeScheme(uri, start, i);
            ++i;
            if (i === t1._captured_end_0) {
              t1._captured_char_6 = -1;
              state = 0;
            } else {
              $char = C.JSString_methods.codeUnitAt$1(uri, i);
              t1._captured_char_6 = $char;
              if ($char === 63 || $char === 35)
                state = 0;
              else
                state = $char === 47 ? 2 : 1;
            }
            pathStart = i;
            break;
          }
          ++i;
          t1._captured_char_6 = -1;
        }
        t1._captured_index_5 = i;
        if (state === 2) {
          H.assertHelper(t1._captured_char_6 === 47);
          t2 = t1._captured_index_5;
          if (typeof t2 !== "number")
            return t2.$add();
          index = t2 + 1;
          t1._captured_index_5 = index;
          if (index === t1._captured_end_0) {
            t1._captured_char_6 = -1;
            state = 0;
          } else {
            $char = C.JSString_methods.codeUnitAt$1(uri, index);
            t1._captured_char_6 = $char;
            if ($char === 47) {
              t2 = t1._captured_index_5;
              if (typeof t2 !== "number")
                return t2.$add();
              t1._captured_index_5 = t2 + 1;
              new P.Uri_parse_parseAuth(t1, uri, -1).call$0();
              pathStart = t1._captured_index_5;
            }
            t2 = t1._captured_char_6;
            state = t2 === 63 || t2 === 35 || t2 === -1 ? 0 : 1;
          }
        }
        t2 = state === 1;
        H.assertHelper(t2 || state === 0);
        if (t2) {
          while (true) {
            t2 = t1._captured_index_5;
            if (typeof t2 !== "number")
              return t2.$add();
            index = t2 + 1;
            t1._captured_index_5 = index;
            if (!C.JSInt_methods.$lt(index, t1._captured_end_0))
              break;
            $char = C.JSString_methods.codeUnitAt$1(uri, t1._captured_index_5);
            t1._captured_char_6 = $char;
            if ($char === 63 || $char === 35)
              break;
            t1._captured_char_6 = -1;
          }
          state = 0;
        }
        H.assertHelper(state === 0);
        t2 = t1._captured_scheme_1;
        t3 = t1._captured_host_3;
        path = P.Uri__makePath(uri, pathStart, t1._captured_index_5, null, t3 != null, t2 === "file");
        t2 = t1._captured_char_6;
        if (t2 === 63) {
          t2 = t1._captured_index_5;
          if (typeof t2 !== "number")
            return t2.$add();
          i = t2 + 1;
          while (true) {
            if (!C.JSInt_methods.$lt(i, t1._captured_end_0)) {
              numberSignIndex = -1;
              break;
            }
            if (C.JSString_methods.codeUnitAt$1(uri, i) === 35) {
              numberSignIndex = i;
              break;
            }
            ++i;
          }
          t2 = t1._captured_index_5;
          if (numberSignIndex < 0) {
            if (typeof t2 !== "number")
              return t2.$add();
            query = P.Uri__makeQuery(uri, t2 + 1, t1._captured_end_0, null);
            fragment = null;
          } else {
            if (typeof t2 !== "number")
              return t2.$add();
            query = P.Uri__makeQuery(uri, t2 + 1, numberSignIndex, null);
            fragment = P.Uri__makeFragment(uri, numberSignIndex + 1, t1._captured_end_0);
          }
        } else {
          if (t2 === 35) {
            t2 = t1._captured_index_5;
            if (typeof t2 !== "number")
              return t2.$add();
            fragment = P.Uri__makeFragment(uri, t2 + 1, t1._captured_end_0);
          } else
            fragment = null;
          query = null;
        }
        t2 = t1._captured_scheme_1;
        t3 = t1._captured_userinfo_2;
        return new P.Uri(t1._captured_host_3, t1._captured_port_4, path, t2, t3, query, fragment, H.assertSubtype(null, "$isList", [P.String], "$asList"), H.assertSubtype(null, "$isMap", [P.String, P.String], "$asMap"));
      }, Uri__fail: function(uri, index, message) {
        throw H.wrapException(P.FormatException$(message, uri, index));
      }, Uri__makePort: function(port, scheme) {
        if (port != null && port === P.Uri__defaultPort(scheme))
          return;
        return port;
      }, Uri__makeHost: function(host, start, end, strictIPv6) {
        var t1, i;
        if (host == null)
          return;
        if (start == null ? end == null : start === end)
          return "";
        if (C.JSString_methods.codeUnitAt$1(host, start) === 91) {
          if (typeof end !== "number")
            return end.$sub();
          t1 = end - 1;
          if (C.JSString_methods.codeUnitAt$1(host, t1) !== 93)
            P.Uri__fail(host, start, "Missing end `]` to match `[` in host");
          if (typeof start !== "number")
            return start.$add();
          P.Uri_parseIPv6Address(host, start + 1, t1);
          return C.JSString_methods.substring$2(host, start, end).toLowerCase();
        }
        if (!strictIPv6) {
          i = start;
          while (true) {
            if (typeof i !== "number")
              return i.$lt();
            if (!C.JSInt_methods.$lt(i, end))
              break;
            if (C.JSString_methods.codeUnitAt$1(host, i) === 58) {
              P.Uri_parseIPv6Address(host, start, end);
              return "[" + host + "]";
            }
            ++i;
          }
        }
        return P.Uri__normalizeRegName(host, start, end);
      }, Uri__normalizeRegName: function(host, start, end) {
        var index, sectionStart, buffer, isNormalized, $char, replacement, t1, slice, sourceLength, tail;
        index = start;
        sectionStart = index;
        buffer = null;
        isNormalized = true;
        while (true) {
          if (typeof index !== "number")
            return index.$lt();
          if (!C.JSInt_methods.$lt(index, end))
            break;
          c$0: {
            $char = C.JSString_methods.codeUnitAt$1(host, index);
            if ($char === 37) {
              replacement = P.Uri__normalizeEscape(host, index, true);
              t1 = replacement == null;
              if (t1 && isNormalized) {
                index += 3;
                break c$0;
              }
              if (buffer == null)
                buffer = new P.StringBuffer("");
              slice = C.JSString_methods.substring$2(host, sectionStart, index);
              if (!isNormalized)
                slice = slice.toLowerCase();
              buffer._contents = buffer._contents + slice;
              if (t1) {
                replacement = C.JSString_methods.substring$2(host, index, index + 3);
                sourceLength = 3;
              } else if (replacement === "%") {
                replacement = "%25";
                sourceLength = 1;
              } else
                sourceLength = 3;
              buffer._contents += replacement;
              index += sourceLength;
              sectionStart = index;
              isNormalized = true;
            } else {
              if ($char < 127) {
                t1 = $char >>> 4;
                if (t1 >= 8)
                  return H.ioore(C.List_qNA, t1);
                t1 = (C.List_qNA[t1] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
              } else
                t1 = false;
              if (t1) {
                if (isNormalized && 65 <= $char && 90 >= $char) {
                  if (buffer == null)
                    buffer = new P.StringBuffer("");
                  if (typeof sectionStart !== "number")
                    return sectionStart.$lt();
                  if (sectionStart < index) {
                    t1 = C.JSString_methods.substring$2(host, sectionStart, index);
                    buffer._contents = buffer._contents + t1;
                    sectionStart = index;
                  }
                  isNormalized = false;
                }
                ++index;
              } else {
                if ($char <= 93) {
                  t1 = $char >>> 4;
                  if (t1 >= 8)
                    return H.ioore(C.List_2Vk, t1);
                  t1 = (C.List_2Vk[t1] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
                } else
                  t1 = false;
                if (t1)
                  P.Uri__fail(host, index, "Invalid character");
                else {
                  if (($char & 64512) === 55296 && C.JSInt_methods.$lt(index + 1, end)) {
                    tail = C.JSString_methods.codeUnitAt$1(host, index + 1);
                    if ((tail & 64512) === 56320) {
                      $char = (65536 | ($char & 1023) << 10 | tail & 1023) >>> 0;
                      sourceLength = 2;
                    } else
                      sourceLength = 1;
                  } else
                    sourceLength = 1;
                  if (buffer == null)
                    buffer = new P.StringBuffer("");
                  slice = C.JSString_methods.substring$2(host, sectionStart, index);
                  if (!isNormalized)
                    slice = slice.toLowerCase();
                  buffer._contents = buffer._contents + slice;
                  buffer._contents += P.Uri__escapeChar($char);
                  index += sourceLength;
                  sectionStart = index;
                }
              }
            }
          }
        }
        if (buffer == null)
          return C.JSString_methods.substring$2(host, start, end);
        if (typeof sectionStart !== "number")
          return sectionStart.$lt();
        if (C.JSInt_methods.$lt(sectionStart, end)) {
          slice = C.JSString_methods.substring$2(host, sectionStart, end);
          buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
        }
        t1 = buffer._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, Uri__makeScheme: function(scheme, start, end) {
        var firstCodeUnit, allLowercase, t1, i, codeUnit;
        if (start === end)
          return "";
        firstCodeUnit = C.JSString_methods.codeUnitAt$1(scheme, start);
        allLowercase = firstCodeUnit >= 97;
        if (!(allLowercase && firstCodeUnit <= 122))
          t1 = firstCodeUnit >= 65 && firstCodeUnit <= 90;
        else
          t1 = true;
        if (!t1)
          P.Uri__fail(scheme, start, "Scheme not starting with alphabetic character");
        for (i = start; i < end; ++i) {
          codeUnit = C.JSString_methods.codeUnitAt$1(scheme, i);
          if (codeUnit < 128) {
            t1 = codeUnit >>> 4;
            if (t1 >= 8)
              return H.ioore(C.List_JYB, t1);
            t1 = (C.List_JYB[t1] & C.JSInt_methods._shlPositive$1(1, codeUnit & 15)) !== 0;
          } else
            t1 = false;
          if (!t1)
            P.Uri__fail(scheme, i, "Illegal scheme character");
          if (codeUnit < 97 || codeUnit > 122)
            allLowercase = false;
        }
        scheme = C.JSString_methods.substring$2(scheme, start, end);
        return !allLowercase ? scheme.toLowerCase() : scheme;
      }, Uri__makeUserInfo: function(userInfo, start, end) {
        return P.Uri__normalize(userInfo, start, end, C.List_gRj);
      }, Uri__makePath: function(path, start, end, pathSegments, ensureLeadingSlash, isFile) {
        var result;
        H.listSuperNativeTypeCheck(pathSegments, "$isIterable");
        result = P.Uri__normalize(path, start, end, C.List_qg4);
        if (result.length === 0) {
          if (isFile)
            return "/";
        } else if ((isFile || ensureLeadingSlash) && C.JSString_methods.codeUnitAt$1(result, 0) !== 47)
          return "/" + result;
        return result;
      }, Uri__makeQuery: function(query, start, end, queryParameters) {
        var t1, t2, result;
        t1 = {};
        H.assertSubtype(queryParameters, "$isMap", [P.String, P.String], "$asMap");
        t2 = query == null;
        if (t2 && true)
          return;
        t2 = !t2;
        if (t2 && false)
          throw H.wrapException(P.ArgumentError$("Both query and queryParameters specified"));
        if (t2)
          return P.Uri__normalize(query, start, end, C.List_CVk);
        result = new P.StringBuffer("");
        t1._captured_first_0 = true;
        C.JSNull_methods.forEach$1(queryParameters, new P.Uri__makeQuery_closure(t1, result));
        t1 = result._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, Uri__makeFragment: function(fragment, start, end) {
        if (fragment == null)
          return;
        return P.Uri__normalize(fragment, start, end, C.List_CVk);
      }, Uri__isHexDigit: function($char) {
        if (57 >= $char)
          return 48 <= $char;
        $char |= 32;
        return 97 <= $char && 102 >= $char;
      }, Uri__hexValue: function($char) {
        H.assertHelper(P.Uri__isHexDigit($char));
        if (57 >= $char)
          return $char - 48;
        return ($char | 32) - 87;
      }, Uri__normalizeEscape: function(source, index, lowerCase) {
        var t1, firstDigit, secondDigit, value;
        H.assertHelper(C.JSString_methods.codeUnitAt$1(source, index) === 37);
        t1 = index + 2;
        if (t1 >= source.length)
          return "%";
        firstDigit = C.JSString_methods.codeUnitAt$1(source, index + 1);
        secondDigit = C.JSString_methods.codeUnitAt$1(source, t1);
        if (!P.Uri__isHexDigit(firstDigit) || !P.Uri__isHexDigit(secondDigit))
          return "%";
        value = P.Uri__hexValue(firstDigit) * 16 + P.Uri__hexValue(secondDigit);
        if (value < 127) {
          t1 = C.JSInt_methods._shrOtherPositive$1(value, 4);
          if (t1 >= 8)
            return H.ioore(C.List_nxB, t1);
          t1 = (C.List_nxB[t1] & C.JSInt_methods._shlPositive$1(1, value & 15)) !== 0;
        } else
          t1 = false;
        if (t1)
          return H.Primitives_stringFromCharCode(lowerCase && 65 <= value && 90 >= value ? (value | 32) >>> 0 : value);
        if (firstDigit >= 97 || secondDigit >= 97)
          return C.JSString_methods.substring$2(source, index, index + 3).toUpperCase();
        return;
      }, Uri__escapeChar: function($char) {
        var codeUnits, flag, encodedBytes, t1, index, $byte, t2, t3;
        H.assertHelper($char <= 1114111);
        if ($char < 128) {
          codeUnits = Array(3);
          codeUnits.fixed$length = Array;
          codeUnits[0] = 37;
          codeUnits[1] = C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", $char >>> 4);
          codeUnits[2] = C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", $char & 15);
        } else {
          if ($char > 2047)
            if ($char > 65535) {
              flag = 240;
              encodedBytes = 4;
            } else {
              flag = 224;
              encodedBytes = 3;
            }
          else {
            flag = 192;
            encodedBytes = 2;
          }
          t1 = 3 * encodedBytes;
          codeUnits = Array(t1);
          codeUnits.fixed$length = Array;
          for (index = 0; --encodedBytes, encodedBytes >= 0; flag = 128) {
            $byte = C.JSInt_methods._shrReceiverPositive$1($char, 6 * encodedBytes) & 63 | flag;
            if (index >= t1)
              return H.ioore(codeUnits, index);
            codeUnits[index] = 37;
            t2 = index + 1;
            t3 = C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", $byte >>> 4);
            if (t2 >= t1)
              return H.ioore(codeUnits, t2);
            codeUnits[t2] = t3;
            t3 = index + 2;
            t2 = C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", $byte & 15);
            if (t3 >= t1)
              return H.ioore(codeUnits, t3);
            codeUnits[t3] = t2;
            index += 3;
          }
        }
        return P.String_String$fromCharCodes(codeUnits, 0, null);
      }, Uri__normalize: function(component, start, end, charTable) {
        var index, sectionStart, buffer, $char, t1, replacement, sourceLength, tail;
        H.assertSubtype(charTable, "$isList", [P.$int], "$asList");
        index = start;
        sectionStart = index;
        buffer = null;
        while (true) {
          if (typeof index !== "number")
            return index.$lt();
          if (!C.JSInt_methods.$lt(index, end))
            break;
          c$0: {
            $char = C.JSString_methods.codeUnitAt$1(component, index);
            if ($char < 127) {
              t1 = $char >>> 4;
              if (t1 >= 8)
                return H.ioore(charTable, t1);
              t1 = (charTable[t1] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
            } else
              t1 = false;
            if (t1)
              ++index;
            else {
              if ($char === 37) {
                replacement = P.Uri__normalizeEscape(component, index, false);
                if (replacement == null) {
                  index += 3;
                  break c$0;
                }
                if ("%" === replacement) {
                  replacement = "%25";
                  sourceLength = 1;
                } else
                  sourceLength = 3;
              } else {
                if ($char <= 93) {
                  t1 = $char >>> 4;
                  if (t1 >= 8)
                    return H.ioore(C.List_2Vk, t1);
                  t1 = (C.List_2Vk[t1] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
                } else
                  t1 = false;
                if (t1) {
                  P.Uri__fail(component, index, "Invalid character");
                  replacement = null;
                  sourceLength = null;
                } else {
                  if (($char & 64512) === 55296) {
                    t1 = index + 1;
                    if (C.JSInt_methods.$lt(t1, end)) {
                      tail = C.JSString_methods.codeUnitAt$1(component, t1);
                      if ((tail & 64512) === 56320) {
                        $char = (65536 | ($char & 1023) << 10 | tail & 1023) >>> 0;
                        sourceLength = 2;
                      } else
                        sourceLength = 1;
                    } else
                      sourceLength = 1;
                  } else
                    sourceLength = 1;
                  replacement = P.Uri__escapeChar($char);
                }
              }
              if (buffer == null)
                buffer = new P.StringBuffer("");
              t1 = C.JSString_methods.substring$2(component, sectionStart, index);
              buffer._contents = buffer._contents + t1;
              buffer._contents += H.S(replacement);
              index = C.JSInt_methods.$add(index, sourceLength);
              sectionStart = index;
            }
          }
        }
        if (buffer == null)
          return C.JSString_methods.substring$2(component, start, end);
        if (typeof sectionStart !== "number")
          return sectionStart.$lt();
        if (C.JSInt_methods.$lt(sectionStart, end))
          buffer._contents += C.JSString_methods.substring$2(component, sectionStart, end);
        t1 = buffer._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, Uri_parseIPv4Address: function(host) {
        var t1, bytes, t2;
        t1 = new P.Uri_parseIPv4Address_error();
        bytes = host.split(".");
        if (bytes.length !== 4)
          t1.call$1("IPv4 address should contain exactly 4 parts");
        t1 = new P.Uri_parseIPv4Address_closure(t1);
        H.buildFunctionType(H.getDynamicRuntimeType(), [H.convertRtiToRuntimeType(bytes.$builtinTypeInfo && bytes.$builtinTypeInfo[0])])._assertCheck$1(t1);
        H.listSuperNativeTypeCheck(bytes, "$isIterable");
        t2 = H.buildFunctionType(H.convertRtiToRuntimeType(null), [H.convertRtiToRuntimeType(null)]);
        t2._assertCheck$1(t1);
        return H.assertSubtype(H.setRuntimeTypeInfo(new H.MappedListIterable(H.listSuperNativeTypeCheck(bytes, "$isIterable"), t2._assertCheck$1(t1)), [null, null]).toList$0(0), "$isList", [P.$int], "$asList");
      }, Uri_parseIPv6Address: function(host, start, end) {
        var error, parseHex, parts, partStart, last, i, wildcardSeen, atEnd, t1, exception, bytes, index, value, wildCardLength, j;
        if (end == null)
          end = J.get$length$asx(host);
        error = new P.Uri_parseIPv6Address_error(host);
        parseHex = new P.Uri_parseIPv6Address_parseHex(host, error);
        if (J.get$length$asx(host) < 2)
          error.call$1("address is too short");
        parts = H.assertSubtype([], "$isList", [P.$int], "$asList");
        partStart = start;
        i = start;
        wildcardSeen = false;
        while (true) {
          if (typeof i !== "number")
            return i.$lt();
          if (!C.JSInt_methods.$lt(i, end))
            break;
          if (J.codeUnitAt$1$s(host, i) === 58) {
            if (i === start) {
              ++i;
              if (J.codeUnitAt$1$s(host, i) !== 58)
                error.call$2("invalid start colon.", i);
              partStart = i;
            }
            if (i === partStart) {
              if (wildcardSeen)
                error.call$2("only one wildcard `::` is allowed", i);
              J.add$1$ax(parts, -1);
              wildcardSeen = true;
            } else
              J.add$1$ax(parts, parseHex.call$2(partStart, i));
            partStart = i + 1;
          }
          ++i;
        }
        if (J.get$length$asx(parts) === 0)
          error.call$1("too few parts");
        atEnd = J.$eq(partStart, end);
        t1 = J.get$last$ax(parts);
        if (atEnd && t1 !== -1)
          error.call$2("expected a part after last `:`", end);
        if (!atEnd)
          try {
            J.add$1$ax(parts, parseHex.call$2(partStart, end));
          } catch (exception) {
            H.unwrapException(exception);
            try {
              last = H.assertSubtype(P.Uri_parseIPv4Address(J.substring$2$s(host, partStart, end)), "$isList", [P.$int], "$asList");
              t1 = J.$index$asx(last, 0);
              if (typeof t1 !== "number")
                return t1.$shl();
              J.add$1$ax(parts, C.JSInt_methods.$or(t1 << 8 >>> 0, J.$index$asx(last, 1)));
              t1 = J.$index$asx(last, 2);
              if (typeof t1 !== "number")
                return t1.$shl();
              J.add$1$ax(parts, C.JSInt_methods.$or(t1 << 8 >>> 0, J.$index$asx(last, 3)));
            } catch (exception) {
              H.unwrapException(exception);
              error.call$2("invalid end of IPv6 address.", partStart);
            }
          }
        if (wildcardSeen) {
          if (J.get$length$asx(parts) > 7)
            error.call$1("an address with a wildcard must have less than 7 parts");
        } else if (J.get$length$asx(parts) !== 8)
          error.call$1("an address without a wildcard must contain exactly 8 parts");
        bytes = Array(16);
        H.assertHelper(true);
        bytes.$builtinTypeInfo = [P.$int];
        for (i = 0, index = 0; C.JSInt_methods.$lt(i, J.get$length$asx(parts)); ++i) {
          value = J.$index$asx(parts, i);
          if (value === -1) {
            wildCardLength = 9 - J.get$length$asx(parts);
            for (j = 0; j < wildCardLength; ++j) {
              if (index < 0 || index >= 16)
                return H.ioore(bytes, index);
              bytes[index] = 0;
              t1 = index + 1;
              if (t1 >= 16)
                return H.ioore(bytes, t1);
              bytes[t1] = 0;
              index += 2;
            }
          } else {
            t1 = J._shrOtherPositive$1$n(value, 8);
            if (index < 0 || index >= 16)
              return H.ioore(bytes, index);
            bytes[index] = t1;
            t1 = index + 1;
            if (t1 >= 16)
              return H.ioore(bytes, t1);
            bytes[t1] = value & 255;
            index += 2;
          }
        }
        return H.assertSubtype(bytes, "$isList", [P.$int], "$asList");
      }, Uri__uriEncode: function(canonicalTable, text, encoding, spaceToPlus) {
        var t1, result, bytes, t2, i, $byte, t3;
        H.assertSubtype(canonicalTable, "$isList", [P.$int], "$asList");
        t1 = new P.Uri__uriEncode_byteToHex();
        result = new P.StringBuffer("");
        H.assertSubtypeOfRuntimeType(text, H.getRuntimeTypeArgument(encoding, "Codec", 0));
        bytes = H.assertSubtypeOfRuntimeType(encoding.get$encoder().convert$1(text), H.getRuntimeTypeArgument(encoding, "Codec", 1));
        for (t2 = bytes.length, i = 0; i < t2; ++i) {
          $byte = bytes[i];
          if ($byte < 128) {
            t3 = $byte >>> 4;
            if (t3 >= 8)
              return H.ioore(canonicalTable, t3);
            t3 = (canonicalTable[t3] & C.JSInt_methods._shlPositive$1(1, $byte & 15)) !== 0;
          } else
            t3 = false;
          if (t3)
            result._contents += H.Primitives_stringFromCharCode($byte);
          else if (spaceToPlus && $byte === 32)
            result._contents += H.Primitives_stringFromCharCode(43);
          else {
            result._contents += H.Primitives_stringFromCharCode(37);
            t1.call$2($byte, result);
          }
        }
        t1 = result._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }}
  },
  Uri_parse_isRegName: {
    "^": "Closure:15;",
    call$1: function(ch) {
      return ch.$lt(0, 128) && (C.JSArray_methods.$index(C.List_qNA, ch.$shr(0, 4)) & C.JSInt_methods.$shl(1, ch.$and(0, 15))) !== 0;
    }
  },
  Uri_parse_parseAuth: {
    "^": "Closure:1;_core$_box_0,_captured_uri_1,_captured_EOI_2",
    call$0: function() {
      var t1, hostStart, t2, $char, lastColon, lastAt, t3, t4, char0, endBracket, hostEnd, i, portNumber, digit;
      t1 = this._core$_box_0;
      hostStart = t1._captured_index_5;
      t2 = t1._captured_end_0;
      if (hostStart == null ? t2 == null : hostStart === t2) {
        t1._captured_char_6 = this._captured_EOI_2;
        return;
      }
      t2 = this._captured_uri_1;
      t1._captured_char_6 = C.JSString_methods.codeUnitAt$1(t2, hostStart);
      $char = this._captured_EOI_2;
      lastColon = -1;
      lastAt = -1;
      while (true) {
        t3 = t1._captured_index_5;
        t4 = t1._captured_end_0;
        if (typeof t3 !== "number")
          return t3.$lt();
        if (!C.JSInt_methods.$lt(t3, t4))
          break;
        char0 = C.JSString_methods.codeUnitAt$1(t2, t1._captured_index_5);
        t1._captured_char_6 = char0;
        if (char0 === 47 || char0 === 63 || char0 === 35)
          break;
        if (char0 === 64) {
          lastAt = t1._captured_index_5;
          lastColon = -1;
        } else if (char0 === 58)
          lastColon = t1._captured_index_5;
        else if (char0 === 91) {
          t3 = t1._captured_index_5;
          if (typeof t3 !== "number")
            return t3.$add();
          endBracket = C.JSString_methods.indexOf$2(t2, "]", t3 + 1);
          if (endBracket === -1) {
            t1._captured_index_5 = t1._captured_end_0;
            t1._captured_char_6 = $char;
            lastColon = -1;
            break;
          } else
            t1._captured_index_5 = endBracket;
          lastColon = -1;
        }
        t3 = t1._captured_index_5;
        if (typeof t3 !== "number")
          return t3.$add();
        t1._captured_index_5 = t3 + 1;
        t1._captured_char_6 = $char;
      }
      hostEnd = t1._captured_index_5;
      if (typeof lastAt !== "number")
        return lastAt.$ge();
      if (lastAt >= 0) {
        t1._captured_userinfo_2 = P.Uri__makeUserInfo(t2, hostStart, lastAt);
        hostStart = lastAt + 1;
      }
      if (typeof lastColon !== "number")
        return lastColon.$ge();
      if (lastColon >= 0) {
        i = lastColon + 1;
        if (C.JSInt_methods.$lt(i, t1._captured_index_5))
          for (portNumber = 0; C.JSInt_methods.$lt(i, t1._captured_index_5); ++i) {
            digit = C.JSString_methods.codeUnitAt$1(t2, i);
            if (48 > digit || 57 < digit)
              P.Uri__fail(t2, i, "Invalid port number");
            portNumber = portNumber * 10 + (digit - 48);
          }
        else
          portNumber = null;
        t1._captured_port_4 = P.Uri__makePort(portNumber, t1._captured_scheme_1);
        hostEnd = lastColon;
      }
      t1._captured_host_3 = P.Uri__makeHost(t2, hostStart, hostEnd, true);
      t3 = t1._captured_index_5;
      t4 = t1._captured_end_0;
      if (typeof t3 !== "number")
        return t3.$lt();
      if (C.JSInt_methods.$lt(t3, t4))
        t1._captured_char_6 = C.JSString_methods.codeUnitAt$1(t2, t1._captured_index_5);
    }
  },
  Uri__makePath_closure: {
    "^": "Closure:2;",
    call$1: function(s) {
      return P.Uri__uriEncode(C.List_qg40, s, C.Utf8Codec_false, false);
    }
  },
  Uri__makeQuery_closure: {
    "^": "Closure:11;_core$_box_0,_core$_captured_result_1",
    call$2: function(key, value) {
      var t1 = this._core$_box_0;
      if (!t1._captured_first_0)
        this._core$_captured_result_1._contents += "&";
      t1._captured_first_0 = false;
      t1 = this._core$_captured_result_1;
      t1._contents += P.Uri__uriEncode(C.List_nxB, key, C.Utf8Codec_false, true);
      if (!value.get$isEmpty(value)) {
        t1._contents += "=";
        t1._contents += P.Uri__uriEncode(C.List_nxB, value, C.Utf8Codec_false, true);
      }
    }
  },
  Uri_hashCode_combine: {
    "^": "Closure:16;",
    call$2: function(part, current) {
      return current * 31 + J.get$hashCode$(part) & 1073741823;
    }
  },
  Uri_parseIPv4Address_error: {
    "^": "Closure:17;",
    call$1: function(msg) {
      throw H.wrapException(P.FormatException$("Illegal IPv4 address, " + msg, null, null));
    }
  },
  Uri_parseIPv4Address_closure: {
    "^": "Closure:2;_core$_captured_error_0",
    call$1: function(byteString) {
      var $byte;
      H.stringTypeCheck(byteString);
      H.buildFunctionType(H.buildInterfaceType(P.$int), [H.buildInterfaceType(P.String)])._assertCheck$1(null);
      $byte = H.Primitives_parseInt(byteString, null, null);
      if (typeof $byte !== "number")
        return $byte.$lt();
      if ($byte < 0 || $byte > 255)
        this._core$_captured_error_0.call$1("each part must be in the range of `0..255`");
      return $byte;
    }
  },
  Uri_parseIPv6Address_error: {
    "^": "Closure:18;_captured_host_0",
    call$2: function(msg, position) {
      throw H.wrapException(P.FormatException$("Illegal IPv6 address, " + msg, this._captured_host_0, position));
    },
    call$1: function(msg) {
      return this.call$2(msg, null);
    }
  },
  Uri_parseIPv6Address_parseHex: {
    "^": "Closure:19;_captured_host_1,_captured_error_2",
    call$2: function(start, end) {
      var t1, value;
      if (C.JSInt_methods.$sub(end, start) > 4)
        this._captured_error_2.call$2("an IPv6 part can only contain a maximum of 4 hex digits", start);
      t1 = C.JSString_methods.substring$2(this._captured_host_1, start, end);
      H.buildFunctionType(H.buildInterfaceType(P.$int), [H.buildInterfaceType(P.String)])._assertCheck$1(null);
      value = H.Primitives_parseInt(t1, 16, null);
      if (typeof value !== "number")
        return value.$lt();
      if (value < 0 || value > 65535)
        this._captured_error_2.call$2("each part must be in the range of `0x0..0xFFFF`", start);
      return value;
    }
  },
  Uri__uriEncode_byteToHex: {
    "^": "Closure:11;",
    call$2: function($byte, buffer) {
      buffer._contents += H.Primitives_stringFromCharCode(C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", $byte >>> 4));
      buffer._contents += H.Primitives_stringFromCharCode(C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", $byte & 15));
    }
  }
}],
["dart.dom.html", "dart:html", , W, {
  "^": "",
  Element_Element$html: function(html, treeSanitizer, validator) {
    var t1, fragment;
    t1 = document.body;
    fragment = (t1 && C.BodyElement_methods).createFragment$3$treeSanitizer$validator(t1, html, treeSanitizer, validator);
    fragment.toString;
    t1 = H.assertSubtype(new W._ChildNodeListLazy(fragment), "$isList", [W.Node], "$asList");
    t1 = t1.where$1(t1, new W.Element_Element$html_closure());
    return H.interceptedTypeCheck(t1.get$single(t1), "$isElement");
  },
  InputElement_InputElement: function(type) {
    var e, exception;
    e = C.HtmlDocument_methods._createElement$2(document, "input", null);
    if (type != null)
      try {
        J.set$type$x(e, type);
      } catch (exception) {
        H.unwrapException(exception);
      }
    return H.interceptedTypeCheck(e, "$isInputElement");
  },
  OptionElement_OptionElement$_: function(data, value, defaultSelected, selected) {
    if (selected != null)
      return new Option(data, value, defaultSelected, selected);
    if (value != null)
      return new Option(data, value);
    return new Option(data);
  },
  _JenkinsSmiHash_combine: function(hash, value) {
    hash = 536870911 & hash + value;
    hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
    return hash ^ hash >>> 6;
  },
  _JenkinsSmiHash_finish: function(hash) {
    hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
    hash ^= hash >>> 11;
    return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
  },
  _wrapZone: function(callback) {
    var t1, t2;
    t1 = H.getDynamicRuntimeType();
    t1 = H.buildFunctionType(t1, [t1])._assertCheck$1(callback);
    t2 = $.Zone__current;
    if (t2 === C.C__RootZone)
      return t1;
    return t2.bindUnaryCallback$2$runGuarded(t1, true);
  },
  HtmlElement: {
    "^": "Element;",
    $isHtmlElement: 1,
    $isElement: 1,
    $isNode: 1,
    $isObject: 1,
    "%": "HTMLAppletElement|HTMLBRElement|HTMLContentElement|HTMLDListElement|HTMLDataListElement|HTMLDetailsElement|HTMLDirectoryElement|HTMLFontElement|HTMLFrameElement|HTMLHRElement|HTMLHtmlElement|HTMLLIElement|HTMLLegendElement|HTMLMarqueeElement|HTMLMeterElement|HTMLModElement|HTMLOptGroupElement|HTMLPictureElement|HTMLPreElement|HTMLProgressElement|HTMLQuoteElement|HTMLShadowElement|HTMLTableCaptionElement|HTMLTableCellElement|HTMLTableColElement|HTMLTableDataCellElement|HTMLTableHeaderCellElement|HTMLTitleElement|HTMLTrackElement|HTMLUListElement|HTMLUnknownElement;HTMLElement"
  },
  AnchorElement: {
    "^": "HtmlElement;type,href",
    set$type: function(receiver, type) {
      receiver.type = H.stringTypeCheck(type);
    },
    set$href: function(receiver, href) {
      receiver.href = H.stringTypeCheck(href);
    },
    toString$0: function(receiver) {
      return String(receiver);
    },
    $isAnchorElement: 1,
    $isInterceptor: 1,
    $isObject: 1,
    "%": "HTMLAnchorElement"
  },
  AreaElement: {
    "^": "HtmlElement;href",
    set$href: function(receiver, href) {
      receiver.href = H.stringTypeCheck(href);
    },
    toString$0: function(receiver) {
      return String(receiver);
    },
    $isInterceptor: 1,
    $isObject: 1,
    "%": "HTMLAreaElement"
  },
  BaseElement: {
    "^": "HtmlElement;href",
    set$href: function(receiver, href) {
      receiver.href = H.stringTypeCheck(href);
    },
    "%": "HTMLBaseElement"
  },
  Blob: {
    "^": "Interceptor;",
    "%": ";Blob"
  },
  BodyElement: {
    "^": "HtmlElement;",
    $isBodyElement: 1,
    $isEventTarget: 1,
    $isInterceptor: 1,
    $isObject: 1,
    "%": "HTMLBodyElement"
  },
  ButtonElement: {
    "^": "HtmlElement;name=,type",
    set$type: function(receiver, type) {
      receiver.type = H.stringTypeCheck(type);
    },
    $isButtonElement: 1,
    $isHtmlElement: 1,
    $isElement: 1,
    $isNode: 1,
    $isObject: 1,
    "%": "HTMLButtonElement"
  },
  CanvasElement: {
    "^": "HtmlElement;",
    $isObject: 1,
    "%": "HTMLCanvasElement"
  },
  CharacterData: {
    "^": "Node;length=",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "CDATASection|CharacterData|Comment|ProcessingInstruction|Text"
  },
  CssStyleDeclaration: {
    "^": "Interceptor_CssStyleDeclarationBase;length=",
    "%": "CSS2Properties|CSSStyleDeclaration|MSStyleCSSProperties"
  },
  Interceptor_CssStyleDeclarationBase: {
    "^": "Interceptor+CssStyleDeclarationBase;"
  },
  CssStyleDeclarationBase: {
    "^": "Object;"
  },
  DialogElement: {
    "^": "HtmlElement;",
    show$0: [function(receiver) {
      return receiver.show();
    }, "call$0", "get$show", 0, 0, 1],
    "%": "HTMLDialogElement"
  },
  DivElement: {
    "^": "HtmlElement;",
    $isDivElement: 1,
    "%": "HTMLDivElement|PluginPlaceholderElement"
  },
  Document1: {
    "^": "Node;",
    adoptNode$1: function(receiver, node) {
      return receiver.adoptNode(node);
    },
    _createElement$2: function(receiver, localName_OR_tagName, typeExtension) {
      return receiver.createElement(localName_OR_tagName, typeExtension);
    },
    _createEvent$1: function(receiver, eventType) {
      return receiver.createEvent(eventType);
    },
    querySelector$1: function(receiver, selectors) {
      return receiver.querySelector(selectors);
    },
    "%": "XMLDocument;Document"
  },
  DocumentFragment0: {
    "^": "Node;_docChildren",
    set$_docChildren: function(receiver, _docChildren) {
      receiver._docChildren = H.assertSubtype(_docChildren, "$isList", [W.Element], "$asList");
    },
    get$children: function(receiver) {
      if (receiver._docChildren == null)
        this.set$_docChildren(receiver, H.setRuntimeTypeInfo(new P.FilteredElementList(receiver, H.assertSubtype(H.assertSubtype(new W._ChildNodeListLazy(receiver), "$isList", [W.Node], "$asList"), "$isList", [W.Node], "$asList")), [null]));
      return H.assertSubtype(receiver._docChildren, "$isList", [W.Element], "$asList");
    },
    set$innerHtml: function(receiver, value) {
      var t1;
      H.assertSubtype(new W._ChildNodeListLazy(receiver), "$isList", [W.Node], "$asList");
      this._clearChildren$0(receiver);
      t1 = document.body;
      this.append$1(receiver, (t1 && C.BodyElement_methods).createFragment$3$treeSanitizer$validator(t1, value, null, null));
    },
    $isDocumentFragment0: 1,
    $isInterceptor: 1,
    $isObject: 1,
    "%": ";DocumentFragment"
  },
  DomError: {
    "^": "Interceptor;name=",
    "%": "DOMError|FileError"
  },
  DomException: {
    "^": "Interceptor;",
    get$name: function(receiver) {
      var errorName = receiver.name;
      if (H.boolConversionCheck(P.Device_isWebKit()) && errorName === "SECURITY_ERR")
        return "SecurityError";
      if (H.boolConversionCheck(P.Device_isWebKit()) && errorName === "SYNTAX_ERR")
        return "SyntaxError";
      return errorName;
    },
    toString$0: function(receiver) {
      return String(receiver);
    },
    "%": "DOMException"
  },
  DomImplementation: {
    "^": "Interceptor;",
    createHtmlDocument$1: function(receiver, title) {
      return receiver.createHTMLDocument(title);
    },
    "%": "DOMImplementation"
  },
  DomRectReadOnly: {
    "^": "Interceptor;bottom=,height=,left=,right=,top=,width=",
    toString$0: function(receiver) {
      return "Rectangle (" + H.S(receiver.left) + ", " + H.S(receiver.top) + ") " + H.S(this.get$width(receiver)) + " x " + H.S(this.get$height(receiver));
    },
    $eq: function(receiver, other) {
      var t1, t2, t3;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isRectangle)
        return false;
      t2 = receiver.left;
      t3 = t1.get$left(other);
      if (t2 == null ? t3 == null : t2 === t3) {
        t2 = receiver.top;
        t3 = t1.get$top(other);
        if (t2 == null ? t3 == null : t2 === t3) {
          t2 = this.get$width(receiver);
          t3 = t1.get$width(other);
          if (t2 == null ? t3 == null : t2 === t3) {
            t2 = this.get$height(receiver);
            t1 = t1.get$height(other);
            t1 = t2 == null ? t1 == null : t2 === t1;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(receiver) {
      var t1, t2, t3, t4;
      t1 = J.get$hashCode$(receiver.left);
      t2 = J.get$hashCode$(receiver.top);
      t3 = J.get$hashCode$(this.get$width(receiver));
      t4 = J.get$hashCode$(this.get$height(receiver));
      return W._JenkinsSmiHash_finish(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(0, t1), t2), t3), t4));
    },
    $isRectangle: 1,
    $asRectangle: $.functionThatReturnsNull,
    $isObject: 1,
    "%": ";DOMRectReadOnly"
  },
  DomTokenList: {
    "^": "Interceptor;length=",
    add$1: function(receiver, tokens) {
      return receiver.add(H.stringTypeCheck(tokens));
    },
    $isDomTokenList: 1,
    "%": "DOMSettableTokenList|DOMTokenList"
  },
  _ChildrenElementList: {
    "^": "ListBase;_html$_element,_childElements",
    get$isEmpty: function(_) {
      return this._html$_element.firstElementChild == null;
    },
    get$length: function(_) {
      return this._childElements.length;
    },
    $index: function(_, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = this._childElements;
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      return H.interceptedTypeCheck(t1[index], "$isElement");
    },
    $indexSet: function(_, index, value) {
      var t1;
      H.interceptedTypeCheck(value, "$isElement");
      t1 = this._childElements;
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      J._replaceChild$2$x(this._html$_element, value, t1[index]);
    },
    set$length: function(_, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize element lists"));
    },
    add$1: function(_, value) {
      H.interceptedTypeCheck(value, "$isElement");
      J.append$1$x(this._html$_element, value);
      return value;
    },
    get$iterator: function(_) {
      var t1, t2, t3;
      t1 = this.toList$0(this);
      t2 = H.getTypeArgumentByIndex(t1, 0);
      H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray");
      t3 = t1.length;
      return H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"), "$isIterator", [W.Element], "$asIterator");
    },
    clear$0: function(_) {
      J._clearChildren$0$x(this._html$_element);
    },
    get$first: function(_) {
      var result = this._html$_element.firstElementChild;
      if (result == null)
        throw H.wrapException(P.StateError$("No elements"));
      return result;
    },
    get$last: function(_) {
      var result = this._html$_element.lastElementChild;
      if (result == null)
        throw H.wrapException(P.StateError$("No elements"));
      return result;
    },
    get$single: function(_) {
      if (this._childElements.length > 1)
        throw H.wrapException(P.StateError$("More than one element"));
      return this.get$first(this);
    },
    $asListBase: function() {
      return [W.Element];
    },
    $asObject_ListMixin: function() {
      return [W.Element];
    },
    $asListMixin: function() {
      return [W.Element];
    },
    $asList: function() {
      return [W.Element];
    },
    $asIterable: function() {
      return [W.Element];
    }
  },
  _FrozenElementList: {
    "^": "ListBase;_nodeList",
    get$length: function(_) {
      return this._nodeList.length;
    },
    $index: function(_, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = this._nodeList;
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      return H.interceptedTypeCheck(t1[index], "$isElement");
    },
    $indexSet: function(_, index, value) {
      H.interceptedTypeCheck(value, "$isElement");
      throw H.wrapException(P.UnsupportedError$("Cannot modify list"));
    },
    set$length: function(_, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify list"));
    },
    get$last: function(_) {
      return H.interceptedTypeCheck(C.NodeList_methods.get$last(this._nodeList), "$isElement");
    },
    get$single: function(_) {
      return H.interceptedTypeCheck(C.NodeList_methods.get$single(this._nodeList), "$isElement");
    },
    get$classes: function(_) {
      return W._MultiElementCssClassSet__MultiElementCssClassSet(this);
    },
    $asListBase: $.functionThatReturnsNull,
    $asObject_ListMixin: $.functionThatReturnsNull,
    $asElementList: $.functionThatReturnsNull,
    $asListMixin: $.functionThatReturnsNull,
    $asList: $.functionThatReturnsNull,
    $asIterable: $.functionThatReturnsNull,
    $isElementList: 1,
    $isList: 1,
    $isEfficientLength: 1,
    $isIterable: 1
  },
  Element: {
    "^": "Node;title=,id=",
    get$children: function(receiver) {
      return H.assertSubtype(new W._ChildrenElementList(receiver, receiver.children), "$isList", [W.Element], "$asList");
    },
    get$classes: function(receiver) {
      return new W._ElementCssClassSet(receiver);
    },
    toString$0: function(receiver) {
      return receiver.localName;
    },
    createFragment$3$treeSanitizer$validator: ["super$Element$createFragment$3$treeSanitizer$validator", function(receiver, html, treeSanitizer, validator) {
      var t1, t2, base, contextElement, fragment;
      if (treeSanitizer == null) {
        t1 = $.Element__defaultValidator;
        if (t1 == null) {
          t1 = H.assertSubtype(H.setRuntimeTypeInfo([], [W.NodeValidator]), "$isList", [W.NodeValidator], "$asList");
          t2 = new W.NodeValidatorBuilder(t1);
          C.JSArray_methods.add$1(t1, W._Html5NodeValidator$(null));
          C.JSArray_methods.add$1(t1, W._TemplatingNodeValidator$());
          $.Element__defaultValidator = t2;
          validator = t2;
        } else
          validator = t1;
        t1 = $.Element__defaultSanitizer;
        if (t1 == null) {
          t1 = new W._ValidatingTreeSanitizer(validator);
          $.Element__defaultSanitizer = t1;
          treeSanitizer = t1;
        } else {
          t1.validator = validator;
          treeSanitizer = t1;
        }
      }
      if ($.Element__parseDocument == null) {
        t1 = document.implementation;
        t1 = (t1 && C.DomImplementation_methods).createHtmlDocument$1(t1, "");
        $.Element__parseDocument = t1;
        $.Element__parseRange = t1.createRange();
        t1 = $.Element__parseDocument;
        base = (t1 && C.HtmlDocument_methods)._createElement$2(t1, "base", null);
        J.set$href$x(base, document.baseURI);
        t1 = $.Element__parseDocument.head;
        (t1 && C.HeadElement_methods).append$1(t1, base);
      }
      t1 = $.Element__parseDocument;
      if (!!this.$isBodyElement)
        contextElement = t1.body;
      else {
        contextElement = (t1 && C.HtmlDocument_methods)._createElement$2(t1, receiver.tagName, null);
        t1 = $.Element__parseDocument.body;
        (t1 && C.BodyElement_methods).append$1(t1, contextElement);
      }
      if ("createContextualFragment" in window.Range.prototype) {
        t1 = $.Element__parseRange;
        (t1 && C.Range_methods).selectNodeContents$1(t1, contextElement);
        t1 = $.Element__parseRange;
        fragment = (t1 && C.Range_methods).createContextualFragment$1(t1, html);
      } else {
        contextElement.innerHTML = html;
        fragment = $.Element__parseDocument.createDocumentFragment();
        for (t1 = J.getInterceptor$x(fragment); t2 = contextElement.firstChild, t2 != null;)
          t1.append$1(fragment, t2);
      }
      t1 = $.Element__parseDocument.body;
      if (contextElement == null ? t1 != null : contextElement !== t1)
        J.remove$0$ax(contextElement);
      treeSanitizer.sanitizeTree$1(fragment);
      C.HtmlDocument_methods.adoptNode$1(document, fragment);
      return fragment;
    }, function($receiver, html, treeSanitizer) {
      return this.createFragment$3$treeSanitizer$validator($receiver, html, treeSanitizer, null);
    }, "createFragment$2$treeSanitizer", null, null, "get$createFragment", 2, 5, null, 0, 0],
    set$innerHtml: function(receiver, html) {
      this.setInnerHtml$1(receiver, html);
    },
    setInnerHtml$3$treeSanitizer$validator: function(receiver, html, treeSanitizer, validator) {
      receiver.textContent = null;
      this.append$1(receiver, this.createFragment$3$treeSanitizer$validator(receiver, html, treeSanitizer, validator));
    },
    setInnerHtml$1: function($receiver, html) {
      return this.setInnerHtml$3$treeSanitizer$validator($receiver, html, null, null);
    },
    getAttribute$1: function(receiver, $name) {
      return receiver.getAttribute($name);
    },
    _hasAttribute$1: function(receiver, $name) {
      return receiver.hasAttribute($name);
    },
    _removeAttribute$1: function(receiver, $name) {
      return receiver.removeAttribute($name);
    },
    setAttribute$2: function(receiver, $name, value) {
      return receiver.setAttribute($name, value);
    },
    querySelector$1: function(receiver, selectors) {
      return receiver.querySelector(selectors);
    },
    _querySelectorAll$1: function(receiver, selectors) {
      return receiver.querySelectorAll(selectors);
    },
    get$onClick: function(receiver) {
      return H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(receiver, "click", false), [null]), "$isElementStream", [H.getTypeArgumentByIndex(C.EventStreamProvider_click, 0)], "$asElementStream"), "$isElementStream", [W.MouseEvent], "$asElementStream");
    },
    $isElement: 1,
    $isNode: 1,
    $isObject: 1,
    $isInterceptor: 1,
    $isEventTarget: 1,
    "%": ";Element"
  },
  Element_Element$html_closure: {
    "^": "Closure:2;",
    call$1: function(e) {
      return !!J.getInterceptor(e).$isElement;
    }
  },
  EmbedElement: {
    "^": "HtmlElement;name=,type",
    set$type: function(receiver, type) {
      receiver.type = H.stringTypeCheck(type);
    },
    "%": "HTMLEmbedElement"
  },
  ErrorEvent: {
    "^": "Event;error=",
    "%": "ErrorEvent"
  },
  Event: {
    "^": "Interceptor;",
    _initEvent$3: function(receiver, eventTypeArg, canBubbleArg, cancelableArg) {
      return receiver.initEvent(eventTypeArg, canBubbleArg, cancelableArg);
    },
    $isEvent: 1,
    $isObject: 1,
    "%": "AnimationPlayerEvent|ApplicationCacheErrorEvent|AudioProcessingEvent|AutocompleteErrorEvent|BeforeUnloadEvent|CloseEvent|CustomEvent|DeviceLightEvent|DeviceMotionEvent|DeviceOrientationEvent|ExtendableEvent|FetchEvent|FontFaceSetLoadEvent|GamepadEvent|HashChangeEvent|IDBVersionChangeEvent|InstallEvent|MIDIConnectionEvent|MIDIMessageEvent|MediaKeyEvent|MediaKeyMessageEvent|MediaKeyNeededEvent|MediaQueryListEvent|MediaStreamEvent|MediaStreamTrackEvent|MessageEvent|MutationEvent|OfflineAudioCompletionEvent|OverflowEvent|PageTransitionEvent|PopStateEvent|ProgressEvent|PushEvent|RTCDTMFToneChangeEvent|RTCDataChannelEvent|RTCIceCandidateEvent|RTCPeerConnectionIceEvent|RelatedEvent|ResourceProgressEvent|SecurityPolicyViolationEvent|SpeechRecognitionEvent|StorageEvent|TrackEvent|TransitionEvent|WebGLContextEvent|WebKitAnimationEvent|WebKitTransitionEvent|XMLHttpRequestProgressEvent;ClipboardEvent|Event|InputEvent"
  },
  EventTarget: {
    "^": "Interceptor;",
    addEventListener$3: function(receiver, type, listener, useCapture) {
      var t1 = H.buildFunctionType(H.getDynamicRuntimeType(), [H.buildInterfaceType(W.Event)])._assertCheck$1(listener);
      if (t1 != null)
        this._addEventListener$3(receiver, type, t1, useCapture);
    },
    removeEventListener$3: function(receiver, type, listener, useCapture) {
      var t1 = H.buildFunctionType(H.getDynamicRuntimeType(), [H.buildInterfaceType(W.Event)])._assertCheck$1(listener);
      if (t1 != null)
        this._removeEventListener$3(receiver, type, t1, useCapture);
    },
    _addEventListener$3: function(receiver, type, listener, useCapture) {
      return receiver.addEventListener(type, H.convertDartClosureToJS(H.buildFunctionType(H.getDynamicRuntimeType(), [H.buildInterfaceType(W.Event)])._assertCheck$1(listener), 1), useCapture);
    },
    _removeEventListener$3: function(receiver, type, listener, useCapture) {
      return receiver.removeEventListener(type, H.convertDartClosureToJS(H.buildFunctionType(H.getDynamicRuntimeType(), [H.buildInterfaceType(W.Event)])._assertCheck$1(listener), 1), useCapture);
    },
    $isEventTarget: 1,
    "%": ";EventTarget"
  },
  FieldSetElement: {
    "^": "HtmlElement;name=",
    "%": "HTMLFieldSetElement"
  },
  File: {
    "^": "Blob;name=",
    "%": "File"
  },
  FormElement0: {
    "^": "HtmlElement;length=,name=",
    "%": "HTMLFormElement"
  },
  HeadElement: {
    "^": "HtmlElement;",
    $isHeadElement: 1,
    "%": "HTMLHeadElement"
  },
  HeadingElement: {
    "^": "HtmlElement;",
    $isHeadingElement: 1,
    "%": "HTMLHeadingElement"
  },
  HtmlCollection: {
    "^": "Interceptor_ListMixin_ImmutableListMixin;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.interceptedTypeCheck(value, "$isNode");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$single: function(receiver) {
      var len = receiver.length;
      if (len === 1)
        return receiver[0];
      if (len === 0)
        throw H.wrapException(P.StateError$("No elements"));
      throw H.wrapException(P.StateError$("More than one element"));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isHtmlCollection: 1,
    $isList: 1,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: 1,
    $isObject: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [W.Node];
    },
    $isJavaScriptIndexingBehavior: 1,
    $isJSIndexable: 1,
    "%": "HTMLCollection|HTMLFormControlsCollection|HTMLOptionsCollection"
  },
  Interceptor_ListMixin: {
    "^": "Interceptor+ListMixin;",
    $isList: 1,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [W.Node];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin: {
    "^": "Interceptor_ListMixin+ImmutableListMixin;",
    $isList: 1,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [W.Node];
    }
  },
  HtmlDocument: {
    "^": "Document1;",
    $isHtmlDocument: 1,
    "%": "HTMLDocument"
  },
  IFrameElement: {
    "^": "HtmlElement;name=",
    "%": "HTMLIFrameElement"
  },
  ImageElement: {
    "^": "HtmlElement;",
    $isObject: 1,
    "%": "HTMLImageElement"
  },
  InputElement: {
    "^": "HtmlElement;checked,disabled,name=,type",
    set$checked: function(receiver, checked) {
      receiver.checked = H.boolTypeCheck(checked);
    },
    set$disabled: function(receiver, disabled) {
      receiver.disabled = H.boolTypeCheck(disabled);
    },
    set$type: function(receiver, type) {
      receiver.type = H.stringTypeCheck(type);
    },
    accept$1: function($receiver, arg0) {
      return $receiver.accept.call$1(arg0);
    },
    $isInputElement: 1,
    $isElement: 1,
    $isInterceptor: 1,
    $isObject: 1,
    $isEventTarget: 1,
    $isNode: 1,
    $isRadioButtonInputElement: 1,
    $isCheckboxInputElement: 1,
    "%": "HTMLInputElement"
  },
  RadioButtonInputElement: {
    "^": "Object;",
    $isElement: 1,
    $isNode: 1,
    $isInterceptor: 1,
    $isEventTarget: 1
  },
  KeygenElement: {
    "^": "HtmlElement;name=",
    "%": "HTMLKeygenElement"
  },
  LabelElement: {
    "^": "HtmlElement;",
    $isLabelElement: 1,
    "%": "HTMLLabelElement"
  },
  LinkElement: {
    "^": "HtmlElement;href,type",
    set$href: function(receiver, href) {
      receiver.href = H.stringTypeCheck(href);
    },
    set$type: function(receiver, type) {
      receiver.type = H.stringTypeCheck(type);
    },
    "%": "HTMLLinkElement"
  },
  Location: {
    "^": "Interceptor;",
    toString$0: function(receiver) {
      return String(receiver);
    },
    $isLocation: 1,
    $isObject: 1,
    "%": "Location"
  },
  MapElement: {
    "^": "HtmlElement;name=",
    "%": "HTMLMapElement"
  },
  MediaElement: {
    "^": "HtmlElement;error=",
    "%": "HTMLAudioElement;HTMLMediaElement"
  },
  MediaError: {
    "^": "Interceptor;",
    $isMediaError: 1,
    "%": "MediaError"
  },
  MediaStream: {
    "^": "EventTarget;id=",
    "%": "MediaStream"
  },
  MenuElement: {
    "^": "HtmlElement;type",
    set$type: function(receiver, type) {
      receiver.type = H.stringTypeCheck(type);
    },
    "%": "HTMLMenuElement"
  },
  MenuItemElement: {
    "^": "HtmlElement;type",
    set$type: function(receiver, type) {
      receiver.type = H.stringTypeCheck(type);
    },
    "%": "HTMLMenuItemElement"
  },
  MetaElement: {
    "^": "HtmlElement;name=",
    "%": "HTMLMetaElement"
  },
  MidiOutput: {
    "^": "MidiPort;",
    send$2: function(receiver, data, timestamp) {
      return receiver.send(H.interceptedTypeCheck(data, "$isUint8List"), timestamp);
    },
    send$1: function($receiver, data) {
      return $receiver.send(data);
    },
    "%": "MIDIOutput"
  },
  MidiPort: {
    "^": "EventTarget;id=,name=",
    "%": "MIDIInput;MIDIPort"
  },
  MouseEvent: {
    "^": "UIEvent;",
    $isMouseEvent: 1,
    $isEvent: 1,
    $isObject: 1,
    "%": "DragEvent|MSPointerEvent|MouseEvent|MouseScrollEvent|MouseWheelEvent|PointerEvent|WheelEvent"
  },
  Navigator: {
    "^": "Interceptor;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "Navigator"
  },
  NavigatorUserMediaError: {
    "^": "Interceptor;name=",
    "%": "NavigatorUserMediaError"
  },
  _ChildNodeListLazy: {
    "^": "ListBase;_this",
    get$last: function(_) {
      var result = this._this.lastChild;
      if (result == null)
        throw H.wrapException(P.StateError$("No elements"));
      return result;
    },
    get$single: function(_) {
      var t1, l;
      t1 = this._this;
      l = t1.childNodes.length;
      if (l === 0)
        throw H.wrapException(P.StateError$("No elements"));
      if (l > 1)
        throw H.wrapException(P.StateError$("More than one element"));
      return t1.firstChild;
    },
    add$1: function(_, value) {
      J.append$1$x(this._this, H.interceptedTypeCheck(value, "$isNode"));
    },
    addAll$1: function(_, iterable) {
      var t1, t2, len, t3, i;
      H.listSuperNativeTypeCheck(iterable, "$isIterable");
      t1 = iterable._this;
      t2 = this._this;
      if (t1 !== t2)
        for (len = t1.childNodes.length, t3 = J.getInterceptor$x(t2), i = 0; i < len; ++i)
          t3.append$1(t2, t1.firstChild);
      return;
    },
    $indexSet: function(_, index, value) {
      var t1, t2;
      H.interceptedTypeCheck(value, "$isNode");
      t1 = this._this;
      t2 = t1.childNodes;
      if (index < 0 || index >= t2.length)
        return H.ioore(t2, index);
      J._replaceChild$2$x(t1, value, t2[index]);
    },
    get$iterator: function(_) {
      return H.assertSubtype(C.NodeList_methods.get$iterator(this._this.childNodes), "$isIterator", [W.Node], "$asIterator");
    },
    get$length: function(_) {
      return this._this.childNodes.length;
    },
    set$length: function(_, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot set length on immutable List."));
    },
    $index: function(_, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = this._this.childNodes;
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $asListBase: function() {
      return [W.Node];
    },
    $asObject_ListMixin: function() {
      return [W.Node];
    },
    $asListMixin: function() {
      return [W.Node];
    },
    $asList: function() {
      return [W.Node];
    },
    $asIterable: function() {
      return [W.Node];
    }
  },
  Node: {
    "^": "EventTarget;text:textContent=",
    set$text: function(receiver, text) {
      receiver.textContent = H.stringTypeCheck(text);
    },
    remove$0: function(receiver) {
      var t1 = receiver.parentNode;
      if (t1 != null)
        J._removeChild$1$x(t1, receiver);
    },
    replaceWith$1: function(receiver, otherNode) {
      var $parent, exception;
      H.interceptedTypeCheck(otherNode, "$isNode");
      try {
        $parent = receiver.parentNode;
        J._replaceChild$2$x($parent, otherNode, receiver);
      } catch (exception) {
        H.unwrapException(exception);
      }
      return receiver;
    },
    _clearChildren$0: function(receiver) {
      var t1;
      for (; t1 = receiver.firstChild, t1 != null;)
        this._removeChild$1(receiver, t1);
    },
    toString$0: function(receiver) {
      var value = receiver.nodeValue;
      return value == null ? this.super$Interceptor$toString$0(receiver) : value;
    },
    append$1: function(receiver, newChild) {
      return receiver.appendChild(newChild);
    },
    _removeChild$1: function(receiver, oldChild) {
      return receiver.removeChild(oldChild);
    },
    _replaceChild$2: function(receiver, newChild, oldChild) {
      return receiver.replaceChild(newChild, oldChild);
    },
    $isNode: 1,
    $isObject: 1,
    "%": ";Node"
  },
  NodeList0: {
    "^": "Interceptor_ListMixin_ImmutableListMixin0;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.interceptedTypeCheck(value, "$isNode");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$single: function(receiver) {
      var len = receiver.length;
      if (len === 1)
        return receiver[0];
      if (len === 0)
        throw H.wrapException(P.StateError$("No elements"));
      throw H.wrapException(P.StateError$("More than one element"));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: 1,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: 1,
    $isObject: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [W.Node];
    },
    $isJavaScriptIndexingBehavior: 1,
    $isJSIndexable: 1,
    "%": "NodeList|RadioNodeList"
  },
  Interceptor_ListMixin0: {
    "^": "Interceptor+ListMixin;",
    $isList: 1,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [W.Node];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin0: {
    "^": "Interceptor_ListMixin0+ImmutableListMixin;",
    $isList: 1,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [W.Node];
    }
  },
  OListElement: {
    "^": "HtmlElement;type",
    set$type: function(receiver, type) {
      receiver.type = H.stringTypeCheck(type);
    },
    $isOListElement: 1,
    "%": "HTMLOListElement"
  },
  ObjectElement: {
    "^": "HtmlElement;name=,type",
    set$type: function(receiver, type) {
      receiver.type = H.stringTypeCheck(type);
    },
    "%": "HTMLObjectElement"
  },
  OptionElement: {
    "^": "HtmlElement;",
    $isOptionElement: 1,
    "%": "HTMLOptionElement"
  },
  OutputElement: {
    "^": "HtmlElement;name=",
    "%": "HTMLOutputElement"
  },
  ParagraphElement: {
    "^": "HtmlElement;",
    $isParagraphElement: 1,
    "%": "HTMLParagraphElement"
  },
  ParamElement: {
    "^": "HtmlElement;name=",
    "%": "HTMLParamElement"
  },
  Range: {
    "^": "Interceptor;",
    createContextualFragment$1: function(receiver, html) {
      return receiver.createContextualFragment(html);
    },
    selectNodeContents$1: function(receiver, refNode) {
      return receiver.selectNodeContents(refNode);
    },
    $isRange: 1,
    "%": "Range"
  },
  ScriptElement0: {
    "^": "HtmlElement;type",
    set$type: function(receiver, type) {
      receiver.type = H.stringTypeCheck(type);
    },
    "%": "HTMLScriptElement"
  },
  SelectElement: {
    "^": "HtmlElement;length=,name=",
    $isSelectElement: 1,
    "%": "HTMLSelectElement"
  },
  ShadowRoot: {
    "^": "DocumentFragment0;innerHTML",
    set$innerHtml: function(receiver, innerHtml) {
      receiver.innerHTML = H.stringTypeCheck(innerHtml);
    },
    "%": "ShadowRoot"
  },
  SourceElement: {
    "^": "HtmlElement;type",
    set$type: function(receiver, type) {
      receiver.type = H.stringTypeCheck(type);
    },
    "%": "HTMLSourceElement"
  },
  SpanElement: {
    "^": "HtmlElement;",
    $isSpanElement: 1,
    "%": "HTMLSpanElement"
  },
  SpeechRecognitionError: {
    "^": "Event;error=",
    "%": "SpeechRecognitionError"
  },
  SpeechSynthesisEvent: {
    "^": "Event;name=",
    "%": "SpeechSynthesisEvent"
  },
  Storage: {
    "^": "Interceptor;",
    containsKey$1: function(receiver, key) {
      return this._getItem$1(receiver, key) != null;
    },
    $index: function(receiver, key) {
      return this._getItem$1(receiver, H.stringTypeCheck(key));
    },
    forEach$1: function(receiver, f) {
      var t1, i, key;
      t1 = H.buildInterfaceType(P.String);
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [t1, t1])._assertCheck$1(f);
      for (i = 0; true; ++i) {
        key = this._key$1(receiver, i);
        if (key == null)
          return;
        t1.call$2(key, this._getItem$1(receiver, key));
      }
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    _getItem$1: function(receiver, key) {
      return receiver.getItem(key);
    },
    _key$1: function(receiver, index) {
      return receiver.key(index);
    },
    _removeItem$1: function(receiver, key) {
      return receiver.removeItem(key);
    },
    _setItem$2: function(receiver, key, data) {
      return receiver.setItem(key, data);
    },
    $isMap: 1,
    $asMap: function() {
      return [P.String, P.String];
    },
    $isObject: 1,
    "%": "Storage"
  },
  StyleElement: {
    "^": "HtmlElement;type",
    set$type: function(receiver, type) {
      receiver.type = H.stringTypeCheck(type);
    },
    "%": "HTMLStyleElement"
  },
  TableElement: {
    "^": "HtmlElement;",
    createFragment$3$treeSanitizer$validator: function(receiver, html, treeSanitizer, validator) {
      var table, fragment, t1;
      if ("createContextualFragment" in window.Range.prototype)
        return this.super$Element$createFragment$3$treeSanitizer$validator(receiver, html, treeSanitizer, validator);
      table = W.Element_Element$html("<table>" + H.S(html) + "</table>", treeSanitizer, validator);
      fragment = document.createDocumentFragment();
      fragment.toString;
      t1 = H.assertSubtype(new W._ChildNodeListLazy(fragment), "$isList", [W.Node], "$asList");
      table.toString;
      t1.addAll$1(0, H.assertSubtype(new W._ChildNodeListLazy(table), "$isList", [W.Node], "$asList"));
      return fragment;
    },
    $isTableElement: 1,
    "%": "HTMLTableElement"
  },
  TableRowElement: {
    "^": "HtmlElement;",
    createFragment$3$treeSanitizer$validator: function(receiver, html, treeSanitizer, validator) {
      var fragment, t1, section, row;
      if ("createContextualFragment" in window.Range.prototype)
        return this.super$Element$createFragment$3$treeSanitizer$validator(receiver, html, treeSanitizer, validator);
      fragment = document.createDocumentFragment();
      t1 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "table", null), "$isTableElement");
      t1 = (t1 && C.TableElement_methods).createFragment$3$treeSanitizer$validator(t1, html, treeSanitizer, validator);
      t1.toString;
      t1 = H.assertSubtype(new W._ChildNodeListLazy(t1), "$isList", [W.Node], "$asList");
      section = t1.get$single(t1);
      section.toString;
      t1 = H.assertSubtype(new W._ChildNodeListLazy(section), "$isList", [W.Node], "$asList");
      row = t1.get$single(t1);
      fragment.toString;
      t1 = H.assertSubtype(new W._ChildNodeListLazy(fragment), "$isList", [W.Node], "$asList");
      row.toString;
      t1.addAll$1(0, H.assertSubtype(new W._ChildNodeListLazy(row), "$isList", [W.Node], "$asList"));
      return fragment;
    },
    "%": "HTMLTableRowElement"
  },
  TableSectionElement: {
    "^": "HtmlElement;",
    createFragment$3$treeSanitizer$validator: function(receiver, html, treeSanitizer, validator) {
      var fragment, t1, section;
      if ("createContextualFragment" in window.Range.prototype)
        return this.super$Element$createFragment$3$treeSanitizer$validator(receiver, html, treeSanitizer, validator);
      fragment = document.createDocumentFragment();
      t1 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "table", null), "$isTableElement");
      t1 = (t1 && C.TableElement_methods).createFragment$3$treeSanitizer$validator(t1, html, treeSanitizer, validator);
      t1.toString;
      t1 = H.assertSubtype(new W._ChildNodeListLazy(t1), "$isList", [W.Node], "$asList");
      section = t1.get$single(t1);
      fragment.toString;
      t1 = H.assertSubtype(new W._ChildNodeListLazy(fragment), "$isList", [W.Node], "$asList");
      section.toString;
      t1.addAll$1(0, H.assertSubtype(new W._ChildNodeListLazy(section), "$isList", [W.Node], "$asList"));
      return fragment;
    },
    "%": "HTMLTableSectionElement"
  },
  TemplateElement: {
    "^": "HtmlElement;",
    setInnerHtml$3$treeSanitizer$validator: function(receiver, html, treeSanitizer, validator) {
      var fragment;
      receiver.textContent = null;
      fragment = this.createFragment$3$treeSanitizer$validator(receiver, html, treeSanitizer, validator);
      J.append$1$x(receiver.content, fragment);
    },
    setInnerHtml$1: function($receiver, html) {
      return this.setInnerHtml$3$treeSanitizer$validator($receiver, html, null, null);
    },
    $isTemplateElement: 1,
    "%": "HTMLTemplateElement"
  },
  TextAreaElement: {
    "^": "HtmlElement;name=",
    "%": "HTMLTextAreaElement"
  },
  UIEvent: {
    "^": "Event;",
    "%": "CompositionEvent|FocusEvent|KeyboardEvent|SVGZoomEvent|TextEvent|TouchEvent;UIEvent"
  },
  VideoElement: {
    "^": "MediaElement;",
    $isObject: 1,
    "%": "HTMLVideoElement"
  },
  Window: {
    "^": "EventTarget;name=",
    confirm$1: function(receiver, message) {
      return receiver.confirm(message);
    },
    $isWindow: 1,
    $isInterceptor: 1,
    $isObject: 1,
    $isEventTarget: 1,
    "%": "DOMWindow|Window"
  },
  _Attr: {
    "^": "Node;name=",
    get$text: function(receiver) {
      return receiver.textContent;
    },
    set$text: function(receiver, value) {
      receiver.textContent = value;
    },
    "%": "Attr"
  },
  _ClientRect: {
    "^": "Interceptor;bottom=,height=,left=,right=,top=,width=",
    toString$0: function(receiver) {
      return "Rectangle (" + H.S(receiver.left) + ", " + H.S(receiver.top) + ") " + H.S(receiver.width) + " x " + H.S(receiver.height);
    },
    $eq: function(receiver, other) {
      var t1, t2, t3;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isRectangle)
        return false;
      t2 = receiver.left;
      t3 = t1.get$left(other);
      if (t2 == null ? t3 == null : t2 === t3) {
        t2 = receiver.top;
        t3 = t1.get$top(other);
        if (t2 == null ? t3 == null : t2 === t3) {
          t2 = receiver.width;
          t3 = t1.get$width(other);
          if (t2 == null ? t3 == null : t2 === t3) {
            t2 = receiver.height;
            t1 = t1.get$height(other);
            t1 = t2 == null ? t1 == null : t2 === t1;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(receiver) {
      var t1, t2, t3, t4;
      t1 = J.get$hashCode$(receiver.left);
      t2 = J.get$hashCode$(receiver.top);
      t3 = J.get$hashCode$(receiver.width);
      t4 = J.get$hashCode$(receiver.height);
      return W._JenkinsSmiHash_finish(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(0, t1), t2), t3), t4));
    },
    $isRectangle: 1,
    $asRectangle: $.functionThatReturnsNull,
    $isObject: 1,
    "%": "ClientRect"
  },
  _DocumentType: {
    "^": "Node;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "DocumentType"
  },
  _DomRect: {
    "^": "DomRectReadOnly;",
    get$height: function(receiver) {
      return receiver.height;
    },
    get$width: function(receiver) {
      return receiver.width;
    },
    "%": "DOMRect"
  },
  _HTMLFrameSetElement: {
    "^": "HtmlElement;",
    $isEventTarget: 1,
    $isInterceptor: 1,
    $isObject: 1,
    "%": "HTMLFrameSetElement"
  },
  _NamedNodeMap: {
    "^": "Interceptor_ListMixin_ImmutableListMixin1;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.interceptedTypeCheck(value, "$isNode");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$single: function(receiver) {
      var len = receiver.length;
      if (len === 1)
        return receiver[0];
      if (len === 0)
        throw H.wrapException(P.StateError$("No elements"));
      throw H.wrapException(P.StateError$("More than one element"));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: 1,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: 1,
    $isObject: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [W.Node];
    },
    $isJavaScriptIndexingBehavior: 1,
    $isJSIndexable: 1,
    "%": "MozNamedAttrMap|NamedNodeMap"
  },
  Interceptor_ListMixin1: {
    "^": "Interceptor+ListMixin;",
    $isList: 1,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [W.Node];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin1: {
    "^": "Interceptor_ListMixin1+ImmutableListMixin;",
    $isList: 1,
    $asList: function() {
      return [W.Node];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [W.Node];
    }
  },
  _AttributeMap: {
    "^": "Object;",
    forEach$1: function(_, f) {
      var t1, t2, t3, t4, key;
      t1 = H.buildInterfaceType(P.String);
      t1 = H.buildFunctionType(H.getVoidRuntimeType(), [t1, t1])._assertCheck$1(f);
      for (t2 = this.get$keys(this), t3 = H.getTypeArgumentByIndex(t2, 0), H.assertSubtype(t2, "$isJSArray", [t3], "$asJSArray"), t4 = t2.length, t2 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t2, "$isJSArray", [t3], "$asJSArray"), t4, 0, H.assertSubtypeOfRuntimeType(null, t3)), [t3]), "$isIterator", [H.getTypeArgumentByIndex(t2, 0)], "$asIterator"); t2.moveNext$0();) {
        key = H.assertSubtypeOfRuntimeType(t2._current, H.getTypeArgumentByIndex(t2, 0));
        t1.call$2(key, this.$index(0, key));
      }
    },
    get$keys: function(_) {
      var attributes, keys, len, i;
      attributes = this._html$_element.attributes;
      keys = H.setRuntimeTypeInfo([], [P.String]);
      for (len = attributes.length, i = 0; i < len; ++i) {
        if (i >= attributes.length)
          return H.ioore(attributes, i);
        if (this._matches$1(attributes[i])) {
          if (i >= attributes.length)
            return H.ioore(attributes, i);
          C.JSArray_methods.add$1(keys, J.get$name$x(attributes[i]));
        }
      }
      return H.listSuperNativeTypeCheck(keys, "$isIterable");
    },
    $isMap: 1,
    $asMap: function() {
      return [P.String, P.String];
    }
  },
  _ElementAttributeMap: {
    "^": "_AttributeMap;_html$_element",
    containsKey$1: function(_, key) {
      return J._hasAttribute$1$x(this._html$_element, key);
    },
    $index: function(_, key) {
      return J.getAttribute$1$x(this._html$_element, H.stringTypeCheck(key));
    },
    get$length: function(_) {
      return this.get$keys(this).length;
    },
    _matches$1: function(node) {
      return node.namespaceURI == null;
    }
  },
  _MultiElementCssClassSet: {
    "^": "CssClassSetImpl;_elementIterable,_sets",
    readClasses$0: function() {
      var s = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
      C.JSArray_methods.forEach$1(this._sets, new W._MultiElementCssClassSet_readClasses_closure(s));
      return H.assertSubtype(s, "$isSet", [P.String], "$asSet");
    },
    writeClasses$1: function(s) {
      var classes, t1;
      classes = H.assertSubtype(s, "$isSet", [P.String], "$asSet").join$1(0, " ");
      for (t1 = this._elementIterable, t1 = t1.get$iterator(t1); t1.moveNext$0();)
        H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t1.__internal$_current, H.getTypeArgumentByIndex(t1, 0)), "$isElement").className = classes;
    },
    modify$1: function(f) {
      C.JSArray_methods.forEach$1(this._sets, new W._MultiElementCssClassSet_modify_closure(H.buildFunctionType(H.getDynamicRuntimeType(), [H.buildInterfaceType(P.Set, [H.buildInterfaceType(P.String)])])._assertCheck$1(f)));
    },
    remove$1: function(_, value) {
      return H.boolTypeCheck(C.JSArray_methods.fold$2(this._sets, false, new W._MultiElementCssClassSet_remove_closure(value)));
    },
    static: {_MultiElementCssClassSet__MultiElementCssClassSet: function(elements) {
        var t1;
        H.listSuperNativeTypeCheck(elements, "$isIterable");
        t1 = elements.map$1(elements, new W._MultiElementCssClassSet__MultiElementCssClassSet_closure()).toList$0(0);
        H.listSuperNativeTypeCheck(elements, "$isIterable");
        H.assertSubtype(t1, "$isList", [P.CssClassSetImpl], "$asList");
        return new W._MultiElementCssClassSet(H.listSuperNativeTypeCheck(elements, "$isIterable"), H.assertSubtype(t1, "$isList", [P.CssClassSetImpl], "$asList"));
      }}
  },
  _MultiElementCssClassSet__MultiElementCssClassSet_closure: {
    "^": "Closure:20;",
    call$1: function(e) {
      return J.get$classes$x(H.interceptedTypeCheck(e, "$isElement"));
    }
  },
  _MultiElementCssClassSet_readClasses_closure: {
    "^": "Closure:21;_captured_s_0",
    call$1: function(e) {
      return this._captured_s_0.addAll$1(0, H.interceptedTypeCheck(e, "$isCssClassSetImpl").readClasses$0());
    }
  },
  _MultiElementCssClassSet_modify_closure: {
    "^": "Closure:21;_captured_f_0",
    call$1: function(e) {
      return H.interceptedTypeCheck(e, "$isCssClassSetImpl").modify$1(this._captured_f_0);
    }
  },
  _MultiElementCssClassSet_remove_closure: {
    "^": "Closure:22;_html$_captured_value_0",
    call$2: function(changed, e) {
      H.boolTypeCheck(changed);
      return H.boolConversionCheck(H.interceptedTypeCheck(e, "$isCssClassSetImpl").remove$1(0, this._html$_captured_value_0)) || changed;
    }
  },
  _ElementCssClassSet: {
    "^": "CssClassSetImpl;_html$_element",
    readClasses$0: function() {
      var s, t1, t2, t3, trimmed;
      s = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
      for (t1 = this._html$_element.className.split(" "), t2 = H.getTypeArgumentByIndex(t1, 0), H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3 = t1.length, t1 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"); t1.moveNext$0();) {
        trimmed = J.trim$0$s(H.stringTypeCheck(H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0))));
        if (trimmed.length !== 0)
          s.add$1(0, trimmed);
      }
      return H.assertSubtype(s, "$isSet", [P.String], "$asSet");
    },
    writeClasses$1: function(s) {
      this._html$_element.className = H.assertSubtype(s, "$isSet", [P.String], "$asSet").join$1(0, " ");
    },
    get$length: function(_) {
      return this._html$_element.classList.length;
    },
    get$isEmpty: function(_) {
      return this._html$_element.classList.length === 0;
    },
    contains$1: function(_, value) {
      return typeof value === "string" && this._html$_element.classList.contains(value);
    },
    add$1: function(_, value) {
      return W._ElementCssClassSet__add(this._html$_element, H.stringTypeCheck(value));
    },
    remove$1: function(_, value) {
      var list, removed, t1;
      list = this._html$_element.classList;
      removed = list.contains(value);
      list.remove(value);
      t1 = removed;
      return t1;
    },
    static: {_ElementCssClassSet__add: function(_element, value) {
        var list, t1;
        list = _element.classList;
        t1 = list.contains(value);
        list.add(value);
        return !t1;
      }, _ElementCssClassSet__addAll: function(_element, iterable) {
        var list, t1, t2;
        H.listSuperNativeTypeCheck(iterable, "$isIterable");
        list = _element.classList;
        for (t1 = H.getTypeArgumentByIndex(iterable, 0), H.assertSubtype(iterable, "$isJSArray", [t1], "$asJSArray"), t2 = iterable.length, t1 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(iterable, "$isJSArray", [t1], "$asJSArray"), t2, 0, H.assertSubtypeOfRuntimeType(null, t1)), [t1]), "$isIterator", [H.getTypeArgumentByIndex(iterable, 0)], "$asIterator"); t1.moveNext$0();)
          list.add(H.stringTypeCheck(H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0))));
      }}
  },
  EventStreamProvider: {
    "^": "Object;_eventType"
  },
  _EventStream: {
    "^": "Stream;",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1, t2;
      t1 = H.getVoidRuntimeType();
      t2 = H.buildFunctionType(t1, [this.T1()])._assertCheck$1(onData);
      H.buildFunctionType(t1)._assertCheck$1(onDone);
      t2 = new W._EventStreamSubscription(0, this._html$_target, this._eventType, W._wrapZone(t2), this._useCapture);
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      t2._tryResume$0();
      return H.assertSubtype(t2, "$isStreamSubscription", [H.getTypeArgumentByIndex(this, 0)], "$asStreamSubscription");
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    T1: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  _ElementEventStreamImpl: {
    "^": "_EventStream;_html$_target,_eventType,_useCapture",
    T1: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    T: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isElementStream: 1
  },
  _EventStreamSubscription: {
    "^": "StreamSubscription;_pauseCount,_html$_target,_eventType,_onData,_useCapture",
    cancel$0: function() {
      if (this._html$_target == null)
        return;
      this._unlisten$0();
      this._html$_target = null;
      this._onData = null;
      return;
    },
    _tryResume$0: function() {
      var t1 = this._onData;
      if (t1 != null && this._pauseCount <= 0)
        J.addEventListener$3$x(this._html$_target, this._eventType, t1, this._useCapture);
    },
    _unlisten$0: function() {
      var t1 = this._onData;
      if (t1 != null)
        J.removeEventListener$3$x(this._html$_target, this._eventType, t1, this._useCapture);
    }
  },
  _Html5NodeValidator: {
    "^": "Object;uriPolicy",
    allowsElement$1: function(element) {
      return $.get$_Html5NodeValidator__allowedElements().contains$1(0, element.tagName);
    },
    allowsAttribute$3: function(element, attributeName, value) {
      var tagName, t1, validator;
      tagName = element.tagName;
      t1 = $.get$_Html5NodeValidator__attributeValidators();
      validator = t1.$index(0, H.S(tagName) + "::" + attributeName);
      if (validator == null)
        validator = t1.$index(0, "*::" + attributeName);
      if (validator == null)
        return false;
      return H.boolTypeCheck(validator.call$4(element, attributeName, value, this));
    },
    _Html5NodeValidator$1$uriPolicy: function(uriPolicy) {
      var t1, t2;
      t1 = $.get$_Html5NodeValidator__attributeValidators();
      if (t1.get$isEmpty(t1)) {
        for (t2 = H.getTypeArgumentByIndex(C.List_1GN, 0), H.assertSubtype(C.List_1GN, "$isJSArray", [t2], "$asJSArray"), t2 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(C.List_1GN, "$isJSArray", [t2], "$asJSArray"), 261, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(C.List_1GN, 0)], "$asIterator"); t2.moveNext$0();)
          t1.$indexSet(0, H.assertSubtypeOfRuntimeType(t2._current, H.getTypeArgumentByIndex(t2, 0)), W._Html5NodeValidator__standardAttributeValidator$closure());
        for (t2 = H.getTypeArgumentByIndex(C.List_yrN, 0), H.assertSubtype(C.List_yrN, "$isJSArray", [t2], "$asJSArray"), t2 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(C.List_yrN, "$isJSArray", [t2], "$asJSArray"), 12, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(C.List_yrN, 0)], "$asIterator"); t2.moveNext$0();)
          t1.$indexSet(0, H.assertSubtypeOfRuntimeType(t2._current, H.getTypeArgumentByIndex(t2, 0)), W._Html5NodeValidator__uriAttributeValidator$closure());
      }
    },
    $isNodeValidator: 1,
    static: {_Html5NodeValidator$: function(uriPolicy) {
        var e, t1;
        e = C.HtmlDocument_methods._createElement$2(document, "a", null);
        t1 = new W._SameOriginUriPolicy(H.interceptedTypeCheck(e, "$isAnchorElement"), window.location);
        t1 = new W._Html5NodeValidator(t1);
        t1._Html5NodeValidator$1$uriPolicy(uriPolicy);
        return t1;
      }, _Html5NodeValidator__standardAttributeValidator: [function(element, attributeName, value, context) {
        H.interceptedTypeCheck(element, "$isElement");
        H.stringTypeCheck(attributeName);
        H.stringTypeCheck(value);
        H.interceptedTypeCheck(context, "$is_Html5NodeValidator");
        return true;
      }, "call$4", "_Html5NodeValidator__standardAttributeValidator$closure", 8, 0, 51], _Html5NodeValidator__uriAttributeValidator: [function(element, attributeName, value, context) {
        var t1, t2, t3, t4, t5;
        H.interceptedTypeCheck(element, "$isElement");
        H.stringTypeCheck(attributeName);
        H.stringTypeCheck(value);
        t1 = H.interceptedTypeCheck(context, "$is_Html5NodeValidator").uriPolicy;
        t2 = t1._hiddenAnchor;
        t2.href = value;
        t3 = t2.hostname;
        t1 = t1._loc;
        t4 = t1.hostname;
        if (t3 == null ? t4 == null : t3 === t4) {
          t4 = t2.port;
          t5 = t1.port;
          if (t4 == null ? t5 == null : t4 === t5) {
            t4 = t2.protocol;
            t1 = t1.protocol;
            t1 = t4 == null ? t1 == null : t4 === t1;
          } else
            t1 = false;
        } else
          t1 = false;
        if (!t1)
          if (t3 === "")
            if (t2.port === "") {
              t1 = t2.protocol;
              t1 = t1 === ":" || t1 === "";
            } else
              t1 = false;
          else
            t1 = false;
        else
          t1 = true;
        return t1;
      }, "call$4", "_Html5NodeValidator__uriAttributeValidator$closure", 8, 0, 51]}
  },
  ImmutableListMixin: {
    "^": "Object;",
    get$iterator: function(receiver) {
      var t1, t2;
      t1 = H.getRuntimeTypeArgument(receiver, "ImmutableListMixin", 0);
      H.assertSubtype(receiver, "$isList", [t1], "$asList");
      t2 = this.get$length(receiver);
      return H.assertSubtype(H.setRuntimeTypeInfo(new W.FixedSizeListIterator(H.assertSubtype(receiver, "$isList", [t1], "$asList"), t2, -1, H.assertSubtypeOfRuntimeType(null, t1)), [t1]), "$isIterator", [H.getRuntimeTypeArgument(receiver, "ImmutableListMixin", 0)], "$asIterator");
    },
    add$1: function(receiver, value) {
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(receiver, "ImmutableListMixin", 0));
      throw H.wrapException(P.UnsupportedError$("Cannot add to immutable List."));
    },
    $isList: 1,
    $asList: null,
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: null
  },
  NodeValidatorBuilder: {
    "^": "Object;_validators",
    add$1: function(_, validator) {
      C.JSArray_methods.add$1(this._validators, H.interceptedTypeCheck(validator, "$isNodeValidator"));
    },
    allowsElement$1: function(element) {
      return C.JSArray_methods.any$1(this._validators, new W.NodeValidatorBuilder_allowsElement_closure(element));
    },
    allowsAttribute$3: function(element, attributeName, value) {
      return C.JSArray_methods.any$1(this._validators, new W.NodeValidatorBuilder_allowsAttribute_closure(element, attributeName, value));
    },
    $isNodeValidator: 1
  },
  NodeValidatorBuilder_allowsElement_closure: {
    "^": "Closure:2;_captured_element_0",
    call$1: function(v) {
      return v.allowsElement$1(this._captured_element_0);
    }
  },
  NodeValidatorBuilder_allowsAttribute_closure: {
    "^": "Closure:2;_captured_element_0,_captured_attributeName_1,_captured_value_2",
    call$1: function(v) {
      return v.allowsAttribute$3(this._captured_element_0, this._captured_attributeName_1, this._captured_value_2);
    }
  },
  _SimpleNodeValidator: {
    "^": "Object;",
    allowsElement$1: function(element) {
      return this.allowedElements.contains$1(0, element.tagName);
    },
    allowsAttribute$3: ["super$_SimpleNodeValidator$allowsAttribute$3", function(element, attributeName, value) {
      var tagName, t1;
      tagName = element.tagName;
      t1 = this.allowedUriAttributes;
      if (t1.contains$1(0, H.S(tagName) + "::" + attributeName))
        return this.uriPolicy.allowsUri$1(value);
      else if (t1.contains$1(0, "*::" + attributeName))
        return this.uriPolicy.allowsUri$1(value);
      else {
        t1 = this.allowedAttributes;
        if (t1.contains$1(0, H.S(tagName) + "::" + attributeName))
          return true;
        else if (t1.contains$1(0, "*::" + attributeName))
          return true;
        else if (t1.contains$1(0, H.S(tagName) + "::*"))
          return true;
        else if (t1.contains$1(0, "*::*"))
          return true;
      }
      return false;
    }],
    $isNodeValidator: 1
  },
  _TemplatingNodeValidator: {
    "^": "_SimpleNodeValidator;_templateAttrs,allowedElements,allowedAttributes,allowedUriAttributes,uriPolicy",
    allowsAttribute$3: function(element, attributeName, value) {
      if (this.super$_SimpleNodeValidator$allowsAttribute$3(element, attributeName, value))
        return true;
      if (attributeName === "template" && value === "")
        return true;
      H.assertSubtype(new W._ElementAttributeMap(element), "$isMap", [P.String, P.String], "$asMap");
      if (J.getAttribute$1$x(element, "template") === "")
        return this._templateAttrs.contains$1(0, attributeName);
      return false;
    },
    static: {_TemplatingNodeValidator$: function() {
        var t1, t2, t3;
        t1 = new W._TemplatingNodeValidator_closure();
        H.buildFunctionType(H.getDynamicRuntimeType(), [H.convertRtiToRuntimeType(C.List_wSV.$builtinTypeInfo && C.List_wSV.$builtinTypeInfo[0])])._assertCheck$1(t1);
        H.listSuperNativeTypeCheck(C.List_wSV, "$isIterable");
        t2 = H.buildFunctionType(H.convertRtiToRuntimeType(null), [H.convertRtiToRuntimeType(null)]);
        t2._assertCheck$1(t1);
        t1 = H.setRuntimeTypeInfo(new H.MappedListIterable(H.listSuperNativeTypeCheck(C.List_wSV, "$isIterable"), t2._assertCheck$1(t1)), [null, null]);
        t2 = P.LinkedHashSet_LinkedHashSet$from(["TEMPLATE"], null);
        t1 = P.LinkedHashSet_LinkedHashSet$from(t1, null);
        t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, null);
        return new W._TemplatingNodeValidator(H.assertSubtype(H.assertSubtype(P.LinkedHashSet_LinkedHashSet$from(C.List_wSV, P.String), "$isSet", [P.String], "$asSet"), "$isSet", [P.String], "$asSet"), H.assertSubtype(t2, "$isSet", [P.String], "$asSet"), H.assertSubtype(t1, "$isSet", [P.String], "$asSet"), H.assertSubtype(t3, "$isSet", [P.String], "$asSet"), null);
      }}
  },
  _TemplatingNodeValidator_closure: {
    "^": "Closure:2;",
    call$1: function(attr) {
      return "TEMPLATE::" + H.S(attr);
    }
  },
  _SvgNodeValidator: {
    "^": "Object;",
    allowsElement$1: function(element) {
      var t1 = J.getInterceptor(element);
      if (!!t1.$isScriptElement)
        return false;
      t1 = !!t1.$isSvgElement;
      if (t1 && element.tagName === "foreignObject")
        return false;
      if (t1)
        return true;
      return false;
    },
    allowsAttribute$3: function(element, attributeName, value) {
      if (attributeName === "is" || C.JSString_methods.startsWith$1(attributeName, "on"))
        return false;
      return this.allowsElement$1(element);
    },
    $isNodeValidator: 1
  },
  FixedSizeListIterator: {
    "^": "Object;_array,_html$_length,_position,_html$_current",
    set$_html$_current: function(_current) {
      this._html$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    moveNext$0: function() {
      var nextPosition, t1;
      nextPosition = this._position + 1;
      t1 = this._html$_length;
      if (nextPosition < t1) {
        this.set$_html$_current(J.$index$asx(this._array, nextPosition));
        this._position = nextPosition;
        return true;
      }
      this.set$_html$_current(null);
      this._position = t1;
      return false;
    },
    get$current: function() {
      return H.assertSubtypeOfRuntimeType(this._html$_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  },
  NodeValidator: {
    "^": "Object;"
  },
  _SameOriginUriPolicy: {
    "^": "Object;_hiddenAnchor,_loc",
    $isUriPolicy: 1
  },
  _ValidatingTreeSanitizer: {
    "^": "Object;validator",
    sanitizeTree$1: function(node) {
      new W._ValidatingTreeSanitizer_sanitizeTree_walk(this).call$2(node, null);
    },
    _removeNode$2: function(node, $parent) {
      if ($parent == null)
        J.remove$0$ax(node);
      else
        J._removeChild$1$x($parent, node);
    },
    sanitizeNode$2: function(node, $parent) {
      var t1, attrs, isAttr, t2, t3, i, $name;
      switch (node.nodeType) {
        case 1:
          H.interceptedTypeCheck(node, "$isElement");
          if (function(element) {
            if (!(element.attributes instanceof NamedNodeMap))
              return true;
            var childNodes = element.childNodes;
            if (element.lastChild && element.lastChild !== childNodes[childNodes.length - 1])
              return true;
            if (element.children)
              if (!(element.children instanceof HTMLCollection || element.children instanceof NodeList))
                return true;
            return false;
          }(node)) {
            window;
            t1 = "Removing element due to corrupted attributes on <" + J.toString$0(node) + ">";
            H.voidTypeCheck(typeof console != "undefined" ? console.warn(t1) : null);
            this._removeNode$2(node, $parent);
            break;
          }
          attrs = H.assertSubtype(new W._ElementAttributeMap(node), "$isMap", [P.String, P.String], "$asMap");
          if (!this.validator.allowsElement$1(node)) {
            window;
            t1 = "Removing disallowed element <" + H.S(node.tagName) + ">";
            H.voidTypeCheck(typeof console != "undefined" ? console.warn(t1) : null);
            this._removeNode$2(node, $parent);
            break;
          }
          t1 = J.getInterceptor$x(node);
          isAttr = t1.getAttribute$1(node, "is");
          if (isAttr != null)
            if (!this.validator.allowsAttribute$3(node, "is", isAttr)) {
              window;
              t1 = "Removing disallowed type extension <" + H.S(node.tagName) + " is=\"" + isAttr + "\">";
              H.voidTypeCheck(typeof console != "undefined" ? console.warn(t1) : null);
              this._removeNode$2(node, $parent);
              break;
            }
          t2 = attrs.get$keys(attrs);
          t3 = H.getTypeArgumentByIndex(t2, 0);
          t3 = H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(H.assertSubtype(t2.slice(), "$isJSArray", [t3], "$asJSArray"), [t3]), "$isJSArray", [t3], "$asJSArray"), "$isList", [H.getTypeArgumentByIndex(t2, 0)], "$asList");
          H.assertSubtype(t3, "$isList", [H.getTypeArgumentByIndex(t2, 0)], "$asList");
          for (i = attrs.get$keys(attrs).length - 1; i >= 0; --i) {
            if (i >= t3.length)
              return H.ioore(t3, i);
            $name = t3[i];
            if (!this.validator.allowsAttribute$3(node, J.toLowerCase$0$s($name), t1.getAttribute$1(node, $name))) {
              window;
              t2 = "Removing disallowed attribute <" + H.S(node.tagName) + " " + $name + "=\"" + H.S(t1.getAttribute$1(node, $name)) + "\">";
              H.voidTypeCheck(typeof console != "undefined" ? console.warn(t2) : null);
              t1.getAttribute$1(node, $name);
              t1._removeAttribute$1(node, $name);
            }
          }
          if (!!J.getInterceptor(node).$isTemplateElement)
            this.sanitizeTree$1(node.content);
          break;
        case 8:
        case 11:
        case 3:
        case 4:
          break;
        default:
          this._removeNode$2(node, $parent);
      }
    },
    $isNodeTreeSanitizer: 1
  },
  _ValidatingTreeSanitizer_sanitizeTree_walk: {
    "^": "Closure:23;_html$_captured_this_0",
    call$2: function(node, $parent) {
      var child, nextChild;
      this._html$_captured_this_0.sanitizeNode$2(node, $parent);
      child = node.lastChild;
      for (; child != null; child = nextChild) {
        nextChild = child.previousSibling;
        this.call$2(child, node);
      }
    }
  }
}],
["dart.dom.indexed_db", "dart:indexed_db", , P, {
  "^": ""
}],
["dart.dom.svg", "dart:svg", , P, {
  "^": "",
  AElement: {
    "^": "GraphicsElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGAElement"
  },
  AltGlyphElement: {
    "^": "TextPositioningElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGAltGlyphElement"
  },
  AnimatedLength: {
    "^": "Interceptor;",
    $isAnimatedLength: 1,
    "%": "SVGAnimatedLength"
  },
  AnimatedString: {
    "^": "Interceptor;",
    $isAnimatedString: 1,
    "%": "SVGAnimatedString"
  },
  AnimationElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGAnimateElement|SVGAnimateMotionElement|SVGAnimateTransformElement|SVGAnimationElement|SVGSetElement"
  },
  FEBlendElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGFEBlendElement"
  },
  FEColorMatrixElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGFEColorMatrixElement"
  },
  FEComponentTransferElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGFEComponentTransferElement"
  },
  FECompositeElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGFECompositeElement"
  },
  FEConvolveMatrixElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGFEConvolveMatrixElement"
  },
  FEDiffuseLightingElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGFEDiffuseLightingElement"
  },
  FEDisplacementMapElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGFEDisplacementMapElement"
  },
  FEFloodElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGFEFloodElement"
  },
  FEGaussianBlurElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGFEGaussianBlurElement"
  },
  FEImageElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGFEImageElement"
  },
  FEMergeElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGFEMergeElement"
  },
  FEMorphologyElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGFEMorphologyElement"
  },
  FEOffsetElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGFEOffsetElement"
  },
  FESpecularLightingElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGFESpecularLightingElement"
  },
  FETileElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGFETileElement"
  },
  FETurbulenceElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGFETurbulenceElement"
  },
  FilterElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGFilterElement"
  },
  GraphicsElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGCircleElement|SVGClipPathElement|SVGDefsElement|SVGEllipseElement|SVGForeignObjectElement|SVGGElement|SVGGeometryElement|SVGLineElement|SVGPathElement|SVGPolygonElement|SVGPolylineElement|SVGRectElement|SVGSwitchElement;SVGGraphicsElement"
  },
  ImageElement0: {
    "^": "GraphicsElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGImageElement"
  },
  MarkerElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGMarkerElement"
  },
  MaskElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGMaskElement"
  },
  PatternElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGPatternElement"
  },
  ScriptElement: {
    "^": "SvgElement;type",
    set$type: function(receiver, type) {
      receiver.type = H.stringTypeCheck(type);
    },
    $isScriptElement: 1,
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGScriptElement"
  },
  StyleElement0: {
    "^": "SvgElement;type",
    set$type: function(receiver, type) {
      receiver.type = H.stringTypeCheck(type);
    },
    get$title: function(receiver) {
      return receiver.title;
    },
    "%": "SVGStyleElement"
  },
  _AttributeClassSet: {
    "^": "CssClassSetImpl;_svg$_element",
    readClasses$0: function() {
      var t1, classname, s, t2, t3, trimmed;
      t1 = this._svg$_element;
      H.assertSubtype(new W._ElementAttributeMap(t1), "$isMap", [P.String, P.String], "$asMap");
      classname = J.getAttribute$1$x(t1, "class");
      s = H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, P.String), "$isSet", [P.String], "$asSet");
      if (classname == null)
        return H.assertSubtype(s, "$isSet", [P.String], "$asSet");
      for (t1 = classname.split(" "), t2 = H.getTypeArgumentByIndex(t1, 0), H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3 = t1.length, t1 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"); t1.moveNext$0();) {
        trimmed = J.trim$0$s(H.stringTypeCheck(H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0))));
        if (trimmed.length !== 0)
          s.add$1(0, trimmed);
      }
      return H.assertSubtype(s, "$isSet", [P.String], "$asSet");
    },
    writeClasses$1: function(s) {
      var t1 = this._svg$_element;
      H.assertSubtype(new W._ElementAttributeMap(t1), "$isMap", [P.String, P.String], "$asMap");
      J.setAttribute$2$x(t1, "class", s.join$1(0, " "));
    }
  },
  SvgElement: {
    "^": "Element;",
    get$classes: function(receiver) {
      return new P._AttributeClassSet(receiver);
    },
    get$children: function(receiver) {
      return H.assertSubtype(H.setRuntimeTypeInfo(new P.FilteredElementList(receiver, H.assertSubtype(H.assertSubtype(new W._ChildNodeListLazy(receiver), "$isList", [W.Node], "$asList"), "$isList", [W.Node], "$asList")), [W.Element]), "$isList", [W.Element], "$asList");
    },
    set$innerHtml: function(receiver, value) {
      receiver.textContent = null;
      this.append$1(receiver, this.createFragment$3$treeSanitizer$validator(receiver, value, null, null));
    },
    createFragment$3$treeSanitizer$validator: function(receiver, svg, treeSanitizer, validator) {
      var t1, html, fragment, svgFragment, root, t2;
      t1 = H.assertSubtype(H.setRuntimeTypeInfo([], [W.NodeValidator]), "$isList", [W.NodeValidator], "$asList");
      validator = new W.NodeValidatorBuilder(t1);
      C.JSArray_methods.add$1(t1, W._Html5NodeValidator$(null));
      C.JSArray_methods.add$1(t1, W._TemplatingNodeValidator$());
      C.JSArray_methods.add$1(t1, new W._SvgNodeValidator());
      treeSanitizer = new W._ValidatingTreeSanitizer(validator);
      html = "<svg version=\"1.1\">" + H.S(svg) + "</svg>";
      t1 = document.body;
      fragment = (t1 && C.BodyElement_methods).createFragment$2$treeSanitizer(t1, html, treeSanitizer);
      svgFragment = document.createDocumentFragment();
      fragment.toString;
      t1 = H.assertSubtype(new W._ChildNodeListLazy(fragment), "$isList", [W.Node], "$asList");
      root = t1.get$single(t1);
      for (t1 = J.getInterceptor$x(svgFragment); t2 = root.firstChild, t2 != null;)
        t1.append$1(svgFragment, t2);
      return svgFragment;
    },
    get$onClick: function(receiver) {
      return H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(receiver, "click", false), [null]), "$isElementStream", [H.getTypeArgumentByIndex(C.EventStreamProvider_click, 0)], "$asElementStream"), "$isElementStream", [W.MouseEvent], "$asElementStream");
    },
    $isSvgElement: 1,
    $isEventTarget: 1,
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGAltGlyphDefElement|SVGAltGlyphItemElement|SVGComponentTransferFunctionElement|SVGDescElement|SVGDiscardElement|SVGFEDistantLightElement|SVGFEFuncAElement|SVGFEFuncBElement|SVGFEFuncGElement|SVGFEFuncRElement|SVGFEMergeNodeElement|SVGFEPointLightElement|SVGFESpotLightElement|SVGFontElement|SVGFontFaceElement|SVGFontFaceFormatElement|SVGFontFaceNameElement|SVGFontFaceSrcElement|SVGFontFaceUriElement|SVGGlyphElement|SVGHKernElement|SVGMetadataElement|SVGMissingGlyphElement|SVGStopElement|SVGTitleElement|SVGVKernElement;SVGElement"
  },
  SvgSvgElement: {
    "^": "GraphicsElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGSVGElement"
  },
  SymbolElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGSymbolElement"
  },
  TextContentElement: {
    "^": "GraphicsElement;",
    "%": ";SVGTextContentElement"
  },
  TextPathElement: {
    "^": "TextContentElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGTextPathElement"
  },
  TextPositioningElement: {
    "^": "TextContentElement;",
    "%": "SVGTSpanElement|SVGTextElement;SVGTextPositioningElement"
  },
  UseElement: {
    "^": "GraphicsElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGUseElement"
  },
  ViewElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGViewElement"
  },
  _GradientElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGGradientElement|SVGLinearGradientElement|SVGRadialGradientElement"
  },
  _SVGCursorElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGCursorElement"
  },
  _SVGFEDropShadowElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGFEDropShadowElement"
  },
  _SVGGlyphRefElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGGlyphRefElement"
  },
  _SVGMPathElement: {
    "^": "SvgElement;",
    $isInterceptor: 1,
    $isObject: 1,
    "%": "SVGMPathElement"
  }
}],
["dart.dom.web_audio", "dart:web_audio", , P, {
  "^": ""
}],
["dart.dom.web_gl", "dart:web_gl", , P, {
  "^": ""
}],
["dart.dom.web_sql", "dart:web_sql", , P, {
  "^": ""
}],
["dart.isolate", "dart:isolate", , P, {
  "^": "",
  Isolate_spawnUri_closure: {
    "^": "Closure:2;",
    call$1: function(msg) {
      var t1, t2, t3;
      t1 = J.$index$asx(msg, 1);
      t2 = J.$index$asx(msg, 2);
      t3 = J.$index$asx(msg, 3);
      return new P.Isolate(H.interceptedTypeCheck(t1, "$isSendPort"), H.interceptedTypeCheck(t2, "$isCapability"), H.interceptedTypeCheck(t3, "$isCapability"));
    }
  },
  Capability: {
    "^": "Object;"
  },
  Isolate: {
    "^": "Object;controlPort<,pauseCapability,terminateCapability",
    static: {Isolate_spawnUri: function(uri, args, message, packageRoot, paused) {
        var i, e, st, t1, t2, t3, exception, error, stackTrace;
        H.assertSubtype(args, "$isList", [P.String], "$asList");
        try {
          t1 = args;
          t2 = H.checkSubtype(t1, "$isList", [P.String], "$asList");
          if (t2)
            for (i = 0; J.$lt$n(i, J.get$length$asx(args)); i = H.intTypeCheck(J.$add$ns(i, 1))) {
              t1 = J.$index$asx(args, i);
              if (typeof t1 !== "string") {
                t1 = P.ArgumentError$("Args must be a list of Strings " + H.S(args));
                throw H.wrapException(t1);
              }
            }
          else if (args != null) {
            t1 = P.ArgumentError$("Args must be a list of Strings " + H.S(args));
            throw H.wrapException(t1);
          }
          t1 = H.interceptedTypeCheck(uri, "$isUri");
          t2 = H.assertSubtype(args, "$isList", [P.String], "$asList");
          t3 = H.boolTypeCheck(paused);
          $.IsolateNatives_enableSpawnWorker = true;
          t3 = H.assertSubtype(H.assertSubtype(H.IsolateNatives_spawn(null, J.toString$0(t1), t2, message, false, true, t3), "$isFuture", [P.List], "$asFuture").then$1(new P.Isolate_spawnUri_closure()), "$isFuture", [P.Isolate], "$asFuture");
          return t3;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          st = H.getTraceFromException(exception);
          error = e;
          t1 = P.Isolate;
          stackTrace = H.interceptedTypeCheck(st, "$isStackTrace");
          error = error != null ? error : new P.NullThrownError();
          t2 = $.Zone__current;
          if (t2 !== C.C__RootZone)
            t2.toString;
          t2 = H.setRuntimeTypeInfo(new P._Future(0, t2, null), [t1]);
          t2._asyncCompleteError$2(error, stackTrace);
          return H.assertSubtype(H.assertSubtype(t2, "$isFuture", [t1], "$asFuture"), "$isFuture", [P.Isolate], "$asFuture");
        }
      }}
  },
  SendPort: {
    "^": "Object;",
    $isCapability: 1
  }
}],
["dart.math", "dart:math", , P, {
  "^": "",
  _JenkinsSmiHash_combine0: function(hash, value) {
    hash = 536870911 & hash + value;
    hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
    return hash ^ hash >>> 6;
  },
  _JenkinsSmiHash_finish0: function(hash) {
    hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
    hash ^= hash >>> 11;
    return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
  }
}],
["dart.typed_data.implementation", "dart:_native_typed_data", , H, {
  "^": "",
  NativeByteBuffer: {
    "^": "Interceptor;",
    get$runtimeType: function(receiver) {
      return C.Type_wAg;
    },
    $isNativeByteBuffer: 1,
    $isObject: 1,
    "%": "ArrayBuffer"
  },
  NativeTypedData: {
    "^": "Interceptor;",
    _invalidIndex$2: function(receiver, index, $length) {
      if (index < 0 || index >= $length) {
        if (!!this.$isList)
          if ($length === receiver.length)
            throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        throw H.wrapException(P.RangeError$range(index, 0, $length - 1, null, null));
      } else
        throw H.wrapException(P.ArgumentError$("Invalid list index " + index));
    },
    _checkIndex$2: function(receiver, index, $length) {
      if (index >>> 0 !== index || index >= $length)
        this._invalidIndex$2(receiver, index, $length);
    },
    _checkSublistArguments$3: function(receiver, start, end, $length) {
      var t1 = $length + 1;
      this._checkIndex$2(receiver, start, t1);
      this._checkIndex$2(receiver, end, t1);
      if (start > end)
        throw H.wrapException(P.RangeError$range(start, 0, end, null, null));
      return end;
    },
    $isNativeTypedData: 1,
    $isObject: 1,
    "%": ";ArrayBufferView;NativeTypedArray|NativeTypedArray_ListMixin|NativeTypedArray_ListMixin_FixedLengthListMixin|NativeTypedArrayOfDouble|NativeTypedArray_ListMixin0|NativeTypedArray_ListMixin_FixedLengthListMixin0|NativeTypedArrayOfInt"
  },
  NativeByteData: {
    "^": "NativeTypedData;",
    get$runtimeType: function(receiver) {
      return C.Type_oGP;
    },
    $isObject: 1,
    "%": "DataView"
  },
  NativeTypedArray: {
    "^": "NativeTypedData;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $isJavaScriptIndexingBehavior: 1,
    $isJSIndexable: 1
  },
  NativeTypedArrayOfDouble: {
    "^": "NativeTypedArray_ListMixin_FixedLengthListMixin;",
    $index: function(receiver, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      var t1;
      H.numTypeCheck(value);
      t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    }
  },
  NativeTypedArray_ListMixin: {
    "^": "NativeTypedArray+ListMixin;",
    $isList: 1,
    $asList: function() {
      return [P.$double];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [P.$double];
    }
  },
  NativeTypedArray_ListMixin_FixedLengthListMixin: {
    "^": "NativeTypedArray_ListMixin+FixedLengthListMixin;"
  },
  NativeTypedArrayOfInt: {
    "^": "NativeTypedArray_ListMixin_FixedLengthListMixin0;",
    $indexSet: function(receiver, index, value) {
      var t1;
      H.intTypeCheck(value);
      t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    },
    $isList: 1,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [P.$int];
    }
  },
  NativeTypedArray_ListMixin0: {
    "^": "NativeTypedArray+ListMixin;",
    $isList: 1,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [P.$int];
    }
  },
  NativeTypedArray_ListMixin_FixedLengthListMixin0: {
    "^": "NativeTypedArray_ListMixin0+FixedLengthListMixin;"
  },
  NativeFloat32List: {
    "^": "NativeTypedArrayOfDouble;",
    get$runtimeType: function(receiver) {
      return C.Type_Art;
    },
    $isObject: 1,
    $isList: 1,
    $asList: function() {
      return [P.$double];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [P.$double];
    },
    "%": "Float32Array"
  },
  NativeFloat64List: {
    "^": "NativeTypedArrayOfDouble;",
    get$runtimeType: function(receiver) {
      return C.Type_ckn;
    },
    $isObject: 1,
    $isList: 1,
    $asList: function() {
      return [P.$double];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [P.$double];
    },
    "%": "Float64Array"
  },
  NativeInt16List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_UoK;
    },
    $index: function(receiver, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $isObject: 1,
    $isList: 1,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [P.$int];
    },
    "%": "Int16Array"
  },
  NativeInt32List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_dTZ;
    },
    $index: function(receiver, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $isObject: 1,
    $isList: 1,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [P.$int];
    },
    "%": "Int32Array"
  },
  NativeInt8List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_mp3;
    },
    $index: function(receiver, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $isObject: 1,
    $isList: 1,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [P.$int];
    },
    "%": "Int8Array"
  },
  NativeUint16List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_CAk;
    },
    $index: function(receiver, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $isObject: 1,
    $isList: 1,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [P.$int];
    },
    "%": "Uint16Array"
  },
  NativeUint32List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_irB;
    },
    $index: function(receiver, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $isObject: 1,
    $isList: 1,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [P.$int];
    },
    "%": "Uint32Array"
  },
  NativeUint8ClampedList: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_QuW;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $isObject: 1,
    $isList: 1,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [P.$int];
    },
    "%": "CanvasPixelArray|Uint8ClampedArray"
  },
  NativeUint8List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_6L0;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $isNativeUint8List: 1,
    $isUint8List: 1,
    $isObject: 1,
    $isList: 1,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [P.$int];
    },
    "%": ";Uint8Array"
  }
}],
["dart2js._js_primitives", "dart:_js_primitives", , H, {
  "^": "",
  printString: function(string) {
    if (typeof dartPrint == "function") {
      dartPrint(string);
      return;
    }
    if (typeof console == "object" && typeof console.log != "undefined") {
      console.log(string);
      return;
    }
    if (typeof window == "object")
      return;
    if (typeof print == "function") {
      print(string);
      return;
    }
    throw "Unable to print message: " + String(string);
  }
}],
["dom", "package:html5lib/dom.dart", , B, {
  "^": "",
  Node1: {
    "^": "Object;parent,attributes,_elements",
    set$parent: function(_, $parent) {
      this.parent = H.interceptedTypeCheck($parent, "$isNode1");
    },
    set$attributes: function(_, attributes) {
      this.attributes = H.assertSubtype(attributes, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
    },
    set$_elements: function(_elements) {
      this._elements = H.assertSubtype(_elements, "$isList", [B.Element1], "$asList");
    },
    get$children: function(_) {
      if (this._elements == null)
        this.set$_elements(new B.FilteredElementList0(this, H.assertSubtype(this.nodes, "$isList", [B.Node1], "$asList")));
      return H.assertSubtype(this._elements, "$isList", [B.Element1], "$asList");
    },
    get$text: function(_) {
      return;
    },
    set$text: function(_, value) {
    },
    remove$0: function(_) {
      var t1 = this.parent;
      if (t1 != null)
        t1.nodes.remove$1(0, this);
      return this;
    },
    replaceWith$1: function(_, otherNode) {
      var t1;
      H.interceptedTypeCheck(otherNode, "$isNode1");
      t1 = this.parent;
      if (t1 == null)
        throw H.wrapException(P.UnsupportedError$("Node must have a parent to replace it."));
      t1 = t1.nodes;
      H.assertSubtypeOfRuntimeType(this, H.getRuntimeTypeArgument(t1, "ListProxy", 0));
      t1.$indexSet(0, C.JSArray_methods.indexOf$2(t1._list, this, 0), otherNode);
      return this;
    }
  },
  Document0: {
    "^": "Node1;",
    get$nodeType: function(_) {
      return 9;
    },
    toString$0: function(_) {
      return "#document";
    }
  },
  DocumentFragment: {
    "^": "Document0;_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    get$nodeType: function(_) {
      return 11;
    },
    toString$0: function(_) {
      return "#document-fragment";
    },
    get$text: function(_) {
      var t1 = new P.StringBuffer("");
      new B._ConcatTextVisitor(t1).visit$1(this);
      t1 = t1._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    set$text: function(_, value) {
      var t1, t2, t3;
      t1 = this.nodes;
      t1.clear$0(0);
      t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t3 = H.setRuntimeTypeInfo([], [B.Node1]);
      t3 = new B.NodeList(null, H.assertSubtype(t3, "$isList", [B.Node1], "$asList"));
      t2 = new B.Text0(value, null, null, H.assertSubtype(t2, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap"), t3, H.assertSubtype(null, "$isList", [B.Element1], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t3._dom$_parent = t2;
      H.voidTypeCheck(t1.add$1(0, t2));
      return;
    }
  },
  Text0: {
    "^": "Node1;data,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    get$nodeType: function(_) {
      return 3;
    },
    toString$0: function(_) {
      return "\"" + H.S(this.data) + "\"";
    },
    get$text: function(_) {
      return this.data;
    },
    set$text: function(_, value) {
      this.data = value;
    }
  },
  Element1: {
    "^": "Node1;namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    get$localName: function(_) {
      return this._tagName;
    },
    get$nodeType: function(_) {
      return 1;
    },
    toString$0: function(_) {
      var t1 = this.namespaceUri;
      if (t1 == null)
        return "<" + H.S(this._tagName) + ">";
      return "<" + F.Namespaces_getPrefix(t1) + " " + H.S(this._tagName) + ">";
    },
    get$text: function(_) {
      var t1 = new P.StringBuffer("");
      new B._ConcatTextVisitor(t1).visit$1(this);
      t1 = t1._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    set$text: function(_, value) {
      var t1, t2, t3;
      t1 = this.nodes;
      t1.clear$0(0);
      t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t3 = H.setRuntimeTypeInfo([], [B.Node1]);
      t3 = new B.NodeList(null, H.assertSubtype(t3, "$isList", [B.Node1], "$asList"));
      t2 = new B.Text0(value, null, null, H.assertSubtype(t2, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap"), t3, H.assertSubtype(null, "$isList", [B.Element1], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t3._dom$_parent = t2;
      H.voidTypeCheck(t1.add$1(0, t2));
      return;
    },
    get$id: function(_) {
      var result = this.attributes.$index(0, "id");
      return H.stringTypeCheck(result != null ? result : "");
    },
    set$id: function(_, value) {
      var t1 = this.attributes;
      if (value == null)
        t1.remove$1(0, "id");
      else
        t1.$indexSet(0, "id", value);
    }
  },
  NodeList: {
    "^": "ListProxy;_dom$_parent,_list",
    add$1: function(_, value) {
      var t1;
      H.interceptedTypeCheck(value, "$isNode1");
      t1 = J.getInterceptor(value);
      if (!!t1.$isDocumentFragment)
        this.addAll$1(0, value.nodes);
      else {
        t1.remove$0(value);
        value.parent = this._dom$_parent;
        this.super$ListProxy$add$1(this, value);
      }
    },
    addAll$1: function(_, collection) {
      var list, t1, t2, t3, node;
      list = this._flattenDocFragments$1(H.listSuperNativeTypeCheck(collection, "$isIterable"));
      for (t1 = H.getTypeArgumentByIndex(list, 0), H.listSuperNativeTypeCheck(list, "$isIterable"), t1 = H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.ReversedListIterable(H.listSuperNativeTypeCheck(list, "$isIterable")), [t1]), "$isIterable"), t2 = H.getRuntimeTypeArgument(t1, "ListIterable", 0), H.listSuperNativeTypeCheck(t1, "$isIterable"), t3 = t1.get$length(t1), t1 = H.assertSubtype(H.setRuntimeTypeInfo(new H.ListIterator(H.listSuperNativeTypeCheck(t1, "$isIterable"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getRuntimeTypeArgument(t1, "ListIterable", 0)], "$asIterator"); t1.moveNext$0();) {
        node = H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t1.__internal$_current, H.getTypeArgumentByIndex(t1, 0)), "$isNode1");
        t2 = node.parent;
        if (t2 != null)
          t2.nodes.remove$1(0, node);
        node.parent = this._dom$_parent;
      }
      this.super$ListProxy$addAll$1(this, list);
    },
    removeAt$1: function(_, i) {
      var t1 = this.super$ListProxy$removeAt$1(this, i);
      J.set$parent$x(t1, null);
      return t1;
    },
    clear$0: function(_) {
      var t1, t2, t3;
      for (t1 = this._list, t2 = H.getTypeArgumentByIndex(t1, 0), H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3 = t1.length, t1 = H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"), "$isIterator", [H.getRuntimeTypeArgument(this, "ListProxy", 0)], "$asIterator"); t1.moveNext$0();)
        J.set$parent$x(H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0)), null);
      this.super$ListProxy$clear$0(this);
    },
    $indexSet: function(_, index, value) {
      var t1;
      H.interceptedTypeCheck(value, "$isNode1");
      if (value instanceof B.DocumentFragment) {
        J.set$parent$x(this.super$ListProxy$removeAt$1(this, index), null);
        this.insertAll$2(0, index, value.nodes);
      } else {
        t1 = this._list;
        if (index < 0 || index >= t1.length)
          return H.ioore(t1, index);
        J.set$parent$x(H.assertSubtypeOfRuntimeType(t1[index], H.getRuntimeTypeArgument(this, "ListProxy", 0)), null);
        t1 = value.parent;
        if (t1 != null)
          t1.nodes.remove$1(0, value);
        value.parent = this._dom$_parent;
        this.super$ListProxy$$indexSet(this, index, value);
      }
    },
    insertAll$2: function(_, index, collection) {
      var list, t1, t2, t3, node;
      list = this._flattenDocFragments$1(H.listSuperNativeTypeCheck(collection, "$isIterable"));
      for (t1 = H.getTypeArgumentByIndex(list, 0), H.listSuperNativeTypeCheck(list, "$isIterable"), t1 = H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.ReversedListIterable(H.listSuperNativeTypeCheck(list, "$isIterable")), [t1]), "$isIterable"), t2 = H.getRuntimeTypeArgument(t1, "ListIterable", 0), H.listSuperNativeTypeCheck(t1, "$isIterable"), t3 = t1.get$length(t1), t1 = H.assertSubtype(H.setRuntimeTypeInfo(new H.ListIterator(H.listSuperNativeTypeCheck(t1, "$isIterable"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getRuntimeTypeArgument(t1, "ListIterable", 0)], "$asIterator"); t1.moveNext$0();) {
        node = H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t1.__internal$_current, H.getTypeArgumentByIndex(t1, 0)), "$isNode1");
        t2 = node.parent;
        if (t2 != null)
          t2.nodes.remove$1(0, node);
        node.parent = this._dom$_parent;
      }
      this.super$ListProxy$insertAll$2(this, index, list);
    },
    _flattenDocFragments$1: function(collection) {
      var result, t1, t2, t3, node;
      H.listSuperNativeTypeCheck(collection, "$isIterable");
      result = [];
      for (t1 = collection._list, t2 = H.getTypeArgumentByIndex(t1, 0), H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3 = t1.length, t1 = H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"), "$isIterator", [H.getRuntimeTypeArgument(collection, "ListProxy", 0)], "$asIterator"); t1.moveNext$0();) {
        node = H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0));
        if (node instanceof B.DocumentFragment)
          C.JSArray_methods.addAll$1(result, node.nodes);
        else
          C.JSArray_methods.add$1(result, node);
      }
      return result;
    },
    E: function() {
      return H.convertRtiToRuntimeType(function() {
        return B.Node1;
      }.apply(null, this.$builtinTypeInfo));
    },
    $asListProxy: function() {
      return [B.Node1];
    },
    $asIterableBase: function() {
      return [B.Node1];
    },
    $asList: function() {
      return [B.Node1];
    },
    $asIterable: function() {
      return [B.Node1];
    }
  },
  FilteredElementList0: {
    "^": "IterableBase_ListMixin;_dom$_node,_dom$_childNodes",
    get$_dom$_filtered: function() {
      var t1, t2, t3, t4;
      t1 = this._dom$_childNodes;
      t2 = new B.FilteredElementList__filtered_closure0();
      t3 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t3, [t1.E()])._assertCheck$1(t2);
      t4 = H.getRuntimeTypeArgument(t1, "IterableBase", 0);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
      return H.assertSubtype(P.List_List$from(H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), H.buildFunctionType(t3, [H.getDynamicRuntimeType()])._assertCheck$1(t2)), [t4]), "$isIterable"), true, B.Element1), "$isList", [B.Element1], "$asList");
    },
    forEach$1: function(_, f) {
      var t1 = H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(B.Element1)])._assertCheck$1(f);
      C.JSArray_methods.forEach$1(this.get$_dom$_filtered(), t1);
    },
    $indexSet: function(_, index, value) {
      var t1, t2;
      H.interceptedTypeCheck(value, "$isElement1");
      t1 = this.get$_dom$_filtered();
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      t1 = H.interceptedTypeCheck(t1[index], "$isElement1");
      t2 = t1.parent;
      if (t2 == null)
        H.throwExpression(P.UnsupportedError$("Node must have a parent to replace it."));
      t2 = t2.nodes;
      H.assertSubtypeOfRuntimeType(t1, H.getRuntimeTypeArgument(t2, "ListProxy", 0));
      t2.$indexSet(0, C.JSArray_methods.indexOf$2(t2._list, t1, 0), value);
    },
    set$length: function(_, newLength) {
      var len = this.get$_dom$_filtered().length;
      if (newLength >= len)
        return;
      else if (newLength < 0)
        throw H.wrapException(P.ArgumentError$("Invalid list length"));
      this.removeRange$2(0, newLength, len);
    },
    add$1: function(_, value) {
      var t1, t2;
      H.interceptedTypeCheck(value, "$isElement1");
      t1 = this._dom$_childNodes;
      t2 = value.parent;
      if (t2 != null)
        t2.nodes.remove$1(0, value);
      value.parent = t1._dom$_parent;
      t1.super$ListProxy$add$1(t1, value);
    },
    addAll$1: function(_, iterable) {
      var t1, t2, t3, element;
      for (t1 = H.listSuperNativeTypeCheck(iterable, "$isIterable").get$_dom$_filtered(), t2 = H.getTypeArgumentByIndex(t1, 0), H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3 = t1.length, t1 = H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"), "$isIterator", [B.Element1], "$asIterator"), t2 = this._dom$_childNodes; t1.moveNext$0();) {
        element = H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0)), "$isElement1");
        t3 = element.parent;
        if (t3 != null)
          t3.nodes.remove$1(0, element);
        element.parent = t2._dom$_parent;
        t2.super$ListProxy$add$1(t2, element);
      }
    },
    removeRange$2: function(_, start, end) {
      C.JSArray_methods.forEach$1(C.JSArray_methods.sublist$2(this.get$_dom$_filtered(), start, end), new B.FilteredElementList_removeRange_closure0());
    },
    map$1: function(_, f) {
      var t1, t2, t3;
      t1 = H.getDynamicRuntimeType();
      t2 = H.buildFunctionType(t1, [H.buildInterfaceType(B.Element1)])._assertCheck$1(f);
      t3 = this.get$_dom$_filtered();
      H.buildFunctionType(t1, [H.convertRtiToRuntimeType(t3.$builtinTypeInfo && t3.$builtinTypeInfo[0])])._assertCheck$1(t2);
      H.listSuperNativeTypeCheck(t3, "$isIterable");
      t1 = H.buildFunctionType(H.convertRtiToRuntimeType(null), [H.convertRtiToRuntimeType(null)]);
      t1._assertCheck$1(t2);
      return H.setRuntimeTypeInfo(new H.MappedListIterable(H.listSuperNativeTypeCheck(t3, "$isIterable"), t1._assertCheck$1(t2)), [null, null]);
    },
    toSet$0: function(_) {
      return H.assertSubtype(H.assertSubtype(P.LinkedHashSet_LinkedHashSet$from(this, B.Element1), "$isSet", [B.Element1], "$asSet"), "$isSet", [B.Element1], "$asSet");
    },
    elementAt$1: function(_, index) {
      var t1 = this.get$_dom$_filtered();
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      return H.interceptedTypeCheck(t1[index], "$isElement1");
    },
    get$isEmpty: function(_) {
      return this.get$_dom$_filtered().length === 0;
    },
    get$length: function(_) {
      return this.get$_dom$_filtered().length;
    },
    $index: function(_, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = this.get$_dom$_filtered();
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      return H.interceptedTypeCheck(t1[index], "$isElement1");
    },
    get$iterator: function(_) {
      var t1, t2, t3;
      t1 = this.get$_dom$_filtered();
      t2 = H.getTypeArgumentByIndex(t1, 0);
      H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray");
      t3 = t1.length;
      return H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"), "$isIterator", [B.Element1], "$asIterator");
    },
    get$last: function(_) {
      return H.interceptedTypeCheck(C.JSArray_methods.get$last(this.get$_dom$_filtered()), "$isElement1");
    },
    get$single: function(_) {
      return H.interceptedTypeCheck(C.JSArray_methods.get$single(this.get$_dom$_filtered()), "$isElement1");
    },
    E: function() {
      return H.convertRtiToRuntimeType(function() {
        return B.Element1;
      }.apply(null, this.$builtinTypeInfo));
    },
    $isList: 1,
    $asList: function() {
      return [B.Element1];
    },
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [B.Element1];
    }
  },
  IterableBase_ListMixin: {
    "^": "IterableBase+ListMixin;",
    E: function() {
      return H.convertRtiToRuntimeType(function() {
        return B.Element1;
      }.apply(null, this.$builtinTypeInfo));
    },
    $asIterableBase: function() {
      return [B.Element1];
    },
    $asListMixin: function() {
      return [B.Element1];
    },
    $asIterable: function() {
      return [B.Element1];
    },
    $asList: function() {
      return [B.Element1];
    },
    $isList: 1,
    $isEfficientLength: 1,
    $isIterable: 1
  },
  FilteredElementList__filtered_closure0: {
    "^": "Closure:2;",
    call$1: function(n) {
      return n instanceof B.Element1;
    }
  },
  FilteredElementList_removeRange_closure0: {
    "^": "Closure:2;",
    call$1: function(el) {
      return J.remove$0$ax(el);
    }
  },
  _ConcatTextVisitor: {
    "^": "TreeVisitor;_str",
    toString$0: function(_) {
      var t1 = this._str._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    visitText$1: function(node) {
      this._str._contents += H.S(H.interceptedTypeCheck(node, "$isText0").data);
    }
  }
}],
["dom_parsing", "package:html5lib/dom_parsing.dart", , F, {
  "^": "",
  TreeVisitor: {
    "^": "Object;",
    visit$1: function(node) {
      H.interceptedTypeCheck(node, "$isNode1");
      switch (node.get$nodeType(node)) {
        case 1:
          return this.visitChildren$1(H.interceptedTypeCheck(node, "$isElement1"));
        case 3:
          return this.visitText$1(node);
        case 8:
          return this.visitChildren$1(H.interceptedTypeCheck(node, "$isComment"));
        case 11:
          return this.visitChildren$1(H.interceptedTypeCheck(node, "$isDocumentFragment"));
        case 9:
          return this.visitChildren$1(H.interceptedTypeCheck(node, "$isDocument0"));
        case 10:
          return this.visitChildren$1(H.interceptedTypeCheck(node, "$isDocumentType"));
        default:
          throw H.wrapException(P.UnsupportedError$("DOM node type " + node.get$nodeType(node)));
      }
    },
    visitChildren$1: function(node) {
      var t1, t2, t3;
      for (t1 = node.nodes, t1 = H.assertSubtype(P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0)), "$isList", [H.getRuntimeTypeArgument(t1, "IterableBase", 0)], "$asList"), t2 = H.getTypeArgumentByIndex(t1, 0), H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3 = t1.length, t1 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"); t1.moveNext$0();)
        this.visit$1(H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0)));
    },
    visitText$1: function(node) {
      return this.visitChildren$1(H.interceptedTypeCheck(node, "$isText0"));
    }
  }
}],
["egb_form", "package:egamebook/src/shared/form.dart", , G, {
  "^": "",
  FormElement: {
    "^": "Element1;namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    get$disabledOrInsideDisabledParent: function() {
      var t1 = this.parent;
      if (t1 != null && H.interceptedTypeCast(t1, "$isFormElement").get$disabledOrInsideDisabledParent())
        return true;
      return J.$eq(this.attributes.$index(0, "disabled"), "true");
    },
    updateFromMap$1: ["super$FormElement$updateFromMap$1", function(map) {
      var t1, t2, t3;
      H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
      t1 = J.getInterceptor$asx(map);
      t2 = H.boolTypeCheck(t1.$index(map, "hidden"));
      t3 = this.attributes;
      t3.$indexSet(0, "hidden", H.boolConversionCheck(t2) ? "true" : "false");
      t1 = H.boolTypeCheck(t1.$index(map, "disabled"));
      t3 = this.attributes;
      t3.$indexSet(0, "disabled", H.boolConversionCheck(t1) ? "true" : "false");
    }],
    _addFormChildrenToSet$2: function(element, set) {
      var t1, t2, t3, child;
      H.assertSubtype(set, "$isSet", [G.FormElement], "$asSet");
      t1 = element.get$formElementChildren();
      t2 = H.getTypeArgumentByIndex(t1, 0);
      H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray");
      t3 = t1.length;
      t3 = new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2));
      H.assertHelper(true);
      t3.$builtinTypeInfo = [t2];
      H.assertSubtype(t3, "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator");
      for (; t3.moveNext$0();) {
        child = H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t3._current, H.getTypeArgumentByIndex(t3, 0)), "$isFormElement");
        set.add$1(0, child);
        this._addFormChildrenToSet$2(child, set);
      }
    },
    get$formElementChildren: function() {
      var result, t1, t2, t3, t4, t5, t6;
      result = H.assertSubtype(H.setRuntimeTypeInfo([], [G.FormElement]), "$isList", [G.FormElement], "$asList");
      for (t1 = this.get$children(this), t2 = new G.FormElement_formElementChildren_closure(), t1.toString, t3 = H.buildInterfaceType(P.bool), H.buildFunctionType(t3, [H.buildInterfaceType(B.Element1)])._assertCheck$1(t2), t1 = t1.get$_dom$_filtered(), H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t1.$builtinTypeInfo && t1.$builtinTypeInfo[0])])._assertCheck$1(t2), t4 = H.getTypeArgumentByIndex(t1, 0), H.listSuperNativeTypeCheck(t1, "$isIterable"), H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2), t5 = H.buildFunctionType(t3, [H.getDynamicRuntimeType()]), t1 = H.listSuperNativeTypeCheck(H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), t5._assertCheck$1(t2)), [t4]), "$isIterable"), "$isIterable"), t4 = J.get$iterator$ax(t1.__internal$_iterable), t2 = t1._f, t6 = H.getTypeArgumentByIndex(t1, 0), H.assertSubtype(t4, "$isIterator", [t6], "$asIterator"), H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t6)])._assertCheck$1(t2), t1 = H.assertSubtype(H.setRuntimeTypeInfo(new H.WhereIterator(H.assertSubtype(t4, "$isIterator", [t6], "$asIterator"), t5._assertCheck$1(t2)), [t6]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"), t6 = t1._iterator; t1.moveNext$0();)
        C.JSArray_methods.add$1(result, H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t6.get$current(), H.getTypeArgumentByIndex(t1, 0)), "$isFormElement"));
      return H.listSuperNativeTypeCheck(result, "$isIterable");
    },
    get$allFormElementsBelowThisOne: function() {
      var set = H.assertSubtype(H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, G.FormElement), "$isSet", [G.FormElement], "$asSet"), "$isSet", [G.FormElement], "$asSet");
      this._addFormChildrenToSet$2(this, set);
      return H.assertSubtype(set, "$isSet", [G.FormElement], "$asSet");
    },
    $isUpdatableByMap: 1
  },
  FormElement_formElementChildren_closure: {
    "^": "Closure:24;",
    call$1: function(child) {
      return H.interceptedTypeCheck(child, "$isElement1") instanceof G.FormElement;
    }
  },
  FormBase: {
    "^": "FormElement;"
  },
  FormConfiguration: {
    "^": "Object;_valuesMap"
  },
  CurrentState: {
    "^": "Object;_valuesMap",
    toString$0: function(_) {
      return "<CurrentState submitted=" + H.S(H.boolTypeCheck(this._valuesMap.$index(0, "__submitted__"))) + ">";
    }
  },
  FormSection: {
    "^": "FormElement;",
    get$name: function(_) {
      return H.stringTypeCheck(this.attributes.$index(0, "name"));
    }
  },
  Output: {
    "^": "Object;"
  },
  SubmitButtonBase: {
    "^": "FormElement;",
    get$name: function(_) {
      return H.stringTypeCheck(this.attributes.$index(0, "name"));
    },
    updateFromMap$1: function(map) {
      var t1;
      H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
      this.super$FormElement$updateFromMap$1(map);
      t1 = H.stringTypeCheck(J.$index$asx(map, "name"));
      this.attributes.$indexSet(0, "name", t1);
    }
  },
  CheckboxBase: {
    "^": "FormElement;",
    get$name: function(_) {
      return H.stringTypeCheck(this.attributes.$index(0, "name"));
    },
    updateFromMap$1: function(map) {
      H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
      this.super$FormElement$updateFromMap$1(map);
      this.current = H.boolTypeCheck(J.$index$asx(map, "current"));
    }
  },
  CheckboxInputBase: {
    "^": "CheckboxBase;",
    $isInput: 1,
    $asInput: function() {
      return [P.bool];
    }
  },
  RangeBase: {
    "^": "FormElement;",
    get$name: function(_) {
      return H.stringTypeCheck(this.attributes.$index(0, "name"));
    },
    updateFromMap$1: ["super$RangeBase$updateFromMap$1", function(map) {
      var t1;
      H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
      this.super$FormElement$updateFromMap$1(map);
      t1 = J.getInterceptor$asx(map);
      this.min = H.intTypeCheck(t1.$index(map, "min"));
      this.max = H.intTypeCheck(t1.$index(map, "max"));
      this.step = H.intTypeCheck(t1.$index(map, "step"));
      this.minEnabled = H.intTypeCheck(t1.$index(map, "minEnabled"));
      this.maxEnabled = H.intTypeCheck(t1.$index(map, "maxEnabled"));
      this.current = H.intTypeCheck(t1.$index(map, "current"));
    }]
  },
  RangeInputBase: {
    "^": "RangeBase;",
    $isInput: 1,
    $asInput: function() {
      return [P.$int];
    }
  },
  RangeOutputBase: {
    "^": "RangeBase;"
  },
  TextBase: {
    "^": "FormElement;",
    updateFromMap$1: function(map) {
      H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
      this.super$FormElement$updateFromMap$1(map);
      this.html = H.stringTypeCheck(J.$index$asx(map, "html"));
    }
  },
  TextOutputBase: {
    "^": "TextBase_Output;"
  },
  TextBase_Output: {
    "^": "TextBase+Output;"
  },
  MultipleChoiceInputBase: {
    "^": "FormElement;",
    get$name: function(_) {
      return H.stringTypeCheck(this.attributes.$index(0, "name"));
    }
  },
  OptionBase: {
    "^": "FormElement;",
    get$text: function(_) {
      return H.stringTypeCheck(this.attributes.$index(0, "text"));
    },
    set$text: function(_, value) {
      H.stringTypeCheck(value);
      this.attributes.$indexSet(0, "text", value);
      return value;
    },
    updateFromMap$1: function(map) {
      var t1, t2;
      H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
      this.super$FormElement$updateFromMap$1(map);
      t1 = J.getInterceptor$asx(map);
      t2 = H.stringTypeCheck(t1.$index(map, "text"));
      this.attributes.$indexSet(0, "text", t2);
      this.current = H.boolTypeCheck(t1.$index(map, "current"));
    },
    OptionBase$3$helpMessage$selected: function(text, helpMessage, selected) {
      this.attributes.$indexSet(0, "text", text);
      this.current = selected;
      this.attributes.$indexSet(0, "helpMessage", helpMessage);
    },
    $isInput: 1,
    $asInput: function() {
      return [P.bool];
    }
  }
}],
["egb_form_proxy", "package:egamebook/src/presenter/form_proxy.dart", , Q, {
  "^": "",
  _getAttributesFromJsonML: function(jsonObject) {
    return H.assertSubtype(H.subtypeCast(J.$index$asx(jsonObject, 1), "$isMap", [P.String, P.Object], "$asMap"), "$isMap", [P.String, P.Object], "$asMap");
  },
  FormProxy: {
    "^": "FormBase;uiElement<,_onChangeSubscriptions,_streamController,namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    set$uiElement: function(uiElement) {
      this.uiElement = H.interceptedTypeCheck(uiElement, "$isUiElement");
    },
    _recursiveCreateUiElement$2: function(builders, element) {
      var t1, uiElement, t2, t3;
      H.assertSubtype(builders, "$isMap", [P.String, {func: "", ret: Q.UiElement, args: [G.FormElement]}], "$asMap");
      t1 = element._tagName;
      if (!builders.containsKey$1(0, t1))
        throw H.wrapException(P.UnimplementedError$("The tag '" + H.S(element.get$localName(element)) + "' is not among the implemented presenter builders (" + builders.get$keys(builders).join$1(0, ", ") + ")."));
      uiElement = H.interceptedTypeCheck(builders.$index(0, t1).call$1(element), "$isUiElement");
      element.set$uiElement(uiElement);
      if (uiElement.get$onChange(uiElement) != null)
        this._onChangeSubscriptions.add$1(0, uiElement.get$onChange(uiElement).listen$1(new Q.FormProxy__recursiveCreateUiElement_closure(this, element)));
      t1 = element.get$formElementChildren();
      t2 = H.getTypeArgumentByIndex(t1, 0);
      H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray");
      t3 = t1.length;
      t3 = new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2));
      H.assertHelper(true);
      t3.$builtinTypeInfo = [t2];
      H.assertSubtype(t3, "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator");
      for (; t3.moveNext$0();)
        uiElement.appendChild$1(this._recursiveCreateUiElement$2(builders, H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t3._current, H.getTypeArgumentByIndex(t3, 0)), "$isBlueprintWithUiRepresentation")).get$uiRepresentation());
      return uiElement;
    },
    update$2$unsetWaitingForUpdate: function(config, unsetWaitingForUpdate) {
      var t1, t2, t3, t4, t5;
      t1 = this.get$allFormElementsBelowThisOne();
      t2 = new Q.FormProxy_update_closure();
      t3 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t3, [t1.E1()])._assertCheck$1(t2);
      t4 = H.getTypeArgumentByIndex(t1, 0);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
      t5 = H.buildFunctionType(t3, [H.getDynamicRuntimeType()]);
      H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), t5._assertCheck$1(t2)), [t4]), "$isIterable").forEach$1(0, new Q.FormProxy_update_closure0(config));
      if (unsetWaitingForUpdate) {
        t1 = this.get$allFormElementsBelowThisOne();
        t2 = new Q.FormProxy_update_closure1();
        H.buildFunctionType(t3, [t1.E1()])._assertCheck$1(t2);
        t4 = H.getTypeArgumentByIndex(t1, 0);
        H.listSuperNativeTypeCheck(t1, "$isIterable");
        H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
        H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), t5._assertCheck$1(t2)), [t4]), "$isIterable").forEach$1(0, new Q.FormProxy_update_closure2());
      }
    },
    update$1: function(config) {
      return this.update$2$unsetWaitingForUpdate(config, true);
    },
    _createCurrentState$2: function(elementTouched, setWaitingForUpdate) {
      var t1, state, t2, t3, t4, t5;
      t1 = H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.Object), "$isMap", [P.String, P.Object], "$asMap"), "$isMap", [P.String, P.Object], "$asMap");
      state = new G.CurrentState(t1);
      t1.$indexSet(0, "__submitted__", false);
      t2 = this.get$allFormElementsBelowThisOne();
      t3 = new Q.FormProxy__createCurrentState_closure();
      t4 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t4, [t2.E1()])._assertCheck$1(t3);
      t5 = H.getTypeArgumentByIndex(t2, 0);
      H.listSuperNativeTypeCheck(t2, "$isIterable");
      H.buildFunctionType(t4, [H.convertRtiToRuntimeType(t5)])._assertCheck$1(t3);
      H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t2, "$isIterable"), H.buildFunctionType(t4, [H.getDynamicRuntimeType()])._assertCheck$1(t3)), [t5]), "$isIterable").forEach$1(0, new Q.FormProxy__createCurrentState_closure0(setWaitingForUpdate, state));
      if (setWaitingForUpdate)
        this.uiElement.set$waitingForUpdate(true);
      t1.$indexSet(0, "__submitted__", !!elementTouched.$isSubmitButtonBase || !!elementTouched.$isFormBase);
      if (H.boolTypeCheck(t1.$index(0, "__submitted__"))) {
        this.uiElement.set$disabled(0, true);
        t1.$indexSet(0, "__submitterId__", elementTouched.get$id(elementTouched));
        this._cancelSubscriptions$0();
      }
      return state;
    },
    _createCurrentState$1: function(elementTouched) {
      return this._createCurrentState$2(elementTouched, true);
    },
    _cancelSubscriptions$0: function() {
      this._onChangeSubscriptions.forEach$1(0, new Q.FormProxy__cancelSubscriptions_closure());
    },
    FormProxy$fromMap$1: function(map) {
      var t1, t2, t3, node;
      H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
      t1 = J.getInterceptor$asx(map);
      H.assertHelper(J.$eq(J.$index$asx(H.listTypeCast(t1.$index(map, "jsonml")), 0), "Form"));
      t2 = H.stringTypeCheck(J.$index$asx(J.$index$asx(H.listTypeCast(t1.$index(map, "jsonml")), 1), "submitText"));
      this.attributes.$indexSet(0, "submitText", t2);
      t2 = H.assertSubtype(t1.$index(map, "jsonml"), "$isList", [P.Object], "$asList");
      t3 = $.get$customTagHandlers();
      H.assertSubtype(t3, "$isMap", [P.String, {func: "", ret: B.Node1, args: [P.Object]}], "$asMap");
      node = H.interceptedTypeCheck(N._createNode(t2, false, t3, false, true), "$isPresenterForm");
      this.set$id(0, node.get$id(node));
      this.get$children(this).addAll$1(0, node.get$children(node));
      t1 = H.assertSubtype(H.assertSubtype(t1.$index(map, "values"), "$isMap", [P.String, [P.Map, P.String, P.Object]], "$asMap"), "$isMap", [P.String, [P.Map, P.String, P.Object]], "$asMap");
      this.get$allFormElementsBelowThisOne().forEach$1(0, new Q.FormProxy$fromMap_closure(new G.FormConfiguration(t1)));
    },
    $isBlueprintWithUiRepresentation: 1,
    $isUpdatableByMap: 1
  },
  FormProxy$fromMap_closure: {
    "^": "Closure:25;_captured_values_0",
    call$1: function(element) {
      var elementValues;
      H.interceptedTypeCheck(element, "$isFormElement");
      elementValues = H.assertSubtype(H.assertSubtype(J.$index$asx(this._captured_values_0._valuesMap, element.get$id(element)), "$isMap", [P.String, P.Object], "$asMap"), "$isMap", [P.String, P.Object], "$asMap");
      if (elementValues != null)
        element.updateFromMap$1(elementValues);
    }
  },
  FormProxy__recursiveCreateUiElement_closure: {
    "^": "Closure:2;_egb_form_proxy$_captured_this_0,_captured_element_1",
    call$1: function(_) {
      var t1, state;
      t1 = this._egb_form_proxy$_captured_this_0;
      state = t1._createCurrentState$1(this._captured_element_1);
      t1 = t1._streamController;
      H.assertSubtypeOfRuntimeType(state, H.getRuntimeTypeArgument(t1, "_StreamController", 0));
      if (t1._state >= 4)
        H.throwExpression(t1._badEventState$0());
      t1._async$_add$1(state);
    }
  },
  FormProxy_update_closure: {
    "^": "Closure:2;",
    call$1: function(element) {
      return !!J.getInterceptor(element).$isUpdatableByMap;
    }
  },
  FormProxy_update_closure0: {
    "^": "Closure:25;_captured_config_0",
    call$1: function(element) {
      var map;
      H.interceptedTypeCheck(element, "$isFormElement");
      map = H.assertSubtype(H.assertSubtype(J.$index$asx(this._captured_config_0._valuesMap, element.get$id(element)), "$isMap", [P.String, P.Object], "$asMap"), "$isMap", [P.String, P.Object], "$asMap");
      if (map != null) {
        element.updateFromMap$1(map);
        H.interceptedTypeCast(element, "$isBlueprintWithUiRepresentation").get$uiElement().update$0();
      }
    }
  },
  FormProxy_update_closure1: {
    "^": "Closure:2;",
    call$1: function(element) {
      return !!J.getInterceptor(element).$isInput;
    }
  },
  FormProxy_update_closure2: {
    "^": "Closure:2;",
    call$1: function(element) {
      H.interceptedTypeCast(element, "$isBlueprintWithUiRepresentation").get$uiElement().set$waitingForUpdate(false);
    }
  },
  FormProxy__createCurrentState_closure: {
    "^": "Closure:2;",
    call$1: function(element) {
      return !!J.getInterceptor(element).$isInput;
    }
  },
  FormProxy__createCurrentState_closure0: {
    "^": "Closure:2;_captured_setWaitingForUpdate_0,_captured_state_1",
    call$1: function(element) {
      var t1, t2;
      t1 = J.get$id$x(element);
      H.interceptedTypeCast(element, "$isBlueprintWithUiRepresentation");
      t2 = element.get$uiElement().get$current();
      this._captured_state_1._valuesMap.$indexSet(0, H.stringTypeCheck(t1), t2);
      if (this._captured_setWaitingForUpdate_0)
        element.get$uiElement().set$waitingForUpdate(true);
    }
  },
  FormProxy__cancelSubscriptions_closure: {
    "^": "Closure:26;",
    call$1: function(s) {
      return H.interceptedTypeCheck(s, "$isStreamSubscription").cancel$0();
    }
  },
  UiElement: {
    "^": "Object;waitingForUpdate",
    set$waitingForUpdate: function(waitingForUpdate) {
      this.waitingForUpdate = H.boolTypeCheck(waitingForUpdate);
    },
    update$0: ["super$UiElement$update$0", function() {
      this.set$waitingForUpdate(false);
      var t1 = this._blueprint;
      this.set$disabled(0, t1.get$disabledOrInsideDisabledParent());
      this.set$hidden(0, J.$eq(t1.attributes.$index(0, "hidden"), "true"));
    }]
  },
  closure9: {
    "^": "Closure:27;",
    call$1: function(jsonObject) {
      var t1, t2, t3;
      t1 = H.stringTypeCheck(J.$index$asx(Q._getAttributesFromJsonML(jsonObject), "id"));
      t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t3 = H.setRuntimeTypeInfo([], [B.Node1]);
      t3 = new B.NodeList(null, H.assertSubtype(t3, "$isList", [B.Node1], "$asList"));
      t2 = new Q.PresenterForm(null, "Form", null, H.assertSubtype(t2, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap"), t3, H.assertSubtype(null, "$isList", [B.Element1], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t3._dom$_parent = t2;
      t2.set$id(0, t1);
      return t2;
    }
  },
  closure10: {
    "^": "Closure:27;",
    call$1: function(jsonObject) {
      var attributes, t1, t2, t3, t4, t5;
      attributes = Q._getAttributesFromJsonML(jsonObject);
      t1 = J.getInterceptor$asx(attributes);
      t2 = t1.$index(attributes, "name");
      t1 = t1.$index(attributes, "id");
      H.stringTypeCheck(t2);
      H.stringTypeCheck(t1);
      t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t4 = H.setRuntimeTypeInfo([], [B.Node1]);
      t4 = new B.NodeList(null, H.assertSubtype(t4, "$isList", [B.Node1], "$asList"));
      H.assertSubtype(t3, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      t5 = new Q.PresenterFormSection(null, null, "FormSection", null, t3, t4, H.assertSubtype(null, "$isList", [B.Element1], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t4._dom$_parent = t5;
      t3.$indexSet(0, "name", t2);
      t5.set$id(0, t1);
      return t5;
    }
  },
  closure11: {
    "^": "Closure:27;",
    call$1: function(jsonObject) {
      var attributes, t1, t2, t3, t4, t5;
      attributes = Q._getAttributesFromJsonML(jsonObject);
      t1 = J.getInterceptor$asx(attributes);
      t2 = t1.$index(attributes, "name");
      t1 = t1.$index(attributes, "id");
      H.stringTypeCheck(t2);
      H.stringTypeCheck(t1);
      t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t4 = H.setRuntimeTypeInfo([], [B.Node1]);
      t4 = new B.NodeList(null, H.assertSubtype(t4, "$isList", [B.Node1], "$asList"));
      H.assertSubtype(t3, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      t5 = new Q.PresenterSubmitButton(null, null, "SubmitButton", null, t3, t4, H.assertSubtype(null, "$isList", [B.Element1], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t4._dom$_parent = t5;
      t3.$indexSet(0, "name", t2);
      t5.attributes.$indexSet(0, "helpMessage", null);
      t5.set$id(0, t1);
      return t5;
    }
  },
  closure12: {
    "^": "Closure:27;",
    call$1: function(jsonObject) {
      var attributes, t1, t2, t3, t4, t5;
      attributes = Q._getAttributesFromJsonML(jsonObject);
      t1 = J.getInterceptor$asx(attributes);
      t2 = t1.$index(attributes, "name");
      t1 = t1.$index(attributes, "id");
      H.stringTypeCheck(t2);
      H.stringTypeCheck(t1);
      t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t4 = H.setRuntimeTypeInfo([], [B.Node1]);
      t4 = new B.NodeList(null, H.assertSubtype(t4, "$isList", [B.Node1], "$asList"));
      H.assertSubtype(t3, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      t5 = new Q.PresenterCheckboxInput(null, null, null, "CheckboxInput", null, t3, t4, H.assertSubtype(null, "$isList", [B.Element1], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t4._dom$_parent = t5;
      t3.$indexSet(0, "name", t2);
      t5.set$id(0, t1);
      return t5;
    }
  },
  closure13: {
    "^": "Closure:27;",
    call$1: function(jsonObject) {
      var attributes, t1, t2, t3, t4, t5;
      attributes = Q._getAttributesFromJsonML(jsonObject);
      t1 = J.getInterceptor$asx(attributes);
      t2 = t1.$index(attributes, "name");
      t1 = t1.$index(attributes, "id");
      H.stringTypeCheck(t2);
      H.stringTypeCheck(t1);
      t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t4 = H.setRuntimeTypeInfo([], [B.Node1]);
      t4 = new B.NodeList(null, H.assertSubtype(t4, "$isList", [B.Node1], "$asList"));
      H.assertSubtype(t3, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      t5 = new Q.PresenterRangeInput(null, null, 0, 0, 10, 1, null, null, null, "RangeInput", null, t3, t4, H.assertSubtype(null, "$isList", [B.Element1], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t4._dom$_parent = t5;
      t3.$indexSet(0, "name", t2);
      t5.set$id(0, t1);
      return t5;
    }
  },
  closure14: {
    "^": "Closure:27;",
    call$1: function(jsonObject) {
      var attributes, t1, t2, t3, t4, t5;
      attributes = Q._getAttributesFromJsonML(jsonObject);
      t1 = J.getInterceptor$asx(attributes);
      t2 = t1.$index(attributes, "name");
      t1 = t1.$index(attributes, "id");
      H.stringTypeCheck(t2);
      H.stringTypeCheck(t1);
      t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t4 = H.setRuntimeTypeInfo([], [B.Node1]);
      t4 = new B.NodeList(null, H.assertSubtype(t4, "$isList", [B.Node1], "$asList"));
      H.assertSubtype(t3, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      t5 = new Q.PresenterRangeOutput(null, null, 0, 0, 10, 1, null, null, null, "RangeOutput", null, t3, t4, H.assertSubtype(null, "$isList", [B.Element1], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t4._dom$_parent = t5;
      t3.$indexSet(0, "name", t2);
      t5.set$id(0, t1);
      return t5;
    }
  },
  closure15: {
    "^": "Closure:27;",
    call$1: function(jsonObject) {
      var t1, t2, t3;
      t1 = H.stringTypeCheck(J.$index$asx(Q._getAttributesFromJsonML(jsonObject), "id"));
      t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t3 = H.setRuntimeTypeInfo([], [B.Node1]);
      t3 = new B.NodeList(null, H.assertSubtype(t3, "$isList", [B.Node1], "$asList"));
      t2 = new Q.PresenterTextOutput(null, null, null, null, "TextOutput", null, H.assertSubtype(t2, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap"), t3, H.assertSubtype(null, "$isList", [B.Element1], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t3._dom$_parent = t2;
      t2.set$id(0, t1);
      return t2;
    }
  },
  closure16: {
    "^": "Closure:27;",
    call$1: function(jsonObject) {
      var attributes, t1, t2, t3, t4, t5;
      attributes = Q._getAttributesFromJsonML(jsonObject);
      t1 = J.getInterceptor$asx(attributes);
      t2 = t1.$index(attributes, "name");
      t1 = t1.$index(attributes, "id");
      H.stringTypeCheck(t2);
      H.stringTypeCheck(t1);
      t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t4 = H.setRuntimeTypeInfo([], [B.Node1]);
      t4 = new B.NodeList(null, H.assertSubtype(t4, "$isList", [B.Node1], "$asList"));
      H.assertSubtype(t3, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap");
      t5 = new Q.PresenterMultipleChoiceInput(null, null, "MultipleChoiceInput", null, t3, t4, H.assertSubtype(null, "$isList", [B.Element1], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t4._dom$_parent = t5;
      t3.$indexSet(0, "name", t2);
      t5.set$id(0, t1);
      return t5;
    }
  },
  closure17: {
    "^": "Closure:27;",
    call$1: function(jsonObject) {
      var attributes, t1, t2, t3, t4, t5;
      attributes = Q._getAttributesFromJsonML(jsonObject);
      t1 = J.getInterceptor$asx(attributes);
      t2 = t1.$index(attributes, "text");
      t3 = J.$eq(t1.$index(attributes, "selected"), "true");
      t1 = t1.$index(attributes, "id");
      H.stringTypeCheck(t2);
      H.stringTypeCheck(t1);
      t4 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t5 = H.setRuntimeTypeInfo([], [B.Node1]);
      t5 = new B.NodeList(null, H.assertSubtype(t5, "$isList", [B.Node1], "$asList"));
      t4 = new Q.PresenterOption(null, false, null, "Option", null, H.assertSubtype(t4, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap"), t5, H.assertSubtype(null, "$isList", [B.Element1], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t5._dom$_parent = t4;
      t4.OptionBase$3$helpMessage$selected(t2, null, t3);
      t4.set$id(0, t1);
      return t4;
    }
  },
  PresenterForm: {
    "^": "FormBase;namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans"
  },
  PresenterFormSection: {
    "^": "FormSection;uiElement<,namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    set$uiElement: function(uiElement) {
      this.uiElement = H.interceptedTypeCheck(uiElement, "$isUiElement");
    },
    $isBlueprintWithUiRepresentation: 1,
    $isUpdatableByMap: 1
  },
  PresenterSubmitButton: {
    "^": "SubmitButtonBase;uiElement<,namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    set$uiElement: function(uiElement) {
      this.uiElement = H.interceptedTypeCheck(uiElement, "$isUiElement");
    },
    $isBlueprintWithUiRepresentation: 1,
    $isUpdatableByMap: 1
  },
  PresenterCheckboxInput: {
    "^": "CheckboxInputBase;uiElement<,current,namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    set$uiElement: function(uiElement) {
      this.uiElement = H.interceptedTypeCheck(uiElement, "$isUiElement");
    },
    $isBlueprintWithUiRepresentation: 1,
    $isUpdatableByMap: 1
  },
  PresenterRangeInput: {
    "^": "RangeInputBase;currentStringRepresentation<,uiElement<,current,min,max,step,minEnabled,maxEnabled,namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    set$uiElement: function(uiElement) {
      this.uiElement = H.interceptedTypeCheck(uiElement, "$isUiElement");
    },
    updateFromMap$1: function(map) {
      H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
      this.super$RangeBase$updateFromMap$1(map);
      this.currentStringRepresentation = H.stringTypeCheck(J.$index$asx(map, "__string__"));
    },
    $isBlueprintWithUiRepresentation: 1,
    $isUpdatableByMap: 1
  },
  PresenterRangeOutput: {
    "^": "RangeOutputBase;currentStringRepresentation<,uiElement<,current,min,max,step,minEnabled,maxEnabled,namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    set$uiElement: function(uiElement) {
      this.uiElement = H.interceptedTypeCheck(uiElement, "$isUiElement");
    },
    updateFromMap$1: function(map) {
      H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
      this.super$RangeBase$updateFromMap$1(map);
      this.currentStringRepresentation = H.stringTypeCheck(J.$index$asx(map, "__string__"));
    },
    $isBlueprintWithUiRepresentation: 1,
    $isUpdatableByMap: 1
  },
  PresenterTextOutput: {
    "^": "TextOutputBase;uiElement<,Output_current,html,namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    set$uiElement: function(uiElement) {
      this.uiElement = H.interceptedTypeCheck(uiElement, "$isUiElement");
    },
    $isBlueprintWithUiRepresentation: 1,
    $isUpdatableByMap: 1
  },
  PresenterMultipleChoiceInput: {
    "^": "MultipleChoiceInputBase;uiElement<,namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    set$uiElement: function(uiElement) {
      this.uiElement = H.interceptedTypeCheck(uiElement, "$isUiElement");
    },
    $isBlueprintWithUiRepresentation: 1,
    $isUpdatableByMap: 1
  },
  PresenterOption: {
    "^": "OptionBase;uiElement<,current,namespaceUri,_tagName,parent,attributes,nodes,_elements,sourceSpan,_attributeSpans,_attributeValueSpans",
    set$uiElement: function(uiElement) {
      this.uiElement = H.interceptedTypeCheck(uiElement, "$isUiElement");
    },
    $isBlueprintWithUiRepresentation: 1,
    $isUpdatableByMap: 1
  }
}],
["egb_message", "package:egamebook/src/shared/message.dart", , A, {
  "^": "",
  EgbMessage: {
    "^": "Object;type,listContent,strContent,intContent,mapContent",
    set$mapContent: function(mapContent) {
      this.mapContent = H.assertSubtype(mapContent, "$isMap", [P.String, P.Object], "$asMap");
    },
    get$typeString: function() {
      var t1 = this.type;
      switch (t1) {
        case 10:
          return "SEND_BOOK_UID";
        case 20:
          return "NO_RESULT";
        case 30:
          return "TEXT_RESULT";
        case 40:
          return "SHOW_CHOICES";
        case 50:
          return "SAVE_GAME";
        case 60:
          return "SAVE_PLAYER_CHRONOLOGY";
        case 70:
          return "POINTS_AWARD";
        case 80:
          return "END_OF_BOOK";
        case 90:
          return "SET_STATS";
        case 100:
          return "UPDATE_STATS";
        case 110:
          return "SHOW_FORM";
        case 120:
          return "UPDATE_FORM";
        case 666:
          return "SCRIPTER_ERROR";
        case 667:
          return "SCRIPTER_LOG";
        case 1000:
          return "REQUEST_BOOK_UID";
        case 1010:
          return "START";
        case 1020:
          return "LOAD_GAME";
        case 1040:
          return "PROCEED";
        case 1050:
          return "CHOICE_SELECTED";
        case 1060:
          return "FORM_INPUT";
        case 1070:
          return "QUIT";
        default:
          return "Unknown type=" + H.S(t1);
      }
    },
    toString$0: function(_) {
      var t1, t2;
      t1 = "EgbMessage " + this.get$typeString();
      t2 = this.type;
      return t1 + (t2 === 50 || t2 === 60 || t2 === 90 || t2 === 100 || t2 === 666 || t2 === 667 ? " (async)" : "");
    },
    toJson$0: function() {
      return C.JsonCodec_null_null.encode$1(this.toMap$0());
    },
    toMap$0: function() {
      var map, t1;
      map = H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.Object), "$isMap", [P.String, P.Object], "$asMap"), "$isMap", [P.String, P.Object], "$asMap");
      map.$indexSet(0, "type", this.type);
      t1 = this.strContent;
      if (t1 != null)
        map.$indexSet(0, "strContent", t1);
      t1 = this.listContent;
      if (t1 != null)
        map.$indexSet(0, "listContent", t1);
      t1 = this.intContent;
      if (t1 != null)
        map.$indexSet(0, "intContent", t1);
      t1 = this.mapContent;
      if (t1 != null)
        map.$indexSet(0, "mapContent", t1);
      return H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
    }
  }
}],
["egb_player_profile", "package:egamebook/src/persistence/player_profile.dart", , V, {
  "^": "",
  EgbPlayerProfile: {
    "^": "Object;playerUid,currentEgamebookUid,preferences,storyChronology,_storage,_maxSaves",
    set$preferences: function(preferences) {
      this.preferences = H.assertSubtype(preferences, "$isMap", [P.String, null], "$asMap");
    },
    set$storyChronology: function(storyChronology) {
      this.storyChronology = H.assertSubtype(storyChronology, "$isQueue", [P.String], "$asQueue");
    },
    _loadPreferences$0: function() {
      var completer = H.assertSubtype(H.setRuntimeTypeInfo(new P._AsyncCompleter(H.assertSubtype(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]), "$is_Future", [null], "$as_Future")), [null]), "$isCompleter", [null], "$asCompleter");
      this._storage.load$1(0, this.playerUid + "::prefs").then$1(new V.EgbPlayerProfile__loadPreferences_closure(this, completer));
      return H.assertSubtype(completer.future, "$isFuture", [P.bool], "$asFuture");
    },
    _save$2: function(key, value) {
      var t1, t2;
      t1 = this.currentEgamebookUid;
      if (t1 == null)
        throw H.wrapException("currentEgamebookUid not set");
      t1 = this.playerUid + "::" + H.S(t1) + "::" + H.S(key);
      t2 = window.localStorage;
      (t2 && C.Storage_methods)._setItem$2(t2, t1, value);
      t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
      t1._asyncComplete$1(true);
      return H.assertSubtype(H.assertSubtype(H.assertSubtype(t1, "$isFuture", [null], "$asFuture"), "$isFuture", [P.bool], "$asFuture"), "$isFuture", [P.bool], "$asFuture");
    },
    _load$1: function(key) {
      var t1 = this.currentEgamebookUid;
      if (t1 == null)
        throw H.wrapException("currentEgamebookUid not set");
      return H.assertSubtype(this._storage.load$1(0, this.playerUid + "::" + H.S(t1) + "::" + H.S(key)), "$isFuture", [P.String], "$asFuture");
    },
    _loadStoryChronology$0: function() {
      return H.assertSubtype(this._load$1("_storyChronology").then$1(new V.EgbPlayerProfile__loadStoryChronology_closure(this)), "$isFuture", [P.bool], "$asFuture");
    },
    loadPlayerChronology$0: function() {
      return H.assertSubtype(this._load$1("_playerChronology").then$1(new V.EgbPlayerProfile_loadPlayerChronology_closure()), "$isFuture", [[P.Set, P.String]], "$asFuture");
    },
    save$1: function(savegame) {
      var t1, completer, hashToRemove, t2;
      t1 = this.storyChronology;
      if (t1 == null) {
        completer = H.assertSubtype(H.setRuntimeTypeInfo(new P._AsyncCompleter(H.assertSubtype(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]), "$is_Future", [null], "$as_Future")), [null]), "$isCompleter", [null], "$asCompleter");
        this._loadStoryChronology$0().then$1(new V.EgbPlayerProfile_save_closure(this, savegame, completer));
        return H.assertSubtype(completer.future, "$isFuture", [P.bool], "$asFuture");
      }
      if (t1.get$length(t1) > this._maxSaves) {
        hashToRemove = H.stringTypeCheck(this.storyChronology.removeFirst$0());
        t1 = this.currentEgamebookUid;
        if (t1 == null)
          H.throwExpression("currentEgamebookUid not set");
        t1 = this.playerUid + "::" + H.S(t1) + "::" + H.S(hashToRemove);
        t2 = window.localStorage;
        (t2 && C.Storage_methods)._getItem$1(t2, t1);
        C.Storage_methods._removeItem$1(t2, t1);
        t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
        t1._asyncComplete$1(true);
        H.assertSubtype(H.assertSubtype(H.assertSubtype(t1, "$isFuture", [null], "$asFuture"), "$isFuture", [P.bool], "$asFuture"), "$isFuture", [P.bool], "$asFuture");
      }
      t1 = this.storyChronology;
      t2 = savegame.uid;
      t1.toString;
      H.assertSubtypeOfRuntimeType(t2, H.getTypeArgumentByIndex(t1, 0));
      t1._add$1(t2);
      H.assertSubtype(this._save$2("_storyChronology", C.JsonCodec_null_null.encode$1(this.storyChronology.toList$0(0))), "$isFuture", [P.bool], "$asFuture");
      return H.assertSubtype(this._save$2(savegame.uid, savegame.toJson$0()), "$isFuture", [P.bool], "$asFuture");
    },
    load$1: function(_, uid) {
      var t1, completer;
      H.stringTypeCheck(uid);
      t1 = Z.EgbSavegame;
      completer = H.assertSubtype(H.setRuntimeTypeInfo(new P._AsyncCompleter(H.assertSubtype(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [t1]), "$is_Future", [t1], "$as_Future")), [t1]), "$isCompleter", [t1], "$asCompleter");
      this._load$1(uid).then$1(new V.EgbPlayerProfile_load_closure(completer));
      return H.assertSubtype(completer.future, "$isFuture", [Z.EgbSavegame], "$asFuture");
    },
    loadMostRecent$0: function() {
      var t1, completer;
      t1 = this.storyChronology;
      if (t1 == null) {
        completer = H.assertSubtype(H.setRuntimeTypeInfo(new P._AsyncCompleter(H.assertSubtype(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]), "$is_Future", [null], "$as_Future")), [null]), "$isCompleter", [null], "$asCompleter");
        this._loadStoryChronology$0().then$1(new V.EgbPlayerProfile_loadMostRecent_closure(this, completer));
        return H.assertSubtype(completer.future, "$isFuture", [Z.EgbSavegame], "$asFuture");
      }
      if (t1._head === t1._tail) {
        t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
        t1._asyncComplete$1(null);
        return H.assertSubtype(H.assertSubtype(t1, "$isFuture", [null], "$asFuture"), "$isFuture", [Z.EgbSavegame], "$asFuture");
      }
      return H.assertSubtype(this.load$1(0, t1.get$last(t1)), "$isFuture", [Z.EgbSavegame], "$asFuture");
    }
  },
  EgbPlayerProfile__loadPreferences_closure: {
    "^": "Closure:2;_egb_player_profile$_captured_this_0,_captured_completer_1",
    call$1: function(json) {
      var t1, t2;
      t1 = json == null || J.$eq(json, "");
      t2 = this._egb_player_profile$_captured_this_0;
      if (t1)
        t2.set$preferences(P.LinkedHashMap_LinkedHashMap(null, null, null, null, null));
      else
        t2.set$preferences(C.JsonCodec_null_null.decode$1(json));
      this._captured_completer_1.complete$1(0, true);
    }
  },
  EgbPlayerProfile__loadStoryChronology_closure: {
    "^": "Closure:2;_egb_player_profile$_captured_this_0",
    call$1: function(json) {
      var t1 = this._egb_player_profile$_captured_this_0;
      if (json != null)
        t1.set$storyChronology(H.assertSubtype(P.ListQueue_ListQueue$from(H.assertSubtype(C.JsonCodec_null_null.decode$1(json), "$isList", [P.String], "$asList"), P.String), "$isQueue", [P.String], "$asQueue"));
      else
        t1.set$storyChronology(H.assertSubtype(P.ListQueue$(null, P.String), "$isQueue", [P.String], "$asQueue"));
      return true;
    }
  },
  EgbPlayerProfile_loadPlayerChronology_closure: {
    "^": "Closure:3;",
    call$1: function(s) {
      return J.toSet$0$ax(H.subtypeCast(C.JsonCodec_null_null.decode$1(H.stringTypeCheck(s)), "$isList", [P.String], "$asList"));
    }
  },
  EgbPlayerProfile_save_closure: {
    "^": "Closure:2;_egb_player_profile$_captured_this_0,_captured_savegame_1,_captured_completer_2",
    call$1: function(_) {
      return this._egb_player_profile$_captured_this_0.save$1(this._captured_savegame_1).then$1(new V.EgbPlayerProfile_save__closure(this._captured_completer_2));
    }
  },
  EgbPlayerProfile_save__closure: {
    "^": "Closure:2;_egb_player_profile$_captured_completer_3",
    call$1: function(value) {
      this._egb_player_profile$_captured_completer_3.complete$1(0, value);
    }
  },
  EgbPlayerProfile_load_closure: {
    "^": "Closure:2;_captured_completer_0",
    call$1: function(json) {
      var t1 = this._captured_completer_0;
      if (json == null)
        t1.complete$1(0, null);
      else
        t1.complete$1(0, Z.EgbSavegame$fromJson(json));
    }
  },
  EgbPlayerProfile_loadMostRecent_closure: {
    "^": "Closure:2;_egb_player_profile$_captured_this_0,_captured_completer_1",
    call$1: function(_) {
      return this._egb_player_profile$_captured_this_0.loadMostRecent$0().then$1(new V.EgbPlayerProfile_loadMostRecent__closure(this._captured_completer_1));
    }
  },
  EgbPlayerProfile_loadMostRecent__closure: {
    "^": "Closure:2;_captured_completer_2",
    call$1: function(value) {
      this._captured_completer_2.complete$1(0, value);
    }
  }
}],
["egb_presenter", "package:egamebook/presenter.dart", , B, {
  "^": "",
  EgbPresenter: {
    "^": "Object;"
  },
  EgbPresenterBase: {
    "^": "Object;",
    continueSavedGameOrCreateNew$0: function() {
      var t1 = {};
      t1._captured_lastSavegame_0 = null;
      t1._captured_playerChronology_1 = null;
      return H.assertSubtype(this._playerProfile.loadMostRecent$0().then$1(new B.EgbPresenterBase_continueSavedGameOrCreateNew_closure(t1, this)).then$1(new B.EgbPresenterBase_continueSavedGameOrCreateNew_closure0(t1, this)), "$isFuture", [B.EgbPresenter], "$asFuture");
    },
    $isEgbPresenter: 1
  },
  EgbPresenterBase_continueSavedGameOrCreateNew_closure: {
    "^": "Closure:28;_egb_presenter$_box_0,_egb_presenter$_captured_this_1",
    call$1: function(savegame) {
      H.interceptedTypeCheck(savegame, "$isEgbSavegame");
      this._egb_presenter$_box_0._captured_lastSavegame_0 = savegame;
      if (savegame == null)
        return H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, P.String), "$isSet", [P.String], "$asSet");
      else
        return this._egb_presenter$_captured_this_1._playerProfile.loadPlayerChronology$0();
    }
  },
  EgbPresenterBase_continueSavedGameOrCreateNew_closure0: {
    "^": "Closure:29;_egb_presenter$_box_0,_egb_presenter$_captured_this_2",
    call$1: function(chronology) {
      var t1, t2, t3;
      t1 = this._egb_presenter$_box_0;
      t1._captured_playerChronology_1 = H.assertSubtype(H.assertSubtype(chronology, "$isSet", [P.String], "$asSet"), "$isSet", [P.String], "$asSet");
      t2 = t1._captured_lastSavegame_0;
      t3 = this._egb_presenter$_captured_this_2;
      if (t2 != null) {
        t3.showText$1(t2.textHistory);
        t3.scripterProxy.load$2(0, t1._captured_lastSavegame_0, t1._captured_playerChronology_1);
      } else {
        t1 = t3.scripterProxy;
        t1.toString;
        t1._send$1(new A.EgbMessage(1010, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap")));
      }
      return t3;
    }
  }
}],
["egb_presenter_html", "package:egamebook/presenters/html/html_presenter.dart", , G, {
  "^": "",
  HtmlPresenter: {
    "^": "EgbPresenterBase;restartAnchor,pointsSpan,bookDiv,startButton,bookTitleDiv,bigBottomButtonDiv,currentActivity,_textHistory,_loadingEl,_loadingElVisible,_periodic,_periodicSubscription,_metaElements,_currentPoints,_stats,_statsElements,_savegameToBe,_formProxy,scripterProxy,_playerProfile",
    set$_stats: function(_stats) {
      this._stats = H.assertSubtype(_stats, "$isList", [Z.UIStat], "$asList");
    },
    setup$0: function() {
      var t1, t2, t3, t4;
      this.bookDiv = H.interceptedTypeCheck(C.HtmlDocument_methods.querySelector$1(document, "div#book-wrapper"), "$isDivElement");
      this._loadingEl = H.interceptedTypeCheck(C.HtmlDocument_methods.querySelector$1(document, "p#loading"), "$isParagraphElement");
      this.bookTitleDiv = H.interceptedTypeCheck(C.HtmlDocument_methods.querySelector$1(document, "div#book-title"), "$isDivElement");
      this.bigBottomButtonDiv = H.interceptedTypeCheck(C.HtmlDocument_methods.querySelector$1(document, "div#big-bottom-button"), "$isDivElement");
      t1 = H.interceptedTypeCheck(C.HtmlDocument_methods.querySelector$1(document, "#start-button"), "$isButtonElement");
      this.startButton = t1;
      (t1 && C.ButtonElement_methods).querySelector$1(t1, "#start-button-loading-span").textContent = "INITIATING";
      t1 = H.interceptedTypeCheck(C.HtmlDocument_methods.querySelector$1(document, "#book-restart"), "$isButtonElement");
      this.restartAnchor = t1;
      t1.toString;
      t1 = H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(t1, "click", false), [null]), "$isElementStream", [H.getTypeArgumentByIndex(C.EventStreamProvider_click, 0)], "$asElementStream"), "$isElementStream", [W.MouseEvent], "$asElementStream");
      t2 = new G.HtmlPresenter_setup_closure(this);
      t3 = H.getVoidRuntimeType();
      H.buildFunctionType(t3, [t1.T1()])._assertCheck$1(t2);
      t4 = H.buildFunctionType(t3);
      t4._assertCheck$1(null);
      t2 = H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(t2), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)]);
      t2._tryResume$0();
      H.assertSubtype(t2, "$isStreamSubscription", [H.getTypeArgumentByIndex(t1, 0)], "$asStreamSubscription");
      this.pointsSpan = H.interceptedTypeCheck(C.HtmlDocument_methods.querySelector$1(document, "span#points-value"), "$isSpanElement");
      t1 = J.get$onClick$x(C.HtmlDocument_methods.querySelector$1(document, "#points-button"));
      t2 = this.get$_statsOnClickListener();
      H.buildFunctionType(t3, [t1.T1()])._assertCheck$1(t2);
      t4._assertCheck$1(null);
      t2 = H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(t2), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)]);
      t2._tryResume$0();
      H.assertSubtype(t2, "$isStreamSubscription", [H.getTypeArgumentByIndex(t1, 0)], "$asStreamSubscription");
      t1 = this._periodic.listen$1(new G.HtmlPresenter_setup_closure0(this));
      this._periodicSubscription = t1;
      t1.pause$0(0);
      this._showLoading$1(false);
    },
    _bookReadyHandler$0: function() {
      var t1 = this.startButton;
      J.get$classes$x((t1 && C.ButtonElement_methods).querySelector$1(t1, "#start-button-loading-span")).add$1(0, "hidden");
      t1 = this.startButton;
      J.get$classes$x((t1 && C.ButtonElement_methods).querySelector$1(t1, "#start-button-loading-gif")).add$1(0, "hidden");
      t1 = this.startButton;
      J.get$classes$x((t1 && C.ButtonElement_methods).querySelector$1(t1, "#start-button-start-text")).remove$1(0, "hidden");
      t1 = this.startButton;
      t1.disabled = false;
      t1.toString;
      t1 = H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(t1, "click", false), [null]), "$isElementStream", [H.getTypeArgumentByIndex(C.EventStreamProvider_click, 0)], "$asElementStream"), "$isElementStream", [W.MouseEvent], "$asElementStream");
      t1.get$first(t1).then$1(new G.HtmlPresenter__bookReadyHandler_closure(this));
    },
    _showLoading$1: function(show) {
      var t1, t2;
      t1 = this._loadingElVisible;
      if (t1 != null && show === t1)
        return;
      t1 = this._loadingEl.style;
      t2 = show ? "visible" : "hidden";
      t1.visibility = t2;
      this._loadingElVisible = show;
    },
    showText$1: function(s) {
      var t1, completer;
      if (s == null) {
        t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
        t1._asyncComplete$1(false);
        return H.assertSubtype(H.assertSubtype(t1, "$isFuture", [null], "$asFuture"), "$isFuture", [P.bool], "$asFuture");
      }
      t1 = P.bool;
      completer = H.assertSubtype(H.setRuntimeTypeInfo(new P._AsyncCompleter(H.assertSubtype(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [t1]), "$is_Future", [t1], "$as_Future")), [t1]), "$isCompleter", [t1], "$asCompleter");
      this._showLoading$1(false);
      P.Future_Future$delayed(C.Duration_100000, new G.HtmlPresenter_showText_closure(this, s, completer), null);
      return H.assertSubtype(completer.future, "$isFuture", [P.bool], "$asFuture");
    },
    _attachFootnoteClickListeners$1: function(el) {
      var t1 = J._querySelectorAll$1$x(el, ".footnote");
      H.assertSubtype(t1, "$isList", [W.Node], "$asList");
      t1 = H.assertSubtype(new W._FrozenElementList(H.assertSubtype(t1, "$isList", [W.Node], "$asList")), "$isElementList", [W.Element], "$asElementList");
      t1.forEach$1(t1, new G.HtmlPresenter__attachFootnoteClickListeners_closure(this));
    },
    _checkMetaElementsInView$0: function() {
      var t1, currentBottom, _processedElements, t2, i, metaEl, t3, t4;
      t1 = this._metaElements;
      if (t1.length === 0) {
        this._periodicSubscription.pause$0(0);
        return;
      }
      currentBottom = C.JSInt_methods.$add(C.JSNumber_methods.round$0(window.pageYOffset), window.innerHeight) - 20;
      _processedElements = H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int), "$isSet", [P.$int], "$asSet");
      for (t2 = H.buildFunctionType(H.getVoidRuntimeType()), i = 0; i < t1.length; ++i) {
        metaEl = t1[i];
        if (C.JSNumber_methods.round$0(metaEl.element.offsetTop) < currentBottom) {
          t3 = metaEl.action;
          if (t3 != null) {
            t4 = t2._isTest$1(t3);
            t4 = t4;
            t3 = t4;
          } else
            t3 = false;
          if (t3) {
            metaEl.action$0(0);
            metaEl.done = true;
          } else
            H.throwExpression(P.StateError$("Called doAction() although action is null."));
          _processedElements.add$1(0, i);
        }
      }
      t2 = new G.HtmlPresenter__checkMetaElementsInView_closure();
      H.buildFunctionType(H.buildInterfaceType(P.bool), [H.convertRtiToRuntimeType(t1.$builtinTypeInfo && t1.$builtinTypeInfo[0])])._assertCheck$1(t2);
      C.JSArray_methods.checkGrowable$1(t1, "removeWhere");
      C.JSArray_methods._removeWhere$2(t1, t2, true);
    },
    showChoices$1: function(choiceList) {
      var t1, completer, choicesDiv, choicesQuestionP, choicesOl, clickSubscriptions, submenus, submenusDiv, submenuButtonsDiv;
      t1 = {};
      if (this.currentActivity === 1)
        this._bookReadyHandler$0();
      completer = H.assertSubtype(H.setRuntimeTypeInfo(new P._AsyncCompleter(H.assertSubtype(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]), "$is_Future", [null], "$as_Future")), [null]), "$isCompleter", [null], "$asCompleter");
      choicesDiv = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      choicesDiv.toString;
      W._ElementCssClassSet__add(choicesDiv, "choices-div");
      if (choiceList.question != null) {
        choicesQuestionP = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "p", null), "$isParagraphElement");
        (choicesQuestionP && C.ParagraphElement_methods).setInnerHtml$1(choicesQuestionP, B.markdownToHtml(choiceList.question, null, true, null, null));
        W._ElementCssClassSet__add(choicesQuestionP, "choices-question");
        J.append$1$x(choicesDiv, choicesQuestionP);
      }
      choicesOl = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "ol", null), "$isOListElement");
      choicesOl.toString;
      W._ElementCssClassSet__add(choicesOl, "choices-ol");
      clickSubscriptions = H.assertSubtype(H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, P.StreamSubscription), "$isSet", [P.StreamSubscription], "$asSet"), "$isSet", [P.StreamSubscription], "$asSet");
      t1._captured_mainChoiceListNumber_0 = 1;
      choiceList.where$1(choiceList, new G.HtmlPresenter_showChoices_closure()).forEach$1(0, new G.HtmlPresenter_showChoices_closure0(t1, this, completer, choicesDiv, choicesOl, clickSubscriptions));
      t1 = J.getInterceptor$x(choicesDiv);
      t1.append$1(choicesDiv, choicesOl);
      submenus = H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, G.Submenu), "$isMap", [P.String, G.Submenu], "$asMap"), "$isMap", [P.String, G.Submenu], "$asMap");
      choiceList.where$1(choiceList, new G.HtmlPresenter_showChoices_closure1()).forEach$1(0, new G.HtmlPresenter_showChoices_closure2(submenus));
      if (submenus.__js_helper$_length !== 0) {
        submenusDiv = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
        submenusDiv.toString;
        W._ElementCssClassSet__add(submenusDiv, "choices-submenus");
        submenuButtonsDiv = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
        submenuButtonsDiv.toString;
        W._ElementCssClassSet__add(submenuButtonsDiv, "choices-submenu-buttons");
        J.append$1$x(submenusDiv, submenuButtonsDiv);
        submenus.forEach$1(0, new G.HtmlPresenter_showChoices_closure3(this, completer, choicesDiv, clickSubscriptions, submenusDiv, submenuButtonsDiv));
        t1.append$1(choicesDiv, submenusDiv);
      }
      W._ElementCssClassSet__add(choicesDiv, "hidden");
      J.append$1$x(this.bookDiv, choicesDiv);
      this._showLoading$1(false);
      P.Future_Future(new G.HtmlPresenter_showChoices_closure4(choicesDiv), null);
      return H.assertSubtype(completer.future, "$isFuture", [P.$int], "$asFuture");
    },
    _createChoiceButton$5: function(index, choice, completer, choicesDiv, clickSubscriptions) {
      var btn, numberSpan, choiceDisplaySpan, choiceWithInfochips, infochipsSpan, t1, j, chipSpan, t2, list, textSpan, t3;
      H.interceptedTypeCheck(choice, "$isEgbChoice");
      H.assertSubtype(clickSubscriptions, "$isSet", [P.StreamSubscription], "$asSet");
      btn = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "button", null), "$isButtonElement");
      numberSpan = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "span", null), "$isSpanElement");
      numberSpan.textContent = index;
      W._ElementCssClassSet__add(numberSpan, "choice-number");
      choiceDisplaySpan = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "span", null), "$isSpanElement");
      choiceDisplaySpan.toString;
      W._ElementCssClassSet__add(choiceDisplaySpan, "choice-display");
      choiceWithInfochips = K.ChoiceWithInfochips$(choice.string);
      if (choiceWithInfochips.infochips.length !== 0) {
        infochipsSpan = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "span", null), "$isSpanElement");
        infochipsSpan.toString;
        W._ElementCssClassSet__add(infochipsSpan, "choice-infochips");
        for (t1 = infochipsSpan && C.SpanElement_methods, j = 0; j < choiceWithInfochips.infochips.length; ++j) {
          chipSpan = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "span", null), "$isSpanElement");
          t2 = choiceWithInfochips.infochips;
          if (j >= t2.length)
            return H.ioore(t2, j);
          chipSpan.textContent = B.markdownToHtml(t2[j], null, true, null, null);
          list = chipSpan.classList;
          list.contains("choice-infochip");
          list.add("choice-infochip");
          t1.append$1(infochipsSpan, chipSpan);
        }
        (choiceDisplaySpan && C.SpanElement_methods).append$1(choiceDisplaySpan, infochipsSpan);
      }
      textSpan = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "span", null), "$isSpanElement");
      (textSpan && C.SpanElement_methods).setInnerHtml$1(textSpan, B.markdownToHtml(choiceWithInfochips.text, null, true, null, null));
      W._ElementCssClassSet__add(textSpan, "choice-text");
      (choiceDisplaySpan && C.SpanElement_methods).append$1(choiceDisplaySpan, textSpan);
      btn.toString;
      t1 = H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(btn, "click", false), [null]), "$isElementStream", [H.getTypeArgumentByIndex(C.EventStreamProvider_click, 0)], "$asElementStream"), "$isElementStream", [W.MouseEvent], "$asElementStream");
      t2 = new G.HtmlPresenter__createChoiceButton_closure(this, choice, completer, choicesDiv, clickSubscriptions, btn);
      t3 = H.getVoidRuntimeType();
      H.buildFunctionType(t3, [t1.T1()])._assertCheck$1(t2);
      H.buildFunctionType(t3)._assertCheck$1(null);
      t2 = H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(t2), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)]);
      t2._tryResume$0();
      clickSubscriptions.add$1(0, H.assertSubtype(t2, "$isStreamSubscription", [H.getTypeArgumentByIndex(t1, 0)], "$asStreamSubscription"));
      (btn && C.ButtonElement_methods).append$1(btn, numberSpan);
      C.ButtonElement_methods.append$1(btn, choiceDisplaySpan);
      return btn;
    },
    _choiceClickListener$6: function($event, completer, choice, btn, choicesDiv, clickSubscriptions) {
      var t1, savegameUid, t2, t3;
      H.assertSubtype(clickSubscriptions, "$isSet", [P.StreamSubscription], "$asSet");
      P.Future_Future$delayed(C.Duration_100000, new G.HtmlPresenter__choiceClickListener_closure(completer, choice), null);
      this._showLoading$1(true);
      W._ElementCssClassSet__add(btn, "chosen");
      W._ElementCssClassSet__add(choicesDiv, "chosen");
      t1 = J._querySelectorAll$1$x(choicesDiv, "button");
      H.assertSubtype(t1, "$isList", [W.Node], "$asList");
      t1 = H.assertSubtype(new W._FrozenElementList(H.assertSubtype(t1, "$isList", [W.Node], "$asList")), "$isElementList", [W.Element], "$asElementList");
      t1.forEach$1(t1, new G.HtmlPresenter__choiceClickListener_closure0());
      clickSubscriptions.forEach$1(0, new G.HtmlPresenter__choiceClickListener_closure1());
      clickSubscriptions.clear$0(0);
      if (this._savegameToBe != null) {
        W._ElementCssClassSet__add(choicesDiv, "bookmark");
        savegameUid = this._savegameToBe.uid;
        t1 = H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(choicesDiv, "click", false), [null]), "$isElementStream", [H.getTypeArgumentByIndex(C.EventStreamProvider_click, 0)], "$asElementStream"), "$isElementStream", [W.MouseEvent], "$asElementStream");
        t2 = new G.HtmlPresenter__choiceClickListener_closure2(this, savegameUid);
        t3 = H.getVoidRuntimeType();
        H.buildFunctionType(t3, [t1.T1()])._assertCheck$1(t2);
        H.buildFunctionType(t3)._assertCheck$1(null);
        t2 = H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(t2), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)]);
        t2._tryResume$0();
        H.assertSubtype(t2, "$isStreamSubscription", [H.getTypeArgumentByIndex(t1, 0)], "$asStreamSubscription");
        this._savegameToBe = null;
      }
      $event.stopPropagation();
    },
    awardPoints$1: function(award) {
      var t1, completer, paragraph;
      t1 = award.result;
      this._currentPoints = t1;
      if (award.addition === 0) {
        this.pointsSpan.textContent = H.S(t1);
        t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
        t1._asyncComplete$1(true);
        return H.assertSubtype(H.assertSubtype(t1, "$isFuture", [null], "$asFuture"), "$isFuture", [P.bool], "$asFuture");
      }
      completer = H.assertSubtype(H.setRuntimeTypeInfo(new P._AsyncCompleter(H.assertSubtype(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]), "$is_Future", [null], "$as_Future")), [null]), "$isCompleter", [null], "$asCompleter");
      paragraph = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "p", null), "$isParagraphElement");
      paragraph.textContent = award.toString$0(0);
      t1 = ["toast", "non-dimmed", "hidden"];
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      W._ElementCssClassSet__addAll(paragraph, t1);
      J.append$1$x(this.bookDiv, paragraph);
      P.Future_Future(new G.HtmlPresenter_awardPoints_closure(paragraph), null);
      P.Future_Future$delayed(C.Duration_200000, new G.HtmlPresenter_awardPoints_closure0(this, award, completer, paragraph), null);
      return H.assertSubtype(completer.future, "$isFuture", [P.bool], "$asFuture");
    },
    setStats$1: function(stats) {
      var statsDiv, t1, t2, t3, t4, t5, i, stat, span, button, list, t6, t7, t8;
      H.assertSubtype(stats, "$isList", [Z.UIStat], "$asList");
      this.set$_stats(stats);
      this._printStats$0();
      statsDiv = C.HtmlDocument_methods.querySelector$1(document, "nav div#stats");
      t1 = J.getInterceptor$x(statsDiv);
      t1.get$children(statsDiv).clear$0(0);
      for (t2 = stats.length, t3 = H.getVoidRuntimeType(), t4 = H.buildFunctionType(t3), t5 = this._statsElements, i = 0; i < t2; ++i) {
        stat = stats[i];
        span = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "span", null), "$isSpanElement");
        span.textContent = stat.string;
        button = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "button", null), "$isButtonElement");
        if (!H.boolConversionCheck(stat.show)) {
          list = button.classList;
          list.contains("display-none");
          list.add("display-none");
        }
        H.assertSubtype(new W._ChildrenElementList(button, button.children), "$isList", [W.Element], "$asList");
        (button && C.ButtonElement_methods).append$1(button, span);
        t1.get$children(statsDiv).add$1(0, button);
        t5.$indexSet(0, stat.name, button);
        t6 = new W._ElementEventStreamImpl(button, "click", false);
        H.assertHelper(true);
        t6.$builtinTypeInfo = [null];
        t6 = H.assertSubtype(H.assertSubtype(t6, "$isElementStream", [H.getTypeArgumentByIndex(C.EventStreamProvider_click, 0)], "$asElementStream"), "$isElementStream", [W.MouseEvent], "$asElementStream");
        t7 = this.get$_statsOnClickListener();
        H.buildFunctionType(t3, [t6.T1()])._assertCheck$1(t7);
        t4._assertCheck$1(null);
        t7 = new W._EventStreamSubscription(0, button, "click", W._wrapZone(t7), false);
        H.assertHelper(true);
        t7.$builtinTypeInfo = [H.getTypeArgumentByIndex(t6, 0)];
        t8 = t7._onData;
        if (t8 != null && t7._pauseCount <= 0)
          J.addEventListener$3$x(t7._html$_target, "click", t8, false);
        H.assertSubtype(t7, "$isStreamSubscription", [H.getTypeArgumentByIndex(t6, 0)], "$asStreamSubscription");
      }
      t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
      t1._asyncComplete$1(null);
      return H.assertSubtype(t1, "$isFuture", [null], "$asFuture");
    },
    updateStats$1: function(updates) {
      var t1;
      C.JSArray_methods.forEach$1(Z.UIStat_updateStatsList(this._stats, updates), new G.HtmlPresenter_updateStats_closure(this));
      t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
      t1._asyncComplete$1(null);
      return H.assertSubtype(t1, "$isFuture", [null], "$asFuture");
    },
    _printStats$0: function() {
      var t1, t2, t3, t4;
      P.print("Stats:");
      t1 = this._stats;
      t2 = new G.HtmlPresenter__printStats_closure();
      t1.toString;
      t3 = H.buildInterfaceType(P.bool);
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t1.$builtinTypeInfo && t1.$builtinTypeInfo[0])])._assertCheck$1(t2);
      t4 = H.getTypeArgumentByIndex(t1, 0);
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      H.buildFunctionType(t3, [H.convertRtiToRuntimeType(t4)])._assertCheck$1(t2);
      H.listSuperNativeTypeCheck(H.setRuntimeTypeInfo(new H.WhereIterable(H.listSuperNativeTypeCheck(t1, "$isIterable"), H.buildFunctionType(t3, [H.getDynamicRuntimeType()])._assertCheck$1(t2)), [t4]), "$isIterable").forEach$1(0, new G.HtmlPresenter__printStats_closure0());
    },
    _blink$1: function(el) {
      J.get$classes$x(el).add$1(0, "blink");
      P.Future_Future$delayed(P.Duration$(0, 0, 0, 1000, 0, 0), new G.HtmlPresenter__blink_closure(el), null);
    },
    _handleSavegameBookmarkClick$1: function(savegameUid) {
      var t1;
      if (H.boolConversionCheck(C.Window_methods.confirm$1(window, "Are you sure you want to come back to this decision (" + H.S(savegameUid) + ") and lose your progress since?"))) {
        t1 = this.bookDiv;
        H.assertSubtype(new W._ChildrenElementList(t1, t1.children), "$isList", [W.Element], "$asList");
        J._clearChildren$0$x(t1);
        this._playerProfile.load$1(0, savegameUid).then$1(new G.HtmlPresenter__handleSavegameBookmarkClick_closure(this));
      }
    },
    showDialog$1: function(dialog) {
      var t1, completer, dialogDiv, overlayDiv, wrapperDiv, titleEl, contentDiv, textDiv, buttonsDiv, t2, t3, dialogButton, buttonEl, t4, t5, t6;
      t1 = P.bool;
      completer = H.assertSubtype(H.setRuntimeTypeInfo(new P._AsyncCompleter(H.assertSubtype(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [t1]), "$is_Future", [t1], "$as_Future")), [t1]), "$isCompleter", [t1], "$asCompleter");
      dialogDiv = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      dialogDiv.toString;
      W._ElementCssClassSet__add(dialogDiv, "dialog");
      overlayDiv = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      overlayDiv.toString;
      W._ElementCssClassSet__add(overlayDiv, "overlay");
      H.assertSubtype(new W._ChildrenElementList(dialogDiv, dialogDiv.children), "$isList", [W.Element], "$asList");
      J.append$1$x(dialogDiv, overlayDiv);
      wrapperDiv = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      wrapperDiv.toString;
      W._ElementCssClassSet__add(wrapperDiv, "dialog-window");
      titleEl = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "h3", null), "$isHeadingElement");
      titleEl.textContent = dialog.title;
      H.assertSubtype(new W._ChildrenElementList(wrapperDiv, wrapperDiv.children), "$isList", [W.Element], "$asList");
      J.append$1$x(wrapperDiv, titleEl);
      contentDiv = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      contentDiv.toString;
      W._ElementCssClassSet__add(contentDiv, "dialog-content");
      H.assertSubtype(new W._ChildrenElementList(wrapperDiv, wrapperDiv.children), "$isList", [W.Element], "$asList");
      J.append$1$x(wrapperDiv, contentDiv);
      textDiv = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      J.setInnerHtml$1$x(textDiv, dialog.html);
      H.assertSubtype(new W._ChildrenElementList(contentDiv, contentDiv.children), "$isList", [W.Element], "$asList");
      J.append$1$x(contentDiv, textDiv);
      buttonsDiv = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      buttonsDiv.toString;
      W._ElementCssClassSet__add(buttonsDiv, "dialog-buttons");
      for (t1 = dialog.buttons, t2 = H.getTypeArgumentByIndex(t1, 0), H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t1 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), 1, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"), t2 = H.getVoidRuntimeType(), t3 = H.buildFunctionType(t2); t1.moveNext$0();) {
        dialogButton = H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0)), "$isDialogButton");
        buttonEl = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "button", null), "$isButtonElement");
        buttonEl.textContent = dialogButton.label;
        buttonEl.toString;
        t4 = new W._ElementEventStreamImpl(buttonEl, "click", false);
        H.assertHelper(true);
        t4.$builtinTypeInfo = [null];
        t4 = H.assertSubtype(H.assertSubtype(t4, "$isElementStream", [H.getTypeArgumentByIndex(C.EventStreamProvider_click, 0)], "$asElementStream"), "$isElementStream", [W.MouseEvent], "$asElementStream");
        t5 = new G.HtmlPresenter_showDialog_closure(completer, dialogDiv, dialogButton);
        H.buildFunctionType(t2, [t4.T1()])._assertCheck$1(t5);
        t3._assertCheck$1(null);
        t5 = new W._EventStreamSubscription(0, buttonEl, "click", W._wrapZone(t5), false);
        H.assertHelper(true);
        t5.$builtinTypeInfo = [H.getTypeArgumentByIndex(t4, 0)];
        t6 = t5._onData;
        if (t6 != null && t5._pauseCount <= 0)
          J.addEventListener$3$x(t5._html$_target, "click", t6, false);
        H.assertSubtype(t5, "$isStreamSubscription", [H.getTypeArgumentByIndex(t4, 0)], "$asStreamSubscription");
        H.assertSubtype(new W._ChildrenElementList(buttonsDiv, buttonsDiv.children), "$isList", [W.Element], "$asList");
        J.append$1$x(buttonsDiv, buttonEl);
      }
      H.assertSubtype(new W._ChildrenElementList(wrapperDiv, wrapperDiv.children), "$isList", [W.Element], "$asList");
      J.append$1$x(wrapperDiv, buttonsDiv);
      H.assertSubtype(new W._ChildrenElementList(dialogDiv, dialogDiv.children), "$isList", [W.Element], "$asList");
      J.append$1$x(dialogDiv, wrapperDiv);
      t1 = document.body;
      H.assertSubtype(new W._ChildrenElementList(t1, t1.children), "$isList", [W.Element], "$asList");
      (t1 && C.BodyElement_methods).append$1(t1, dialogDiv);
      return H.assertSubtype(completer.future, "$isFuture", [P.bool], "$asFuture");
    },
    _statsOnClickListener$1: [function($event) {
      var html, t1, i, stat;
      H.interceptedTypeCheck($event, "$isEvent");
      html = new P.StringBuffer("");
      html._contents = "<table>";
      html._contents = "<table>\n";
      t1 = "<table>\n" + ("<tr><td>Score:</td><td>" + H.S(this._currentPoints) + "</td></tr>");
      html._contents = t1;
      html._contents = t1 + "\n";
      for (i = 0; t1 = this._stats, i < t1.length; ++i) {
        stat = t1[i];
        if (H.boolConversionCheck(stat.show)) {
          t1 = html._contents += "<tr><td>" + H.S(stat.name) + ":</td><td>" + H.S(stat.string) + "</td></tr>";
          html._contents = t1 + "\n";
        }
      }
      t1 = html._contents += "</table>";
      t1 += "\n";
      html._contents = t1;
      t1 = t1.charCodeAt(0) == 0 ? t1 : t1;
      H.assertSubtype(C.List_DialogButton_Close_null, "$isList", [G.DialogButton], "$asList");
      this.showDialog$1(new G.Dialog("Stats", t1, H.assertSubtype(C.List_DialogButton_Close_null, "$isList", [G.DialogButton], "$asList")));
    }, "call$1", "get$_statsOnClickListener", 2, 0, 30],
    reportError$2: function(title, text) {
      var t1 = "<p>" + H.S(text) + "</p>";
      H.assertSubtype(C.List_DialogButton_Close_null, "$isList", [G.DialogButton], "$asList");
      return H.assertSubtype(this.showDialog$1(new G.Dialog(title, t1, H.assertSubtype(C.List_DialogButton_Close_null, "$isList", [G.DialogButton], "$asList"))), "$isFuture", [P.bool], "$asFuture");
    }
  },
  HtmlPresenter_setup_closure: {
    "^": "Closure:2;_egb_presenter_html$_captured_this_0",
    call$1: function(_) {
      var t1, t2;
      t1 = this._egb_presenter_html$_captured_this_0;
      t2 = t1.scripterProxy;
      t2.toString;
      t2._send$1(new A.EgbMessage(1010, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap")));
      t2 = t1.bookDiv;
      H.assertSubtype(new W._ChildrenElementList(t2, t2.children), "$isList", [W.Element], "$asList");
      J._clearChildren$0$x(t2);
      t1._textHistory._contents = "";
      t1._savegameToBe = null;
    }
  },
  HtmlPresenter_setup_closure0: {
    "^": "Closure:2;_egb_presenter_html$_captured_this_1",
    call$1: function(_) {
      this._egb_presenter_html$_captured_this_1._checkMetaElementsInView$0();
    }
  },
  HtmlPresenter__bookReadyHandler_closure: {
    "^": "Closure:2;_egb_presenter_html$_captured_this_0",
    call$1: function(_) {
      var t1, t2;
      t1 = this._egb_presenter_html$_captured_this_0;
      t2 = t1.bookDiv.style;
      t2.display = "block";
      P.Future_Future(new G.HtmlPresenter__bookReadyHandler__closure(t1), null);
    }
  },
  HtmlPresenter__bookReadyHandler__closure: {
    "^": "Closure:0;_egb_presenter_html$_captured_this_1",
    call$0: function() {
      var t1, t2, t3, hasScrollIntoViewIfNeeded;
      t1 = this._egb_presenter_html$_captured_this_1;
      t2 = t1.bookDiv;
      t3 = t2.children;
      H.assertSubtype(new W._ChildrenElementList(t2, t3), "$isList", [W.Element], "$asList");
      H.assertHelper(t3.length > 0);
      t3 = t1.bookDiv;
      t3 = H.assertSubtype(new W._ChildrenElementList(t3, t3.children), "$isList", [W.Element], "$asList");
      t3 = t3.get$last(t3);
      hasScrollIntoViewIfNeeded = !!t3.scrollIntoViewIfNeeded;
      if (hasScrollIntoViewIfNeeded)
        t3.scrollIntoViewIfNeeded();
      else
        t3.scrollIntoView();
      t2 = t1.bookTitleDiv.style;
      t2.display = "none";
      t2 = t1.bigBottomButtonDiv.style;
      t2.display = "none";
      t1.currentActivity = 2;
    }
  },
  HtmlPresenter_showText_closure: {
    "^": "Closure:0;_egb_presenter_html$_captured_this_0,_captured_s_1,_egb_presenter_html$_captured_completer_2",
    call$0: function() {
      var t1, t2, t3, html, container, count, el;
      t1 = this._egb_presenter_html$_captured_this_0;
      t2 = this._captured_s_1;
      t1._textHistory._contents += t2 + "\n\n";
      t3 = H.JSSyntaxRegExp_makeNative("<sup class=\"footnote\" title=\"(.*?)\">", true, true, false);
      html = B.markdownToHtml(t2, null, false, H.assertSubtype(H.setRuntimeTypeInfo([new G.FootnoteSupTagSyntax(null, new H.JSSyntaxRegExp("</sup>", H.JSSyntaxRegExp_makeNative("</sup>", true, true, false), null, null), "sup", new H.JSSyntaxRegExp("<sup class=\"footnote\" title=\"(.*?)\">", t3, null, null))], [R.InlineSyntax]), "$isList", [R.InlineSyntax], "$asList"), null);
      container = document.createDocumentFragment();
      t2 = J.getInterceptor$x(container);
      t2.set$innerHtml(container, html);
      for (t3 = J.get$iterator$ax(t2.get$children(container)), count = 0; t3.moveNext$0();) {
        el = H.interceptedTypeCheck(t3.get$current(), "$isElement");
        t1._attachFootnoteClickListeners$1(el);
        J.append$1$x(t1.bookDiv, el);
      }
      t2.remove$0(container);
      P.Future_Future$delayed(new P.Duration(C.JSInt_methods.round$0(200000 * count)), new G.HtmlPresenter_showText__closure(this._egb_presenter_html$_captured_completer_2), null);
    }
  },
  HtmlPresenter_showText__closure0: {
    "^": "Closure:0;_captured_el_3",
    call$0: function() {
      J.get$classes$x(this._captured_el_3).remove$1(0, "hidden");
    }
  },
  HtmlPresenter_showText__closure: {
    "^": "Closure:0;_captured_completer_4",
    call$0: function() {
      return this._captured_completer_4.complete$1(0, true);
    }
  },
  HtmlPresenter__attachFootnoteClickListeners_closure: {
    "^": "Closure:20;_egb_presenter_html$_captured_this_0",
    call$1: function(footnoteEl) {
      var t1, t2, t3;
      H.interceptedTypeCheck(footnoteEl, "$isElement");
      P.print("Found footnote");
      t1 = J.get$onClick$x(footnoteEl);
      t2 = new G.HtmlPresenter__attachFootnoteClickListeners__closure(this._egb_presenter_html$_captured_this_0, footnoteEl);
      t3 = H.getVoidRuntimeType();
      H.buildFunctionType(t3, [t1.T1()])._assertCheck$1(t2);
      H.buildFunctionType(t3)._assertCheck$1(null);
      t2 = H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(t2), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)]);
      t2._tryResume$0();
      H.assertSubtype(t2, "$isStreamSubscription", [H.getTypeArgumentByIndex(t1, 0)], "$asStreamSubscription");
    }
  },
  HtmlPresenter__attachFootnoteClickListeners__closure: {
    "^": "Closure:2;_egb_presenter_html$_captured_this_1,_captured_footnoteEl_2",
    call$1: function(_) {
      var t1 = "<p>" + H.S(J.get$title$x(this._captured_footnoteEl_2)) + "</p>";
      H.assertSubtype(C.List_DialogButton_Close_null, "$isList", [G.DialogButton], "$asList");
      this._egb_presenter_html$_captured_this_1.showDialog$1(new G.Dialog("Footnote", t1, H.assertSubtype(C.List_DialogButton_Close_null, "$isList", [G.DialogButton], "$asList")));
    }
  },
  HtmlPresenter__checkMetaElementsInView_closure: {
    "^": "Closure:2;",
    call$1: function(metaEl) {
      return metaEl.get$done();
    }
  },
  HtmlPresenter_showChoices_closure: {
    "^": "Closure:2;",
    call$1: function(choice) {
      return choice.get$submenu() == null;
    }
  },
  HtmlPresenter_showChoices_closure0: {
    "^": "Closure:2;_egb_presenter_html$_box_0,_egb_presenter_html$_captured_this_1,_egb_presenter_html$_captured_completer_2,_captured_choicesDiv_3,_captured_choicesOl_4,_captured_clickSubscriptions_5",
    call$1: function(choice) {
      var t1 = this._egb_presenter_html$_box_0;
      C.OListElement_methods.append$1(this._captured_choicesOl_4, this._egb_presenter_html$_captured_this_1._createChoiceButton$5("" + t1._captured_mainChoiceListNumber_0 + ".", choice, this._egb_presenter_html$_captured_completer_2, this._captured_choicesDiv_3, this._captured_clickSubscriptions_5));
      ++t1._captured_mainChoiceListNumber_0;
    }
  },
  HtmlPresenter_showChoices_closure1: {
    "^": "Closure:2;",
    call$1: function(choice) {
      return choice.get$submenu() != null;
    }
  },
  HtmlPresenter_showChoices_closure2: {
    "^": "Closure:2;_captured_submenus_6",
    call$1: function(choice) {
      C.JSArray_methods.add$1(H.interceptedTypeCheck(this._captured_submenus_6.putIfAbsent$2(0, choice.get$submenu(), new G.HtmlPresenter_showChoices__closure1(choice)), "$isSubmenu").choices, choice);
    }
  },
  HtmlPresenter_showChoices__closure1: {
    "^": "Closure:0;_captured_choice_7",
    call$0: function() {
      return new G.Submenu(this._captured_choice_7.submenu, H.assertSubtype(H.setRuntimeTypeInfo([], [L.EgbChoice]), "$isList", [L.EgbChoice], "$asList"));
    }
  },
  HtmlPresenter_showChoices_closure3: {
    "^": "Closure:11;_captured_this_8,_captured_completer_9,_captured_choicesDiv_10,_captured_clickSubscriptions_11,_captured_submenusDiv_12,_captured_submenuButtonsDiv_13",
    call$2: function($name, submenu) {
      var submenuButton, submenuChoicesOl, t1, t2, t3, t4;
      submenuButton = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "button", null), "$isButtonElement");
      submenuButton.toString;
      W._ElementCssClassSet__add(submenuButton, "submenu-button");
      submenuButton.textContent = J.get$name$x(submenu);
      J.append$1$x(this._captured_submenuButtonsDiv_13, submenuButton);
      submenuChoicesOl = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "ol", null), "$isOListElement");
      submenuChoicesOl.toString;
      t1 = ["choices-ol", "display-none"];
      H.listSuperNativeTypeCheck(t1, "$isIterable");
      W._ElementCssClassSet__addAll(submenuChoicesOl, t1);
      t1 = this._captured_clickSubscriptions_11;
      C.JSArray_methods.forEach$1(submenu.get$choices(), new G.HtmlPresenter_showChoices__closure(this._captured_this_8, this._captured_completer_9, this._captured_choicesDiv_10, t1, submenuChoicesOl));
      t2 = H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(submenuButton, "click", false), [null]), "$isElementStream", [H.getTypeArgumentByIndex(C.EventStreamProvider_click, 0)], "$asElementStream"), "$isElementStream", [W.MouseEvent], "$asElementStream");
      t3 = new G.HtmlPresenter_showChoices__closure0(submenuButton, submenuChoicesOl);
      t4 = H.getVoidRuntimeType();
      H.buildFunctionType(t4, [t2.T1()])._assertCheck$1(t3);
      H.buildFunctionType(t4)._assertCheck$1(null);
      t3 = H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t2._html$_target, t2._eventType, W._wrapZone(t3), t2._useCapture), [H.getTypeArgumentByIndex(t2, 0)]);
      t3._tryResume$0();
      t1.add$1(0, H.assertSubtype(t3, "$isStreamSubscription", [H.getTypeArgumentByIndex(t2, 0)], "$asStreamSubscription"));
      J.append$1$x(this._captured_submenusDiv_12, submenuChoicesOl);
    }
  },
  HtmlPresenter_showChoices__closure: {
    "^": "Closure:2;_captured_this_14,_captured_completer_15,_captured_choicesDiv_16,_captured_clickSubscriptions_17,_captured_submenuChoicesOl_18",
    call$1: function(choice) {
      var t1 = this._captured_submenuChoicesOl_18;
      (t1 && C.OListElement_methods).append$1(t1, this._captured_this_14._createChoiceButton$5("", choice, this._captured_completer_15, this._captured_choicesDiv_16, this._captured_clickSubscriptions_17));
    }
  },
  HtmlPresenter_showChoices__closure0: {
    "^": "Closure:2;_captured_submenuButton_19,_captured_submenuChoicesOl_20",
    call$1: function(_) {
      this._captured_submenuChoicesOl_20.classList.toggle("display-none");
      this._captured_submenuButton_19.classList.toggle("depressed");
    }
  },
  HtmlPresenter_showChoices_closure4: {
    "^": "Closure:0;_captured_choicesDiv_21",
    call$0: function() {
      var list, removed, t1;
      list = this._captured_choicesDiv_21.classList;
      removed = list.contains("hidden");
      list.remove("hidden");
      t1 = removed;
      return t1;
    }
  },
  HtmlPresenter__createChoiceButton_closure: {
    "^": "Closure:31;_egb_presenter_html$_captured_this_0,_captured_choice_1,_egb_presenter_html$_captured_completer_2,_captured_choicesDiv_3,_captured_clickSubscriptions_4,_captured_btn_5",
    call$1: function($event) {
      return this._egb_presenter_html$_captured_this_0._choiceClickListener$6(H.interceptedTypeCheck($event, "$isMouseEvent"), this._egb_presenter_html$_captured_completer_2, this._captured_choice_1, this._captured_btn_5, this._captured_choicesDiv_3, this._captured_clickSubscriptions_4);
    }
  },
  HtmlPresenter__choiceClickListener_closure: {
    "^": "Closure:0;_egb_presenter_html$_captured_completer_0,_captured_choice_1",
    call$0: function() {
      return this._egb_presenter_html$_captured_completer_0.complete$1(0, this._captured_choice_1.hash);
    }
  },
  HtmlPresenter__choiceClickListener_closure0: {
    "^": "Closure:32;",
    call$1: function(b) {
      H.interceptedTypeCheck(b, "$isButtonElement").disabled = true;
      return true;
    }
  },
  HtmlPresenter__choiceClickListener_closure1: {
    "^": "Closure:26;",
    call$1: function(s) {
      return H.interceptedTypeCheck(s, "$isStreamSubscription").cancel$0();
    }
  },
  HtmlPresenter__choiceClickListener_closure2: {
    "^": "Closure:2;_egb_presenter_html$_captured_this_2,_captured_savegameUid_3",
    call$1: function(_) {
      return this._egb_presenter_html$_captured_this_2._handleSavegameBookmarkClick$1(this._captured_savegameUid_3);
    }
  },
  HtmlPresenter_awardPoints_closure: {
    "^": "Closure:0;_captured_paragraph_0",
    call$0: function() {
      var list = this._captured_paragraph_0.classList;
      list.contains("hidden");
      list.remove("hidden");
    }
  },
  HtmlPresenter_awardPoints_closure0: {
    "^": "Closure:0;_egb_presenter_html$_captured_this_1,_captured_award_2,_captured_completer_3,_captured_paragraph_4",
    call$0: function() {
      var t1, t2, metaEl, t3;
      t1 = this._captured_award_2;
      t2 = this._captured_paragraph_4;
      metaEl = new G.PointsAwardElement(t2, H.buildFunctionType(H.getVoidRuntimeType())._assertCheck$1(null), false, t1.addition, t1.result, t1.justification);
      t3 = this._egb_presenter_html$_captured_this_1;
      metaEl.action = new G.HtmlPresenter_awardPoints__closure(t3, t1, t2);
      C.JSArray_methods.add$1(t3._metaElements, metaEl);
      if (t3._periodicSubscription.get$isPaused())
        t3._periodicSubscription.resume$0();
      this._captured_completer_3.complete$1(0, true);
    }
  },
  HtmlPresenter_awardPoints__closure: {
    "^": "Closure:0;_captured_this_5,_captured_award_6,_captured_paragraph_7",
    call$0: function() {
      var t1, t2, list;
      t1 = this._captured_this_5;
      t1.pointsSpan.textContent = H.S(this._captured_award_6.result);
      t2 = this._captured_paragraph_7;
      t1._blink$1(t2);
      list = t2.classList;
      list.contains("non-dimmed");
      list.remove("non-dimmed");
      t1._blink$1(t1.pointsSpan.parentElement);
    }
  },
  HtmlPresenter_updateStats_closure: {
    "^": "Closure:33;_egb_presenter_html$_captured_this_0",
    call$1: function(stat) {
      var anchor, t1;
      H.interceptedTypeCheck(stat, "$isUIStat");
      anchor = this._egb_presenter_html$_captured_this_0._statsElements.$index(0, stat.name);
      t1 = J.getInterceptor$x(anchor);
      J.set$text$x(J.get$single$ax(t1.get$children(anchor)), stat.string);
      if (H.boolConversionCheck(stat.show))
        t1.get$classes(anchor).remove$1(0, "display-none");
      else
        t1.get$classes(anchor).add$1(0, "display-none");
    }
  },
  HtmlPresenter__printStats_closure: {
    "^": "Closure:2;",
    call$1: function(stat) {
      return J.$eq(J.get$show$x(stat), true);
    }
  },
  HtmlPresenter__printStats_closure0: {
    "^": "Closure:2;",
    call$1: function(stat) {
      P.print("- " + H.S(stat));
    }
  },
  HtmlPresenter__blink_closure: {
    "^": "Closure:0;_captured_el_0",
    call$0: function() {
      return J.get$classes$x(this._captured_el_0).remove$1(0, "blink");
    }
  },
  HtmlPresenter__handleSavegameBookmarkClick_closure: {
    "^": "Closure:28;_egb_presenter_html$_captured_this_0",
    call$1: function(savegame) {
      var t1;
      H.interceptedTypeCheck(savegame, "$isEgbSavegame");
      t1 = this._egb_presenter_html$_captured_this_0;
      if (savegame == null)
        t1.reportError$2("Bad gamesave", "That savegame is missing.");
      else
        t1.showText$1(savegame.textHistory).then$1(new G.HtmlPresenter__handleSavegameBookmarkClick__closure(t1, savegame));
    }
  },
  HtmlPresenter__handleSavegameBookmarkClick__closure: {
    "^": "Closure:2;_egb_presenter_html$_captured_this_1,_captured_savegame_2",
    call$1: function(_) {
      this._egb_presenter_html$_captured_this_1.scripterProxy.load$1(0, this._captured_savegame_2);
    }
  },
  HtmlPresenter_showDialog_closure: {
    "^": "Closure:2;_egb_presenter_html$_captured_completer_0,_captured_dialogDiv_1,_captured_dialogButton_2",
    call$1: function(_) {
      if (H.boolTypeCheck(this._captured_dialogButton_2.behaviour$0())) {
        J.remove$0$ax(this._captured_dialogDiv_1);
        this._egb_presenter_html$_captured_completer_0.complete$1(0, true);
      }
    }
  },
  closure0: {
    "^": "Closure:25;",
    call$1: function(e) {
      return G.HtmlForm$(H.interceptedTypeCheck(e, "$isFormElement"));
    }
  },
  closure1: {
    "^": "Closure:25;",
    call$1: function(e) {
      return G.HtmlFormSection$(H.interceptedTypeCheck(e, "$isFormElement"));
    }
  },
  closure2: {
    "^": "Closure:25;",
    call$1: function(e) {
      return G.HtmlSubmitButton$(H.interceptedTypeCheck(e, "$isFormElement"));
    }
  },
  closure3: {
    "^": "Closure:25;",
    call$1: function(e) {
      var t1, t2, checkboxId, t3, t4;
      e = H.interceptedTypeCheck(H.interceptedTypeCheck(e, "$isFormElement"), "$isCheckboxInputBase");
      t1 = new G.HtmlCheckboxInput(null, null, null, null, null, false, null, false, e, null);
      t1.blueprint = e;
      P.print(H.stringTypeCheck(e.attributes.$index(0, "name")));
      t2 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      t2.toString;
      W._ElementCssClassSet__add(t2, "checkbox-input");
      t2.id = e.get$id(e);
      t1.HtmlCheckboxInput_uiRepresentation = t2;
      checkboxId = H.S(e.get$id(e)) + "-checkbox";
      t3 = W.InputElement_InputElement("checkbox");
      t3.id = checkboxId;
      t1._checkboxEl = t3;
      t4 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "label", null), "$isLabelElement");
      t4.htmlFor = checkboxId;
      (t4 && C.LabelElement_methods).setInnerHtml$1(t4, H.stringTypeCheck(e.attributes.$index(0, "name")));
      t1._labelEl = t4;
      J.append$1$x(t2, t3);
      J.append$1$x(t2, t4);
      t1.super$UiElement$update$0();
      t1._checkboxEl.checked = t1.blueprint.current;
      t4 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      t1._childrenDiv = t4;
      J.append$1$x(t1.HtmlCheckboxInput_uiRepresentation, t4);
      return t1;
    }
  },
  closure4: {
    "^": "Closure:25;",
    call$1: function(e) {
      var t1, t2;
      e = H.interceptedTypeCheck(H.interceptedTypeCheck(e, "$isFormElement"), "$isRangeInputBase");
      t1 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, W.RadioButtonInputElement), "$isMap", [P.$int, W.RadioButtonInputElement], "$asMap");
      t2 = P.StreamController_StreamController(null, null, null, null, false, null);
      t2 = new G.HtmlRangeInput(null, null, null, null, null, H.assertSubtype(t1, "$isMap", [P.$int, W.RadioButtonInputElement], "$asMap"), false, t2, null, false, null, false, e, null);
      t2.HtmlRangeBase$2(e, "range-input");
      return t2;
    }
  },
  closure5: {
    "^": "Closure:25;",
    call$1: function(e) {
      var t1, t2;
      e = H.interceptedTypeCheck(H.interceptedTypeCheck(e, "$isFormElement"), "$isRangeOutputBase");
      t1 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, W.RadioButtonInputElement), "$isMap", [P.$int, W.RadioButtonInputElement], "$asMap");
      t2 = P.StreamController_StreamController(null, null, null, null, false, null);
      t2 = new G.HtmlRangeOuput(null, null, null, null, null, H.assertSubtype(t1, "$isMap", [P.$int, W.RadioButtonInputElement], "$asMap"), false, t2, null, false, null, false, e, null);
      t2.HtmlRangeBase$2(e, "range-output");
      return t2;
    }
  },
  closure6: {
    "^": "Closure:25;",
    call$1: function(e) {
      var t1, t2;
      e = H.interceptedTypeCheck(H.interceptedTypeCheck(e, "$isFormElement"), "$isTextBase");
      t1 = new G.HtmlTextOuput(null, null, null, false, false, null, false, e, null);
      t1.blueprint = e;
      t2 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      t2.toString;
      W._ElementCssClassSet__add(t2, "text-output");
      t2.id = e.get$id(e);
      t1.HtmlTextOuput_uiRepresentation = t2;
      t1.super$UiElement$update$0();
      J.setInnerHtml$1$x(t1.HtmlTextOuput_uiRepresentation, t1.blueprint.html);
      t2 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      t1._childrenDiv = t2;
      J.append$1$x(t1.HtmlTextOuput_uiRepresentation, t2);
      return t1;
    }
  },
  closure7: {
    "^": "Closure:25;",
    call$1: function(e) {
      return G.HtmlMultipleChoiceInput$(H.interceptedTypeCheck(e, "$isFormElement"));
    }
  },
  closure8: {
    "^": "Closure:25;",
    call$1: function(e) {
      var t1, t2;
      e = H.interceptedTypeCheck(H.interceptedTypeCheck(e, "$isFormElement"), "$isOptionBase");
      t1 = new G.HtmlOption(null, null, false, P.StreamController_StreamController(null, null, null, null, false, null), false, null, false, e, null);
      t1.blueprint = e;
      t2 = W.OptionElement_OptionElement$_("", e.get$id(e), null, e.current);
      t2.textContent = H.stringTypeCheck(e.attributes.$index(0, "text"));
      t1.HtmlOption_uiRepresentation = t2;
      t1.super$UiElement$update$0();
      t1.HtmlOption_uiRepresentation.selected = t1.blueprint.current;
      return t1;
    }
  },
  HtmlUiElement: {
    "^": "UiElement;uiRepresentation<",
    set$hidden: function(_, value) {
      var t1, list;
      if (value) {
        t1 = this.get$uiRepresentation();
        t1.toString;
        W._ElementCssClassSet__add(t1, "display-none");
      } else {
        t1 = this.get$uiRepresentation();
        list = t1.classList;
        list.contains("display-none");
        list.remove("display-none");
      }
      this._hidden = value;
    }
  },
  HtmlForm: {
    "^": "HtmlUiElement;blueprint,uiRepresentation:HtmlForm_uiRepresentation<,_childrenContainerDiv,submitButton,_disabled,_onChangeController,uiRepresentation,_hidden,_blueprint,waitingForUpdate",
    appendChild$1: function(childUiRepresentation) {
      J.append$1$x(this._childrenContainerDiv, childUiRepresentation);
    },
    set$disabled: function(_, value) {
      var t1;
      this._disabled = value;
      t1 = this.submitButton;
      if (t1 != null)
        t1.disabled = value;
    },
    get$onChange: function(_) {
      var t1 = this._onChangeController;
      H.assertSubtype(t1, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle");
      return H.assertSubtype(H.setRuntimeTypeInfo(new P._ControllerStream(H.assertSubtype(t1, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle")), [null]), "$isStream", [H.getRuntimeTypeArgument(t1, "_StreamController", 0)], "$asStream");
    },
    update$0: function() {
      this.super$UiElement$update$0();
      var t1 = this.submitButton;
      if (t1 != null)
        t1.textContent = H.stringTypeCheck(this.blueprint.attributes.$index(0, "submitText"));
    },
    set$waitingForUpdate: function(_waitingForUpdate) {
    },
    get$current: function() {
      return;
    },
    HtmlForm$1: function(blueprint, _box_0) {
      var t1, submitText, t2, t3;
      H.interceptedTypeCheck(blueprint, "$isFormProxy");
      this.blueprint = blueprint;
      t1 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      t1.toString;
      W._ElementCssClassSet__add(t1, "form");
      this.HtmlForm_uiRepresentation = t1;
      t1 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      this._childrenContainerDiv = t1;
      J.append$1$x(this.HtmlForm_uiRepresentation, t1);
      submitText = H.stringTypeCheck(blueprint.attributes.$index(0, "submitText"));
      if (submitText != null) {
        t1 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "button", null), "$isButtonElement");
        t1.toString;
        W._ElementCssClassSet__add(t1, "submit-main");
        t1.textContent = submitText;
        this.submitButton = t1;
        _box_0._captured_subscription_0 = null;
        t1.toString;
        t1 = H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(t1, "click", false), [null]), "$isElementStream", [H.getTypeArgumentByIndex(C.EventStreamProvider_click, 0)], "$asElementStream"), "$isElementStream", [W.MouseEvent], "$asElementStream");
        t2 = new G.HtmlForm_closure(_box_0, this);
        t3 = H.getVoidRuntimeType();
        H.buildFunctionType(t3, [t1.T1()])._assertCheck$1(t2);
        H.buildFunctionType(t3)._assertCheck$1(null);
        t2 = H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(t2), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)]);
        t2._tryResume$0();
        _box_0._captured_subscription_0 = H.assertSubtype(t2, "$isStreamSubscription", [H.getTypeArgumentByIndex(t1, 0)], "$asStreamSubscription");
        J.append$1$x(this.HtmlForm_uiRepresentation, this.submitButton);
      }
    },
    static: {HtmlForm$: function(blueprint) {
        var t1;
        H.interceptedTypeCheck(blueprint, "$isFormProxy");
        t1 = new G.HtmlForm(null, null, null, null, false, P.StreamController_StreamController(null, null, null, null, false, null), null, false, blueprint, null);
        t1.HtmlForm$1(blueprint, {});
        return t1;
      }}
  },
  HtmlForm_closure: {
    "^": "Closure:2;_egb_presenter_html$_box_0,_egb_presenter_html$_captured_this_1",
    call$1: function(ev) {
      var t1 = this._egb_presenter_html$_captured_this_1._onChangeController;
      H.assertSubtypeOfRuntimeType(ev, H.getRuntimeTypeArgument(t1, "_StreamController", 0));
      if (t1._state >= 4)
        H.throwExpression(t1._badEventState$0());
      t1._async$_add$1(ev);
      this._egb_presenter_html$_box_0._captured_subscription_0.cancel$0();
    }
  },
  HtmlFormSection: {
    "^": "HtmlUiElement;blueprint,uiRepresentation:HtmlFormSection_uiRepresentation<,_headerEl,_openCloseEl,_childrenDiv,disabled,HtmlFormSection_waitingForUpdate,uiRepresentation,_hidden,_blueprint,waitingForUpdate",
    set$disabled: function(_, disabled) {
      this.disabled = H.boolTypeCheck(disabled);
    },
    set$waitingForUpdate: function(waitingForUpdate) {
      this.HtmlFormSection_waitingForUpdate = H.boolTypeCheck(waitingForUpdate);
    },
    updateOpenCloseDomState$0: function() {
      var t1, list;
      t1 = this._childrenDiv;
      if (t1.classList.contains("closed")) {
        list = t1.classList;
        list.contains("closed");
        list.remove("closed");
        J.setInnerHtml$1$x(this._openCloseEl, "&#9665;");
        t1 = J._querySelectorAll$1$x(this.HtmlFormSection_uiRepresentation.parentElement, ".form-section");
        H.assertSubtype(t1, "$isList", [W.Node], "$asList");
        t1 = H.assertSubtype(new W._FrozenElementList(H.assertSubtype(t1, "$isList", [W.Node], "$asList")), "$isElementList", [W.Element], "$asElementList");
        t1.where$1(t1, new G.HtmlFormSection_updateOpenCloseDomState_closure(this)).forEach$1(0, new G.HtmlFormSection_updateOpenCloseDomState_closure0());
      } else {
        W._ElementCssClassSet__add(t1, "closed");
        J.setInnerHtml$1$x(this._openCloseEl, "&#9661;");
      }
    },
    appendChild$1: function(childUiRepresentation) {
      J.append$1$x(this._childrenDiv, childUiRepresentation);
    },
    get$current: function() {
      return this._headerEl.textContent;
    },
    get$onChange: function(_) {
      return;
    },
    update$0: function() {
      this.super$UiElement$update$0();
      this._headerEl.textContent = H.stringTypeCheck(this.blueprint.attributes.$index(0, "name"));
    },
    HtmlFormSection$1: function(blueprint) {
      var t1, titleWrapperDiv, t2, t3;
      H.interceptedTypeCheck(blueprint, "$isFormSection");
      this.blueprint = blueprint;
      t1 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      t1.toString;
      W._ElementCssClassSet__add(t1, "form-section");
      t1.id = blueprint.get$id(blueprint);
      this.HtmlFormSection_uiRepresentation = t1;
      titleWrapperDiv = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "button", null), "$isButtonElement");
      titleWrapperDiv.toString;
      W._ElementCssClassSet__add(titleWrapperDiv, "form-section-title-wrapper");
      t1 = H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(titleWrapperDiv, "click", false), [null]), "$isElementStream", [H.getTypeArgumentByIndex(C.EventStreamProvider_click, 0)], "$asElementStream"), "$isElementStream", [W.MouseEvent], "$asElementStream");
      t2 = new G.HtmlFormSection_closure(this);
      t3 = H.getVoidRuntimeType();
      H.buildFunctionType(t3, [t1.T1()])._assertCheck$1(t2);
      H.buildFunctionType(t3)._assertCheck$1(null);
      t2 = H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(t2), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)]);
      t2._tryResume$0();
      H.assertSubtype(t2, "$isStreamSubscription", [H.getTypeArgumentByIndex(t1, 0)], "$asStreamSubscription");
      t1 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      t1.toString;
      W._ElementCssClassSet__add(t1, "form-section-open-close");
      J.setInnerHtml$1$x(t1, "&#9661;");
      this._openCloseEl = t1;
      (titleWrapperDiv && C.ButtonElement_methods).append$1(titleWrapperDiv, t1);
      t1 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "span", null), "$isSpanElement");
      t1.toString;
      W._ElementCssClassSet__add(t1, "form-section-title");
      t1.textContent = H.stringTypeCheck(blueprint.attributes.$index(0, "name"));
      this._headerEl = t1;
      C.ButtonElement_methods.append$1(titleWrapperDiv, t1);
      J.append$1$x(this.HtmlFormSection_uiRepresentation, titleWrapperDiv);
      this.super$UiElement$update$0();
      this._headerEl.textContent = H.stringTypeCheck(this.blueprint.attributes.$index(0, "name"));
      t1 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      t1.toString;
      W._ElementCssClassSet__add(t1, "form-section-children");
      W._ElementCssClassSet__add(t1, "closed");
      this._childrenDiv = t1;
      J.append$1$x(this.HtmlFormSection_uiRepresentation, t1);
    },
    static: {HtmlFormSection$: function(blueprint) {
        var t1;
        H.interceptedTypeCheck(blueprint, "$isFormSection");
        t1 = new G.HtmlFormSection(null, null, null, null, null, false, false, null, false, blueprint, null);
        t1.HtmlFormSection$1(blueprint);
        return t1;
      }}
  },
  HtmlFormSection_closure: {
    "^": "Closure:2;_egb_presenter_html$_captured_this_0",
    call$1: function(_) {
      this._egb_presenter_html$_captured_this_0.updateOpenCloseDomState$0();
    }
  },
  HtmlFormSection_updateOpenCloseDomState_closure: {
    "^": "Closure:20;_egb_presenter_html$_captured_this_0",
    call$1: function(e) {
      var t1;
      H.interceptedTypeCheck(e, "$isElement");
      t1 = this._egb_presenter_html$_captured_this_0.HtmlFormSection_uiRepresentation;
      return e == null ? t1 != null : e !== t1;
    }
  },
  HtmlFormSection_updateOpenCloseDomState_closure0: {
    "^": "Closure:20;",
    call$1: function(e) {
      var t1;
      H.interceptedTypeCheck(e, "$isElement");
      t1 = J.getInterceptor$x(e);
      J.get$classes$x(t1.querySelector$1(e, ".form-section-children")).add$1(0, "closed");
      J.set$innerHtml$x(t1.querySelector$1(e, ".form-section-open-close"), "&#9661;");
    }
  },
  HtmlSubmitButton: {
    "^": "HtmlUiElement;blueprint,uiRepresentation:HtmlSubmitButton_uiRepresentation<,_childrenDiv,_disabled,_onChangeController,_waitingForUpdate,uiRepresentation,_hidden,_blueprint,waitingForUpdate",
    appendChild$1: function(childUiRepresentation) {
      J.append$1$x(this._childrenDiv, childUiRepresentation);
    },
    get$current: function() {
      return;
    },
    set$disabled: function(_, value) {
      this.HtmlSubmitButton_uiRepresentation.disabled = value;
      this._disabled = value;
    },
    get$onChange: function(_) {
      var t1 = this._onChangeController;
      H.assertSubtype(t1, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle");
      return H.assertSubtype(H.setRuntimeTypeInfo(new P._ControllerStream(H.assertSubtype(t1, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle")), [null]), "$isStream", [H.getRuntimeTypeArgument(t1, "_StreamController", 0)], "$asStream");
    },
    update$0: function() {
      this.super$UiElement$update$0();
      this.HtmlSubmitButton_uiRepresentation.textContent = H.stringTypeCheck(this.blueprint.attributes.$index(0, "name"));
    },
    set$waitingForUpdate: function(value) {
      this.HtmlSubmitButton_uiRepresentation.disabled = value;
      this._waitingForUpdate = value;
    },
    HtmlSubmitButton$1: function(blueprint) {
      var t1, t2, t3, t4;
      H.interceptedTypeCheck(blueprint, "$isPresenterSubmitButton");
      this.blueprint = blueprint;
      this._childrenDiv = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      t1 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "button", null), "$isButtonElement");
      t1.textContent = H.stringTypeCheck(blueprint.attributes.$index(0, "name"));
      t1.toString;
      W._ElementCssClassSet__add(t1, "submit-button");
      (t1 && C.ButtonElement_methods).append$1(t1, this._childrenDiv);
      t2 = H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(t1, "click", false), [null]), "$isElementStream", [H.getTypeArgumentByIndex(C.EventStreamProvider_click, 0)], "$asElementStream"), "$isElementStream", [W.MouseEvent], "$asElementStream");
      t3 = new G.HtmlSubmitButton_closure(this);
      t4 = H.getVoidRuntimeType();
      H.buildFunctionType(t4, [t2.T1()])._assertCheck$1(t3);
      H.buildFunctionType(t4)._assertCheck$1(null);
      t3 = H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t2._html$_target, t2._eventType, W._wrapZone(t3), t2._useCapture), [H.getTypeArgumentByIndex(t2, 0)]);
      t3._tryResume$0();
      H.assertSubtype(t3, "$isStreamSubscription", [H.getTypeArgumentByIndex(t2, 0)], "$asStreamSubscription");
      this.HtmlSubmitButton_uiRepresentation = t1;
      this.super$UiElement$update$0();
      this.HtmlSubmitButton_uiRepresentation.textContent = H.stringTypeCheck(this.blueprint.attributes.$index(0, "name"));
    },
    static: {HtmlSubmitButton$: function(blueprint) {
        var t1;
        H.interceptedTypeCheck(blueprint, "$isPresenterSubmitButton");
        t1 = new G.HtmlSubmitButton(null, null, null, false, P.StreamController_StreamController(null, null, null, null, false, null), false, null, false, blueprint, null);
        t1.HtmlSubmitButton$1(blueprint);
        return t1;
      }}
  },
  HtmlSubmitButton_closure: {
    "^": "Closure:2;_egb_presenter_html$_captured_this_0",
    call$1: function(ev) {
      var t1 = this._egb_presenter_html$_captured_this_0._onChangeController;
      H.assertSubtypeOfRuntimeType(ev, H.getRuntimeTypeArgument(t1, "_StreamController", 0));
      if (t1._state >= 4)
        H.throwExpression(t1._badEventState$0());
      t1._async$_add$1(ev);
    }
  },
  HtmlCheckboxInput: {
    "^": "HtmlUiElement;blueprint,uiRepresentation:HtmlCheckboxInput_uiRepresentation<,_checkboxEl,_labelEl,_childrenDiv,HtmlCheckboxInput_waitingForUpdate,uiRepresentation,_hidden,_blueprint,waitingForUpdate",
    set$waitingForUpdate: function(waitingForUpdate) {
      this.HtmlCheckboxInput_waitingForUpdate = H.boolTypeCheck(waitingForUpdate);
    },
    appendChild$1: function(childUiRepresentation) {
      J.append$1$x(this._childrenDiv, childUiRepresentation);
    },
    get$current: function() {
      return this._checkboxEl.checked;
    },
    get$onChange: function(_) {
      var t1 = this._checkboxEl;
      t1.toString;
      return H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(t1, "change", false), [null]), "$isElementStream", [H.getTypeArgumentByIndex(C.EventStreamProvider_change, 0)], "$asElementStream"), "$isElementStream", [W.Event], "$asElementStream");
    },
    update$0: function() {
      this.super$UiElement$update$0();
      this._checkboxEl.checked = this.blueprint.current;
    },
    set$disabled: function(_, value) {
      this._checkboxEl.disabled = value;
    }
  },
  HtmlRangeBase: {
    "^": "HtmlUiElement;uiRepresentation:HtmlRangeBase_uiRepresentation<",
    _createRadioButtons$0: function() {
      var i, t1, radioButton;
      i = this.blueprint.min;
      while (true) {
        t1 = this.blueprint.max;
        if (typeof i !== "number")
          return i.$le();
        if (!C.JSInt_methods.$le(i, t1))
          break;
        radioButton = this._createRadioButton$1(i);
        this._radioButtons.$indexSet(0, i, radioButton);
        J.append$1$x(this._radioButtonsDiv, radioButton);
        i = C.JSInt_methods.$add(i, this.blueprint.step);
      }
    },
    _updateRadioButtons$0: function() {
      this._radioButtons.forEach$1(0, new G.HtmlRangeBase__updateRadioButtons_closure(this));
    },
    appendChild$1: function(childUiRepresentation) {
      J.append$1$x(this._childrenDiv, childUiRepresentation);
    },
    set$disabled: function(_, value) {
      this._disabled = value;
      this._updateRadioButtons$0();
    },
    get$onChange: function(_) {
      var t1 = this._onChangeController;
      H.assertSubtype(t1, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle");
      return H.assertSubtype(H.setRuntimeTypeInfo(new P._ControllerStream(H.assertSubtype(t1, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle")), [null]), "$isStream", [H.getRuntimeTypeArgument(t1, "_StreamController", 0)], "$asStream");
    },
    get$current: function() {
      return this._egb_presenter_html$_current;
    },
    update$0: function() {
      this.super$UiElement$update$0();
      this._egb_presenter_html$_current = this.blueprint.current;
      this._updateRadioButtons$0();
      this._currentValueP.textContent = this.blueprint.get$currentStringRepresentation();
    },
    set$waitingForUpdate: function(value) {
      this._waitingForUpdate = value;
      this._updateRadioButtons$0();
    },
    HtmlRangeBase$2: function(blueprint, divClass) {
      var t1, label, buttonsAndValueDiv, t2;
      this.blueprint = blueprint;
      t1 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      t1.toString;
      W._ElementCssClassSet__add(t1, divClass);
      t1.id = blueprint.get$id(blueprint);
      this.HtmlRangeBase_uiRepresentation = t1;
      label = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "label", null), "$isLabelElement");
      label.htmlFor = blueprint.get$id(blueprint);
      (label && C.LabelElement_methods).setInnerHtml$1(label, H.stringTypeCheck(blueprint.attributes.$index(0, "name")));
      J.append$1$x(this.HtmlRangeBase_uiRepresentation, label);
      buttonsAndValueDiv = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      buttonsAndValueDiv.toString;
      W._ElementCssClassSet__add(buttonsAndValueDiv, "buttons-and-value");
      J.append$1$x(this.HtmlRangeBase_uiRepresentation, buttonsAndValueDiv);
      t1 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      t1.toString;
      W._ElementCssClassSet__add(t1, "buttons");
      this._radioButtonsDiv = t1;
      t2 = J.getInterceptor$x(buttonsAndValueDiv);
      t2.append$1(buttonsAndValueDiv, t1);
      t1 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "p", null), "$isParagraphElement");
      t1.toString;
      W._ElementCssClassSet__add(t1, "current-value");
      this._currentValueP = t1;
      t2.append$1(buttonsAndValueDiv, t1);
      this._createRadioButtons$0();
      t1 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      this._childrenDiv = t1;
      J.append$1$x(this.HtmlRangeBase_uiRepresentation, t1);
      this.update$0();
    }
  },
  HtmlRangeBase__updateRadioButtons_closure: {
    "^": "Closure:34;_egb_presenter_html$_captured_this_0",
    call$2: function(i, e) {
      return this._egb_presenter_html$_captured_this_0._updateRadioButton$2(H.intTypeCheck(i), H.interceptedTypeCheck(e, "$isRadioButtonInputElement"));
    }
  },
  HtmlRangeOuput: {
    "^": "HtmlRangeBase;blueprint,HtmlRangeBase_uiRepresentation,_childrenDiv,_radioButtonsDiv,_currentValueP,_radioButtons,_disabled,_onChangeController,_egb_presenter_html$_current,_waitingForUpdate,uiRepresentation,_hidden,_blueprint,waitingForUpdate",
    _createRadioButton$1: function(i) {
      var radioButton, result;
      radioButton = W.InputElement_InputElement("radio");
      result = this.blueprint.attributes.$index(0, "id");
      radioButton.name = H.stringTypeCheck(result != null ? result : "");
      radioButton.value = "" + i;
      radioButton.disabled = true;
      radioButton.checked = i === this.blueprint.current;
      return radioButton;
    },
    get$onChange: function(_) {
      return;
    },
    _updateRadioButton$2: function(i, radioButton) {
      var t1 = this.blueprint.current;
      J.set$checked$x(radioButton, i == null ? t1 == null : i === t1);
    }
  },
  HtmlRangeInput: {
    "^": "HtmlRangeBase;blueprint,HtmlRangeBase_uiRepresentation,_childrenDiv,_radioButtonsDiv,_currentValueP,_radioButtons,_disabled,_onChangeController,_egb_presenter_html$_current,_waitingForUpdate,uiRepresentation,_hidden,_blueprint,waitingForUpdate",
    _createRadioButton$1: function(i) {
      var radioButton, result, t1, t2, t3;
      radioButton = W.InputElement_InputElement("radio");
      result = this.blueprint.attributes.$index(0, "id");
      radioButton.name = H.stringTypeCheck(result != null ? result : "");
      radioButton.checked = i === this.blueprint.current;
      radioButton.value = "" + i;
      this._updateRadioButton$2(i, radioButton);
      radioButton.toString;
      t1 = new W._ElementEventStreamImpl(radioButton, "click", false);
      H.assertHelper(true);
      t1.$builtinTypeInfo = [null];
      t1 = H.assertSubtype(H.assertSubtype(t1, "$isElementStream", [H.getTypeArgumentByIndex(C.EventStreamProvider_click, 0)], "$asElementStream"), "$isElementStream", [W.MouseEvent], "$asElementStream");
      t2 = new G.HtmlRangeInput__createRadioButton_closure(this, i, radioButton);
      t3 = H.getVoidRuntimeType();
      H.buildFunctionType(t3, [t1.T1()])._assertCheck$1(t2);
      H.buildFunctionType(t3)._assertCheck$1(null);
      t2 = new W._EventStreamSubscription(0, radioButton, "click", W._wrapZone(t2), false);
      H.assertHelper(true);
      t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
      t3 = t2._onData;
      if (t3 != null && t2._pauseCount <= 0)
        J.addEventListener$3$x(t2._html$_target, "click", t3, false);
      H.assertSubtype(t2, "$isStreamSubscription", [H.getTypeArgumentByIndex(t1, 0)], "$asStreamSubscription");
      return radioButton;
    },
    _updateRadioButton$2: function(i, radioButton) {
      var t1, t2;
      t1 = this.blueprint.current;
      t2 = J.getInterceptor$x(radioButton);
      t2.set$checked(radioButton, i == null ? t1 == null : i === t1);
      t1 = this.blueprint.minEnabled;
      if (t1 != null) {
        if (typeof i !== "number")
          return i.$lt();
        t1 = C.JSInt_methods.$lt(i, t1);
      } else
        t1 = false;
      if (!t1) {
        t1 = this.blueprint.maxEnabled;
        if (t1 != null) {
          if (typeof i !== "number")
            return i.$gt();
          t1 = C.JSInt_methods.$gt(i, t1);
        } else
          t1 = false;
        t1 = t1 || this._disabled || this._waitingForUpdate;
      } else
        t1 = true;
      t2.set$disabled(radioButton, t1);
    }
  },
  HtmlRangeInput__createRadioButton_closure: {
    "^": "Closure:2;_egb_presenter_html$_captured_this_0,_captured_i_1,_captured_radioButton_2",
    call$1: function(ev) {
      var t1;
      if (!H.boolConversionCheck(this._captured_radioButton_2.disabled)) {
        t1 = this._egb_presenter_html$_captured_this_0;
        t1._egb_presenter_html$_current = this._captured_i_1;
        t1 = t1._onChangeController;
        H.assertSubtypeOfRuntimeType(ev, H.getRuntimeTypeArgument(t1, "_StreamController", 0));
        if (t1._state >= 4)
          H.throwExpression(t1._badEventState$0());
        t1._async$_add$1(ev);
      }
    }
  },
  HtmlTextOuput: {
    "^": "HtmlUiElement;blueprint,uiRepresentation:HtmlTextOuput_uiRepresentation<,_childrenDiv,disabled,HtmlTextOuput_waitingForUpdate,uiRepresentation,_hidden,_blueprint,waitingForUpdate",
    set$disabled: function(_, disabled) {
      this.disabled = H.boolTypeCheck(disabled);
    },
    set$waitingForUpdate: function(waitingForUpdate) {
      this.HtmlTextOuput_waitingForUpdate = H.boolTypeCheck(waitingForUpdate);
    },
    appendChild$1: function(childUiRepresentation) {
      J.append$1$x(this._childrenDiv, childUiRepresentation);
    },
    get$current: function() {
      return this.HtmlTextOuput_uiRepresentation.textContent;
    },
    get$onChange: function(_) {
      return;
    },
    update$0: function() {
      this.super$UiElement$update$0();
      J.setInnerHtml$1$x(this.HtmlTextOuput_uiRepresentation, this.blueprint.html);
    }
  },
  HtmlMultipleChoiceInput: {
    "^": "HtmlUiElement;blueprint,uiRepresentation:HtmlMultipleChoiceInput_uiRepresentation<,_labelElement,_childrenSelectElement,_disabled,_waitingForUpdate,uiRepresentation,_hidden,_blueprint,waitingForUpdate",
    appendChild$1: function(childUiRepresentation) {
      var t1;
      H.assertHelper(!!J.getInterceptor(childUiRepresentation).$isOptionElement);
      t1 = this._childrenSelectElement;
      (t1 && C.SelectElement_methods).append$1(t1, childUiRepresentation);
    },
    get$current: function() {
      return;
    },
    set$disabled: function(_, value) {
      this._childrenSelectElement.disabled = value;
      this._disabled = value;
    },
    get$onChange: function(_) {
      return;
    },
    set$waitingForUpdate: function(value) {
      this._childrenSelectElement.disabled = value;
      this._waitingForUpdate = value;
    },
    HtmlMultipleChoiceInput$1: function(blueprint) {
      var t1, t2, t3, t4;
      H.interceptedTypeCheck(blueprint, "$isMultipleChoiceInputBase");
      this.blueprint = blueprint;
      t1 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "div", null), "$isDivElement");
      t1.toString;
      W._ElementCssClassSet__add(t1, "multiple-choice-input");
      t1.id = blueprint.get$id(blueprint);
      this.HtmlMultipleChoiceInput_uiRepresentation = t1;
      t1 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "label", null), "$isLabelElement");
      t1.textContent = H.stringTypeCheck(blueprint.attributes.$index(0, "name"));
      this._labelElement = t1;
      J.append$1$x(this.HtmlMultipleChoiceInput_uiRepresentation, t1);
      t1 = H.interceptedTypeCheck(C.HtmlDocument_methods._createElement$2(document, "select", null), "$isSelectElement");
      t1.toString;
      t2 = H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new W._ElementEventStreamImpl(t1, "change", false), [null]), "$isElementStream", [H.getTypeArgumentByIndex(C.EventStreamProvider_change, 0)], "$asElementStream"), "$isElementStream", [W.Event], "$asElementStream");
      t3 = new G.HtmlMultipleChoiceInput_closure(this, blueprint);
      t4 = H.getVoidRuntimeType();
      H.buildFunctionType(t4, [t2.T1()])._assertCheck$1(t3);
      H.buildFunctionType(t4)._assertCheck$1(null);
      t3 = H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t2._html$_target, t2._eventType, W._wrapZone(t3), t2._useCapture), [H.getTypeArgumentByIndex(t2, 0)]);
      t3._tryResume$0();
      H.assertSubtype(t3, "$isStreamSubscription", [H.getTypeArgumentByIndex(t2, 0)], "$asStreamSubscription");
      this._childrenSelectElement = t1;
      J.append$1$x(this.HtmlMultipleChoiceInput_uiRepresentation, t1);
      this.update$0();
    },
    static: {HtmlMultipleChoiceInput$: function(blueprint) {
        var t1;
        H.interceptedTypeCheck(blueprint, "$isMultipleChoiceInputBase");
        t1 = new G.HtmlMultipleChoiceInput(null, null, null, null, false, false, null, false, blueprint, null);
        t1.HtmlMultipleChoiceInput$1(blueprint);
        return t1;
      }}
  },
  HtmlMultipleChoiceInput_closure: {
    "^": "Closure:35;_egb_presenter_html$_captured_this_0,_captured_blueprint_1",
    call$1: function(ev) {
      var t1, childOptions, t2, t3, t4, el, e;
      H.interceptedTypeCheck(ev, "$isEvent");
      t1 = this._egb_presenter_html$_captured_this_0;
      if (!H.boolConversionCheck(t1._childrenSelectElement.disabled)) {
        childOptions = H.assertSubtype([], "$isList", [Q.PresenterOption], "$asList");
        for (t2 = this._captured_blueprint_1, t2 = t2.get$children(t2).get$_dom$_filtered(), t3 = H.getTypeArgumentByIndex(t2, 0), H.assertSubtype(t2, "$isJSArray", [t3], "$asJSArray"), t4 = t2.length, t2 = H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t2, "$isJSArray", [t3], "$asJSArray"), t4, 0, H.assertSubtypeOfRuntimeType(null, t3)), [t3]), "$isIterator", [H.getTypeArgumentByIndex(t2, 0)], "$asIterator"), "$isIterator", [B.Element1], "$asIterator"); t2.moveNext$0();) {
          el = H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(t2._current, H.getTypeArgumentByIndex(t2, 0)), "$isElement1");
          if (el instanceof Q.PresenterOption)
            C.JSArray_methods.add$1(childOptions, el);
        }
        t1 = H.interceptedTypeCheck(C.JSArray_methods.$index(childOptions, t1._childrenSelectElement.selectedIndex).uiElement, "$isHtmlOption")._onChangeController;
        e = C.HtmlDocument_methods._createEvent$1(document, "Event");
        J._initEvent$3$x(e, "select", true, true);
        H.assertSubtypeOfRuntimeType(e, H.getRuntimeTypeArgument(t1, "_StreamController", 0));
        if (t1._state >= 4)
          H.throwExpression(t1._badEventState$0());
        t1._async$_add$1(e);
      }
    }
  },
  HtmlOption: {
    "^": "HtmlUiElement;blueprint,uiRepresentation:HtmlOption_uiRepresentation<,_disabled,_onChangeController,_waitingForUpdate,uiRepresentation,_hidden,_blueprint,waitingForUpdate",
    appendChild$1: function(childUiRepresentation) {
      throw H.wrapException("Not implemented: adding children to Option");
    },
    get$current: function() {
      return this.HtmlOption_uiRepresentation.selected;
    },
    set$disabled: function(_, value) {
      this.HtmlOption_uiRepresentation.disabled = value;
      this._disabled = value;
    },
    set$hidden: function(_, value) {
      if (value)
        throw H.wrapException("Can't hide a <option> in a select");
    },
    get$onChange: function(_) {
      var t1 = this._onChangeController;
      H.assertSubtype(t1, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle");
      return H.assertSubtype(H.setRuntimeTypeInfo(new P._ControllerStream(H.assertSubtype(t1, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle")), [null]), "$isStream", [H.getRuntimeTypeArgument(t1, "_StreamController", 0)], "$asStream");
    },
    update$0: function() {
      this.super$UiElement$update$0();
      this.HtmlOption_uiRepresentation.selected = this.blueprint.current;
    },
    set$waitingForUpdate: function(value) {
      this.HtmlOption_uiRepresentation.disabled = value;
      this._waitingForUpdate = value;
    }
  },
  Submenu: {
    "^": "Object;name>,choices<"
  },
  Dialog: {
    "^": "Object;title,html,buttons"
  },
  DialogButton: {
    "^": "Object;label,_behaviour",
    get$behaviour: function() {
      return H.buildFunctionType(H.buildInterfaceType(P.bool))._assertCheck$1($.get$DialogButton_NO_BEHAVIOUR());
    },
    behaviour$0: function() {
      return this.get$behaviour().call$0();
    }
  },
  closure: {
    "^": "Closure:0;",
    call$0: function() {
      return true;
    }
  },
  PointsAwardElement: {
    "^": "PointsAward;element,action,done<,addition,result,justification",
    action$0: function($receiver) {
      return this.action.call$0();
    },
    $isEgbMetaElement: 1
  },
  EgbMetaElement: {
    "^": "Object;"
  },
  LocalStorage: {
    "^": "Object;",
    load$1: function(_, key) {
      var t1, result;
      t1 = window.localStorage;
      result = (t1 && C.Storage_methods)._getItem$1(t1, key);
      t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
      t1._asyncComplete$1(result);
      return H.assertSubtype(H.assertSubtype(t1, "$isFuture", [null], "$asFuture"), "$isFuture", [P.String], "$asFuture");
    },
    $isEgbStorage: 1
  },
  FootnoteSupTagSyntax: {
    "^": "TagSyntax;title,endPattern,tag,pattern",
    onMatch$2: function(parser, match) {
      var t1 = match._match;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      this.title = H.stringTypeCheck(t1[1]);
      return this.super$TagSyntax$onMatch$2(parser, match);
    },
    onMatchEnd$3: function(parser, match, state) {
      var t1, t2;
      t1 = state.children;
      H.assertSubtype(t1, "$isList", [T.Node0], "$asList");
      H.assertSubtype(t1, "$isList", [T.Node0], "$asList");
      t2 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.String), "$isMap", [P.String, P.String], "$asMap");
      t2.$indexSet(0, "class", "footnote");
      t2.$indexSet(0, "title", this.title);
      C.JSArray_methods.add$1(C.JSArray_methods.get$last(parser._stack).children, new T.Element0(this.tag, t1, t2));
      return true;
    }
  }
}],
["egb_runner", "package:egamebook/runner.dart", , M, {
  "^": "",
  runFromIsolate: function(dartFilename, presenter, storage) {
    var t1 = new V.EgbPlayerProfile("default", null, H.assertSubtype(null, "$isMap", [P.String, null], "$asMap"), H.assertSubtype(null, "$isQueue", [P.String], "$asQueue"), storage, 10);
    t1._loadPreferences$0();
    presenter._playerProfile = t1;
    return H.assertSubtype(M.init(new M.EgbIsolateScripterProxy(P.Uri_parse(dartFilename, 0, null), null, null, null, null, null), presenter).then$1(new M.runFromIsolate_closure(presenter)), "$isFuture", [B.EgbPresenter], "$asFuture");
  },
  init: function(bookProxy, presenter) {
    var t1, t2, t3, t4;
    t1 = bookProxy._isolateUri;
    P.print("INT: " + ("Initializing the isolate at " + t1.toString$0(0)));
    bookProxy._initCompleter = H.assertSubtype(H.setRuntimeTypeInfo(new P._AsyncCompleter(H.assertSubtype(H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]), "$is_Future", [null], "$as_Future")), [null]), "$isCompleter", [null], "$asCompleter");
    t2 = $.RawReceivePortImpl__nextFreeId;
    $.RawReceivePortImpl__nextFreeId = t2 + 1;
    t3 = new H.RawReceivePortImpl(t2, null, false);
    t4 = init.globalState.currentContext;
    t4._addRegistration$2(t2, t3);
    t4._updateGlobalState$0();
    t4 = new H.ReceivePortImpl(t3, null);
    t4.ReceivePortImpl$fromRawReceivePort$1(t3);
    bookProxy._receivePort = t4;
    P.Isolate_spawnUri(t1, [], new H._NativeJsSendPort(t3, init.globalState.currentContext.id), null, false);
    t3 = bookProxy._receivePort;
    t1 = bookProxy.get$_onMessageFromScripterIsolate();
    t3.toString;
    t4 = H.getVoidRuntimeType();
    H.buildFunctionType(t4, [H.getDynamicRuntimeType()])._assertCheck$1(t1);
    H.buildFunctionType(t4)._assertCheck$1(null);
    t3 = t3._controller;
    t3.toString;
    H.assertSubtype(t3, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle");
    H.assertSubtype(H.setRuntimeTypeInfo(new P._ControllerStream(H.assertSubtype(t3, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle")), [null]), "$isStream", [H.getRuntimeTypeArgument(t3, "_StreamController", 0)], "$asStream").listen$4$cancelOnError$onDone$onError(t1, null, null, null);
    return H.assertSubtype(bookProxy._initCompleter.future.then$1(new M.init_closure(bookProxy, presenter)), "$isFuture", [B.EgbPresenter], "$asFuture");
  },
  runFromIsolate_closure: {
    "^": "Closure:2;_captured_presenter_0",
    call$1: function(_) {
      var t1 = this._captured_presenter_0;
      t1.setup$0();
      t1.continueSavedGameOrCreateNew$0();
    }
  },
  init_closure: {
    "^": "Closure:2;_captured_bookProxy_0,_captured_presenter_1",
    call$1: function(_) {
      var t1, t2;
      t1 = this._captured_presenter_1;
      t2 = this._captured_bookProxy_0;
      t1.scripterProxy = t2;
      t2.presenter = t1;
      if (t2.get$uid() != null)
        t1._playerProfile.currentEgamebookUid = t2.get$uid();
      else
        H.throwExpression("Setting presenter before we have uid (before initialization).");
      return t1;
    }
  }
}],
["egb_savegame", "package:egamebook/src/persistence/savegame.dart", , Z, {
  "^": "",
  EgbSavegame: {
    "^": "Object;currentPageName,pageMapState,vars,textHistory,uid,timestamp",
    set$pageMapState: function(pageMapState) {
      this.pageMapState = H.assertSubtype(pageMapState, "$isMap", [P.String, null], "$asMap");
    },
    set$vars: function(vars) {
      this.vars = H.assertSubtype(vars, "$isMap", [P.String, P.Object], "$asMap");
    },
    toJson$0: function() {
      var saveMap, t1;
      saveMap = H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, null), "$isMap", [P.String, null], "$asMap"), "$isMap", [P.String, null], "$asMap");
      saveMap.$indexSet(0, "uid", this.uid);
      saveMap.$indexSet(0, "currentPageName", this.currentPageName);
      saveMap.$indexSet(0, "pageMapState", this.pageMapState);
      saveMap.$indexSet(0, "vars", this.vars);
      saveMap.$indexSet(0, "timestamp", this.timestamp);
      t1 = this.textHistory;
      if (t1 != null)
        saveMap.$indexSet(0, "previousText", t1);
      return C.JsonCodec_null_null.encode$1(saveMap);
    },
    toString$0: function(_) {
      return this.toJson$0();
    },
    EgbSavegame$fromJson$1: function(json) {
      var saveMap, t1;
      H.stringTypeCheck(json);
      saveMap = H.assertSubtype(C.JsonCodec_null_null.decode$1(json), "$isMap", [P.String, null], "$asMap");
      t1 = J.getInterceptor$x(saveMap);
      if (!H.boolConversionCheck(t1.containsKey$1(saveMap, "currentPageName")) || !H.boolConversionCheck(t1.containsKey$1(saveMap, "vars")))
        throw H.wrapException(new Z.InvalidSavegameException("Invalid JSON for EgbSavegame. Doesn't contain required fields 'currentPageName' or 'vars'. JSON='" + H.S(json) + "'."));
      this.uid = H.stringTypeCheck(t1.$index(saveMap, "uid"));
      this.currentPageName = H.stringTypeCheck(t1.$index(saveMap, "currentPageName"));
      this.timestamp = H.intTypeCheck(t1.$index(saveMap, "timestamp"));
      this.set$pageMapState(t1.$index(saveMap, "pageMapState"));
      this.set$vars(t1.$index(saveMap, "vars"));
      if (H.boolConversionCheck(t1.containsKey$1(saveMap, "previousText")))
        this.textHistory = H.stringTypeCheck(t1.$index(saveMap, "previousText"));
    },
    static: {EgbSavegame$fromJson: function(json) {
        var t1;
        H.stringTypeCheck(json);
        t1 = new Z.EgbSavegame(null, H.assertSubtype(null, "$isMap", [P.String, null], "$asMap"), H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"), null, null, null);
        t1.EgbSavegame$fromJson$1(json);
        return t1;
      }}
  },
  InvalidSavegameException: {
    "^": "Object;message",
    toString$0: function(_) {
      return "InvalidSavegameException: " + this.message;
    },
    $isException: 1
  }
}],
["egb_scripter_proxy", "package:egamebook/src/book/scripter_proxy.dart", , M, {
  "^": "",
  EgbScripterViewedFromPresenter: {
    "^": "Object;"
  },
  EgbScripterProxy: {
    "^": "EgbScripterViewedFromPresenter;"
  },
  EgbIsolateScripterProxy: {
    "^": "EgbScripterProxy;_isolateUri,_receivePort,_scripterPort,_uid,_initCompleter,presenter",
    get$uid: function() {
      return this._uid;
    },
    _onMessageFromScripterIsolate$1: [function(_message) {
      var t1, t2, message, savegame, t3, t4, t5, formProxy, form;
      t1 = J.getInterceptor(_message);
      if (!!t1.$isSendPort) {
        P.print("INT: Received SendPort from Isolate");
        this._scripterPort = _message;
        this._send$1(new A.EgbMessage(1000, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap")));
        return;
      }
      H.assertHelper(!!t1.$isMap);
      _message = H.assertSubtype(H.subtypeCast(_message, "$isMap", [P.String, P.Object], "$asMap"), "$isMap", [P.String, P.Object], "$asMap");
      H.assertSubtype(_message, "$isMap", [P.String, P.Object], "$asMap");
      t2 = H.intTypeCheck(t1.$index(_message, "type"));
      message = new A.EgbMessage(t2, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
      H.assertSubtype(_message, "$isMap", [P.String, P.Object], "$asMap");
      if (H.boolConversionCheck(t1.containsKey$1(_message, "strContent")))
        message.strContent = H.stringTypeCheck(t1.$index(_message, "strContent"));
      if (H.boolConversionCheck(t1.containsKey$1(_message, "listContent")))
        message.listContent = H.listTypeCheck(t1.$index(_message, "listContent"));
      if (H.boolConversionCheck(t1.containsKey$1(_message, "intContent")))
        message.intContent = H.intTypeCheck(t1.$index(_message, "intContent"));
      if (H.boolConversionCheck(t1.containsKey$1(_message, "mapContent")))
        message.set$mapContent(t1.$index(_message, "mapContent"));
      if (t2 !== 667)
        P.print("INT: " + ("Received: " + message.toString$0(0)));
      switch (t2) {
        case 80:
          t1 = this.presenter;
          t1.toString;
          P.print("The book has ended.");
          if (t1.currentActivity === 1) {
            t2 = t1.bookDiv;
            H.assertSubtype(new W._ChildrenElementList(t2, t2.children), "$isList", [W.Element], "$asList");
            J._clearChildren$0$x(t2);
            t1 = t1.scripterProxy;
            t1.toString;
            t1._send$1(new A.EgbMessage(1010, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap")));
          }
          return;
        case 10:
          P.print("INT: " + ("Book UID received ('" + H.S(message.strContent) + "')"));
          this._uid = message.strContent;
          this._initCompleter.complete$0(0);
          return;
        case 50:
          savegame = Z.EgbSavegame$fromJson(message.strContent);
          t1 = this.presenter._textHistory._contents;
          savegame.textHistory = t1.charCodeAt(0) == 0 ? t1 : t1;
          t1 = this.presenter;
          t1._textHistory._contents = "";
          t1._playerProfile.save$1(savegame);
          P.print("Creating savegame bookmark for " + H.S(savegame.uid));
          t1._savegameToBe = savegame;
          t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null), [null]);
          t1._asyncComplete$1(true);
          H.assertSubtype(H.assertSubtype(t1, "$isFuture", [null], "$asFuture"), "$isFuture", [P.bool], "$asFuture");
          return;
        case 60:
          t1 = this.presenter._playerProfile;
          t2 = J.toSet$0$ax(message.listContent);
          t1.toString;
          H.assertSubtype(t2, "$isSet", [P.String], "$asSet");
          H.assertSubtype(t1._save$2("_playerChronology", C.JsonCodec_null_null.encode$1(t2.toList$1$growable(0, false))), "$isFuture", [P.bool], "$asFuture");
          return;
        case 30:
          this.presenter.showText$1(message.strContent).then$1(new M.EgbIsolateScripterProxy__onMessageFromScripterIsolate_closure(this));
          return;
        case 20:
          this._send$1(new A.EgbMessage(1040, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap")));
          return;
        case 70:
          this.presenter.awardPoints$1(new A.PointsAward(H.intTypeCheck(J.$index$asx(message.listContent, 0)), H.intTypeCheck(J.$index$asx(message.listContent, 1)), message.strContent)).then$1(new M.EgbIsolateScripterProxy__onMessageFromScripterIsolate_closure0(this));
          return;
        case 90:
          this.presenter.setStats$1(Z.UIStat_overwriteStatsListFromDataStructure(message.listContent));
          return;
        case 100:
          P.print("RUN: Received updated stats.");
          this.presenter.updateStats$1(Z.StatUpdateCollection$fromMap(message.mapContent));
          return;
        case 40:
          P.print("INT: Showing choices.");
          this.presenter.showChoices$1(L.EgbChoiceList$fromMessage(message)).then$1(new M.EgbIsolateScripterProxy__onMessageFromScripterIsolate_closure1(this));
          return;
        case 110:
          P.print("INT: Showing form.");
          t1 = H.assertSubtype(P.LinkedHashSet_LinkedHashSet(null, null, null, P.StreamSubscription), "$isSet", [P.StreamSubscription], "$asSet");
          t2 = P.StreamController_StreamController(null, null, null, null, false, G.CurrentState);
          t3 = message.mapContent;
          t4 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
          t5 = H.setRuntimeTypeInfo([], [B.Node1]);
          t5 = new B.NodeList(null, H.assertSubtype(t5, "$isList", [B.Node1], "$asList"));
          formProxy = new Q.FormProxy(null, H.assertSubtype(t1, "$isSet", [P.StreamSubscription], "$asSet"), H.assertSubtype(t2, "$isStreamController", [G.CurrentState], "$asStreamController"), null, "Form", null, H.assertSubtype(t4, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap"), t5, H.assertSubtype(null, "$isList", [B.Element1], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
          t5._dom$_parent = formProxy;
          formProxy.FormProxy$fromMap$1(t3);
          t3 = this.presenter;
          if (t3.currentActivity === 1)
            t3._bookReadyHandler$0();
          t3._formProxy = formProxy;
          t1 = $.get$ELEMENT_BUILDERS();
          H.assertSubtype(t1, "$isMap", [P.String, {func: "", ret: Q.UiElement, args: [G.FormElement]}], "$asMap");
          form = H.interceptedTypeCheck(formProxy._recursiveCreateUiElement$2(t1, formProxy), "$isHtmlForm");
          J.append$1$x(t3.bookDiv, form.HtmlForm_uiRepresentation);
          t3._attachFootnoteClickListeners$1(form.HtmlForm_uiRepresentation);
          t3._showLoading$1(false);
          t3 = t3._formProxy._streamController;
          H.assertSubtype(t3, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle");
          H.assertSubtype(H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new P._ControllerStream(H.assertSubtype(t3, "$is_StreamControllerLifecycle", [null], "$as_StreamControllerLifecycle")), [null]), "$isStream", [H.getRuntimeTypeArgument(t3, "_StreamController", 0)], "$asStream"), "$isStream", [G.CurrentState], "$asStream"), "$isStream", [G.CurrentState], "$asStream").listen$1(new M.EgbIsolateScripterProxy__onMessageFromScripterIsolate_closure2(this));
          return;
        case 120:
          P.print("INT: Updating form.");
          t1 = message.mapContent;
          H.assertSubtype(t1, "$isMap", [P.String, [P.Map, P.String, P.Object]], "$asMap");
          H.assertSubtype(t1, "$isMap", [P.String, [P.Map, P.String, P.Object]], "$asMap");
          this.presenter._formProxy.update$1(new G.FormConfiguration(t1));
          return;
        case 666:
          P.print("INT: " + ("SCRIPTER ERROR: " + H.S(message.strContent)));
          this.presenter.reportError$2("Scripter Error", message.strContent);
          return;
        case 667:
          P.print("INT: " + ("Scripter: " + H.S(message.strContent)));
          return;
        default:
          throw H.wrapException("Message " + message.toString$0(0) + " not expected by Runner.");
      }
    }, "call$1", "get$_onMessageFromScripterIsolate", 2, 0, 36],
    _send$1: function(message) {
      var t1 = this._scripterPort;
      if (t1 == null)
        throw H.wrapException(P.StateError$("Cannot send message when _scripterPort is null."));
      t1.send$1(0, message.toMap$0());
    },
    load$2: function(_, savegame, playerChronology) {
      var message;
      H.assertSubtype(playerChronology, "$isSet", [P.String], "$asSet");
      savegame.toString;
      message = new A.EgbMessage(1020, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
      message.strContent = savegame.toJson$0();
      if (playerChronology != null)
        message.listContent = playerChronology.toList$1$growable(0, false);
      else
        message.listContent = null;
      this._send$1(message);
    },
    load$1: function($receiver, savegame) {
      return this.load$2($receiver, savegame, null);
    }
  },
  EgbIsolateScripterProxy__onMessageFromScripterIsolate_closure: {
    "^": "Closure:2;_egb_scripter_proxy$_captured_this_0",
    call$1: function(_) {
      this._egb_scripter_proxy$_captured_this_0._send$1(new A.EgbMessage(1040, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap")));
    }
  },
  EgbIsolateScripterProxy__onMessageFromScripterIsolate_closure0: {
    "^": "Closure:2;_egb_scripter_proxy$_captured_this_1",
    call$1: function(_) {
      this._egb_scripter_proxy$_captured_this_1._send$1(new A.EgbMessage(1040, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap")));
    }
  },
  EgbIsolateScripterProxy__onMessageFromScripterIsolate_closure1: {
    "^": "Closure:37;_egb_scripter_proxy$_captured_this_2",
    call$1: function(hash) {
      var t1, t2;
      H.intTypeCheck(hash);
      t1 = this._egb_scripter_proxy$_captured_this_2;
      if (hash != null) {
        t2 = new A.EgbMessage(1050, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
        t2.intContent = hash;
        t1._send$1(t2);
      } else {
        if (t1._scripterPort != null)
          t1._send$1(new A.EgbMessage(1070, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap")));
        t1 = t1._receivePort;
        t1._rawPort.close$0(0);
        t1._controller.close$0(0);
      }
    }
  },
  EgbIsolateScripterProxy__onMessageFromScripterIsolate_closure2: {
    "^": "Closure:38;_captured_this_3",
    call$1: function(state) {
      var t1;
      H.interceptedTypeCheck(state, "$isCurrentState");
      P.print("INT: Form updated or submitted by player.");
      t1 = new A.EgbMessage(1060, null, null, null, H.assertSubtype(null, "$isMap", [P.String, P.Object], "$asMap"));
      t1.set$mapContent(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$from(state._valuesMap, null, null), "$isMap", [P.String, P.Object], "$asMap"));
      this._captured_this_3._send$1(t1);
    }
  }
}],
["egb_user_interaction", "package:egamebook/src/shared/user_interaction.dart", , L, {
  "^": "",
  EgbUserInteraction: {
    "^": "Object;"
  },
  EgbChoice: {
    "^": "EgbUserInteraction;string,f,$goto,submenu<,shown,deferToEndOfPage,deferToChoiceList,hash",
    compareTo$1: function(_, other) {
      H.interceptedTypeCheck(other, "$isEgbChoice");
      return J.compareTo$1$ns(this.string, other.string);
    },
    toString$0: function(_) {
      return "Choice: " + H.S(this.string) + " [" + H.S(this.$goto) + "]";
    },
    $isComparable: 1,
    $asComparable: $.functionThatReturnsNull
  },
  EgbChoiceList: {
    "^": "ListBase;question,_choices",
    get$length: function(_) {
      return this._choices.length;
    },
    set$length: function(_, value) {
      C.JSArray_methods.set$length(this._choices, value);
      return value;
    },
    $index: function(_, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = this._choices;
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $indexSet: function(_, index, value) {
      var t1;
      H.interceptedTypeCheck(value, "$isEgbChoice");
      t1 = this._choices;
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      t1[index] = value;
      return value;
    },
    add$6$deferToChoiceList$deferToEndOfPage$goto$script$submenu: function(_, element, deferToChoiceList, deferToEndOfPage, $goto, script, submenu) {
      var choice;
      if (!!J.getInterceptor(element).$isEgbChoice)
        C.JSArray_methods.add$1(this._choices, element);
      else if (typeof element === "string") {
        choice = new L.EgbChoice(null, null, $goto, submenu, false, null, null, null);
        choice.string = C.JSString_methods.trim$0(element);
        choice.hash = C.JSString_methods.get$hashCode(element);
        choice.f = script;
        choice.deferToEndOfPage = deferToEndOfPage;
        choice.deferToChoiceList = deferToChoiceList;
        C.JSArray_methods.add$1(this._choices, choice);
      } else
        throw H.wrapException(P.ArgumentError$("To add a choice to choices, one must provide either a new EgbChoice element or a String."));
    },
    add$1: function($receiver, element) {
      return this.add$6$deferToChoiceList$deferToEndOfPage$goto$script$submenu($receiver, element, false, false, null, null, null);
    },
    EgbChoiceList$fromMessage$1: function(m) {
      var t1, t2, i, t3, t4, t5;
      t1 = J.get$length$asx(m.listContent);
      t2 = m.listContent;
      if (t1 < 3)
        throw H.wrapException("Message with choices doesn't have enough data: " + H.S(t2) + ".");
      else {
        this.question = H.stringTypeCheck(J.$index$asx(t2, 1));
        for (t1 = this._choices, i = 2; i < J.get$length$asx(m.listContent); ++i) {
          t2 = H.assertSubtype(J.$index$asx(m.listContent, i), "$isMap", [P.String, null], "$asMap");
          t3 = new L.EgbChoice(null, null, null, null, false, null, null, null);
          H.assertSubtype(t2, "$isMap", [P.String, null], "$asMap");
          t4 = J.getInterceptor$asx(t2);
          t5 = J.trim$0$s(t4.$index(t2, "string"));
          t3.string = t5;
          if (H.boolConversionCheck(t4.containsKey$1(t2, "hash")))
            t3.hash = H.intTypeCheck(t4.$index(t2, "hash"));
          else
            t3.hash = C.JSString_methods.get$hashCode(t5);
          t3.$goto = H.stringTypeCheck(t4.$index(t2, "goto"));
          if (H.boolConversionCheck(t4.containsKey$1(t2, "showNow")))
            t3.deferToEndOfPage = !H.boolConversionCheck(t4.$index(t2, "showNow"));
          t3.f = H.interceptedTypeCheck(t4.$index(t2, "then"), "$isFunction");
          t3.submenu = H.stringTypeCheck(t4.$index(t2, "submenu"));
          C.JSArray_methods.add$1(t1, t3);
        }
      }
    },
    $asListBase: function() {
      return [L.EgbChoice];
    },
    $asObject_ListMixin: function() {
      return [L.EgbChoice];
    },
    $asListMixin: function() {
      return [L.EgbChoice];
    },
    $asList: function() {
      return [L.EgbChoice];
    },
    $asIterable: function() {
      return [L.EgbChoice];
    },
    static: {EgbChoiceList$fromMessage: function(m) {
        var t1 = new L.EgbChoiceList(null, H.assertSubtype(H.setRuntimeTypeInfo([], [L.EgbChoice]), "$isList", [L.EgbChoice], "$asList"));
        t1.EgbChoiceList$fromMessage$1(m);
        return t1;
      }}
  }
}],
["html_common", "dart:html_common", , P, {
  "^": "",
  Device_isOpera: function() {
    var t1 = $.Device__isOpera;
    if (t1 == null) {
      t1 = J.contains$2$asx(window.navigator.userAgent, "Opera", 0);
      $.Device__isOpera = t1;
    }
    return t1;
  },
  Device_isWebKit: function() {
    var t1 = $.Device__isWebKit;
    if (t1 == null) {
      t1 = !H.boolConversionCheck(P.Device_isOpera()) && J.contains$2$asx(window.navigator.userAgent, "WebKit", 0);
      $.Device__isWebKit = t1;
    }
    return t1;
  },
  CssClassSetImpl: {
    "^": "Object;",
    _validateToken$1: function(value) {
      if ($.get$CssClassSetImpl__validTokenRE()._nativeRegExp.test(H.checkString(value)))
        return value;
      throw H.wrapException(P.ArgumentError$value(value, "value", "Not a valid class token"));
    },
    toString$0: function(_) {
      return this.readClasses$0().join$1(0, " ");
    },
    get$iterator: function(_) {
      var t1, t2;
      t1 = this.readClasses$0();
      t2 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._collection$_modifications, null, H.assertSubtypeOfRuntimeType(null, null)), [null]);
      t2._cell = t2._set._collection$_first;
      return H.assertSubtype(H.assertSubtype(t2, "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"), "$isIterator", [P.String], "$asIterator");
    },
    forEach$1: function(_, f) {
      var t1 = H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P.String)])._assertCheck$1(f);
      this.readClasses$0().forEach$1(0, t1);
    },
    get$isEmpty: function(_) {
      return this.readClasses$0()._collection$_length === 0;
    },
    get$length: function(_) {
      return this.readClasses$0()._collection$_length;
    },
    contains$1: function(_, value) {
      if (typeof value !== "string")
        return false;
      this._validateToken$1(value);
      return this.readClasses$0().contains$1(0, value);
    },
    lookup$1: function(value) {
      return H.stringTypeCheck(this.contains$1(0, value) ? value : null);
    },
    add$1: function(_, value) {
      H.stringTypeCheck(value);
      this._validateToken$1(value);
      return H.boolTypeCheck(this.modify$1(new P.CssClassSetImpl_add_closure(value)));
    },
    remove$1: function(_, value) {
      var s, result;
      this._validateToken$1(value);
      s = H.assertSubtype(this.readClasses$0(), "$isSet", [P.String], "$asSet");
      result = s.remove$1(0, value);
      this.writeClasses$1(s);
      return result;
    },
    get$last: function(_) {
      var t1 = this.readClasses$0();
      return H.stringTypeCheck(t1.get$last(t1));
    },
    toList$1$growable: function(_, growable) {
      return H.assertSubtype(this.readClasses$0().toList$1$growable(0, growable), "$isList", [P.String], "$asList");
    },
    modify$1: function(f) {
      var t1, s, ret;
      t1 = H.buildFunctionType(H.getDynamicRuntimeType(), [H.buildInterfaceType(P.Set, [H.buildInterfaceType(P.String)])])._assertCheck$1(f);
      s = H.assertSubtype(this.readClasses$0(), "$isSet", [P.String], "$asSet");
      ret = t1.call$1(s);
      this.writeClasses$1(s);
      return ret;
    },
    $isSet: 1,
    $asSet: function() {
      return [P.String];
    },
    $isCssClassSet: 1,
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: function() {
      return [P.String];
    }
  },
  CssClassSetImpl_add_closure: {
    "^": "Closure:2;_captured_value_0",
    call$1: function(s) {
      return s.add$1(0, this._captured_value_0);
    }
  },
  FilteredElementList: {
    "^": "ListBase;_node,_childNodes",
    get$_filtered: function() {
      var t1 = this._childNodes;
      return H.assertSubtype(P.List_List$from(t1.where$1(t1, new P.FilteredElementList__filtered_closure()), true, H.getTypeArgumentByIndex(this, 0)), "$isList", [H.getTypeArgumentByIndex(this, 0)], "$asList");
    },
    forEach$1: function(_, f) {
      var t1 = H.buildFunctionType(H.getVoidRuntimeType(), [this.T3()])._assertCheck$1(f);
      C.JSArray_methods.forEach$1(this.get$_filtered(), t1);
    },
    $indexSet: function(_, index, value) {
      var t1;
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0));
      t1 = this.get$_filtered();
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      J.replaceWith$1$x(H.assertSubtypeOfRuntimeType(t1[index], H.getTypeArgumentByIndex(this, 0)), value);
    },
    set$length: function(_, newLength) {
      var len = this.get$_filtered().length;
      if (newLength >= len)
        return;
      else if (newLength < 0)
        throw H.wrapException(P.ArgumentError$("Invalid list length"));
      this.removeRange$2(0, newLength, len);
    },
    add$1: function(_, value) {
      J.append$1$x(this._childNodes._this, H.interceptedTypeCheck(H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0)), "$isNode"));
    },
    removeRange$2: function(_, start, end) {
      C.JSArray_methods.forEach$1(C.JSArray_methods.sublist$2(this.get$_filtered(), start, end), new P.FilteredElementList_removeRange_closure());
    },
    clear$0: function(_) {
      J._clearChildren$0$x(this._childNodes._this);
    },
    get$length: function(_) {
      return this.get$_filtered().length;
    },
    $index: function(_, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = this.get$_filtered();
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      return H.assertSubtypeOfRuntimeType(t1[index], H.getTypeArgumentByIndex(this, 0));
    },
    get$iterator: function(_) {
      var t1, t2, t3;
      t1 = this.get$_filtered();
      t2 = H.getTypeArgumentByIndex(t1, 0);
      H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray");
      t3 = t1.length;
      return H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"), "$isIterator", [H.getTypeArgumentByIndex(this, 0)], "$asIterator");
    },
    T3: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    }
  },
  FilteredElementList__filtered_closure: {
    "^": "Closure:2;",
    call$1: function(n) {
      return !!J.getInterceptor(n).$isElement;
    }
  },
  FilteredElementList_removeRange_closure: {
    "^": "Closure:2;",
    call$1: function(el) {
      return J.remove$0$ax(el);
    }
  }
}],
["jsonml2html5lib", "package:jsonml/jsonml2html5lib.dart", , N, {
  "^": "",
  _createNode: function(jsonMLObject, allowUnknownTags, customTags, svg, unsafe) {
    var t1, t2, node, tagName, t3, documentFragment, element, i, newNode, t4;
    H.assertSubtype(customTags, "$isMap", [P.String, {func: "", ret: B.Node1, args: [P.Object]}], "$asMap");
    if (!unsafe)
      throw H.wrapException(P.UnimplementedError$("Safe operation (no script tags, etc.) is not supported yet. Currently, you _must_ specify `unsafe: true`. In the future, the default operation will be in safe mode (unsafe: false), which will strip all tags and attributes that could be exploited by malicious users. Only use unsafe mode for input which you are absolutely certain is safe (= no user input."));
    if (typeof jsonMLObject === "string") {
      t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t2 = [];
      H.assertHelper(true);
      t2.$builtinTypeInfo = [B.Node1];
      t2 = new B.NodeList(null, H.assertSubtype(t2, "$isList", [B.Node1], "$asList"));
      node = new B.Text0(jsonMLObject, null, null, H.assertSubtype(t1, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap"), t2, H.assertSubtype(null, "$isList", [B.Element1], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
      t2._dom$_parent = node;
    } else {
      t1 = J.getInterceptor(jsonMLObject);
      if (!!t1.$isList) {
        t2 = t1.$index(jsonMLObject, 0);
        H.assertHelper(typeof t2 === "string");
        tagName = H.stringTypeCheck(t1.$index(jsonMLObject, 0));
        if (tagName === "") {
          t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
          t3 = [];
          H.assertHelper(true);
          t3.$builtinTypeInfo = [B.Node1];
          t3 = new B.NodeList(null, H.assertSubtype(t3, "$isList", [B.Node1], "$asList"));
          documentFragment = new B.DocumentFragment(null, null, H.assertSubtype(t2, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap"), t3, H.assertSubtype(null, "$isList", [B.Element1], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
          t3._dom$_parent = documentFragment;
          element = null;
        } else {
          if (customTags.containsKey$1(0, tagName))
            element = H.interceptedTypeCheck(customTags.$index(0, tagName).call$1(jsonMLObject), "$isElement1");
          else if (!allowUnknownTags && !C.JSArray_methods.contains$1(C.List_4CW, J.toLowerCase$0$s(tagName)))
            throw H.wrapException(Q.JsonMLFormatException$("Tag '" + H.S(tagName) + "' not a valid HTML5 tag nor is it defined in customTags."));
          else {
            t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
            t3 = [];
            H.assertHelper(true);
            t3.$builtinTypeInfo = [B.Node1];
            t3 = new B.NodeList(null, H.assertSubtype(t3, "$isList", [B.Node1], "$asList"));
            element = new B.Element1(null, tagName, null, H.assertSubtype(t2, "$isLinkedHashMap", [null, P.String], "$asLinkedHashMap"), t3, H.assertSubtype(null, "$isList", [B.Element1], "$asList"), null, H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"), H.assertSubtype(null, "$isLinkedHashMap", [null, Y.FileSpan], "$asLinkedHashMap"));
            t3._dom$_parent = element;
          }
          documentFragment = null;
        }
        if (t1.get$length(jsonMLObject) > 1) {
          if (!!J.getInterceptor(t1.$index(jsonMLObject, 1)).$isMap) {
            if (element != null)
              element.set$attributes(0, t1.$index(jsonMLObject, 1));
            else {
              H.assertHelper(documentFragment != null);
              throw H.wrapException(Q.JsonMLFormatException$("DocumentFragment cannot have attributes. Value of currently encoded JsonML object: '" + H.S(jsonMLObject) + "'"));
            }
            i = 2;
          } else
            i = 1;
          for (t2 = element != null; i < t1.get$length(jsonMLObject); ++i) {
            newNode = N._createNode(t1.$index(jsonMLObject, i), false, customTags, svg, true);
            if (newNode == null)
              continue;
            if (t2) {
              t3 = element.nodes;
              if (!!newNode.$isDocumentFragment)
                t3.addAll$1(0, newNode.nodes);
              else {
                t4 = newNode.parent;
                if (t4 != null)
                  t4.nodes.remove$1(0, newNode);
                newNode.parent = t3._dom$_parent;
                t3.super$ListProxy$add$1(t3, newNode);
              }
              H.voidTypeCheck(null);
            } else {
              t3 = documentFragment.nodes;
              if (!!newNode.$isDocumentFragment)
                t3.addAll$1(0, newNode.nodes);
              else {
                t4 = newNode.parent;
                if (t4 != null)
                  t4.nodes.remove$1(0, newNode);
                newNode.parent = t3._dom$_parent;
                t3.super$ListProxy$add$1(t3, newNode);
              }
              H.voidTypeCheck(null);
            }
          }
        }
        if (element != null)
          node = element;
        else {
          H.assertHelper(documentFragment != null);
          node = documentFragment;
        }
      } else
        throw H.wrapException(Q.JsonMLFormatException$("Unexpected JsonML object. Objects in JsonML can be either Strings, Lists, or Maps (and Maps can be only on second positions in Lists, and can be only <String,String>). The faulty object is of runtime type " + t1.get$runtimeType(jsonMLObject).toString$0(0) + " and its value is '" + H.S(jsonMLObject) + "'."));
    }
    return node;
  }
}],
["jsonml_exception", "package:jsonml/src/exception.dart", , Q, {
  "^": "",
  JsonMLFormatException: {
    "^": "Object;message",
    toString$0: function(_) {
      return "JsonMLFormatException: " + this.message;
    },
    $isException: 1,
    static: {JsonMLFormatException$: function(message) {
        return new Q.JsonMLFormatException(message);
      }}
  }
}],
["list_proxy", "package:html5lib/src/list_proxy.dart", , F, {
  "^": "",
  ListProxy: {
    "^": "IterableBase;",
    remove$1: function(_, item) {
      var i;
      H.assertSubtypeOfRuntimeType(item, H.getRuntimeTypeArgument(this, "ListProxy", 0));
      H.assertSubtypeOfRuntimeType(item, H.getRuntimeTypeArgument(this, "ListProxy", 0));
      i = C.JSArray_methods.indexOf$2(this._list, item, 0);
      if (i === -1)
        return false;
      this.removeAt$1(0, i);
      return true;
    },
    get$length: function(_) {
      return this._list.length;
    },
    get$last: function(_) {
      return H.assertSubtypeOfRuntimeType(C.JSArray_methods.get$last(this._list), H.getRuntimeTypeArgument(this, "ListProxy", 0));
    },
    get$single: function(_) {
      return H.assertSubtypeOfRuntimeType(C.JSArray_methods.get$single(this._list), H.getRuntimeTypeArgument(this, "ListProxy", 0));
    },
    get$iterator: function(_) {
      var t1, t2, t3;
      t1 = this._list;
      t2 = H.getTypeArgumentByIndex(t1, 0);
      H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray");
      t3 = t1.length;
      return H.assertSubtype(H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"), "$isIterator", [H.getRuntimeTypeArgument(this, "ListProxy", 0)], "$asIterator");
    },
    $index: function(_, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = this._list;
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      return H.assertSubtypeOfRuntimeType(t1[index], H.getRuntimeTypeArgument(this, "ListProxy", 0));
    },
    $indexSet: ["super$ListProxy$$indexSet", function(_, index, value) {
      var t1;
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(this, "ListProxy", 0));
      t1 = this._list;
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      t1[index] = value;
    }],
    add$1: ["super$ListProxy$add$1", function(_, value) {
      C.JSArray_methods.add$1(this._list, H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(this, "ListProxy", 0)));
    }],
    addAll$1: ["super$ListProxy$addAll$1", function(_, collection) {
      C.JSArray_methods.addAll$1(this._list, H.listSuperNativeTypeCheck(collection, "$isIterable"));
    }],
    clear$0: ["super$ListProxy$clear$0", function(_) {
      C.JSArray_methods.set$length(this._list, 0);
    }],
    removeAt$1: ["super$ListProxy$removeAt$1", function(_, index) {
      return H.assertSubtypeOfRuntimeType(C.JSArray_methods.removeAt$1(this._list, index), H.getRuntimeTypeArgument(this, "ListProxy", 0));
    }],
    insertAll$2: ["super$ListProxy$insertAll$2", function(_, index, iterable) {
      C.JSArray_methods.insertAll$2(this._list, index, H.listSuperNativeTypeCheck(iterable, "$isIterable"));
    }],
    E: function() {
      return H.convertRtiToRuntimeType(this.$builtinTypeInfo && this.$builtinTypeInfo[0]);
    },
    $isList: 1,
    $asList: null,
    $isEfficientLength: 1,
    $isIterable: 1,
    $asIterable: null
  }
}],
["markdown.block_parser", "package:markdown/src/block_parser.dart", , U, {
  "^": "",
  BlockSyntax_isAtBlockEnd: function(parser) {
    if (parser._pos >= parser.lines.length)
      return true;
    return C.JSArray_methods.any$1(C.List_gBu, new U.BlockSyntax_isAtBlockEnd_closure(parser));
  },
  BlockParser: {
    "^": "Object;lines,document,_pos",
    get$next: function() {
      var t1, t2;
      t1 = this._pos;
      t2 = this.lines;
      if (t1 >= t2.length - 1)
        return;
      return H.stringTypeCheck(t2[t1 + 1]);
    },
    matches$1: function(_, regex) {
      var t1, t2;
      t1 = this._pos;
      t2 = this.lines;
      if (t1 >= t2.length)
        return false;
      return regex.firstMatch$1(H.stringTypeCheck(t2[t1])) != null;
    },
    matchesNext$1: function(regex) {
      if (this.get$next() == null)
        return false;
      return regex.firstMatch$1(this.get$next()) != null;
    }
  },
  BlockSyntax: {
    "^": "Object;",
    get$pattern: function(_) {
      return;
    },
    get$canEndBlock: function() {
      return true;
    },
    canParse$1: function(parser) {
      var t1, t2, t3;
      t1 = this.get$pattern(this);
      t2 = parser.lines;
      t3 = parser._pos;
      if (t3 >= t2.length)
        return H.ioore(t2, t3);
      return t1.firstMatch$1(H.stringTypeCheck(t2[t3])) != null;
    },
    parseChildLines$1: function(parser) {
      var childLines, t1, t2, t3, match;
      childLines = H.setRuntimeTypeInfo([], [P.String]);
      for (t1 = parser.lines; parser._pos < t1.length;) {
        t2 = this.get$pattern(this);
        t3 = parser._pos;
        if (t3 >= t1.length)
          return H.ioore(t1, t3);
        match = t2.firstMatch$1(H.stringTypeCheck(t1[t3]));
        if (match == null)
          break;
        t2 = match._match;
        if (1 >= t2.length)
          return H.ioore(t2, 1);
        C.JSArray_methods.add$1(childLines, H.stringTypeCheck(t2[1]));
        ++parser._pos;
      }
      return H.assertSubtype(childLines, "$isList", [P.String], "$asList");
    }
  },
  BlockSyntax_isAtBlockEnd_closure: {
    "^": "Closure:2;_captured_parser_0",
    call$1: function(s) {
      return s.canParse$1(this._captured_parser_0) && s.get$canEndBlock();
    }
  },
  EmptyBlockSyntax: {
    "^": "BlockSyntax;",
    get$pattern: function(_) {
      return $.get$_emptyPattern();
    },
    parse$1: function(parser) {
      ++parser._pos;
      return;
    }
  },
  SetextHeaderSyntax: {
    "^": "BlockSyntax;",
    canParse$1: function(parser) {
      return parser.matchesNext$1($.get$_setextPattern());
    },
    parse$1: function(parser) {
      var t1, tag, t2, contents;
      t1 = $.get$_setextPattern().firstMatch$1(parser.get$next())._match;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      t1 = H.stringTypeCheck(t1[1]);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      tag = t1[0] === "=" ? "h1" : "h2";
      t1 = parser.lines;
      t2 = parser._pos;
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      contents = H.assertSubtype(R.InlineParser$(H.stringTypeCheck(t1[t2]), parser.document).parse$0(), "$isList", [T.Node0], "$asList");
      parser._pos = ++parser._pos + 1;
      H.assertSubtype(contents, "$isList", [T.Node0], "$asList");
      return new T.Element0(tag, H.assertSubtype(contents, "$isList", [T.Node0], "$asList"), H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.String), "$isMap", [P.String, P.String], "$asMap"));
    }
  },
  HeaderSyntax: {
    "^": "BlockSyntax;",
    get$pattern: function(_) {
      return $.get$_headerPattern();
    },
    parse$1: function(parser) {
      var t1, t2, t3, match, level, contents;
      t1 = $.get$_headerPattern();
      t2 = parser.lines;
      t3 = parser._pos;
      if (t3 >= t2.length)
        return H.ioore(t2, t3);
      match = t1.firstMatch$1(H.stringTypeCheck(t2[t3]));
      ++parser._pos;
      t3 = match._match;
      t2 = t3.length;
      if (1 >= t2)
        return H.ioore(t3, 1);
      level = H.stringTypeCheck(t3[1]).length;
      if (2 >= t2)
        return H.ioore(t3, 2);
      contents = H.assertSubtype(R.InlineParser$(J.trim$0$s(H.stringTypeCheck(t3[2])), parser.document).parse$0(), "$isList", [T.Node0], "$asList");
      t3 = "h" + level;
      H.assertSubtype(contents, "$isList", [T.Node0], "$asList");
      return new T.Element0(t3, H.assertSubtype(contents, "$isList", [T.Node0], "$asList"), H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.String), "$isMap", [P.String, P.String], "$asMap"));
    }
  },
  BlockquoteSyntax: {
    "^": "BlockSyntax;",
    get$pattern: function(_) {
      return $.get$_blockquotePattern();
    },
    parse$1: function(parser) {
      var children = parser.document.parseLines$1(this.parseChildLines$1(parser));
      H.assertSubtype(children, "$isList", [T.Node0], "$asList");
      return new T.Element0("blockquote", H.assertSubtype(children, "$isList", [T.Node0], "$asList"), H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.String), "$isMap", [P.String, P.String], "$asMap"));
    }
  },
  CodeBlockSyntax: {
    "^": "BlockSyntax;",
    get$pattern: function(_) {
      return $.get$_indentPattern();
    },
    parseChildLines$1: function(parser) {
      var childLines, t1, t2, t3, t4, match, nextMatch;
      childLines = H.setRuntimeTypeInfo([], [P.String]);
      for (t1 = parser.lines; t2 = parser._pos, t3 = t1.length, t2 < t3;) {
        t4 = $.get$_indentPattern();
        if (t2 >= t3)
          return H.ioore(t1, t2);
        match = t4.firstMatch$1(H.stringTypeCheck(t1[t2]));
        if (match != null) {
          t2 = match._match;
          if (1 >= t2.length)
            return H.ioore(t2, 1);
          C.JSArray_methods.add$1(childLines, H.stringTypeCheck(t2[1]));
          ++parser._pos;
        } else {
          nextMatch = parser.get$next() != null ? t4.firstMatch$1(parser.get$next()) : null;
          t2 = parser._pos;
          if (t2 >= t1.length)
            return H.ioore(t1, t2);
          if (J.trim$0$s(H.stringTypeCheck(t1[t2])) === "" && nextMatch != null) {
            C.JSArray_methods.add$1(childLines, "");
            t2 = nextMatch._match;
            if (1 >= t2.length)
              return H.ioore(t2, 1);
            C.JSArray_methods.add$1(childLines, H.stringTypeCheck(t2[1]));
            parser._pos = ++parser._pos + 1;
          } else
            break;
        }
      }
      return H.assertSubtype(childLines, "$isList", [P.String], "$asList");
    },
    parse$1: function(parser) {
      var childLines, t1;
      childLines = this.parseChildLines$1(parser);
      C.JSArray_methods.add$1(childLines, "");
      t1 = C.JSString_methods.replaceAll$2(C.JSArray_methods.join$1(childLines, "\n"), "&", "&amp;");
      H.checkString("&lt;");
      t1 = H.stringReplaceAllUnchecked(t1, "<", "&lt;");
      H.checkString("&gt;");
      t1 = [new T.Element0("code", H.assertSubtype([new T.Text(H.stringReplaceAllUnchecked(t1, ">", "&gt;"))], "$isList", [T.Node0], "$asList"), H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(null, null), "$isMap", [P.String, P.String], "$asMap"))];
      H.assertSubtype(t1, "$isList", [T.Node0], "$asList");
      return new T.Element0("pre", H.assertSubtype(t1, "$isList", [T.Node0], "$asList"), H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.String), "$isMap", [P.String, P.String], "$asMap"));
    }
  },
  FencedCodeBlockSyntax: {
    "^": "BlockSyntax;",
    get$pattern: function(_) {
      return $.get$_codePattern();
    },
    parseChildLines$2: function(parser, endBlock) {
      var childLines, t1, t2, t3, t4, match;
      if (endBlock == null)
        endBlock = "";
      childLines = H.setRuntimeTypeInfo([], [P.String]);
      t1 = ++parser._pos;
      for (t2 = parser.lines; t3 = t2.length, t1 < t3;) {
        t4 = $.get$_codePattern();
        if (t1 < 0 || t1 >= t3)
          return H.ioore(t2, t1);
        match = t4.firstMatch$1(H.stringTypeCheck(t2[t1]));
        if (match != null) {
          t1 = match._match;
          if (1 >= t1.length)
            return H.ioore(t1, 1);
          t1 = !J.startsWith$1$s(H.stringTypeCheck(t1[1]), endBlock);
        } else
          t1 = true;
        t3 = parser._pos;
        if (t1) {
          if (t3 >= t2.length)
            return H.ioore(t2, t3);
          C.JSArray_methods.add$1(childLines, H.stringTypeCheck(t2[t3]));
          t1 = ++parser._pos;
        } else {
          parser._pos = t3 + 1;
          break;
        }
      }
      return H.assertSubtype(childLines, "$isList", [P.String], "$asList");
    },
    parse$1: function(parser) {
      var t1, t2, t3, endBlock, syntax, childLines;
      t1 = $.get$_codePattern();
      t2 = parser.lines;
      t3 = parser._pos;
      if (t3 >= t2.length)
        return H.ioore(t2, t3);
      t3 = t1.firstMatch$1(H.stringTypeCheck(t2[t3]))._match;
      t2 = t3.length;
      if (1 >= t2)
        return H.ioore(t3, 1);
      endBlock = H.stringTypeCheck(t3[1]);
      if (2 >= t2)
        return H.ioore(t3, 2);
      syntax = H.stringTypeCheck(t3[2]);
      childLines = this.parseChildLines$2(parser, endBlock);
      C.JSArray_methods.add$1(childLines, "");
      t3 = C.JSString_methods.replaceAll$2(C.JSArray_methods.join$1(childLines, "\n"), "&", "&amp;");
      H.checkString("&lt;");
      t3 = H.stringReplaceAllUnchecked(t3, "<", "&lt;");
      H.checkString("&gt;");
      t3 = [new T.Element0("code", H.assertSubtype([new T.Text(H.stringReplaceAllUnchecked(t3, ">", "&gt;"))], "$isList", [T.Node0], "$asList"), H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(null, null), "$isMap", [P.String, P.String], "$asMap"))];
      H.assertSubtype(t3, "$isList", [T.Node0], "$asList");
      H.assertSubtype(t3, "$isList", [T.Node0], "$asList");
      t2 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.String), "$isMap", [P.String, P.String], "$asMap");
      if (syntax !== "")
        t2.$indexSet(0, "class", syntax);
      return new T.Element0("pre", t3, t2);
    }
  },
  HorizontalRuleSyntax: {
    "^": "BlockSyntax;",
    get$pattern: function(_) {
      return $.get$_hrPattern();
    },
    parse$1: function(parser) {
      ++parser._pos;
      return new T.Element0("hr", H.assertSubtype(null, "$isList", [T.Node0], "$asList"), H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(null, null), "$isMap", [P.String, P.String], "$asMap"));
    }
  },
  BlockHtmlSyntax: {
    "^": "BlockSyntax;",
    get$pattern: function(_) {
      return $.get$_htmlPattern();
    },
    get$canEndBlock: function() {
      return false;
    },
    parse$1: function(parser) {
      var childLines, t1, t2;
      childLines = H.setRuntimeTypeInfo([], [P.String]);
      t1 = parser.lines;
      while (true) {
        if (!(parser._pos < t1.length && !parser.matches$1(0, $.get$_emptyPattern())))
          break;
        t2 = parser._pos;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        C.JSArray_methods.add$1(childLines, H.stringTypeCheck(t1[t2]));
        ++parser._pos;
      }
      return new T.Text(C.JSArray_methods.join$1(childLines, "\n"));
    }
  },
  ListItem: {
    "^": "Object;forceBlock<,lines"
  },
  ListSyntax: {
    "^": "BlockSyntax;",
    get$canEndBlock: function() {
      return false;
    },
    parse$1: function(parser) {
      var t1, items, t2, t3, t4, t5, t6, i, j, i0, itemNodes, item, blockItem, blocksInList, pattern, children, contents;
      t1 = {};
      items = H.setRuntimeTypeInfo([], [U.ListItem]);
      t1._captured_childLines_0 = H.setRuntimeTypeInfo([], [P.String]);
      t2 = new U.ListSyntax_parse_endItem(t1, items);
      t1._captured_match_1 = null;
      t3 = new U.ListSyntax_parse_tryMatch(t1, parser);
      for (t4 = parser.lines; parser._pos < t4.length;) {
        if (H.boolConversionCheck(t3.call$1($.get$_emptyPattern())))
          C.JSArray_methods.add$1(t1._captured_childLines_0, "");
        else if (H.boolConversionCheck(t3.call$1($.get$_ulPattern())) || H.boolConversionCheck(t3.call$1($.get$_olPattern()))) {
          t2.call$0();
          t5 = t1._captured_childLines_0;
          t6 = t1._captured_match_1._match;
          if (1 >= t6.length)
            return H.ioore(t6, 1);
          C.JSArray_methods.add$1(t5, H.stringTypeCheck(t6[1]));
        } else if (H.boolConversionCheck(t3.call$1($.get$_indentPattern()))) {
          t5 = t1._captured_childLines_0;
          t6 = t1._captured_match_1._match;
          if (1 >= t6.length)
            return H.ioore(t6, 1);
          C.JSArray_methods.add$1(t5, H.stringTypeCheck(t6[1]));
        } else if (U.BlockSyntax_isAtBlockEnd(parser))
          break;
        else {
          t5 = t1._captured_childLines_0;
          if (t5.length > 0 && C.JSArray_methods.get$last(t5) === "")
            break;
          t5 = t1._captured_childLines_0;
          t6 = parser._pos;
          if (t6 >= t4.length)
            return H.ioore(t4, t6);
          C.JSArray_methods.add$1(t5, H.stringTypeCheck(t4[t6]));
        }
        ++parser._pos;
      }
      t2.call$0();
      for (i = 0; i < items.length; i = i0)
        for (j = items[i].lines.length - 1, i0 = i + 1; j > 0; --j) {
          t1 = $.get$_emptyPattern();
          if (i >= items.length)
            return H.ioore(items, i);
          t2 = items[i].lines;
          if (j >= t2.length)
            return H.ioore(t2, j);
          if (t1.firstMatch$1(t2[j]) != null) {
            t1 = items.length;
            if (i < t1 - 1) {
              items[i].forceBlock = true;
              if (i0 >= t1)
                return H.ioore(items, i0);
              items[i0].forceBlock = true;
            }
            if (i >= t1)
              return H.ioore(items, i);
            t1 = items[i].lines;
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            t1.pop();
          } else
            break;
        }
      itemNodes = H.setRuntimeTypeInfo([], [T.Node0]);
      for (t1 = H.getTypeArgumentByIndex(items, 0), H.assertSubtype(items, "$isJSArray", [t1], "$asJSArray"), t2 = items.length, t1 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(items, "$isJSArray", [t1], "$asJSArray"), t2, 0, H.assertSubtypeOfRuntimeType(null, t1)), [t1]), "$isIterator", [H.getTypeArgumentByIndex(items, 0)], "$asIterator"), t2 = parser.document; t1.moveNext$0();) {
        item = H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0));
        blockItem = item.get$forceBlock() || item.lines.length > 1;
        blocksInList = [$.get$_blockquotePattern(), $.get$_headerPattern(), $.get$_hrPattern(), $.get$_indentPattern(), $.get$_ulPattern(), $.get$_olPattern()];
        if (!blockItem) {
          t3 = H.getTypeArgumentByIndex(blocksInList, 0);
          H.assertSubtype(blocksInList, "$isJSArray", [t3], "$asJSArray");
          t4 = new J.ArrayIterator(H.assertSubtype(blocksInList, "$isJSArray", [t3], "$asJSArray"), 6, 0, H.assertSubtypeOfRuntimeType(null, t3));
          H.assertHelper(true);
          t4.$builtinTypeInfo = [t3];
          H.assertSubtype(t4, "$isIterator", [H.getTypeArgumentByIndex(blocksInList, 0)], "$asIterator");
          t3 = item.lines;
          while (true) {
            if (!t4.moveNext$0()) {
              blockItem = false;
              break;
            }
            pattern = H.assertSubtypeOfRuntimeType(t4._current, H.getTypeArgumentByIndex(t4, 0));
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            if (pattern.firstMatch$1(t3[0]) != null) {
              blockItem = true;
              break;
            }
          }
        }
        t3 = item.lines;
        if (blockItem) {
          children = t2.parseLines$1(t3);
          H.assertSubtype(children, "$isList", [T.Node0], "$asList");
          C.JSArray_methods.add$1(itemNodes, new T.Element0("li", H.assertSubtype(children, "$isList", [T.Node0], "$asList"), H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.String), "$isMap", [P.String, P.String], "$asMap")));
        } else {
          if (0 >= t3.length)
            return H.ioore(t3, 0);
          contents = H.assertSubtype(R.InlineParser$(t3[0], t2).parse$0(), "$isList", [T.Node0], "$asList");
          H.assertSubtype(contents, "$isList", [T.Node0], "$asList");
          C.JSArray_methods.add$1(itemNodes, new T.Element0("li", H.assertSubtype(contents, "$isList", [T.Node0], "$asList"), H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.String), "$isMap", [P.String, P.String], "$asMap")));
        }
      }
      t1 = this.get$listTag();
      H.assertSubtype(itemNodes, "$isList", [T.Node0], "$asList");
      return new T.Element0(t1, H.assertSubtype(itemNodes, "$isList", [T.Node0], "$asList"), H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.String), "$isMap", [P.String, P.String], "$asMap"));
    }
  },
  ListSyntax_parse_endItem: {
    "^": "Closure:0;_block_parser$_box_0,_captured_items_1",
    call$0: function() {
      var t1, t2;
      t1 = this._block_parser$_box_0;
      t2 = t1._captured_childLines_0;
      if (t2.length > 0) {
        H.assertSubtype(t2, "$isList", [P.String], "$asList");
        C.JSArray_methods.add$1(this._captured_items_1, new U.ListItem(false, H.assertSubtype(t2, "$isList", [P.String], "$asList")));
        t1._captured_childLines_0 = H.setRuntimeTypeInfo([], [P.String]);
      }
    }
  },
  ListSyntax_parse_tryMatch: {
    "^": "Closure:39;_block_parser$_box_0,_captured_parser_2",
    call$1: function(pattern) {
      var t1, t2, match;
      t1 = this._captured_parser_2;
      t2 = t1.lines;
      t1 = t1._pos;
      if (t1 >= t2.length)
        return H.ioore(t2, t1);
      match = pattern.firstMatch$1(H.stringTypeCheck(t2[t1]));
      this._block_parser$_box_0._captured_match_1 = match;
      return match != null;
    }
  },
  UnorderedListSyntax: {
    "^": "ListSyntax;",
    get$pattern: function(_) {
      return $.get$_ulPattern();
    },
    get$listTag: function() {
      return "ul";
    }
  },
  OrderedListSyntax: {
    "^": "ListSyntax;",
    get$pattern: function(_) {
      return $.get$_olPattern();
    },
    get$listTag: function() {
      return "ol";
    }
  },
  ParagraphSyntax: {
    "^": "BlockSyntax;",
    get$canEndBlock: function() {
      return false;
    },
    canParse$1: function(parser) {
      return true;
    },
    parse$1: function(parser) {
      var childLines, t1, t2, contents;
      childLines = H.setRuntimeTypeInfo([], [P.String]);
      for (t1 = parser.lines; !U.BlockSyntax_isAtBlockEnd(parser);) {
        t2 = parser._pos;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        C.JSArray_methods.add$1(childLines, H.stringTypeCheck(t1[t2]));
        ++parser._pos;
      }
      contents = H.assertSubtype(R.InlineParser$(C.JSArray_methods.join$1(childLines, "\n"), parser.document).parse$0(), "$isList", [T.Node0], "$asList");
      H.assertSubtype(contents, "$isList", [T.Node0], "$asList");
      return new T.Element0("p", H.assertSubtype(contents, "$isList", [T.Node0], "$asList"), H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.String), "$isMap", [P.String, P.String], "$asMap"));
    }
  }
}],
["markdown.src.ast", "package:markdown/src/ast.dart", , T, {
  "^": "",
  Node0: {
    "^": "Object;"
  },
  Element0: {
    "^": "Object;tag,children>,attributes>",
    accept$1: function(_, visitor) {
      var t1, t2, t3;
      if (visitor.visitElementBefore$1(this)) {
        for (t1 = this.children, t1.toString, t2 = H.getTypeArgumentByIndex(t1, 0), H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3 = t1.length, t1 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(t1, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(t1, 0)], "$asIterator"); t1.moveNext$0();)
          J.accept$1$x(H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0)), visitor);
        visitor.buffer._contents += "</" + H.S(this.tag) + ">";
      }
    },
    $isNode0: 1
  },
  Text: {
    "^": "Object;text>",
    accept$1: function(_, visitor) {
      var t1 = visitor.buffer;
      t1.toString;
      t1._contents += H.S(this.text);
      return H.voidTypeCheck(null);
    },
    $isNode0: 1
  }
}],
["markdown.src.document", "package:markdown/src/document.dart", , L, {
  "^": "",
  Document: {
    "^": "Object;refLinks,inlineSyntaxes,linkResolver,imageLinkResolver",
    parseRefLinks$1: function(lines) {
      var pattern, t1, i, match, t2, t3, id, url, title;
      H.assertSubtype(lines, "$isList", [P.String], "$asList");
      pattern = new H.JSSyntaxRegExp("^[ ]{0,3}\\[([^\\]]+)\\]:\\s+(\\S+)\\s*(\"[^\"]+\"|'[^']+'|\\([^)]+\\)|)\\s*$", H.JSSyntaxRegExp_makeNative("^[ ]{0,3}\\[([^\\]]+)\\]:\\s+(\\S+)\\s*(\"[^\"]+\"|'[^']+'|\\([^)]+\\)|)\\s*$", false, true, false), null, null);
      for (t1 = this.refLinks, i = 0; i < lines.length; ++i) {
        match = pattern.firstMatch$1(lines[i]);
        if (match != null) {
          t2 = match._match;
          t3 = t2.length;
          if (1 >= t3)
            return H.ioore(t2, 1);
          id = H.stringTypeCheck(t2[1]);
          if (2 >= t3)
            return H.ioore(t2, 2);
          url = H.stringTypeCheck(t2[2]);
          if (3 >= t3)
            return H.ioore(t2, 3);
          title = H.stringTypeCheck(t2[3]);
          title = title === "" ? null : J.substring$2$s(title, 1, title.length - 1);
          id = J.toLowerCase$0$s(id);
          t1.$indexSet(0, id, new L.Link(id, url, title));
          if (i >= lines.length)
            return H.ioore(lines, i);
          lines[i] = "";
        }
      }
    },
    parseLines$1: function(lines) {
      var parser, blocks, t1, t2, syntax, block;
      H.assertSubtype(lines, "$isList", [P.String], "$asList");
      H.assertSubtype(lines, "$isList", [P.String], "$asList");
      H.assertSubtype(lines, "$isList", [P.String], "$asList");
      parser = new U.BlockParser(lines, this, 0);
      blocks = H.setRuntimeTypeInfo([], [T.Node0]);
      for (; parser._pos < lines.length;) {
        t1 = H.getTypeArgumentByIndex(C.List_gBu, 0);
        H.assertSubtype(C.List_gBu, "$isJSArray", [t1], "$asJSArray");
        t2 = new J.ArrayIterator(H.assertSubtype(C.List_gBu, "$isJSArray", [t1], "$asJSArray"), 11, 0, H.assertSubtypeOfRuntimeType(null, t1));
        H.assertHelper(true);
        t2.$builtinTypeInfo = [t1];
        H.assertSubtype(t2, "$isIterator", [H.getTypeArgumentByIndex(C.List_gBu, 0)], "$asIterator");
        for (; t2.moveNext$0();) {
          syntax = H.assertSubtypeOfRuntimeType(t2._current, H.getTypeArgumentByIndex(t2, 0));
          if (syntax.canParse$1(parser)) {
            block = syntax.parse$1(parser);
            if (block != null)
              C.JSArray_methods.add$1(blocks, block);
            break;
          }
        }
      }
      return H.assertSubtype(blocks, "$isList", [T.Node0], "$asList");
    }
  },
  Link: {
    "^": "Object;id>,url,title"
  }
}],
["markdown.src.html_renderer", "package:markdown/src/html_renderer.dart", , B, {
  "^": "",
  markdownToHtml: function(markdown, imageLinkResolver, inlineOnly, inlineSyntaxes, linkResolver) {
    var t1, t2, t3, $document, lines;
    t1 = H.buildFunctionType(H.buildInterfaceType(T.Node0), [H.buildInterfaceType(P.String)]);
    t2 = t1._assertCheck$1(imageLinkResolver);
    H.assertSubtype(inlineSyntaxes, "$isList", [R.InlineSyntax], "$asList");
    t3 = t1._assertCheck$1(linkResolver);
    t1._assertCheck$1(t2);
    H.assertSubtype(inlineSyntaxes, "$isList", [R.InlineSyntax], "$asList");
    t1._assertCheck$1(t3);
    $document = new L.Document(H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(P.String, L.Link), "$isMap", [P.String, L.Link], "$asMap"), H.assertSubtype(inlineSyntaxes, "$isList", [R.InlineSyntax], "$asList"), t1._assertCheck$1(t3), t1._assertCheck$1(t2));
    if (inlineOnly) {
      t1 = H.assertSubtype(R.InlineParser$(markdown, $document).parse$0(), "$isList", [T.Node0], "$asList");
      H.assertSubtype(t1, "$isList", [T.Node0], "$asList");
      return new B.HtmlRenderer(null).render$1(t1);
    }
    lines = J.replaceAll$2$s(markdown, "\r\n", "\n").split("\n");
    $document.parseRefLinks$1(lines);
    t1 = $document.parseLines$1(lines);
    H.assertSubtype(t1, "$isList", [T.Node0], "$asList");
    return new B.HtmlRenderer(null).render$1(t1);
  },
  HtmlRenderer: {
    "^": "Object;buffer",
    render$1: function(nodes) {
      var t1, t2;
      H.assertSubtype(nodes, "$isList", [T.Node0], "$asList");
      this.buffer = new P.StringBuffer("");
      for (nodes.toString, t1 = H.getTypeArgumentByIndex(nodes, 0), H.assertSubtype(nodes, "$isJSArray", [t1], "$asJSArray"), t2 = nodes.length, t1 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(nodes, "$isJSArray", [t1], "$asJSArray"), t2, 0, H.assertSubtypeOfRuntimeType(null, t1)), [t1]), "$isIterator", [H.getTypeArgumentByIndex(nodes, 0)], "$asIterator"); t1.moveNext$0();)
        J.accept$1$x(H.assertSubtypeOfRuntimeType(t1._current, H.getTypeArgumentByIndex(t1, 0)), this);
      return J.toString$0(this.buffer);
    },
    visitElementBefore$1: function(element) {
      var t1, attributeNames, t2, t3, $name;
      if (this.buffer._contents.length !== 0 && $.get$HtmlRenderer__blockTags().firstMatch$1(element.tag) != null)
        this.buffer._contents += "\n";
      this.buffer._contents += "<" + H.S(element.tag);
      t1 = element.attributes;
      attributeNames = t1.get$keys(t1).toList$0(0);
      C.JSArray_methods.sort$1(attributeNames, new B.HtmlRenderer_visitElementBefore_closure());
      for (t2 = H.getTypeArgumentByIndex(attributeNames, 0), H.assertSubtype(attributeNames, "$isJSArray", [t2], "$asJSArray"), t3 = attributeNames.length, t2 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(attributeNames, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(attributeNames, 0)], "$asIterator"); t2.moveNext$0();) {
        $name = H.assertSubtypeOfRuntimeType(t2._current, H.getTypeArgumentByIndex(t2, 0));
        this.buffer._contents += " " + H.S($name) + "=\"" + H.S(t1.$index(0, $name)) + "\"";
      }
      t1 = this.buffer;
      if (element.children == null) {
        t1._contents += " />";
        return false;
      } else {
        t1._contents += ">";
        return true;
      }
    },
    $isNodeVisitor: 1
  },
  HtmlRenderer_visitElementBefore_closure: {
    "^": "Closure:11;",
    call$2: function(a, b) {
      return J.compareTo$1$ns(a, b);
    }
  }
}],
["markdown.src.inline_parser", "package:markdown/src/inline_parser.dart", , R, {
  "^": "",
  InlineParser: {
    "^": "Object;source,document,syntaxes,pos,start,_stack",
    parse$0: function() {
      var t1, t2, t3, matched, i, t4, t5;
      t1 = this._stack;
      C.JSArray_methods.add$1(t1, new R.TagState(0, 0, null, H.assertSubtype(H.setRuntimeTypeInfo([], [T.Node0]), "$isList", [T.Node0], "$asList")));
      for (t2 = this.source.length, t3 = this.syntaxes; this.pos !== t2;) {
        i = t1.length - 1;
        while (true) {
          if (!(i > 0)) {
            matched = false;
            break;
          }
          if (i >= t1.length)
            return H.ioore(t1, i);
          if (t1[i].tryMatch$1(this)) {
            matched = true;
            break;
          }
          --i;
        }
        if (matched)
          continue;
        t4 = H.getTypeArgumentByIndex(t3, 0);
        H.assertSubtype(t3, "$isJSArray", [t4], "$asJSArray");
        t5 = t3.length;
        t5 = new J.ArrayIterator(H.assertSubtype(t3, "$isJSArray", [t4], "$asJSArray"), t5, 0, H.assertSubtypeOfRuntimeType(null, t4));
        H.assertHelper(true);
        t5.$builtinTypeInfo = [t4];
        H.assertSubtype(t5, "$isIterator", [H.getTypeArgumentByIndex(t3, 0)], "$asIterator");
        while (true) {
          if (!t5.moveNext$0()) {
            matched = false;
            break;
          }
          if (H.assertSubtypeOfRuntimeType(t5._current, H.getTypeArgumentByIndex(t5, 0)).tryMatch$1(this)) {
            matched = true;
            break;
          }
        }
        if (matched)
          continue;
        ++this.pos;
      }
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return H.assertSubtype(t1[0].close$2(0, this, null), "$isList", [T.Node0], "$asList");
    },
    writeTextRange$2: function(start, end) {
      var text, nodes, t1, t2;
      if (end <= start)
        return;
      text = J.substring$2$s(this.source, start, end);
      nodes = C.JSArray_methods.get$last(this._stack).children;
      if (nodes.length > 0 && C.JSArray_methods.get$last(nodes) instanceof T.Text) {
        t1 = nodes.length - 1;
        t2 = H.S(J.get$text$x(C.JSArray_methods.get$last(nodes))) + text;
        if (t1 < 0 || t1 >= nodes.length)
          return H.ioore(nodes, t1);
        nodes[t1] = new T.Text(t2);
      } else
        C.JSArray_methods.add$1(nodes, new T.Text(text));
    },
    InlineParser$2: function(source, $document) {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10;
      t1 = this.document;
      t2 = t1.inlineSyntaxes;
      if (t2 != null)
        C.JSArray_methods.addAll$1(this.syntaxes, t2);
      t2 = this.syntaxes;
      C.JSArray_methods.addAll$1(t2, $.get$InlineParser__defaultSyntaxes());
      t3 = t1.linkResolver;
      t4 = H.buildFunctionType(H.buildInterfaceType(T.Node0), [H.buildInterfaceType(P.String)]);
      t4._assertCheck$1(t3);
      t5 = R.LinkSyntax_linkPattern();
      t6 = H.JSSyntaxRegExp_makeNative("\\[", true, true, false);
      t7 = H.JSSyntaxRegExp_makeNative(t5, true, true, false);
      t3 = t4._assertCheck$1(t3);
      t1 = t1.imageLinkResolver;
      t4._assertCheck$1(t1);
      t8 = R.LinkSyntax_linkPattern();
      t9 = H.JSSyntaxRegExp_makeNative("!\\[", true, true, false);
      t10 = H.JSSyntaxRegExp_makeNative(t8, true, true, false);
      C.JSArray_methods.insertAll$2(t2, 1, [new R.LinkSyntax(t3, false, new H.JSSyntaxRegExp(t5, t7, null, null), null, new H.JSSyntaxRegExp("\\[", t6, null, null)), new R.ImageLinkSyntax(t4._assertCheck$1(t1), t4._assertCheck$1(null), false, new H.JSSyntaxRegExp(t8, t10, null, null), null, new H.JSSyntaxRegExp("!\\[", t9, null, null))]);
    },
    static: {InlineParser$: function(source, $document) {
        var t1, t2;
        t1 = H.setRuntimeTypeInfo([], [R.InlineSyntax]);
        t2 = H.setRuntimeTypeInfo([], [R.TagState]);
        t2 = new R.InlineParser(source, $document, H.assertSubtype(t1, "$isList", [R.InlineSyntax], "$asList"), 0, 0, H.assertSubtype(t2, "$isList", [R.TagState], "$asList"));
        t2.InlineParser$2(source, $document);
        return t2;
      }}
  },
  InlineSyntax: {
    "^": "Object;",
    tryMatch$1: function(parser) {
      var startMatch, t1;
      startMatch = this.pattern.matchAsPrefix$2(0, parser.source, parser.pos);
      if (startMatch != null) {
        parser.writeTextRange$2(parser.start, parser.pos);
        parser.start = parser.pos;
        if (this.onMatch$2(parser, startMatch)) {
          t1 = startMatch._match;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1 = parser.pos += H.stringTypeCheck(t1[0]).length;
          parser.start = t1;
        }
        return true;
      }
      return false;
    }
  },
  TextSyntax: {
    "^": "InlineSyntax;substitute,pattern",
    onMatch$2: function(parser, match) {
      var t1 = this.substitute;
      if (t1 == null) {
        t1 = match._match;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        parser.pos += H.stringTypeCheck(t1[0]).length;
        return false;
      }
      C.JSArray_methods.add$1(C.JSArray_methods.get$last(parser._stack).children, new T.Text(t1));
      return true;
    },
    static: {TextSyntax$: function(pattern, sub) {
        return new R.TextSyntax(sub, new H.JSSyntaxRegExp(pattern, H.JSSyntaxRegExp_makeNative(pattern, true, true, false), null, null));
      }}
  },
  AutolinkSyntax: {
    "^": "InlineSyntax;pattern",
    onMatch$2: function(parser, match) {
      var t1, url, t2;
      t1 = match._match;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      url = H.stringTypeCheck(t1[1]);
      t1 = J.replaceAll$2$s(url, "&", "&amp;");
      H.checkString("&lt;");
      t1 = H.stringReplaceAllUnchecked(t1, "<", "&lt;");
      H.checkString("&gt;");
      t1 = H.assertSubtype([new T.Text(H.stringReplaceAllUnchecked(t1, ">", "&gt;"))], "$isList", [T.Node0], "$asList");
      t2 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(null, null), "$isMap", [P.String, P.String], "$asMap");
      t2.$indexSet(0, "href", url);
      C.JSArray_methods.add$1(C.JSArray_methods.get$last(parser._stack).children, new T.Element0("a", t1, t2));
      return true;
    }
  },
  TagSyntax: {
    "^": "InlineSyntax;endPattern,tag,pattern",
    onMatch$2: ["super$TagSyntax$onMatch$2", function(parser, match) {
      var t1, t2;
      t1 = parser.pos;
      t2 = match._match;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      C.JSArray_methods.add$1(parser._stack, new R.TagState(t1, t1 + H.stringTypeCheck(t2[0]).length, this, H.assertSubtype(H.setRuntimeTypeInfo([], [T.Node0]), "$isList", [T.Node0], "$asList")));
      return true;
    }],
    onMatchEnd$3: function(parser, match, state) {
      var t1, t2;
      t1 = state.children;
      H.assertSubtype(t1, "$isList", [T.Node0], "$asList");
      H.assertSubtype(t1, "$isList", [T.Node0], "$asList");
      t2 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.String), "$isMap", [P.String, P.String], "$asMap");
      C.JSArray_methods.add$1(C.JSArray_methods.get$last(parser._stack).children, new T.Element0(this.tag, t1, t2));
      return true;
    },
    static: {TagSyntax$: function(pattern, end, tag) {
        var t1, t2;
        t1 = H.JSSyntaxRegExp_makeNative(pattern, true, true, false);
        t2 = end != null ? end : pattern;
        return new R.TagSyntax(new H.JSSyntaxRegExp(t2, H.JSSyntaxRegExp_makeNative(t2, true, true, false), null, null), tag, new H.JSSyntaxRegExp(pattern, t1, null, null));
      }}
  },
  LinkSyntax: {
    "^": "TagSyntax;linkResolver<,resolved,endPattern,tag,pattern",
    createNode$3: ["super$LinkSyntax$createNode$3", function(parser, match, state) {
      var t1, link, t2, t3;
      t1 = match._match;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      if (H.stringTypeCheck(t1[1]) == null) {
        this.get$linkResolver();
        return;
      } else {
        link = this.getLink$3(parser, match, state);
        if (link == null)
          return;
        t1 = state.children;
        H.assertSubtype(t1, "$isList", [T.Node0], "$asList");
        H.assertSubtype(t1, "$isList", [T.Node0], "$asList");
        t2 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.String), "$isMap", [P.String, P.String], "$asMap");
        t3 = J.replaceAll$2$s(link.url, "&", "&amp;");
        H.checkString("&lt;");
        t3 = H.stringReplaceAllUnchecked(t3, "<", "&lt;");
        H.checkString("&gt;");
        t2.$indexSet(0, "href", H.stringReplaceAllUnchecked(t3, ">", "&gt;"));
        t3 = link.title;
        if (t3 != null) {
          t3 = J.replaceAll$2$s(t3, "&", "&amp;");
          H.checkString("&lt;");
          t3 = H.stringReplaceAllUnchecked(t3, "<", "&lt;");
          H.checkString("&gt;");
          t2.$indexSet(0, "title", H.stringReplaceAllUnchecked(t3, ">", "&gt;"));
        }
        return new T.Element0("a", t1, t2);
      }
    }],
    getLink$3: function(parser, match, state) {
      var t1, t2, url, title, id;
      t1 = match._match;
      t2 = t1.length;
      if (3 >= t2)
        return H.ioore(t1, 3);
      url = H.stringTypeCheck(t1[3]);
      if (url != null && url !== "") {
        if (4 >= t2)
          return H.ioore(t1, 4);
        title = H.stringTypeCheck(t1[4]);
        return new L.Link(null, J.getInterceptor$s(url).startsWith$1(url, "<") && C.JSString_methods.endsWith$1(url, ">") ? C.JSString_methods.substring$2(url, 1, url.length - 1) : url, title);
      } else {
        id = H.stringTypeCheck(t1[2]);
        return parser.document.refLinks.$index(0, J.toLowerCase$0$s(id === "" ? J.substring$2$s(parser.source, state.startPos + 1, parser.pos) : id));
      }
    },
    onMatchEnd$3: function(parser, match, state) {
      var node = this.createNode$3(parser, match, state);
      if (node == null)
        return false;
      C.JSArray_methods.add$1(C.JSArray_methods.get$last(parser._stack).children, node);
      return true;
    },
    static: {LinkSyntax_linkPattern: function() {
        return "](?:(\\s?\\[([^\\]]*)\\]|\\s?\\(([^ )]+)(?:[ ]*\"([^\"]+)\"|)\\))|)";
      }, LinkSyntax$: function(linkResolver, pattern) {
        var t1, t2, t3, t4, t5;
        t1 = H.buildFunctionType(H.buildInterfaceType(T.Node0), [H.buildInterfaceType(P.String)]);
        t2 = t1._assertCheck$1(linkResolver);
        t3 = R.LinkSyntax_linkPattern();
        t4 = H.JSSyntaxRegExp_makeNative(pattern, true, true, false);
        t5 = H.JSSyntaxRegExp_makeNative(t3, true, true, false);
        return new R.LinkSyntax(t1._assertCheck$1(t2), false, new H.JSSyntaxRegExp(t3, t5, null, null), null, new H.JSSyntaxRegExp(pattern, t4, null, null));
      }}
  },
  ImageLinkSyntax: {
    "^": "LinkSyntax;linkResolver:ImageLinkSyntax_linkResolver<,linkResolver,resolved,endPattern,tag,pattern",
    createNode$3: function(parser, match, state) {
      var node, t1, t2, t3, t4, t5, alt;
      node = this.super$LinkSyntax$createNode$3(parser, match, state);
      if (this.resolved)
        return node;
      if (node == null)
        return;
      t1 = H.assertSubtype([], "$isList", [T.Node0], "$asList");
      t2 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(null, null), "$isMap", [P.String, P.String], "$asMap");
      t2.$indexSet(0, "src", node.get$attributes(node).$index(0, "href"));
      t3 = node.attributes;
      if (t3.containsKey$1(0, "title"))
        t2.$indexSet(0, "title", t3.$index(0, "title"));
      t3 = node.children;
      t4 = new R.ImageLinkSyntax_createNode_closure();
      t3.toString;
      H.buildFunctionType(H.getDynamicRuntimeType(), [H.convertRtiToRuntimeType(t3.$builtinTypeInfo && t3.$builtinTypeInfo[0])])._assertCheck$1(t4);
      H.listSuperNativeTypeCheck(t3, "$isIterable");
      t5 = H.buildFunctionType(H.convertRtiToRuntimeType(null), [H.convertRtiToRuntimeType(null)]);
      t5._assertCheck$1(t4);
      H.listSuperNativeTypeCheck(t3, "$isIterable");
      alt = H.setRuntimeTypeInfo(new H.MappedListIterable(t3, t5._assertCheck$1(t4)), [null, null]).join$1(0, " ");
      if (alt !== "")
        t2.$indexSet(0, "alt", alt);
      (t3 && C.JSArray_methods).set$length(t3, 0);
      C.JSArray_methods.add$1(t3, new T.Element0("img", t1, t2));
      return node;
    },
    static: {ImageLinkSyntax$: function(linkResolver) {
        var t1, t2, t3, t4, t5;
        t1 = H.buildFunctionType(H.buildInterfaceType(T.Node0), [H.buildInterfaceType(P.String)]);
        t2 = t1._assertCheck$1(linkResolver);
        t3 = R.LinkSyntax_linkPattern();
        t4 = H.JSSyntaxRegExp_makeNative("!\\[", true, true, false);
        t5 = H.JSSyntaxRegExp_makeNative(t3, true, true, false);
        return new R.ImageLinkSyntax(t1._assertCheck$1(t2), t1._assertCheck$1(null), false, new H.JSSyntaxRegExp(t3, t5, null, null), null, new H.JSSyntaxRegExp("!\\[", t4, null, null));
      }}
  },
  ImageLinkSyntax_createNode_closure: {
    "^": "Closure:2;",
    call$1: function(e) {
      return !(e instanceof T.Text) ? "" : e.text;
    }
  },
  CodeSyntax: {
    "^": "InlineSyntax;pattern",
    onMatch$2: function(parser, match) {
      var t1, t2;
      t1 = match._match;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      t1 = J.replaceAll$2$s(H.stringTypeCheck(t1[1]), "&", "&amp;");
      H.checkString("&lt;");
      t1 = H.stringReplaceAllUnchecked(t1, "<", "&lt;");
      H.checkString("&gt;");
      t1 = H.assertSubtype([new T.Text(H.stringReplaceAllUnchecked(t1, ">", "&gt;"))], "$isList", [T.Node0], "$asList");
      t2 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(null, null), "$isMap", [P.String, P.String], "$asMap");
      C.JSArray_methods.add$1(C.JSArray_methods.get$last(parser._stack).children, new T.Element0("code", t1, t2));
      return true;
    },
    static: {CodeSyntax$: function(pattern) {
        return new R.CodeSyntax(new H.JSSyntaxRegExp(pattern, H.JSSyntaxRegExp_makeNative(pattern, true, true, false), null, null));
      }}
  },
  TagState: {
    "^": "Object;startPos<,endPos,syntax,children>",
    tryMatch$1: function(parser) {
      var endMatch = this.syntax.endPattern.matchAsPrefix$2(0, parser.source, parser.pos);
      if (endMatch != null) {
        this.close$2(0, parser, endMatch);
        return true;
      }
      return false;
    },
    close$2: function(_, parser, endMatch) {
      var t1, t2, unmatchedTags, t3, unmatched;
      t1 = parser._stack;
      t2 = C.JSArray_methods.indexOf$1(t1, this) + 1;
      unmatchedTags = C.JSArray_methods.sublist$1(t1, t2);
      C.JSArray_methods.removeRange$2(t1, t2, t1.length);
      for (t2 = H.getTypeArgumentByIndex(unmatchedTags, 0), H.assertSubtype(unmatchedTags, "$isJSArray", [t2], "$asJSArray"), t3 = unmatchedTags.length, t2 = H.assertSubtype(H.setRuntimeTypeInfo(new J.ArrayIterator(H.assertSubtype(unmatchedTags, "$isJSArray", [t2], "$asJSArray"), t3, 0, H.assertSubtypeOfRuntimeType(null, t2)), [t2]), "$isIterator", [H.getTypeArgumentByIndex(unmatchedTags, 0)], "$asIterator"), t3 = this.children; t2.moveNext$0();) {
        unmatched = H.assertSubtypeOfRuntimeType(t2._current, H.getTypeArgumentByIndex(t2, 0));
        parser.writeTextRange$2(unmatched.get$startPos(), unmatched.endPos);
        C.JSArray_methods.addAll$1(t3, unmatched.children);
      }
      parser.writeTextRange$2(parser.start, parser.pos);
      parser.start = parser.pos;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
      if (t1.length === 0)
        return H.assertSubtype(t3, "$isList", [T.Node0], "$asList");
      if (this.syntax.onMatchEnd$3(parser, endMatch, this)) {
        t1 = endMatch._match;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = parser.pos += H.stringTypeCheck(t1[0]).length;
        parser.start = t1;
      } else {
        parser.start = this.startPos;
        t1 = endMatch._match;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        parser.pos += H.stringTypeCheck(t1[0]).length;
      }
      return H.assertSubtype(null, "$isList", [T.Node0], "$asList");
    }
  }
}],
["points_award", "package:egamebook/src/shared/points_award.dart", , A, {
  "^": "",
  PointsAward: {
    "^": "Object;addition,result,justification",
    toString$0: function(_) {
      var t1, t2;
      t1 = this.justification;
      t2 = this.addition;
      if (t1 != null)
        return "Score +" + H.S(t2) + " for " + H.S(t1) + ".";
      else
        return "Score +" + H.S(t2) + ".";
    }
  }
}],
["source_maps.span", "package:source_maps/span.dart", , Y, {
  "^": "",
  Span: {
    "^": "Object;",
    $isComparable: 1,
    $asComparable: $.functionThatReturnsNull
  },
  Location0: {
    "^": "Object;",
    $isComparable: 1,
    $asComparable: $.functionThatReturnsNull
  },
  FileSpan: {
    "^": "Span;"
  }
}],
["stat", "package:egamebook/src/shared/stat.dart", , Z, {
  "^": "",
  StatUpdate: {
    "^": "Object;show>,string"
  },
  StatUpdateCollection: {
    "^": "Object;_updates",
    forEach$1: function(_, $function) {
      this._updates.forEach$1(0, H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P.String), H.buildInterfaceType(Z.StatUpdate)])._assertCheck$1($function));
    },
    StatUpdateCollection$fromMap$1: function(map) {
      J.forEach$1$ax(H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap"), new Z.StatUpdateCollection$fromMap_closure(this));
    },
    static: {StatUpdateCollection$fromMap: function(map) {
        var t1;
        H.assertSubtype(map, "$isMap", [P.String, P.Object], "$asMap");
        t1 = new Z.StatUpdateCollection(H.assertSubtype(H.assertSubtype(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, Z.StatUpdate), "$isMap", [P.String, Z.StatUpdate], "$asMap"), "$isMap", [P.String, Z.StatUpdate], "$asMap"));
        t1.StatUpdateCollection$fromMap$1(map);
        return t1;
      }}
  },
  StatUpdateCollection$fromMap_closure: {
    "^": "Closure:40;_stat$_captured_this_0",
    call$2: function($name, o) {
      var t1, t2;
      H.stringTypeCheck($name);
      H.subtypeCast(o, "$isMap", [P.String, P.Object], "$asMap");
      H.assertSubtype(o, "$isMap", [P.String, P.Object], "$asMap");
      t1 = J.getInterceptor$asx(o);
      t2 = t1.$index(o, "show");
      t1 = t1.$index(o, "string");
      this._stat$_captured_this_0._updates.$indexSet(0, $name, new Z.StatUpdate(H.boolTypeCheck(t2), H.stringTypeCheck(t1)));
    }
  },
  UIStat: {
    "^": "Object;name>,description,color,priority<,show>,notifyOnChange,string",
    static: {UIStat_updateStatsList: function(statsList, updates) {
        var changedStats, t1;
        H.assertSubtype(statsList, "$isList", [Z.UIStat], "$asList");
        changedStats = H.assertSubtype(H.setRuntimeTypeInfo([], [Z.UIStat]), "$isList", [Z.UIStat], "$asList");
        t1 = new Z.UIStat_updateStatsList_closure(statsList, changedStats);
        H.buildFunctionType(H.getVoidRuntimeType(), [H.buildInterfaceType(P.String), H.buildInterfaceType(Z.StatUpdate)])._assertCheck$1(t1);
        updates._updates.forEach$1(0, t1);
        return H.assertSubtype(changedStats, "$isList", [Z.UIStat], "$asList");
      }, UIStat_overwriteStatsListFromDataStructure: function(list) {
        var t1, statsList, t2, i, statMap, t3, t4, t5, t6, t7, t8, t9;
        H.assertSubtype(list, "$isList", [[P.Map, P.String, P.Object]], "$asList");
        t1 = J.getInterceptor$asx(list);
        statsList = H.setRuntimeTypeInfo(Array(t1.get$length(list)), [Z.UIStat]);
        for (t1 = t1.get$iterator(list), t2 = statsList.length, i = 0; t1.moveNext$0();) {
          statMap = H.assertSubtype(t1.get$current(), "$isMap", [P.String, P.Object], "$asMap");
          t3 = J.getInterceptor$asx(statMap);
          t4 = t3.$index(statMap, "name");
          t5 = t3.$index(statMap, "description");
          t6 = t3.$index(statMap, "color");
          t7 = t3.$index(statMap, "priority");
          t8 = t3.$index(statMap, "show");
          t9 = t3.$index(statMap, "notifyOnChange");
          t3 = t3.$index(statMap, "string");
          H.stringTypeCheck(t4);
          H.stringTypeCheck(t5);
          H.stringTypeCheck(t6);
          H.intTypeCheck(t7);
          H.boolTypeCheck(t8);
          H.boolTypeCheck(t9);
          H.stringTypeCheck(t3);
          if (i >= t2)
            return H.ioore(statsList, i);
          statsList[i] = new Z.UIStat(t4, t5, t6, t7, t8, t9, t3);
          ++i;
        }
        C.JSArray_methods.sort$1(statsList, new Z.UIStat_overwriteStatsListFromDataStructure_closure());
        return H.assertSubtype(statsList, "$isList", [Z.UIStat], "$asList");
      }}
  },
  UIStat_updateStatsList_closure: {
    "^": "Closure:41;_captured_statsList_0,_captured_changedStats_1",
    call$2: function($name, update) {
      var t1, stat;
      H.stringTypeCheck($name);
      H.interceptedTypeCheck(update, "$isStatUpdate");
      t1 = this._captured_statsList_0;
      stat = (t1 && C.JSArray_methods).singleWhere$1(t1, new Z.UIStat_updateStatsList__closure($name));
      stat.show = update.show;
      stat.string = update.string;
      C.JSArray_methods.add$1(this._captured_changedStats_1, stat);
    }
  },
  UIStat_updateStatsList__closure: {
    "^": "Closure:2;_captured_name_2",
    call$1: function(st) {
      var t1, t2;
      t1 = J.get$name$x(st);
      t2 = this._captured_name_2;
      return t1 == null ? t2 == null : t1 === t2;
    }
  },
  UIStat_overwriteStatsListFromDataStructure_closure: {
    "^": "Closure:11;",
    call$2: function(a, b) {
      var t1, t2;
      t1 = b.get$priority();
      t2 = a.get$priority();
      if (typeof t1 !== "number")
        return t1.$sub();
      return C.JSInt_methods.$sub(t1, t2);
    }
  }
}],
];
setupProgram(dart);
// getInterceptor methods
J.getInterceptor = function(receiver) {
  if (typeof receiver == "number") {
    if (Math.floor(receiver) == receiver)
      return J.JSInt.prototype;
    return J.JSDouble.prototype;
  }
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return J.JSNull.prototype;
  if (typeof receiver == "boolean")
    return J.JSBool.prototype;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$asx = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$ax = function(receiver) {
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$n = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$ns = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$s = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$x = function(receiver) {
  if (receiver == null)
    return receiver;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.$add$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver + a0;
  return J.getInterceptor$ns(receiver).$add(receiver, a0);
};
J.$eq = function(receiver, a0) {
  if (receiver == null)
    return a0 == null;
  if (typeof receiver != "object")
    return a0 != null && receiver === a0;
  return J.getInterceptor(receiver).$eq(receiver, a0);
};
J.$gt$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver > a0;
  return J.getInterceptor$n(receiver).$gt(receiver, a0);
};
J.$index$asx = function(receiver, a0) {
  if (receiver.constructor == Array || typeof receiver == "string" || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName]))
    if (a0 >>> 0 === a0 && a0 < receiver.length)
      return receiver[a0];
  return J.getInterceptor$asx(receiver).$index(receiver, a0);
};
J.$lt$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver < a0;
  return J.getInterceptor$n(receiver).$lt(receiver, a0);
};
J._clearChildren$0$x = function(receiver) {
  return J.getInterceptor$x(receiver)._clearChildren$0(receiver);
};
J._hasAttribute$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver)._hasAttribute$1(receiver, a0);
};
J._initEvent$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver)._initEvent$3(receiver, a0, a1, a2);
};
J._querySelectorAll$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver)._querySelectorAll$1(receiver, a0);
};
J._removeChild$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver)._removeChild$1(receiver, a0);
};
J._replaceChild$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver)._replaceChild$2(receiver, a0, a1);
};
J._shrOtherPositive$1$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver)._shrOtherPositive$1(receiver, a0);
};
J.accept$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).accept$1(receiver, a0);
};
J.add$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).add$1(receiver, a0);
};
J.addEventListener$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).addEventListener$3(receiver, a0, a1, a2);
};
J.append$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).append$1(receiver, a0);
};
J.codeUnitAt$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).codeUnitAt$1(receiver, a0);
};
J.compareTo$1$ns = function(receiver, a0) {
  return J.getInterceptor$ns(receiver).compareTo$1(receiver, a0);
};
J.contains$2$asx = function(receiver, a0, a1) {
  return J.getInterceptor$asx(receiver).contains$2(receiver, a0, a1);
};
J.elementAt$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).elementAt$1(receiver, a0);
};
J.forEach$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).forEach$1(receiver, a0);
};
J.get$classes$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$classes(receiver);
};
J.get$error$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$error(receiver);
};
J.get$hashCode$ = function(receiver) {
  return J.getInterceptor(receiver).get$hashCode(receiver);
};
J.get$id$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$id(receiver);
};
J.get$isEmpty$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$isEmpty(receiver);
};
J.get$isNotEmpty$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$isNotEmpty(receiver);
};
J.get$iterator$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$iterator(receiver);
};
J.get$last$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$last(receiver);
};
J.get$length$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$length(receiver);
};
J.get$name$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$name(receiver);
};
J.get$onClick$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$onClick(receiver);
};
J.get$show$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$show(receiver);
};
J.get$single$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$single(receiver);
};
J.get$text$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$text(receiver);
};
J.get$title$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$title(receiver);
};
J.getAttribute$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).getAttribute$1(receiver, a0);
};
J.map$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).map$1(receiver, a0);
};
J.matchAsPrefix$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).matchAsPrefix$2(receiver, a0, a1);
};
J.remove$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).remove$0(receiver);
};
J.removeEventListener$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).removeEventListener$3(receiver, a0, a1, a2);
};
J.replaceAll$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).replaceAll$2(receiver, a0, a1);
};
J.replaceWith$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).replaceWith$1(receiver, a0);
};
J.send$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).send$1(receiver, a0);
};
J.set$checked$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$checked(receiver, value);
};
J.set$href$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$href(receiver, value);
};
J.set$innerHtml$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$innerHtml(receiver, value);
};
J.set$parent$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$parent(receiver, value);
};
J.set$text$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$text(receiver, value);
};
J.set$type$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$type(receiver, value);
};
J.setAttribute$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).setAttribute$2(receiver, a0, a1);
};
J.setInnerHtml$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).setInnerHtml$1(receiver, a0);
};
J.startsWith$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).startsWith$1(receiver, a0);
};
J.substring$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).substring$2(receiver, a0, a1);
};
J.toLowerCase$0$s = function(receiver) {
  return J.getInterceptor$s(receiver).toLowerCase$0(receiver);
};
J.toSet$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).toSet$0(receiver);
};
J.toString$0 = function(receiver) {
  return J.getInterceptor(receiver).toString$0(receiver);
};
J.trim$0$s = function(receiver) {
  return J.getInterceptor$s(receiver).trim$0(receiver);
};
Isolate.makeConstantList = function(list) {
  list.immutable$list = Array;
  list.fixed$length = Array;
  return list;
};
;
C.BodyElement_methods = W.BodyElement.prototype;
C.ButtonElement_methods = W.ButtonElement.prototype;
C.DomImplementation_methods = W.DomImplementation.prototype;
C.HeadElement_methods = W.HeadElement.prototype;
C.HtmlDocument_methods = W.HtmlDocument.prototype;
C.JSArray_methods = J.JSArray.prototype;
C.JSDouble_methods = J.JSDouble.prototype;
C.JSInt_methods = J.JSInt.prototype;
C.JSNull_methods = J.JSNull.prototype;
C.JSNumber_methods = J.JSNumber.prototype;
C.JSString_methods = J.JSString.prototype;
C.LabelElement_methods = W.LabelElement.prototype;
C.NativeUint8List_methods = H.NativeUint8List.prototype;
C.NodeList_methods = W.NodeList0.prototype;
C.OListElement_methods = W.OListElement.prototype;
C.ParagraphElement_methods = W.ParagraphElement.prototype;
C.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
C.Range_methods = W.Range.prototype;
C.SelectElement_methods = W.SelectElement.prototype;
C.SpanElement_methods = W.SpanElement.prototype;
C.Storage_methods = W.Storage.prototype;
C.TableElement_methods = W.TableElement.prototype;
C.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
C.Window_methods = W.Window.prototype;
C.C_DynamicRuntimeType = new H.DynamicRuntimeType();
C.C_OutOfMemoryError = new P.OutOfMemoryError();
C.C_VoidRuntimeType = new H.VoidRuntimeType();
C.C__DelayedDone = new P._DelayedDone();
C.C__RootZone = new P._RootZone();
C.Duration_0 = new P.Duration(0);
C.Duration_100000 = new P.Duration(100000);
C.Duration_1000000 = new P.Duration(1000000);
C.Duration_200000 = new P.Duration(200000);
C.EventStreamProvider_change = H.setRuntimeTypeInfo(new W.EventStreamProvider("change"), [W.Event]);
C.EventStreamProvider_click = H.setRuntimeTypeInfo(new W.EventStreamProvider("click"), [W.MouseEvent]);
C.JS_CONST_0 = function(hooks) {
  if (typeof dartExperimentalFixupGetTag != "function") return hooks;
  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);
};
C.JS_CONST_4hp = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Firefox") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "GeoGeolocation": "Geolocation",
    "Location": "!Location",
    "WorkerMessageEvent": "MessageEvent",
    "XMLDocument": "!Document"};
  function getTagFirefox(o) {
    var tag = getTag(o);
    return quickMap[tag] || tag;
  }
  hooks.getTag = getTagFirefox;
};
C.JS_CONST_8ZY = function getTagFallback(o) {
  var constructor = o.constructor;
  if (typeof constructor == "function") {
    var name = constructor.name;
    if (typeof name == "string" &&
        name.length > 2 &&
        name !== "Object" &&
        name !== "Function.prototype") {
      return name;
    }
  }
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
C.JS_CONST_Fs4 = function(hooks) { return hooks; }
;
C.JS_CONST_QJm = function(getTagFallback) {
  return function(hooks) {
    if (typeof navigator != "object") return hooks;
    var ua = navigator.userAgent;
    if (ua.indexOf("DumpRenderTree") >= 0) return hooks;
    if (ua.indexOf("Chrome") >= 0) {
      function confirm(p) {
        return typeof window == "object" && window[p] && window[p].name == p;
      }
      if (confirm("Window") && confirm("HTMLElement")) return hooks;
    }
    hooks.getTag = getTagFallback;
  };
};
C.JS_CONST_gkc = function() {
  function typeNameInChrome(o) {
    var constructor = o.constructor;
    if (constructor) {
      var name = constructor.name;
      if (name) return name;
    }
    var s = Object.prototype.toString.call(o);
    return s.substring(8, s.length - 1);
  }
  function getUnknownTag(object, tag) {
    if (/^HTML[A-Z].*Element$/.test(tag)) {
      var name = Object.prototype.toString.call(object);
      if (name == "[object Object]") return null;
      return "HTMLElement";
    }
  }
  function getUnknownTagGenericBrowser(object, tag) {
    if (self.HTMLElement && object instanceof HTMLElement) return "HTMLElement";
    return getUnknownTag(object, tag);
  }
  function prototypeForTag(tag) {
    if (typeof window == "undefined") return null;
    if (typeof window[tag] == "undefined") return null;
    var constructor = window[tag];
    if (typeof constructor != "function") return null;
    return constructor.prototype;
  }
  function discriminator(tag) { return null; }
  var isBrowser = typeof navigator == "object";
  return {
    getTag: typeNameInChrome,
    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,
    prototypeForTag: prototypeForTag,
    discriminator: discriminator };
};
C.JS_CONST_gkc0 = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Trident/") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "HTMLDDElement": "HTMLElement",
    "HTMLDTElement": "HTMLElement",
    "HTMLPhraseElement": "HTMLElement",
    "Position": "Geoposition"
  };
  function getTagIE(o) {
    var tag = getTag(o);
    var newTag = quickMap[tag];
    if (newTag) return newTag;
    if (tag == "Object") {
      if (window.DataView && (o instanceof window.DataView)) return "DataView";
    }
    return tag;
  }
  function prototypeForTagIE(tag) {
    var constructor = window[tag];
    if (constructor == null) return null;
    return constructor.prototype;
  }
  hooks.getTag = getTagIE;
  hooks.prototypeForTag = prototypeForTagIE;
};
C.JS_CONST_rr7 = function(hooks) {
  var getTag = hooks.getTag;
  var prototypeForTag = hooks.prototypeForTag;
  function getTagFixed(o) {
    var tag = getTag(o);
    if (tag == "Document") {
      if (!!o.xmlVersion) return "!Document";
      return "!HTMLDocument";
    }
    return tag;
  }
  function prototypeForTagFixed(tag) {
    if (tag == "Document") return null;
    return prototypeForTag(tag);
  }
  hooks.getTag = getTagFixed;
  hooks.prototypeForTag = prototypeForTagFixed;
};
C.JsonCodec_null_null = new P.JsonCodec(null, null);
C.JsonDecoder_null = new P.JsonDecoder(null);
C.JsonEncoder_null_null = new P.JsonEncoder(null, null);
C.List_1GN = H.setRuntimeTypeInfo(Isolate.makeConstantList(["*::class", "*::dir", "*::draggable", "*::hidden", "*::id", "*::inert", "*::itemprop", "*::itemref", "*::itemscope", "*::lang", "*::spellcheck", "*::title", "*::translate", "A::accesskey", "A::coords", "A::hreflang", "A::name", "A::shape", "A::tabindex", "A::target", "A::type", "AREA::accesskey", "AREA::alt", "AREA::coords", "AREA::nohref", "AREA::shape", "AREA::tabindex", "AREA::target", "AUDIO::controls", "AUDIO::loop", "AUDIO::mediagroup", "AUDIO::muted", "AUDIO::preload", "BDO::dir", "BODY::alink", "BODY::bgcolor", "BODY::link", "BODY::text", "BODY::vlink", "BR::clear", "BUTTON::accesskey", "BUTTON::disabled", "BUTTON::name", "BUTTON::tabindex", "BUTTON::type", "BUTTON::value", "CANVAS::height", "CANVAS::width", "CAPTION::align", "COL::align", "COL::char", "COL::charoff", "COL::span", "COL::valign", "COL::width", "COLGROUP::align", "COLGROUP::char", "COLGROUP::charoff", "COLGROUP::span", "COLGROUP::valign", "COLGROUP::width", "COMMAND::checked", "COMMAND::command", "COMMAND::disabled", "COMMAND::label", "COMMAND::radiogroup", "COMMAND::type", "DATA::value", "DEL::datetime", "DETAILS::open", "DIR::compact", "DIV::align", "DL::compact", "FIELDSET::disabled", "FONT::color", "FONT::face", "FONT::size", "FORM::accept", "FORM::autocomplete", "FORM::enctype", "FORM::method", "FORM::name", "FORM::novalidate", "FORM::target", "FRAME::name", "H1::align", "H2::align", "H3::align", "H4::align", "H5::align", "H6::align", "HR::align", "HR::noshade", "HR::size", "HR::width", "HTML::version", "IFRAME::align", "IFRAME::frameborder", "IFRAME::height", "IFRAME::marginheight", "IFRAME::marginwidth", "IFRAME::width", "IMG::align", "IMG::alt", "IMG::border", "IMG::height", "IMG::hspace", "IMG::ismap", "IMG::name", "IMG::usemap", "IMG::vspace", "IMG::width", "INPUT::accept", "INPUT::accesskey", "INPUT::align", "INPUT::alt", "INPUT::autocomplete", "INPUT::checked", "INPUT::disabled", "INPUT::inputmode", "INPUT::ismap", "INPUT::list", "INPUT::max", "INPUT::maxlength", "INPUT::min", "INPUT::multiple", "INPUT::name", "INPUT::placeholder", "INPUT::readonly", "INPUT::required", "INPUT::size", "INPUT::step", "INPUT::tabindex", "INPUT::type", "INPUT::usemap", "INPUT::value", "INS::datetime", "KEYGEN::disabled", "KEYGEN::keytype", "KEYGEN::name", "LABEL::accesskey", "LABEL::for", "LEGEND::accesskey", "LEGEND::align", "LI::type", "LI::value", "LINK::sizes", "MAP::name", "MENU::compact", "MENU::label", "MENU::type", "METER::high", "METER::low", "METER::max", "METER::min", "METER::value", "OBJECT::typemustmatch", "OL::compact", "OL::reversed", "OL::start", "OL::type", "OPTGROUP::disabled", "OPTGROUP::label", "OPTION::disabled", "OPTION::label", "OPTION::selected", "OPTION::value", "OUTPUT::for", "OUTPUT::name", "P::align", "PRE::width", "PROGRESS::max", "PROGRESS::min", "PROGRESS::value", "SELECT::autocomplete", "SELECT::disabled", "SELECT::multiple", "SELECT::name", "SELECT::required", "SELECT::size", "SELECT::tabindex", "SOURCE::type", "TABLE::align", "TABLE::bgcolor", "TABLE::border", "TABLE::cellpadding", "TABLE::cellspacing", "TABLE::frame", "TABLE::rules", "TABLE::summary", "TABLE::width", "TBODY::align", "TBODY::char", "TBODY::charoff", "TBODY::valign", "TD::abbr", "TD::align", "TD::axis", "TD::bgcolor", "TD::char", "TD::charoff", "TD::colspan", "TD::headers", "TD::height", "TD::nowrap", "TD::rowspan", "TD::scope", "TD::valign", "TD::width", "TEXTAREA::accesskey", "TEXTAREA::autocomplete", "TEXTAREA::cols", "TEXTAREA::disabled", "TEXTAREA::inputmode", "TEXTAREA::name", "TEXTAREA::placeholder", "TEXTAREA::readonly", "TEXTAREA::required", "TEXTAREA::rows", "TEXTAREA::tabindex", "TEXTAREA::wrap", "TFOOT::align", "TFOOT::char", "TFOOT::charoff", "TFOOT::valign", "TH::abbr", "TH::align", "TH::axis", "TH::bgcolor", "TH::char", "TH::charoff", "TH::colspan", "TH::headers", "TH::height", "TH::nowrap", "TH::rowspan", "TH::scope", "TH::valign", "TH::width", "THEAD::align", "THEAD::char", "THEAD::charoff", "THEAD::valign", "TR::align", "TR::bgcolor", "TR::char", "TR::charoff", "TR::valign", "TRACK::default", "TRACK::kind", "TRACK::label", "TRACK::srclang", "UL::compact", "UL::type", "VIDEO::controls", "VIDEO::height", "VIDEO::loop", "VIDEO::mediagroup", "VIDEO::muted", "VIDEO::preload", "VIDEO::width"]), [P.String]);
C.List_2Vk = Isolate.makeConstantList([0, 0, 32776, 33792, 1, 10240, 0, 0]);
C.List_4CW = Isolate.makeConstantList(["a", "address", "annotation-xml", "applet", "area", "article", "aside", "b", "base", "basefont", "bgsound", "big", "blockquote", "body", "br", "button", "caption", "center", "code", "col", "colgroup", "command", "dd", "desc", "details", "dir", "div", "dl", "dt", "em", "embed", "fieldset", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "i", "iframe", "image", "img", "input", "isindex", "li", "link", "listing", "marquee", "men", "meta", "mi", "mn", "mo", "ms", "mtext", "nav", "nobr", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "s", "script", "section", "select", "small", "strike", "strong", "style", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "title", "tr", "tt", "ul", "wbr", "xmp"]);
C.List_CVk = Isolate.makeConstantList([0, 0, 65490, 45055, 65535, 34815, 65534, 18431]);
C.DialogButton_Close_null = new G.DialogButton("Close", null);
C.List_DialogButton_Close_null = Isolate.makeConstantList([C.DialogButton_Close_null]);
C.List_JYB = Isolate.makeConstantList([0, 0, 26624, 1023, 65534, 2047, 65534, 2047]);
C.List_empty = Isolate.makeConstantList([]);
C.C_EmptyBlockSyntax = new U.EmptyBlockSyntax();
C.C_BlockHtmlSyntax = new U.BlockHtmlSyntax();
C.C_SetextHeaderSyntax = new U.SetextHeaderSyntax();
C.C_HeaderSyntax = new U.HeaderSyntax();
C.C_CodeBlockSyntax = new U.CodeBlockSyntax();
C.C_FencedCodeBlockSyntax = new U.FencedCodeBlockSyntax();
C.C_BlockquoteSyntax = new U.BlockquoteSyntax();
C.C_HorizontalRuleSyntax = new U.HorizontalRuleSyntax();
C.C_UnorderedListSyntax = new U.UnorderedListSyntax();
C.C_OrderedListSyntax = new U.OrderedListSyntax();
C.C_ParagraphSyntax = new U.ParagraphSyntax();
C.List_gBu = Isolate.makeConstantList([C.C_EmptyBlockSyntax, C.C_BlockHtmlSyntax, C.C_SetextHeaderSyntax, C.C_HeaderSyntax, C.C_CodeBlockSyntax, C.C_FencedCodeBlockSyntax, C.C_BlockquoteSyntax, C.C_HorizontalRuleSyntax, C.C_UnorderedListSyntax, C.C_OrderedListSyntax, C.C_ParagraphSyntax]);
C.List_gRj = Isolate.makeConstantList([0, 0, 32722, 12287, 65534, 34815, 65534, 18431]);
C.List_nxB = Isolate.makeConstantList([0, 0, 24576, 1023, 65534, 34815, 65534, 18431]);
C.List_qNA = Isolate.makeConstantList([0, 0, 32754, 11263, 65534, 34815, 65534, 18431]);
C.List_qg4 = Isolate.makeConstantList([0, 0, 65490, 12287, 65535, 34815, 65534, 18431]);
C.List_qg40 = Isolate.makeConstantList([0, 0, 32722, 12287, 65535, 34815, 65534, 18431]);
C.List_wSV = H.setRuntimeTypeInfo(Isolate.makeConstantList(["bind", "if", "ref", "repeat", "syntax"]), [P.String]);
C.List_yrN = H.setRuntimeTypeInfo(Isolate.makeConstantList(["A::href", "AREA::href", "BLOCKQUOTE::cite", "BODY::background", "COMMAND::icon", "DEL::cite", "FORM::action", "IMG::src", "INPUT::src", "INS::cite", "Q::cite", "VIDEO::poster"]), [P.String]);
C.Type_6L0 = H.createRuntimeType('Uint8List');
C.Type_Art = H.createRuntimeType('Float32List');
C.Type_CAk = H.createRuntimeType('Uint16List');
C.Type_Ejg = H.createRuntimeType('String');
C.Type_EsU = H.createRuntimeType('bool');
C.Type_QuW = H.createRuntimeType('Uint8ClampedList');
C.Type_SnA = H.createRuntimeType('$int');
C.Type_UoK = H.createRuntimeType('Int16List');
C.Type_XXD = H.createRuntimeType('JSObject');
C.Type_ckn = H.createRuntimeType('Float64List');
C.Type_dTZ = H.createRuntimeType('Int32List');
C.Type_eZO = H.createRuntimeType('Null');
C.Type_irB = H.createRuntimeType('Uint32List');
C.Type_mp3 = H.createRuntimeType('Int8List');
C.Type_oGP = H.createRuntimeType('ByteData');
C.Type_qq1 = H.createRuntimeType('$double');
C.Type_wAg = H.createRuntimeType('ByteBuffer');
C.Type_xM7 = H.createRuntimeType('num');
C.Utf8Codec_false = new P.Utf8Codec(false);
{
  init.isHunkLoaded = function(hunkHash) {
    return !!$dart_deferred_initializers[hunkHash];
  };
  init.deferredInitialized = new Object(null);
  init.isHunkInitialized = function(hunkHash) {
    return init.deferredInitialized[hunkHash];
  };
  init.initializeLoadedHunk = function(hunkHash) {
    $dart_deferred_initializers[hunkHash](globalsHolder, $);
    init.deferredInitialized[hunkHash] = true;
  };
}
init.deferredLibraryUris = {};
init.deferredLibraryHashes = {};
$.IsolateNatives_enableSpawnWorker = null;
$.RawReceivePortImpl__nextFreeId = 1;
$.Primitives_mirrorFunctionCacheName = "$cachedFunction";
$.Primitives_mirrorInvokeCacheName = "$cachedInvocation";
$.Primitives_timerFrequency = null;
$.Primitives_timerTicks = null;
$.Closure_functionCounter = 0;
$.BoundClosure_selfFieldNameCache = null;
$.BoundClosure_receiverFieldNameCache = null;
$.RuntimeFunctionType_inAssert = false;
$.getTagFunction = null;
$.alternateTagFunction = null;
$.prototypeForTagFunction = null;
$.dispatchRecordsForInstanceTags = null;
$.interceptorsForUncacheableTags = null;
$.initNativeDispatchFlag = null;
$.printToZone = null;
$._nextCallback = null;
$._lastCallback = null;
$._lastPriorityCallback = null;
$._isInCallbackLoop = false;
$.Zone__current = C.C__RootZone;
$.Expando__keyCount = 0;
$.Stopwatch__frequency = null;
$.Element__parseDocument = null;
$.Element__parseRange = null;
$.Element__defaultValidator = null;
$.Element__defaultSanitizer = null;
$.Device__isOpera = null;
$.Device__isIE = null;
$.Device__isFirefox = null;
$.Device__isWebKit = null;
$.Device__cachedCssPrefix = null;
(function(lazies) {
  var descriptorLength = 4;
  for (var i = 0; i < lazies.length; i += descriptorLength) {
    var fieldName = lazies[i];
    var getterName = lazies[i + 1];
    var lazyValue = lazies[i + 2];
    var staticName = lazies[i + 3];
    Isolate.$lazy(fieldName, getterName, lazyValue, staticName);
  }
})(["IsolateNatives_thisScript", "get$IsolateNatives_thisScript", function() {
  return H.IsolateNatives_computeThisScript();
}, "thisScript", "IsolateNatives_workerIds", "get$IsolateNatives_workerIds", function() {
  return H.assertSubtype(H.setRuntimeTypeInfo(new P.Expando(null), [P.$int]), "$isExpando", [P.$int], "$asExpando");
}, "workerIds", "TypeErrorDecoder_noSuchMethodPattern", "get$TypeErrorDecoder_noSuchMethodPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({toString: function() {
      return "$receiver$";
    }}));
}, "noSuchMethodPattern", "TypeErrorDecoder_notClosurePattern", "get$TypeErrorDecoder_notClosurePattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({$method$: null, toString: function() {
      return "$receiver$";
    }}));
}, "notClosurePattern", "TypeErrorDecoder_nullCallPattern", "get$TypeErrorDecoder_nullCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(null));
}, "nullCallPattern", "TypeErrorDecoder_nullLiteralCallPattern", "get$TypeErrorDecoder_nullLiteralCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    var $argumentsExpr$ = '$arguments$';
    try {
      null.$method$($argumentsExpr$);
    } catch (e) {
      return e.message;
    }
  }());
}, "nullLiteralCallPattern", "TypeErrorDecoder_undefinedCallPattern", "get$TypeErrorDecoder_undefinedCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(void 0));
}, "undefinedCallPattern", "TypeErrorDecoder_undefinedLiteralCallPattern", "get$TypeErrorDecoder_undefinedLiteralCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    var $argumentsExpr$ = '$arguments$';
    try {
      (void 0).$method$($argumentsExpr$);
    } catch (e) {
      return e.message;
    }
  }());
}, "undefinedLiteralCallPattern", "TypeErrorDecoder_nullPropertyPattern", "get$TypeErrorDecoder_nullPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(null));
}, "nullPropertyPattern", "TypeErrorDecoder_nullLiteralPropertyPattern", "get$TypeErrorDecoder_nullLiteralPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    try {
      null.$method$;
    } catch (e) {
      return e.message;
    }
  }());
}, "nullLiteralPropertyPattern", "TypeErrorDecoder_undefinedPropertyPattern", "get$TypeErrorDecoder_undefinedPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(void 0));
}, "undefinedPropertyPattern", "TypeErrorDecoder_undefinedLiteralPropertyPattern", "get$TypeErrorDecoder_undefinedLiteralPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    try {
      (void 0).$method$;
    } catch (e) {
      return e.message;
    }
  }());
}, "undefinedLiteralPropertyPattern", "_AsyncRun_scheduleImmediateClosure", "get$_AsyncRun_scheduleImmediateClosure", function() {
  return P._AsyncRun__initializeScheduleImmediate();
}, "scheduleImmediateClosure", "Future__nullFuture", "get$Future__nullFuture", function() {
  return P.Future_Future$value(null, null);
}, "_nullFuture", "IterableBase__toStringVisiting", "get$IterableBase__toStringVisiting", function() {
  return [];
}, "_toStringVisiting", "_Html5NodeValidator__allowedElements", "get$_Html5NodeValidator__allowedElements", function() {
  return H.assertSubtype(P.LinkedHashSet_LinkedHashSet$from(["A", "ABBR", "ACRONYM", "ADDRESS", "AREA", "ARTICLE", "ASIDE", "AUDIO", "B", "BDI", "BDO", "BIG", "BLOCKQUOTE", "BR", "BUTTON", "CANVAS", "CAPTION", "CENTER", "CITE", "CODE", "COL", "COLGROUP", "COMMAND", "DATA", "DATALIST", "DD", "DEL", "DETAILS", "DFN", "DIR", "DIV", "DL", "DT", "EM", "FIELDSET", "FIGCAPTION", "FIGURE", "FONT", "FOOTER", "FORM", "H1", "H2", "H3", "H4", "H5", "H6", "HEADER", "HGROUP", "HR", "I", "IFRAME", "IMG", "INPUT", "INS", "KBD", "LABEL", "LEGEND", "LI", "MAP", "MARK", "MENU", "METER", "NAV", "NOBR", "OL", "OPTGROUP", "OPTION", "OUTPUT", "P", "PRE", "PROGRESS", "Q", "S", "SAMP", "SECTION", "SELECT", "SMALL", "SOURCE", "SPAN", "STRIKE", "STRONG", "SUB", "SUMMARY", "SUP", "TABLE", "TBODY", "TD", "TEXTAREA", "TFOOT", "TH", "THEAD", "TIME", "TR", "TRACK", "TT", "U", "UL", "VAR", "VIDEO", "WBR"], null), "$isSet", [P.String], "$asSet");
}, "_allowedElements", "_Html5NodeValidator__attributeValidators", "get$_Html5NodeValidator__attributeValidators", function() {
  return H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_empty(null, null), "$isMap", [P.String, P.Function], "$asMap");
}, "_attributeValidators", "customTagHandlers", "get$customTagHandlers", function() {
  return H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_literal(["Form", new Q.closure9(), "FormSection", new Q.closure10(), "SubmitButton", new Q.closure11(), "CheckboxInput", new Q.closure12(), "RangeInput", new Q.closure13(), "RangeOutput", new Q.closure14(), "TextOutput", new Q.closure15(), "MultipleChoiceInput", new Q.closure16(), "Option", new Q.closure17()], null, null), "$isMap", [P.String, {func: "", ret: B.Node1, args: [P.Object]}], "$asMap");
}, "customTagHandlers", "ELEMENT_BUILDERS", "get$ELEMENT_BUILDERS", function() {
  return H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_literal(["Form", new G.closure0(), "FormSection", new G.closure1(), "SubmitButton", new G.closure2(), "CheckboxInput", new G.closure3(), "RangeInput", new G.closure4(), "RangeOutput", new G.closure5(), "TextOutput", new G.closure6(), "MultipleChoiceInput", new G.closure7(), "Option", new G.closure8()], null, null), "$isMap", [P.String, {func: "", ret: Q.UiElement, args: [G.FormElement]}], "$asMap");
}, "ELEMENT_BUILDERS", "DialogButton_NO_BEHAVIOUR", "get$DialogButton_NO_BEHAVIOUR", function() {
  return H.buildFunctionType(H.buildInterfaceType(P.bool))._assertCheck$1(new G.closure());
}, "NO_BEHAVIOUR", "CssClassSetImpl__validTokenRE", "get$CssClassSetImpl__validTokenRE", function() {
  return P.RegExp_RegExp("^\\S+$", true, false);
}, "_validTokenRE", "_emptyPattern", "get$_emptyPattern", function() {
  return P.RegExp_RegExp("^([ \\t]*)$", true, false);
}, "_emptyPattern", "_setextPattern", "get$_setextPattern", function() {
  return P.RegExp_RegExp("^((=+)|(-+))$", true, false);
}, "_setextPattern", "_headerPattern", "get$_headerPattern", function() {
  return P.RegExp_RegExp("^(#{1,6})(.*?)#*$", true, false);
}, "_headerPattern", "_blockquotePattern", "get$_blockquotePattern", function() {
  return P.RegExp_RegExp("^[ ]{0,3}>[ ]?(.*)$", true, false);
}, "_blockquotePattern", "_indentPattern", "get$_indentPattern", function() {
  return P.RegExp_RegExp("^(?:    |\\t)(.*)$", true, false);
}, "_indentPattern", "_codePattern", "get$_codePattern", function() {
  return P.RegExp_RegExp("^(`{3,}|~{3,})(.*)$", true, false);
}, "_codePattern", "_hrPattern", "get$_hrPattern", function() {
  return P.RegExp_RegExp("^[ ]{0,3}((-+[ ]{0,2}){3,}|(_+[ ]{0,2}){3,}|(\\*+[ ]{0,2}){3,})$", true, false);
}, "_hrPattern", "_htmlPattern", "get$_htmlPattern", function() {
  return P.RegExp_RegExp("^<[ ]*\\w+[ >]", true, false);
}, "_htmlPattern", "_ulPattern", "get$_ulPattern", function() {
  return P.RegExp_RegExp("^[ ]{0,3}[*+-][ \\t]+(.*)$", true, false);
}, "_ulPattern", "_olPattern", "get$_olPattern", function() {
  return P.RegExp_RegExp("^[ ]{0,3}\\d+\\.[ \\t]+(.*)$", true, false);
}, "_olPattern", "HtmlRenderer__blockTags", "get$HtmlRenderer__blockTags", function() {
  return P.RegExp_RegExp("blockquote|h1|h2|h3|h4|h5|h6|hr|p|pre", true, false);
}, "_blockTags", "InlineParser__defaultSyntaxes", "get$InlineParser__defaultSyntaxes", function() {
  return H.assertSubtype(H.setRuntimeTypeInfo([R.TextSyntax$("\\s*[A-Za-z0-9]+", null), new R.AutolinkSyntax(P.RegExp_RegExp("<((http|https|ftp)://[^>]*)>", true, true)), R.LinkSyntax$(null, "\\["), R.ImageLinkSyntax$(null), R.TextSyntax$(" \\* ", null), R.TextSyntax$(" _ ", null), R.TextSyntax$("&[#a-zA-Z0-9]*;", null), R.TextSyntax$("&", "&amp;"), R.TextSyntax$("<", "&lt;"), R.TagSyntax$("\\*\\*", null, "strong"), R.TagSyntax$("__", null, "strong"), R.TagSyntax$("\\*", null, "em"), R.TagSyntax$("_", null, "em"), R.CodeSyntax$("``\\s?((?:.|\\n)*?)\\s?``"), R.CodeSyntax$("`([^`]*)`")], [R.InlineSyntax]), "$isList", [R.InlineSyntax], "$asList");
}, "_defaultSyntaxes"]);
;

init.metadata = [,
];
init.types = [{func: ""},
{func: "", void: true},
{func: "", args: [,]},
{func: "", args: [P.String]},
{func: "", args: [, P.String]},
{func: "", args: [{func: "", void: true}]},
{func: "", void: true, args: [,], opt: [P.StackTrace]},
{func: "", args: [,], opt: [,]},
{func: "", ret: P.bool},
{func: "", args: [P.Timer]},
{func: "", args: [, P.StackTrace]},
{func: "", args: [,,]},
{func: "", args: [P.String,,]},
{func: "", args: [P.Symbol,,]},
{func: "", ret: P.String, args: [P.$int]},
{func: "", ret: P.bool, args: [P.$int]},
{func: "", ret: P.$int, args: [,,]},
{func: "", void: true, args: [P.String]},
{func: "", void: true, args: [P.String], opt: [,]},
{func: "", ret: P.$int, args: [P.$int, P.$int]},
{func: "", args: [W.Element]},
{func: "", args: [P.CssClassSetImpl]},
{func: "", args: [P.bool, P.CssClassSetImpl]},
{func: "", void: true, args: [W.Node, W.Node]},
{func: "", args: [B.Element1]},
{func: "", args: [G.FormElement]},
{func: "", args: [P.StreamSubscription]},
{func: "", args: [P.Object]},
{func: "", args: [Z.EgbSavegame]},
{func: "", args: [[P.Set, P.String]]},
{func: "", void: true, args: [W.Event]},
{func: "", args: [W.MouseEvent]},
{func: "", args: [W.ButtonElement]},
{func: "", args: [Z.UIStat]},
{func: "", args: [P.$int, W.RadioButtonInputElement]},
{func: "", args: [W.Event]},
{func: "", void: true, args: [P.Object]},
{func: "", args: [P.$int]},
{func: "", args: [G.CurrentState]},
{func: "", args: [P.RegExp]},
{func: "", args: [P.String, P.Object]},
{func: "", args: [P.String, Z.StatUpdate]},
{func: "", ret: P.num},
{func: "", void: true, args: [{func: "", void: true}]},
{func: "", void: true, args: [,]},
{func: "", ret: P.bool, args: [,,]},
{func: "", ret: P.$int, args: [,]},
{func: "", ret: P.Object, args: [,]},
{func: "", ret: P.$int, args: [P.Comparable, P.Comparable]},
{func: "", ret: P.bool, args: [P.Object, P.Object]},
{func: "", ret: P.$int, args: [P.Object]},
{func: "", ret: P.bool, args: [W.Element, P.String, P.String, W._Html5NodeValidator]},
];
$ = null;
Isolate = Isolate.$finishIsolateConstructor(Isolate);
$ = new Isolate();
function convertToFastObject(properties) {
  function MyClass() {
  }
  MyClass.prototype = properties;
  new MyClass();
  return properties;
}
;
function convertToSlowObject(properties) {
  properties.__MAGIC_SLOW_PROPERTY = 1;
  delete properties.__MAGIC_SLOW_PROPERTY;
  return properties;
}
;
A = convertToFastObject(A);
B = convertToFastObject(B);
C = convertToFastObject(C);
D = convertToFastObject(D);
E = convertToFastObject(E);
F = convertToFastObject(F);
G = convertToFastObject(G);
H = convertToFastObject(H);
J = convertToFastObject(J);
K = convertToFastObject(K);
L = convertToFastObject(L);
M = convertToFastObject(M);
N = convertToFastObject(N);
O = convertToFastObject(O);
P = convertToFastObject(P);
Q = convertToFastObject(Q);
R = convertToFastObject(R);
S = convertToFastObject(S);
T = convertToFastObject(T);
U = convertToFastObject(U);
V = convertToFastObject(V);
W = convertToFastObject(W);
X = convertToFastObject(X);
Y = convertToFastObject(Y);
Z = convertToFastObject(Z);
function init() {
  Isolate.$isolateProperties = Object.create(null);
  init.allClasses = Object.create(null);
  init.getTypeFromName = function(name) {
    return init.allClasses[name];
  };
  init.interceptorsByTag = Object.create(null);
  init.leafTags = Object.create(null);
  init.finishedClasses = Object.create(null);
  Isolate.$lazy = function(fieldName, getterName, lazyValue, staticName, prototype) {
    if (!init.lazies)
      init.lazies = Object.create(null);
    init.lazies[fieldName] = getterName;
    prototype = prototype || Isolate.$isolateProperties;
    var sentinelUndefined = {};
    var sentinelInProgress = {};
    prototype[fieldName] = sentinelUndefined;
    prototype[getterName] = function() {
      var result = this[fieldName];
      try {
        if (result === sentinelUndefined) {
          this[fieldName] = sentinelInProgress;
          try {
            result = this[fieldName] = lazyValue();
          } finally {
            if (result === sentinelUndefined)
              this[fieldName] = null;
          }
        } else
          if (result === sentinelInProgress)
            H.throwCyclicInit(staticName || fieldName);
        return result;
      } finally {
        this[getterName] = function() {
          return this[fieldName];
        };
      }
    };
  };
  Isolate.$finishIsolateConstructor = function(oldIsolate) {
    var isolateProperties = oldIsolate.$isolateProperties;
    function Isolate() {
      var staticNames = Object.keys(isolateProperties);
      for (var i = 0; i < staticNames.length; i++) {
        var staticName = staticNames[i];
        this[staticName] = isolateProperties[staticName];
      }
      var lazies = init.lazies;
      var lazyInitializers = lazies ? Object.keys(lazies) : [];
      for (var i = 0; i < lazyInitializers.length; i++)
        this[lazies[lazyInitializers[i]]] = null;
      function ForceEfficientMap() {
      }
      ForceEfficientMap.prototype = this;
      new ForceEfficientMap();
      for (var i = 0; i < lazyInitializers.length; i++) {
        var lazyInitName = lazies[lazyInitializers[i]];
        this[lazyInitName] = isolateProperties[lazyInitName];
      }
    }
    Isolate.prototype = oldIsolate.prototype;
    Isolate.prototype.constructor = Isolate;
    Isolate.$isolateProperties = isolateProperties;
    Isolate.makeConstantList = oldIsolate.makeConstantList;
    return Isolate;
  };
}
!function() {
  function intern(s) {
    var o = {};
    o[s] = 1;
    return Object.keys(convertToFastObject(o))[0];
  }
  init.getIsolateTag = function(name) {
    return intern("___dart_" + name + init.isolateTag);
  };
  var tableProperty = "___dart_isolate_tags_";
  var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
  var rootProperty = "_ZxYxX";
  for (var i = 0;; i++) {
    var property = intern(rootProperty + "_" + i + "_");
    if (!(property in usedProperties)) {
      usedProperties[property] = 1;
      init.isolateTag = property;
      break;
    }
  }
  init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
}();
;// BEGIN invoke [main].
(function(callback) {
  if (typeof document === "undefined") {
    callback(null);
    return;
  }
  if (document.currentScript) {
    callback(document.currentScript);
    return;
  }
  var scripts = document.scripts;
  function onLoad(event) {
    for (var i = 0; i < scripts.length; ++i)
      scripts[i].removeEventListener("load", onLoad, false);
    callback(event.target);
  }
  for (var i = 0; i < scripts.length; ++i)
    scripts[i].addEventListener("load", onLoad, false);
})(function(currentScript) {
  init.currentScript = currentScript;
  if (typeof dartMainRunner === "function")
    dartMainRunner(function(a) {
      H.startRootIsolate(M.main$closure(), a);
    }, []);
  else
    (function(a) {
      H.startRootIsolate(M.main$closure(), a);
    })([]);
});
;
// END invoke [main].
})()

//# sourceMappingURL=bodega.html.dart.js.map
